/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.97
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */

var Custom = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
    get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
  }) : x3)(function(x3) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x3 + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key2 of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key2) && key2 !== except)
          __defProp(to, key2, { get: () => from2[key2], enumerable: !(desc = __getOwnPropDesc(from2, key2)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "../node_modules/object-assign/index.js"(exports5, module) {
      "use strict";
      /*
      object-assign
      (c) Sindre Sorhus
      @license MIT
      */
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from2;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from2 = Object(arguments[s]);
          for (var key2 in from2) {
            if (hasOwnProperty2.call(from2, key2)) {
              to[key2] = from2[key2];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from2);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from2, symbols[i])) {
                to[symbols[i]] = from2[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // ../node_modules/rbush/rbush.min.js
  var require_rbush_min = __commonJS({
    "../node_modules/rbush/rbush.min.js"(exports5, module) {
      !function(t, i) {
        "object" == typeof exports5 && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).RBush = i();
      }(exports5, function() {
        "use strict";
        function t(t2, r2, e3, a3, h2) {
          !function t3(n2, r3, e4, a4, h3) {
            for (; a4 > e4; ) {
              if (a4 - e4 > 600) {
                var o2 = a4 - e4 + 1, s2 = r3 - e4 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e4, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a4, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
                t3(n2, r3, m2, c2, h3);
              }
              var p2 = n2[r3], d2 = e4, x3 = a4;
              for (i(n2, e4, r3), h3(n2[a4], p2) > 0 && i(n2, e4, a4); d2 < x3; ) {
                for (i(n2, d2, x3), d2++, x3--; h3(n2[d2], p2) < 0; )
                  d2++;
                for (; h3(n2[x3], p2) > 0; )
                  x3--;
              }
              0 === h3(n2[e4], p2) ? i(n2, e4, x3) : i(n2, ++x3, a4), x3 <= r3 && (e4 = x3 + 1), r3 <= x3 && (a4 = x3 - 1);
            }
          }(t2, r2, e3 || 0, a3 || t2.length - 1, h2 || n);
        }
        function i(t2, i2, n2) {
          var r2 = t2[i2];
          t2[i2] = t2[n2], t2[n2] = r2;
        }
        function n(t2, i2) {
          return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
        }
        var r = function(t2) {
          void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        };
        function e(t2, i2, n2) {
          if (!n2)
            return i2.indexOf(t2);
          for (var r2 = 0; r2 < i2.length; r2++)
            if (n2(t2, i2[r2]))
              return r2;
          return -1;
        }
        function a2(t2, i2) {
          h(t2, 0, t2.children.length, i2, t2);
        }
        function h(t2, i2, n2, r2, e3) {
          e3 || (e3 = p(null)), e3.minX = 1 / 0, e3.minY = 1 / 0, e3.maxX = -1 / 0, e3.maxY = -1 / 0;
          for (var a3 = i2; a3 < n2; a3++) {
            var h2 = t2.children[a3];
            o(e3, t2.leaf ? r2(h2) : h2);
          }
          return e3;
        }
        function o(t2, i2) {
          return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
        }
        function s(t2, i2) {
          return t2.minX - i2.minX;
        }
        function l(t2, i2) {
          return t2.minY - i2.minY;
        }
        function f(t2) {
          return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
        }
        function u(t2) {
          return t2.maxX - t2.minX + (t2.maxY - t2.minY);
        }
        function m(t2, i2) {
          return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
        }
        function c(t2, i2) {
          return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
        }
        function p(t2) {
          return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        }
        function d(i2, n2, r2, e3, a3) {
          for (var h2 = [n2, r2]; h2.length; )
            if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e3)) {
              var o2 = n2 + Math.ceil((r2 - n2) / e3 / 2) * e3;
              t(i2, o2, n2, r2, a3), h2.push(n2, o2, o2, r2);
            }
        }
        return r.prototype.all = function() {
          return this._all(this.data, []);
        }, r.prototype.search = function(t2) {
          var i2 = this.data, n2 = [];
          if (!c(t2, i2))
            return n2;
          for (var r2 = this.toBBox, e3 = []; i2; ) {
            for (var a3 = 0; a3 < i2.children.length; a3++) {
              var h2 = i2.children[a3], o2 = i2.leaf ? r2(h2) : h2;
              c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e3.push(h2));
            }
            i2 = e3.pop();
          }
          return n2;
        }, r.prototype.collides = function(t2) {
          var i2 = this.data;
          if (!c(t2, i2))
            return false;
          for (var n2 = []; i2; ) {
            for (var r2 = 0; r2 < i2.children.length; r2++) {
              var e3 = i2.children[r2], a3 = i2.leaf ? this.toBBox(e3) : e3;
              if (c(t2, a3)) {
                if (i2.leaf || m(t2, a3))
                  return true;
                n2.push(e3);
              }
            }
            i2 = n2.pop();
          }
          return false;
        }, r.prototype.load = function(t2) {
          if (!t2 || !t2.length)
            return this;
          if (t2.length < this._minEntries) {
            for (var i2 = 0; i2 < t2.length; i2++)
              this.insert(t2[i2]);
            return this;
          }
          var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === n2.height)
              this._splitRoot(this.data, n2);
            else {
              if (this.data.height < n2.height) {
                var r2 = this.data;
                this.data = n2, n2 = r2;
              }
              this._insert(n2, this.data.height - n2.height - 1, true);
            }
          else
            this.data = n2;
          return this;
        }, r.prototype.insert = function(t2) {
          return t2 && this._insert(t2, this.data.height - 1), this;
        }, r.prototype.clear = function() {
          return this.data = p([]), this;
        }, r.prototype.remove = function(t2, i2) {
          if (!t2)
            return this;
          for (var n2, r2, a3, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
            if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a3 = true), h2.leaf) {
              var f2 = e(t2, h2.children, i2);
              if (-1 !== f2)
                return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
            }
            a3 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a3 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
          }
          return this;
        }, r.prototype.toBBox = function(t2) {
          return t2;
        }, r.prototype.compareMinX = function(t2, i2) {
          return t2.minX - i2.minX;
        }, r.prototype.compareMinY = function(t2, i2) {
          return t2.minY - i2.minY;
        }, r.prototype.toJSON = function() {
          return this.data;
        }, r.prototype.fromJSON = function(t2) {
          return this.data = t2, this;
        }, r.prototype._all = function(t2, i2) {
          for (var n2 = []; t2; )
            t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
          return i2;
        }, r.prototype._build = function(t2, i2, n2, r2) {
          var e3, h2 = n2 - i2 + 1, o2 = this._maxEntries;
          if (h2 <= o2)
            return a2(e3 = p(t2.slice(i2, n2 + 1)), this.toBBox), e3;
          r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e3 = p([])).leaf = false, e3.height = r2;
          var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
          d(t2, i2, n2, l2, this.compareMinX);
          for (var f2 = i2; f2 <= n2; f2 += l2) {
            var u2 = Math.min(f2 + l2 - 1, n2);
            d(t2, f2, u2, s2, this.compareMinY);
            for (var m2 = f2; m2 <= u2; m2 += s2) {
              var c2 = Math.min(m2 + s2 - 1, u2);
              e3.children.push(this._build(t2, m2, c2, r2 - 1));
            }
          }
          return a2(e3, this.toBBox), e3;
        }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
          for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
            for (var e3 = 1 / 0, a3 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
              var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
              u2 < a3 ? (a3 = u2, e3 = l2 < e3 ? l2 : e3, h2 = s2) : u2 === a3 && l2 < e3 && (e3 = l2, h2 = s2);
            }
            i2 = h2 || i2.children[0];
          }
          var m2, c2;
          return i2;
        }, r.prototype._insert = function(t2, i2, n2) {
          var r2 = n2 ? t2 : this.toBBox(t2), e3 = [], a3 = this._chooseSubtree(r2, this.data, i2, e3);
          for (a3.children.push(t2), o(a3, r2); i2 >= 0 && e3[i2].children.length > this._maxEntries; )
            this._split(e3, i2), i2--;
          this._adjustParentBBoxes(r2, e3, i2);
        }, r.prototype._split = function(t2, i2) {
          var n2 = t2[i2], r2 = n2.children.length, e3 = this._minEntries;
          this._chooseSplitAxis(n2, e3, r2);
          var h2 = this._chooseSplitIndex(n2, e3, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
          o2.height = n2.height, o2.leaf = n2.leaf, a2(n2, this.toBBox), a2(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
        }, r.prototype._splitRoot = function(t2, i2) {
          this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a2(this.data, this.toBBox);
        }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
          for (var r2, e3, a3, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
            var d2 = h(t2, 0, p2, this.toBBox), x3 = h(t2, p2, n2, this.toBBox), v = (e3 = d2, a3 = x3, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e3.minX, a3.minX), s2 = Math.max(e3.minY, a3.minY), l2 = Math.min(e3.maxX, a3.maxX), u2 = Math.min(e3.maxY, a3.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x3);
            v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
          }
          return r2 || n2 - i2;
        }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
          var r2 = t2.leaf ? this.compareMinX : s, e3 = t2.leaf ? this.compareMinY : l;
          this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e3) && t2.children.sort(r2);
        }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
          t2.children.sort(r2);
          for (var e3 = this.toBBox, a3 = h(t2, 0, i2, e3), s2 = h(t2, n2 - i2, n2, e3), l2 = u(a3) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
            var m2 = t2.children[f2];
            o(a3, t2.leaf ? e3(m2) : m2), l2 += u(a3);
          }
          for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
            var p2 = t2.children[c2];
            o(s2, t2.leaf ? e3(p2) : p2), l2 += u(s2);
          }
          return l2;
        }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
          for (var r2 = n2; r2 >= 0; r2--)
            o(i2[r2], t2);
        }, r.prototype._condense = function(t2) {
          for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
            0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a2(t2[i2], this.toBBox);
        }, r;
      });
    }
  });

  // ../node_modules/tinyqueue/tinyqueue.js
  var require_tinyqueue = __commonJS({
    "../node_modules/tinyqueue/tinyqueue.js"(exports5, module) {
      (function(global, factory) {
        typeof exports5 === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = global || self, global.TinyQueue = factory());
      })(exports5, function() {
        "use strict";
        var TinyQueue = function TinyQueue2(data, compare3) {
          if (data === void 0)
            data = [];
          if (compare3 === void 0)
            compare3 = defaultCompare;
          this.data = data;
          this.length = this.data.length;
          this.compare = compare3;
          if (this.length > 0) {
            for (var i = (this.length >> 1) - 1; i >= 0; i--) {
              this._down(i);
            }
          }
        };
        TinyQueue.prototype.push = function push(item) {
          this.data.push(item);
          this.length++;
          this._up(this.length - 1);
        };
        TinyQueue.prototype.pop = function pop() {
          if (this.length === 0) {
            return void 0;
          }
          var top = this.data[0];
          var bottom = this.data.pop();
          this.length--;
          if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
          }
          return top;
        };
        TinyQueue.prototype.peek = function peek() {
          return this.data[0];
        };
        TinyQueue.prototype._up = function _up(pos) {
          var ref = this;
          var data = ref.data;
          var compare3 = ref.compare;
          var item = data[pos];
          while (pos > 0) {
            var parent = pos - 1 >> 1;
            var current = data[parent];
            if (compare3(item, current) >= 0) {
              break;
            }
            data[pos] = current;
            pos = parent;
          }
          data[pos] = item;
        };
        TinyQueue.prototype._down = function _down(pos) {
          var ref = this;
          var data = ref.data;
          var compare3 = ref.compare;
          var halfLength = this.length >> 1;
          var item = data[pos];
          while (pos < halfLength) {
            var left = (pos << 1) + 1;
            var best = data[left];
            var right = left + 1;
            if (right < this.length && compare3(data[right], best) < 0) {
              left = right;
              best = data[right];
            }
            if (compare3(best, item) >= 0) {
              break;
            }
            data[pos] = best;
            pos = left;
          }
          data[pos] = item;
        };
        function defaultCompare(a2, b) {
          return a2 < b ? -1 : a2 > b ? 1 : 0;
        }
        return TinyQueue;
      });
    }
  });

  // ../node_modules/point-in-polygon/flat.js
  var require_flat = __commonJS({
    "../node_modules/point-in-polygon/flat.js"(exports5, module) {
      module.exports = function pointInPolygonFlat(point2, vs, start2, end) {
        var x3 = point2[0], y3 = point2[1];
        var inside = false;
        if (start2 === void 0)
          start2 = 0;
        if (end === void 0)
          end = vs.length;
        var len = (end - start2) / 2;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[start2 + i * 2 + 0], yi = vs[start2 + i * 2 + 1];
          var xj = vs[start2 + j * 2 + 0], yj = vs[start2 + j * 2 + 1];
          var intersect2 = yi > y3 !== yj > y3 && x3 < (xj - xi) * (y3 - yi) / (yj - yi) + xi;
          if (intersect2)
            inside = !inside;
        }
        return inside;
      };
    }
  });

  // ../node_modules/point-in-polygon/nested.js
  var require_nested = __commonJS({
    "../node_modules/point-in-polygon/nested.js"(exports5, module) {
      module.exports = function pointInPolygonNested(point2, vs, start2, end) {
        var x3 = point2[0], y3 = point2[1];
        var inside = false;
        if (start2 === void 0)
          start2 = 0;
        if (end === void 0)
          end = vs.length;
        var len = end - start2;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[i + start2][0], yi = vs[i + start2][1];
          var xj = vs[j + start2][0], yj = vs[j + start2][1];
          var intersect2 = yi > y3 !== yj > y3 && x3 < (xj - xi) * (y3 - yi) / (yj - yi) + xi;
          if (intersect2)
            inside = !inside;
        }
        return inside;
      };
    }
  });

  // ../node_modules/point-in-polygon/index.js
  var require_point_in_polygon = __commonJS({
    "../node_modules/point-in-polygon/index.js"(exports5, module) {
      var pointInPolygonFlat = require_flat();
      var pointInPolygonNested = require_nested();
      module.exports = function pointInPolygon(point2, vs, start2, end) {
        if (vs.length > 0 && Array.isArray(vs[0])) {
          return pointInPolygonNested(point2, vs, start2, end);
        } else {
          return pointInPolygonFlat(point2, vs, start2, end);
        }
      };
      module.exports.nested = pointInPolygonNested;
      module.exports.flat = pointInPolygonFlat;
    }
  });

  // ../node_modules/robust-predicates/umd/orient2d.min.js
  var require_orient2d_min = __commonJS({
    "../node_modules/robust-predicates/umd/orient2d.min.js"(exports5, module) {
      !function(t, e) {
        "object" == typeof exports5 && "undefined" != typeof module ? e(exports5) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).predicates = {});
      }(exports5, function(t) {
        "use strict";
        const e = 134217729, n = 33306690738754706e-32;
        function r(t2, e3, n2, r2, o2) {
          let f2, i2, u2, c2, s2 = e3[0], a3 = r2[0], d2 = 0, l2 = 0;
          a3 > s2 == a3 > -s2 ? (f2 = s2, s2 = e3[++d2]) : (f2 = a3, a3 = r2[++l2]);
          let p = 0;
          if (d2 < t2 && l2 < n2)
            for (a3 > s2 == a3 > -s2 ? (u2 = f2 - ((i2 = s2 + f2) - s2), s2 = e3[++d2]) : (u2 = f2 - ((i2 = a3 + f2) - a3), a3 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2); d2 < t2 && l2 < n2; )
              a3 > s2 == a3 > -s2 ? (u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2]) : (u2 = f2 - ((i2 = f2 + a3) - (c2 = i2 - f2)) + (a3 - c2), a3 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2);
          for (; d2 < t2; )
            u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
          for (; l2 < n2; )
            u2 = f2 - ((i2 = f2 + a3) - (c2 = i2 - f2)) + (a3 - c2), a3 = r2[++l2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
          return 0 === f2 && 0 !== p || (o2[p++] = f2), p;
        }
        function o(t2) {
          return new Float64Array(t2);
        }
        const f = 33306690738754716e-32, i = 22204460492503146e-32, u = 11093356479670487e-47, c = o(4), s = o(8), a2 = o(12), d = o(16), l = o(4);
        t.orient2d = function(t2, o2, p, b, y3, h) {
          const M = (o2 - h) * (p - y3), x3 = (t2 - y3) * (b - h), j = M - x3;
          if (0 === M || 0 === x3 || M > 0 != x3 > 0)
            return j;
          const m = Math.abs(M + x3);
          return Math.abs(j) >= f * m ? j : -function(t3, o3, f2, p2, b2, y4, h2) {
            let M2, x4, j2, m2, _, v, w, A2, F, O2, P, g, k, q, z2, B2, C, D;
            const E = t3 - b2, G = f2 - b2, H = o3 - y4, I2 = p2 - y4;
            _ = (z2 = (A2 = E - (w = (v = e * E) - (v - E))) * (O2 = I2 - (F = (v = e * I2) - (v - I2))) - ((q = E * I2) - w * F - A2 * F - w * O2)) - (P = z2 - (C = (A2 = H - (w = (v = e * H) - (v - H))) * (O2 = G - (F = (v = e * G) - (v - G))) - ((B2 = H * G) - w * F - A2 * F - w * O2))), c[0] = z2 - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), c[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, c[2] = g - (D - _) + (P - _), c[3] = D;
            let J = function(t4, e3) {
              let n2 = e3[0];
              for (let r2 = 1; r2 < t4; r2++)
                n2 += e3[r2];
              return n2;
            }(4, c), K = i * h2;
            if (J >= K || -J >= K)
              return J;
            if (M2 = t3 - (E + (_ = t3 - E)) + (_ - b2), j2 = f2 - (G + (_ = f2 - G)) + (_ - b2), x4 = o3 - (H + (_ = o3 - H)) + (_ - y4), m2 = p2 - (I2 + (_ = p2 - I2)) + (_ - y4), 0 === M2 && 0 === x4 && 0 === j2 && 0 === m2)
              return J;
            if (K = u * h2 + n * Math.abs(J), (J += E * m2 + I2 * M2 - (H * j2 + G * x4)) >= K || -J >= K)
              return J;
            _ = (z2 = (A2 = M2 - (w = (v = e * M2) - (v - M2))) * (O2 = I2 - (F = (v = e * I2) - (v - I2))) - ((q = M2 * I2) - w * F - A2 * F - w * O2)) - (P = z2 - (C = (A2 = x4 - (w = (v = e * x4) - (v - x4))) * (O2 = G - (F = (v = e * G) - (v - G))) - ((B2 = x4 * G) - w * F - A2 * F - w * O2))), l[0] = z2 - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const L = r(4, c, 4, l, s);
            _ = (z2 = (A2 = E - (w = (v = e * E) - (v - E))) * (O2 = m2 - (F = (v = e * m2) - (v - m2))) - ((q = E * m2) - w * F - A2 * F - w * O2)) - (P = z2 - (C = (A2 = H - (w = (v = e * H) - (v - H))) * (O2 = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = H * j2) - w * F - A2 * F - w * O2))), l[0] = z2 - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const N = r(L, s, 4, l, a2);
            _ = (z2 = (A2 = M2 - (w = (v = e * M2) - (v - M2))) * (O2 = m2 - (F = (v = e * m2) - (v - m2))) - ((q = M2 * m2) - w * F - A2 * F - w * O2)) - (P = z2 - (C = (A2 = x4 - (w = (v = e * x4) - (v - x4))) * (O2 = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = x4 * j2) - w * F - A2 * F - w * O2))), l[0] = z2 - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const Q = r(N, a2, 4, l, d);
            return d[Q - 1];
          }(t2, o2, p, b, y3, h, m);
        }, t.orient2dfast = function(t2, e3, n2, r2, o2, f2) {
          return (e3 - f2) * (n2 - o2) - (t2 - o2) * (r2 - f2);
        }, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // ../node_modules/concaveman/index.js
  var require_concaveman = __commonJS({
    "../node_modules/concaveman/index.js"(exports5, module) {
      "use strict";
      var RBush = require_rbush_min();
      var Queue = require_tinyqueue();
      var pointInPolygon = require_point_in_polygon();
      var orient = require_orient2d_min().orient2d;
      if (Queue.default) {
        Queue = Queue.default;
      }
      module.exports = concaveman2;
      module.exports.default = concaveman2;
      function concaveman2(points, concavity, lengthThreshold) {
        concavity = Math.max(0, concavity === void 0 ? 2 : concavity);
        lengthThreshold = lengthThreshold || 0;
        var hull = fastConvexHull(points);
        var tree = new RBush(16);
        tree.toBBox = function(a3) {
          return {
            minX: a3[0],
            minY: a3[1],
            maxX: a3[0],
            maxY: a3[1]
          };
        };
        tree.compareMinX = function(a3, b2) {
          return a3[0] - b2[0];
        };
        tree.compareMinY = function(a3, b2) {
          return a3[1] - b2[1];
        };
        tree.load(points);
        var queue = [];
        for (var i = 0, last; i < hull.length; i++) {
          var p = hull[i];
          tree.remove(p);
          last = insertNode(p, last);
          queue.push(last);
        }
        var segTree = new RBush(16);
        for (i = 0; i < queue.length; i++)
          segTree.insert(updateBBox(queue[i]));
        var sqConcavity = concavity * concavity;
        var sqLenThreshold = lengthThreshold * lengthThreshold;
        while (queue.length) {
          var node = queue.shift();
          var a2 = node.p;
          var b = node.next.p;
          var sqLen = getSqDist(a2, b);
          if (sqLen < sqLenThreshold)
            continue;
          var maxSqLen = sqLen / sqConcavity;
          p = findCandidate(tree, node.prev.p, a2, b, node.next.next.p, maxSqLen, segTree);
          if (p && Math.min(getSqDist(p, a2), getSqDist(p, b)) <= maxSqLen) {
            queue.push(node);
            queue.push(insertNode(p, node));
            tree.remove(p);
            segTree.remove(node);
            segTree.insert(updateBBox(node));
            segTree.insert(updateBBox(node.next));
          }
        }
        node = last;
        var concave = [];
        do {
          concave.push(node.p);
          node = node.next;
        } while (node !== last);
        concave.push(node.p);
        return concave;
      }
      function findCandidate(tree, a2, b, c, d, maxDist, segTree) {
        var queue = new Queue([], compareDist);
        var node = tree.data;
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
            if (dist > maxDist)
              continue;
            queue.push({
              node: child,
              dist
            });
          }
          while (queue.length && !queue.peek().node.children) {
            var item = queue.pop();
            var p = item.node;
            var d0 = sqSegDist(p, a2, b);
            var d1 = sqSegDist(p, c, d);
            if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree))
              return p;
          }
          node = queue.pop();
          if (node)
            node = node.node;
        }
        return null;
      }
      function compareDist(a2, b) {
        return a2.dist - b.dist;
      }
      function sqSegBoxDist(a2, b, bbox2) {
        if (inside(a2, bbox2) || inside(b, bbox2))
          return 0;
        var d1 = sqSegSegDist(a2[0], a2[1], b[0], b[1], bbox2.minX, bbox2.minY, bbox2.maxX, bbox2.minY);
        if (d1 === 0)
          return 0;
        var d2 = sqSegSegDist(a2[0], a2[1], b[0], b[1], bbox2.minX, bbox2.minY, bbox2.minX, bbox2.maxY);
        if (d2 === 0)
          return 0;
        var d3 = sqSegSegDist(a2[0], a2[1], b[0], b[1], bbox2.maxX, bbox2.minY, bbox2.maxX, bbox2.maxY);
        if (d3 === 0)
          return 0;
        var d4 = sqSegSegDist(a2[0], a2[1], b[0], b[1], bbox2.minX, bbox2.maxY, bbox2.maxX, bbox2.maxY);
        if (d4 === 0)
          return 0;
        return Math.min(d1, d2, d3, d4);
      }
      function inside(a2, bbox2) {
        return a2[0] >= bbox2.minX && a2[0] <= bbox2.maxX && a2[1] >= bbox2.minY && a2[1] <= bbox2.maxY;
      }
      function noIntersections(a2, b, segTree) {
        var minX = Math.min(a2[0], b[0]);
        var minY = Math.min(a2[1], b[1]);
        var maxX = Math.max(a2[0], b[0]);
        var maxY = Math.max(a2[1], b[1]);
        var edges2 = segTree.search({ minX, minY, maxX, maxY });
        for (var i = 0; i < edges2.length; i++) {
          if (intersects(edges2[i].p, edges2[i].next.p, a2, b))
            return false;
        }
        return true;
      }
      function cross(p1, p2, p3) {
        return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
      }
      function intersects(p1, q1, p2, q2) {
        return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
      }
      function updateBBox(node) {
        var p1 = node.p;
        var p2 = node.next.p;
        node.minX = Math.min(p1[0], p2[0]);
        node.minY = Math.min(p1[1], p2[1]);
        node.maxX = Math.max(p1[0], p2[0]);
        node.maxY = Math.max(p1[1], p2[1]);
        return node;
      }
      function fastConvexHull(points) {
        var left = points[0];
        var top = points[0];
        var right = points[0];
        var bottom = points[0];
        for (var i = 0; i < points.length; i++) {
          var p = points[i];
          if (p[0] < left[0])
            left = p;
          if (p[0] > right[0])
            right = p;
          if (p[1] < top[1])
            top = p;
          if (p[1] > bottom[1])
            bottom = p;
        }
        var cull = [left, top, right, bottom];
        var filtered = cull.slice();
        for (i = 0; i < points.length; i++) {
          if (!pointInPolygon(points[i], cull))
            filtered.push(points[i]);
        }
        return convexHull(filtered);
      }
      function insertNode(p, prev) {
        var node = {
          p,
          prev: null,
          next: null,
          minX: 0,
          minY: 0,
          maxX: 0,
          maxY: 0
        };
        if (!prev) {
          node.prev = node;
          node.next = node;
        } else {
          node.next = prev.next;
          node.prev = prev;
          prev.next.prev = node;
          prev.next = node;
        }
        return node;
      }
      function getSqDist(p1, p2) {
        var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
        return dx * dx + dy * dy;
      }
      function sqSegDist(p, p1, p2) {
        var x3 = p1[0], y3 = p1[1], dx = p2[0] - x3, dy = p2[1] - y3;
        if (dx !== 0 || dy !== 0) {
          var t = ((p[0] - x3) * dx + (p[1] - y3) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
            x3 = p2[0];
            y3 = p2[1];
          } else if (t > 0) {
            x3 += dx * t;
            y3 += dy * t;
          }
        }
        dx = p[0] - x3;
        dy = p[1] - y3;
        return dx * dx + dy * dy;
      }
      function sqSegSegDist(x02, y02, x12, y12, x22, y22, x3, y3) {
        var ux = x12 - x02;
        var uy = y12 - y02;
        var vx = x3 - x22;
        var vy = y3 - y22;
        var wx = x02 - x22;
        var wy = y02 - y22;
        var a2 = ux * ux + uy * uy;
        var b = ux * vx + uy * vy;
        var c = vx * vx + vy * vy;
        var d = ux * wx + uy * wy;
        var e = vx * wx + vy * wy;
        var D = a2 * c - b * b;
        var sc, sN, tc, tN;
        var sD = D;
        var tD = D;
        if (D === 0) {
          sN = 0;
          sD = 1;
          tN = e;
          tD = c;
        } else {
          sN = b * e - c * d;
          tN = a2 * e - b * d;
          if (sN < 0) {
            sN = 0;
            tN = e;
            tD = c;
          } else if (sN > sD) {
            sN = sD;
            tN = e + b;
            tD = c;
          }
        }
        if (tN < 0) {
          tN = 0;
          if (-d < 0)
            sN = 0;
          else if (-d > a2)
            sN = sD;
          else {
            sN = -d;
            sD = a2;
          }
        } else if (tN > tD) {
          tN = tD;
          if (-d + b < 0)
            sN = 0;
          else if (-d + b > a2)
            sN = sD;
          else {
            sN = -d + b;
            sD = a2;
          }
        }
        sc = sN === 0 ? 0 : sN / sD;
        tc = tN === 0 ? 0 : tN / tD;
        var cx = (1 - sc) * x02 + sc * x12;
        var cy = (1 - sc) * y02 + sc * y12;
        var cx2 = (1 - tc) * x22 + tc * x3;
        var cy2 = (1 - tc) * y22 + tc * y3;
        var dx = cx2 - cx;
        var dy = cy2 - cy;
        return dx * dx + dy * dy;
      }
      function compareByX(a2, b) {
        return a2[0] === b[0] ? a2[1] - b[1] : a2[0] - b[0];
      }
      function convexHull(points) {
        points.sort(compareByX);
        var lower = [];
        for (var i = 0; i < points.length; i++) {
          while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
            lower.pop();
          }
          lower.push(points[i]);
        }
        var upper = [];
        for (var ii = points.length - 1; ii >= 0; ii--) {
          while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {
            upper.pop();
          }
          upper.push(points[ii]);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
      }
    }
  });

  // ../node_modules/@turf/collect/node_modules/quickselect/quickselect.js
  var require_quickselect = __commonJS({
    "../node_modules/@turf/collect/node_modules/quickselect/quickselect.js"(exports5, module) {
      (function(global, factory) {
        typeof exports5 === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.quickselect = factory();
      })(exports5, function() {
        "use strict";
        function quickselect(arr2, k, left, right, compare3) {
          quickselectStep(arr2, k, left || 0, right || arr2.length - 1, compare3 || defaultCompare);
        }
        function quickselectStep(arr2, k, left, right, compare3) {
          while (right > left) {
            if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z2 = Math.log(n);
              var s = 0.5 * Math.exp(2 * z2 / 3);
              var sd = 0.5 * Math.sqrt(z2 * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr2, k, newLeft, newRight, compare3);
            }
            var t = arr2[k];
            var i = left;
            var j = right;
            swap2(arr2, left, k);
            if (compare3(arr2[right], t) > 0)
              swap2(arr2, left, right);
            while (i < j) {
              swap2(arr2, i, j);
              i++;
              j--;
              while (compare3(arr2[i], t) < 0)
                i++;
              while (compare3(arr2[j], t) > 0)
                j--;
            }
            if (compare3(arr2[left], t) === 0)
              swap2(arr2, left, j);
            else {
              j++;
              swap2(arr2, j, right);
            }
            if (j <= k)
              left = j + 1;
            if (k <= j)
              right = j - 1;
          }
        }
        function swap2(arr2, i, j) {
          var tmp = arr2[i];
          arr2[i] = arr2[j];
          arr2[j] = tmp;
        }
        function defaultCompare(a2, b) {
          return a2 < b ? -1 : a2 > b ? 1 : 0;
        }
        return quickselect;
      });
    }
  });

  // ../node_modules/@turf/collect/node_modules/rbush/index.js
  var require_rbush = __commonJS({
    "../node_modules/@turf/collect/node_modules/rbush/index.js"(exports5, module) {
      "use strict";
      module.exports = rbush6;
      module.exports.default = rbush6;
      var quickselect = require_quickselect();
      function rbush6(maxEntries, format) {
        if (!(this instanceof rbush6))
          return new rbush6(maxEntries, format);
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        if (format) {
          this._initFormat(format);
        }
        this.clear();
      }
      rbush6.prototype = {
        all: function() {
          return this._all(this.data, []);
        },
        search: function(bbox2) {
          var node = this.data, result = [], toBBox = this.toBBox;
          if (!intersects(bbox2, node))
            return result;
          var nodesToSearch = [], i, len, child, childBBox;
          while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects(bbox2, childBBox)) {
                if (node.leaf)
                  result.push(child);
                else if (contains(bbox2, childBBox))
                  this._all(child, result);
                else
                  nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return result;
        },
        collides: function(bbox2) {
          var node = this.data, toBBox = this.toBBox;
          if (!intersects(bbox2, node))
            return false;
          var nodesToSearch = [], i, len, child, childBBox;
          while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects(bbox2, childBBox)) {
                if (node.leaf || contains(bbox2, childBBox))
                  return true;
                nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return false;
        },
        load: function(data) {
          if (!(data && data.length))
            return this;
          if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
              this.insert(data[i]);
            }
            return this;
          }
          var node = this._build(data.slice(), 0, data.length - 1, 0);
          if (!this.data.children.length) {
            this.data = node;
          } else if (this.data.height === node.height) {
            this._splitRoot(this.data, node);
          } else {
            if (this.data.height < node.height) {
              var tmpNode = this.data;
              this.data = node;
              node = tmpNode;
            }
            this._insert(node, this.data.height - node.height - 1, true);
          }
          return this;
        },
        insert: function(item) {
          if (item)
            this._insert(item, this.data.height - 1);
          return this;
        },
        clear: function() {
          this.data = createNode([]);
          return this;
        },
        remove: function(item, equalsFn) {
          if (!item)
            return this;
          var node = this.data, bbox2 = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
          while (node || path.length) {
            if (!node) {
              node = path.pop();
              parent = path[path.length - 1];
              i = indexes.pop();
              goingUp = true;
            }
            if (node.leaf) {
              index = findItem(item, node.children, equalsFn);
              if (index !== -1) {
                node.children.splice(index, 1);
                path.push(node);
                this._condense(path);
                return this;
              }
            }
            if (!goingUp && !node.leaf && contains(node, bbox2)) {
              path.push(node);
              indexes.push(i);
              i = 0;
              parent = node;
              node = node.children[0];
            } else if (parent) {
              i++;
              node = parent.children[i];
              goingUp = false;
            } else
              node = null;
          }
          return this;
        },
        toBBox: function(item) {
          return item;
        },
        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,
        toJSON: function() {
          return this.data;
        },
        fromJSON: function(data) {
          this.data = data;
          return this;
        },
        _all: function(node, result) {
          var nodesToSearch = [];
          while (node) {
            if (node.leaf)
              result.push.apply(result, node.children);
            else
              nodesToSearch.push.apply(nodesToSearch, node.children);
            node = nodesToSearch.pop();
          }
          return result;
        },
        _build: function(items, left, right, height) {
          var N = right - left + 1, M = this._maxEntries, node;
          if (N <= M) {
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
          }
          if (!height) {
            height = Math.ceil(Math.log(N) / Math.log(M));
            M = Math.ceil(N / Math.pow(M, height - 1));
          }
          node = createNode([]);
          node.leaf = false;
          node.height = height;
          var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
          multiSelect(items, left, right, N1, this.compareMinX);
          for (i = left; i <= right; i += N1) {
            right2 = Math.min(i + N1 - 1, right);
            multiSelect(items, i, right2, N2, this.compareMinY);
            for (j = i; j <= right2; j += N2) {
              right3 = Math.min(j + N2 - 1, right2);
              node.children.push(this._build(items, j, right3, height - 1));
            }
          }
          calcBBox(node, this.toBBox);
          return node;
        },
        _chooseSubtree: function(bbox2, node, level, path) {
          var i, len, child, targetNode, area2, enlargement, minArea, minEnlargement;
          while (true) {
            path.push(node);
            if (node.leaf || path.length - 1 === level)
              break;
            minArea = minEnlargement = Infinity;
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              area2 = bboxArea(child);
              enlargement = enlargedArea(bbox2, child) - area2;
              if (enlargement < minEnlargement) {
                minEnlargement = enlargement;
                minArea = area2 < minArea ? area2 : minArea;
                targetNode = child;
              } else if (enlargement === minEnlargement) {
                if (area2 < minArea) {
                  minArea = area2;
                  targetNode = child;
                }
              }
            }
            node = targetNode || node.children[0];
          }
          return node;
        },
        _insert: function(item, level, isNode2) {
          var toBBox = this.toBBox, bbox2 = isNode2 ? item : toBBox(item), insertPath = [];
          var node = this._chooseSubtree(bbox2, this.data, level, insertPath);
          node.children.push(item);
          extend(node, bbox2);
          while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
              this._split(insertPath, level);
              level--;
            } else
              break;
          }
          this._adjustParentBBoxes(bbox2, insertPath, level);
        },
        _split: function(insertPath, level) {
          var node = insertPath[level], M = node.children.length, m = this._minEntries;
          this._chooseSplitAxis(node, m, M);
          var splitIndex = this._chooseSplitIndex(node, m, M);
          var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
          newNode.height = node.height;
          newNode.leaf = node.leaf;
          calcBBox(node, this.toBBox);
          calcBBox(newNode, this.toBBox);
          if (level)
            insertPath[level - 1].children.push(newNode);
          else
            this._splitRoot(node, newNode);
        },
        _splitRoot: function(node, newNode) {
          this.data = createNode([node, newNode]);
          this.data.height = node.height + 1;
          this.data.leaf = false;
          calcBBox(this.data, this.toBBox);
        },
        _chooseSplitIndex: function(node, m, M) {
          var i, bbox1, bbox2, overlap, area2, minOverlap, minArea, index;
          minOverlap = minArea = Infinity;
          for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);
            overlap = intersectionArea(bbox1, bbox2);
            area2 = bboxArea(bbox1) + bboxArea(bbox2);
            if (overlap < minOverlap) {
              minOverlap = overlap;
              index = i;
              minArea = area2 < minArea ? area2 : minArea;
            } else if (overlap === minOverlap) {
              if (area2 < minArea) {
                minArea = area2;
                index = i;
              }
            }
          }
          return index;
        },
        _chooseSplitAxis: function(node, m, M) {
          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
          if (xMargin < yMargin)
            node.children.sort(compareMinX);
        },
        _allDistMargin: function(node, m, M, compare3) {
          node.children.sort(compare3);
          var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
          for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
          }
          for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
          }
          return margin;
        },
        _adjustParentBBoxes: function(bbox2, path, level) {
          for (var i = level; i >= 0; i--) {
            extend(path[i], bbox2);
          }
        },
        _condense: function(path) {
          for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
              if (i > 0) {
                siblings = path[i - 1].children;
                siblings.splice(siblings.indexOf(path[i]), 1);
              } else
                this.clear();
            } else
              calcBBox(path[i], this.toBBox);
          }
        },
        _initFormat: function(format) {
          var compareArr = ["return a", " - b", ";"];
          this.compareMinX = new Function("a", "b", compareArr.join(format[0]));
          this.compareMinY = new Function("a", "b", compareArr.join(format[1]));
          this.toBBox = new Function(
            "a",
            "return {minX: a" + format[0] + ", minY: a" + format[1] + ", maxX: a" + format[2] + ", maxY: a" + format[3] + "};"
          );
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn)
          return items.indexOf(item);
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i]))
            return i;
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode)
          destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k, child; i < p; i++) {
          child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend(a2, b) {
        a2.minX = Math.min(a2.minX, b.minX);
        a2.minY = Math.min(a2.minY, b.minY);
        a2.maxX = Math.max(a2.maxX, b.maxX);
        a2.maxY = Math.max(a2.maxY, b.maxY);
        return a2;
      }
      function compareNodeMinX(a2, b) {
        return a2.minX - b.minX;
      }
      function compareNodeMinY(a2, b) {
        return a2.minY - b.minY;
      }
      function bboxArea(a2) {
        return (a2.maxX - a2.minX) * (a2.maxY - a2.minY);
      }
      function bboxMargin(a2) {
        return a2.maxX - a2.minX + (a2.maxY - a2.minY);
      }
      function enlargedArea(a2, b) {
        return (Math.max(b.maxX, a2.maxX) - Math.min(b.minX, a2.minX)) * (Math.max(b.maxY, a2.maxY) - Math.min(b.minY, a2.minY));
      }
      function intersectionArea(a2, b) {
        var minX = Math.max(a2.minX, b.minX), minY = Math.max(a2.minY, b.minY), maxX = Math.min(a2.maxX, b.maxX), maxY = Math.min(a2.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a2, b) {
        return a2.minX <= b.minX && a2.minY <= b.minY && b.maxX <= a2.maxX && b.maxY <= a2.maxY;
      }
      function intersects(a2, b) {
        return b.minX <= a2.maxX && b.minY <= a2.maxY && b.maxX >= a2.minX && b.maxY >= a2.minY;
      }
      function createNode(children) {
        return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr2, left, right, n, compare3) {
        var stack = [left, right], mid;
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n)
            continue;
          mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr2, mid, left, right, compare3);
          stack.push(left, mid, mid, right);
        }
      }
    }
  });

  // ../node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "../node_modules/earcut/src/earcut.js"(exports5, module) {
      "use strict";
      module.exports = earcut2;
      module.exports.default = earcut2;
      function earcut2(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x3, y3, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i = dim; i < outerLen; i += dim) {
            x3 = data[i];
            y3 = data[i + 1];
            if (x3 < minX)
              minX = x3;
            if (y3 < minY)
              minY = y3;
            if (x3 > maxX)
              maxX = x3;
            if (y3 > maxY)
              maxY = y3;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start2, end, dim, clockwise) {
        var i, last;
        if (clockwise === signedArea(data, start2, end, dim) > 0) {
          for (i = start2; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start2; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals2(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start2, end) {
        if (!start2)
          return start2;
        if (!end)
          end = start2;
        var p = start2, again;
        do {
          again = false;
          if (!p.steiner && (equals2(p, p.next) || area2(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a2 = ear.prev, b = ear, c = ear.next;
        if (area2(a2, b, c) >= 0)
          return false;
        var ax = a2.x, bx = b.x, cx = c.x, ay = a2.y, by = b.y, cy = c.y;
        var x02 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y02 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x12 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y12 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p = c.next;
        while (p !== a2) {
          if (p.x >= x02 && p.x <= x12 && p.y >= y02 && p.y <= y12 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a2 = ear.prev, b = ear, c = ear.next;
        if (area2(a2, b, c) >= 0)
          return false;
        var ax = a2.x, bx = b.x, cx = c.x, ay = a2.y, by = b.y, cy = c.y;
        var x02 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y02 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x12 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y12 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x02, y02, minX, minY, invSize), maxZ = zOrder(x12, y12, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p.x >= x02 && p.x <= x12 && p.y >= y02 && p.y <= y12 && p !== a2 && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n.x >= x02 && n.x <= x12 && n.y >= y02 && n.y <= y12 && n !== a2 && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p.x >= x02 && p.x <= x12 && p.y >= y02 && p.y <= y12 && p !== a2 && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n.x >= x02 && n.x <= x12 && n.y >= y02 && n.y <= y12 && n !== a2 && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start2, triangles, dim) {
        var p = start2;
        do {
          var a2 = p.prev, b = p.next.next;
          if (!equals2(a2, b) && intersects(a2, p, p.next, b) && locallyInside(a2, b) && locallyInside(b, a2)) {
            triangles.push(a2.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            removeNode(p);
            removeNode(p.next);
            p = start2 = b;
          }
          p = p.next;
        } while (p !== start2);
        return filterPoints(p);
      }
      function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
        var a2 = start2;
        do {
          var b = a2.next.next;
          while (b !== a2.prev) {
            if (a2.i !== b.i && isValidDiagonal(a2, b)) {
              var c = splitPolygon(a2, b);
              a2 = filterPoints(a2, a2.next);
              c = filterPoints(c, c.next);
              earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b = b.next;
          }
          a2 = a2.next;
        } while (a2 !== start2);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start2, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start2 = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start2, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
          outerNode = eliminateHole(queue[i], outerNode);
        }
        return outerNode;
      }
      function compareX(a2, b) {
        return a2.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x3 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x3 <= hx && x3 > qx) {
              qx = x3;
              m = p.x < p.next.x ? p : p.next;
              if (x3 === hx)
                return m;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m)
          return null;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan3;
        p = m;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan3 = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan3 < tanMin || tan3 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
              m = p;
              tanMin = tan3;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m;
      }
      function sectorContainsSector(m, p) {
        return area2(m.prev, m, p.prev) < 0 && area2(p.next, m, m.next) < 0;
      }
      function indexCurve(start2, minX, minY, invSize) {
        var p = start2;
        do {
          if (p.z === 0)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start2);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x3, y3, minX, minY, invSize) {
        x3 = (x3 - minX) * invSize | 0;
        y3 = (y3 - minY) * invSize | 0;
        x3 = (x3 | x3 << 8) & 16711935;
        x3 = (x3 | x3 << 4) & 252645135;
        x3 = (x3 | x3 << 2) & 858993459;
        x3 = (x3 | x3 << 1) & 1431655765;
        y3 = (y3 | y3 << 8) & 16711935;
        y3 = (y3 | y3 << 4) & 252645135;
        y3 = (y3 | y3 << 2) & 858993459;
        y3 = (y3 | y3 << 1) & 1431655765;
        return x3 | y3 << 1;
      }
      function getLeftmost(start2) {
        var p = start2, leftmost = start2;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start2);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a2, b) {
        return a2.next.i !== b.i && a2.prev.i !== b.i && !intersectsPolygon(a2, b) && (locallyInside(a2, b) && locallyInside(b, a2) && middleInside(a2, b) && (area2(a2.prev, a2, b.prev) || area2(a2, b.prev, b)) || equals2(a2, b) && area2(a2.prev, a2, a2.next) > 0 && area2(b.prev, b, b.next) > 0);
      }
      function area2(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals2(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        var o1 = sign2(area2(p1, q1, p2));
        var o2 = sign2(area2(p1, q1, q2));
        var o3 = sign2(area2(p2, q2, p1));
        var o4 = sign2(area2(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a2, b) {
        var p = a2;
        do {
          if (p.i !== a2.i && p.next.i !== a2.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a2, b))
            return true;
          p = p.next;
        } while (p !== a2);
        return false;
      }
      function locallyInside(a2, b) {
        return area2(a2.prev, a2, a2.next) < 0 ? area2(a2, b, a2.next) >= 0 && area2(a2, a2.prev, b) >= 0 : area2(a2, b, a2.prev) < 0 || area2(a2, a2.next, b) < 0;
      }
      function middleInside(a2, b) {
        var p = a2, inside = false, px = (a2.x + b.x) / 2, py = (a2.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a2);
        return inside;
      }
      function splitPolygon(a2, b) {
        var a22 = new Node2(a2.i, a2.x, a2.y), b2 = new Node2(b.i, b.x, b.y), an = a2.next, bp = b.prev;
        a2.next = b;
        b.prev = a2;
        a22.next = an;
        an.prev = a22;
        b2.next = a22;
        a22.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x3, y3, last) {
        var p = new Node2(i, x3, y3);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node2(i, x3, y3) {
        this.i = i;
        this.x = x3;
        this.y = y3;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut2.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start2 = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start2, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
          var a2 = triangles[i] * dim;
          var b = triangles[i + 1] * dim;
          var c = triangles[i + 2] * dim;
          trianglesArea += Math.abs(
            (data[a2] - data[c]) * (data[b + 1] - data[a2 + 1]) - (data[a2] - data[b]) * (data[c + 1] - data[a2 + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start2, end, dim) {
        var sum2 = 0;
        for (var i = start2, j = end - dim; i < end; i += dim) {
          sum2 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum2;
      }
      earcut2.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++)
              result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // ../node_modules/@turf/helpers/dist/js/index.js
  var require_js = __commonJS({
    "../node_modules/@turf/helpers/dist/js/index.js"(exports5) {
      "use strict";
      Object.defineProperty(exports5, "__esModule", { value: true });
      exports5.earthRadius = 63710088e-1;
      exports5.factors = {
        centimeters: exports5.earthRadius * 100,
        centimetres: exports5.earthRadius * 100,
        degrees: exports5.earthRadius / 111325,
        feet: exports5.earthRadius * 3.28084,
        inches: exports5.earthRadius * 39.37,
        kilometers: exports5.earthRadius / 1e3,
        kilometres: exports5.earthRadius / 1e3,
        meters: exports5.earthRadius,
        metres: exports5.earthRadius,
        miles: exports5.earthRadius / 1609.344,
        millimeters: exports5.earthRadius * 1e3,
        millimetres: exports5.earthRadius * 1e3,
        nauticalmiles: exports5.earthRadius / 1852,
        radians: 1,
        yards: exports5.earthRadius * 1.0936
      };
      exports5.unitsFactors = {
        centimeters: 100,
        centimetres: 100,
        degrees: 1 / 111325,
        feet: 3.28084,
        inches: 39.37,
        kilometers: 1 / 1e3,
        kilometres: 1 / 1e3,
        meters: 1,
        metres: 1,
        miles: 1 / 1609.344,
        millimeters: 1e3,
        millimetres: 1e3,
        nauticalmiles: 1 / 1852,
        radians: 1 / exports5.earthRadius,
        yards: 1.0936133
      };
      exports5.areaFactors = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        hectares: 1e-4,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 386e-9,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046
      };
      function feature3(geom, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var feat = { type: "Feature" };
        if (options.id === 0 || options.id) {
          feat.id = options.id;
        }
        if (options.bbox) {
          feat.bbox = options.bbox;
        }
        feat.properties = properties || {};
        feat.geometry = geom;
        return feat;
      }
      exports5.feature = feature3;
      function geometry(type, coordinates, _options) {
        if (_options === void 0) {
          _options = {};
        }
        switch (type) {
          case "Point":
            return point2(coordinates).geometry;
          case "LineString":
            return lineString2(coordinates).geometry;
          case "Polygon":
            return polygon2(coordinates).geometry;
          case "MultiPoint":
            return multiPoint2(coordinates).geometry;
          case "MultiLineString":
            return multiLineString2(coordinates).geometry;
          case "MultiPolygon":
            return multiPolygon2(coordinates).geometry;
          default:
            throw new Error(type + " is invalid");
        }
      }
      exports5.geometry = geometry;
      function point2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        if (!coordinates) {
          throw new Error("coordinates is required");
        }
        if (!Array.isArray(coordinates)) {
          throw new Error("coordinates must be an Array");
        }
        if (coordinates.length < 2) {
          throw new Error("coordinates must be at least 2 numbers long");
        }
        if (!isNumber2(coordinates[0]) || !isNumber2(coordinates[1])) {
          throw new Error("coordinates must contain numbers");
        }
        var geom = {
          type: "Point",
          coordinates
        };
        return feature3(geom, properties, options);
      }
      exports5.point = point2;
      function points(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return point2(coords, properties);
        }), options);
      }
      exports5.points = points;
      function polygon2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
          var ring = coordinates_1[_i];
          if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
          }
          for (var j = 0; j < ring[ring.length - 1].length; j++) {
            if (ring[ring.length - 1][j] !== ring[0][j]) {
              throw new Error("First and last Position are not equivalent.");
            }
          }
        }
        var geom = {
          type: "Polygon",
          coordinates
        };
        return feature3(geom, properties, options);
      }
      exports5.polygon = polygon2;
      function polygons(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return polygon2(coords, properties);
        }), options);
      }
      exports5.polygons = polygons;
      function lineString2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        if (coordinates.length < 2) {
          throw new Error("coordinates must be an array of two or more positions");
        }
        var geom = {
          type: "LineString",
          coordinates
        };
        return feature3(geom, properties, options);
      }
      exports5.lineString = lineString2;
      function lineStrings(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return lineString2(coords, properties);
        }), options);
      }
      exports5.lineStrings = lineStrings;
      function featureCollection2(features, options) {
        if (options === void 0) {
          options = {};
        }
        var fc = { type: "FeatureCollection" };
        if (options.id) {
          fc.id = options.id;
        }
        if (options.bbox) {
          fc.bbox = options.bbox;
        }
        fc.features = features;
        return fc;
      }
      exports5.featureCollection = featureCollection2;
      function multiLineString2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiLineString",
          coordinates
        };
        return feature3(geom, properties, options);
      }
      exports5.multiLineString = multiLineString2;
      function multiPoint2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiPoint",
          coordinates
        };
        return feature3(geom, properties, options);
      }
      exports5.multiPoint = multiPoint2;
      function multiPolygon2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiPolygon",
          coordinates
        };
        return feature3(geom, properties, options);
      }
      exports5.multiPolygon = multiPolygon2;
      function geometryCollection2(geometries, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "GeometryCollection",
          geometries
        };
        return feature3(geom, properties, options);
      }
      exports5.geometryCollection = geometryCollection2;
      function round(num, precision) {
        if (precision === void 0) {
          precision = 0;
        }
        if (precision && !(precision >= 0)) {
          throw new Error("precision must be a positive number");
        }
        var multiplier = Math.pow(10, precision || 0);
        return Math.round(num * multiplier) / multiplier;
      }
      exports5.round = round;
      function radiansToLength2(radians2, units) {
        if (units === void 0) {
          units = "kilometers";
        }
        var factor = exports5.factors[units];
        if (!factor) {
          throw new Error(units + " units is invalid");
        }
        return radians2 * factor;
      }
      exports5.radiansToLength = radiansToLength2;
      function lengthToRadians2(distance, units) {
        if (units === void 0) {
          units = "kilometers";
        }
        var factor = exports5.factors[units];
        if (!factor) {
          throw new Error(units + " units is invalid");
        }
        return distance / factor;
      }
      exports5.lengthToRadians = lengthToRadians2;
      function lengthToDegrees2(distance, units) {
        return radiansToDegrees2(lengthToRadians2(distance, units));
      }
      exports5.lengthToDegrees = lengthToDegrees2;
      function bearingToAzimuth2(bearing2) {
        var angle = bearing2 % 360;
        if (angle < 0) {
          angle += 360;
        }
        return angle;
      }
      exports5.bearingToAzimuth = bearingToAzimuth2;
      function radiansToDegrees2(radians2) {
        var degrees2 = radians2 % (2 * Math.PI);
        return degrees2 * 180 / Math.PI;
      }
      exports5.radiansToDegrees = radiansToDegrees2;
      function degreesToRadians2(degrees2) {
        var radians2 = degrees2 % 360;
        return radians2 * Math.PI / 180;
      }
      exports5.degreesToRadians = degreesToRadians2;
      function convertLength2(length2, originalUnit, finalUnit) {
        if (originalUnit === void 0) {
          originalUnit = "kilometers";
        }
        if (finalUnit === void 0) {
          finalUnit = "kilometers";
        }
        if (!(length2 >= 0)) {
          throw new Error("length must be a positive number");
        }
        return radiansToLength2(lengthToRadians2(length2, originalUnit), finalUnit);
      }
      exports5.convertLength = convertLength2;
      function convertArea(area2, originalUnit, finalUnit) {
        if (originalUnit === void 0) {
          originalUnit = "meters";
        }
        if (finalUnit === void 0) {
          finalUnit = "kilometers";
        }
        if (!(area2 >= 0)) {
          throw new Error("area must be a positive number");
        }
        var startFactor = exports5.areaFactors[originalUnit];
        if (!startFactor) {
          throw new Error("invalid original units");
        }
        var finalFactor = exports5.areaFactors[finalUnit];
        if (!finalFactor) {
          throw new Error("invalid final units");
        }
        return area2 / startFactor * finalFactor;
      }
      exports5.convertArea = convertArea;
      function isNumber2(num) {
        return !isNaN(num) && num !== null && !Array.isArray(num);
      }
      exports5.isNumber = isNumber2;
      function isObject2(input) {
        return !!input && input.constructor === Object;
      }
      exports5.isObject = isObject2;
      function validateBBox(bbox2) {
        if (!bbox2) {
          throw new Error("bbox is required");
        }
        if (!Array.isArray(bbox2)) {
          throw new Error("bbox must be an Array");
        }
        if (bbox2.length !== 4 && bbox2.length !== 6) {
          throw new Error("bbox must be an Array of 4 or 6 numbers");
        }
        bbox2.forEach(function(num) {
          if (!isNumber2(num)) {
            throw new Error("bbox must only contain numbers");
          }
        });
      }
      exports5.validateBBox = validateBBox;
      function validateId(id) {
        if (!id) {
          throw new Error("id is required");
        }
        if (["string", "number"].indexOf(typeof id) === -1) {
          throw new Error("id must be a number or a string");
        }
      }
      exports5.validateId = validateId;
    }
  });

  // ../node_modules/@turf/meta/dist/js/index.js
  var require_js2 = __commonJS({
    "../node_modules/@turf/meta/dist/js/index.js"(exports5) {
      "use strict";
      Object.defineProperty(exports5, "__esModule", { value: true });
      var helpers = require_js();
      function coordEach2(geojson, callback, excludeWrapCoord) {
        if (geojson === null)
          return;
        var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
        for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
          geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
          for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
            if (geometry === null)
              continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;
            wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
            switch (geomType) {
              case null:
                break;
              case "Point":
                if (callback(
                  coords,
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
                multiFeatureIndex++;
                break;
              case "LineString":
              case "MultiPoint":
                for (j = 0; j < coords.length; j++) {
                  if (callback(
                    coords[j],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                  if (geomType === "MultiPoint")
                    multiFeatureIndex++;
                }
                if (geomType === "LineString")
                  multiFeatureIndex++;
                break;
              case "Polygon":
              case "MultiLineString":
                for (j = 0; j < coords.length; j++) {
                  for (k = 0; k < coords[j].length - wrapShrink; k++) {
                    if (callback(
                      coords[j][k],
                      coordIndex,
                      featureIndex,
                      multiFeatureIndex,
                      geometryIndex
                    ) === false)
                      return false;
                    coordIndex++;
                  }
                  if (geomType === "MultiLineString")
                    multiFeatureIndex++;
                  if (geomType === "Polygon")
                    geometryIndex++;
                }
                if (geomType === "Polygon")
                  multiFeatureIndex++;
                break;
              case "MultiPolygon":
                for (j = 0; j < coords.length; j++) {
                  geometryIndex = 0;
                  for (k = 0; k < coords[j].length; k++) {
                    for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                      if (callback(
                        coords[j][k][l],
                        coordIndex,
                        featureIndex,
                        multiFeatureIndex,
                        geometryIndex
                      ) === false)
                        return false;
                      coordIndex++;
                    }
                    geometryIndex++;
                  }
                  multiFeatureIndex++;
                }
                break;
              case "GeometryCollection":
                for (j = 0; j < geometry.geometries.length; j++)
                  if (coordEach2(geometry.geometries[j], callback, excludeWrapCoord) === false)
                    return false;
                break;
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
        }
      }
      function coordReduce2(geojson, callback, initialValue, excludeWrapCoord) {
        var previousValue = initialValue;
        coordEach2(
          geojson,
          function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
            if (coordIndex === 0 && initialValue === void 0)
              previousValue = currentCoord;
            else
              previousValue = callback(
                previousValue,
                currentCoord,
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              );
          },
          excludeWrapCoord
        );
        return previousValue;
      }
      function propEach(geojson, callback) {
        var i;
        switch (geojson.type) {
          case "FeatureCollection":
            for (i = 0; i < geojson.features.length; i++) {
              if (callback(geojson.features[i].properties, i) === false)
                break;
            }
            break;
          case "Feature":
            callback(geojson.properties, 0);
            break;
        }
      }
      function propReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        propEach(geojson, function(currentProperties, featureIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentProperties;
          else
            previousValue = callback(previousValue, currentProperties, featureIndex);
        });
        return previousValue;
      }
      function featureEach2(geojson, callback) {
        if (geojson.type === "Feature") {
          callback(geojson, 0);
        } else if (geojson.type === "FeatureCollection") {
          for (var i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i], i) === false)
              break;
          }
        }
      }
      function featureReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        featureEach2(geojson, function(currentFeature, featureIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentFeature;
          else
            previousValue = callback(previousValue, currentFeature, featureIndex);
        });
        return previousValue;
      }
      function coordAll2(geojson) {
        var coords = [];
        coordEach2(geojson, function(coord) {
          coords.push(coord);
        });
        return coords;
      }
      function geomEach2(geojson, callback) {
        var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
        for (i = 0; i < stop; i++) {
          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
          for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            if (geometry === null) {
              if (callback(
                null,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false)
                return false;
              continue;
            }
            switch (geometry.type) {
              case "Point":
              case "LineString":
              case "MultiPoint":
              case "Polygon":
              case "MultiLineString":
              case "MultiPolygon": {
                if (callback(
                  geometry,
                  featureIndex,
                  featureProperties,
                  featureBBox,
                  featureId
                ) === false)
                  return false;
                break;
              }
              case "GeometryCollection": {
                for (j = 0; j < geometry.geometries.length; j++) {
                  if (callback(
                    geometry.geometries[j],
                    featureIndex,
                    featureProperties,
                    featureBBox,
                    featureId
                  ) === false)
                    return false;
                }
                break;
              }
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
          featureIndex++;
        }
      }
      function geomReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        geomEach2(
          geojson,
          function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
            if (featureIndex === 0 && initialValue === void 0)
              previousValue = currentGeometry;
            else
              previousValue = callback(
                previousValue,
                currentGeometry,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              );
          }
        );
        return previousValue;
      }
      function flattenEach2(geojson, callback) {
        geomEach2(geojson, function(geometry, featureIndex, properties, bbox2, id) {
          var type = geometry === null ? null : geometry.type;
          switch (type) {
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
              if (callback(
                helpers.feature(geometry, properties, { bbox: bbox2, id }),
                featureIndex,
                0
              ) === false)
                return false;
              return;
          }
          var geomType;
          switch (type) {
            case "MultiPoint":
              geomType = "Point";
              break;
            case "MultiLineString":
              geomType = "LineString";
              break;
            case "MultiPolygon":
              geomType = "Polygon";
              break;
          }
          for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
              type: geomType,
              coordinates: coordinate
            };
            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false)
              return false;
          }
        });
      }
      function flattenReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        flattenEach2(
          geojson,
          function(currentFeature, featureIndex, multiFeatureIndex) {
            if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
              previousValue = currentFeature;
            else
              previousValue = callback(
                previousValue,
                currentFeature,
                featureIndex,
                multiFeatureIndex
              );
          }
        );
        return previousValue;
      }
      function segmentEach2(geojson, callback) {
        flattenEach2(geojson, function(feature3, featureIndex, multiFeatureIndex) {
          var segmentIndex = 0;
          if (!feature3.geometry)
            return;
          var type = feature3.geometry.type;
          if (type === "Point" || type === "MultiPoint")
            return;
          var previousCoords;
          var previousFeatureIndex = 0;
          var previousMultiIndex = 0;
          var prevGeomIndex = 0;
          if (coordEach2(
            feature3,
            function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
              if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
              }
              var currentSegment = helpers.lineString(
                [previousCoords, currentCoord],
                feature3.properties
              );
              if (callback(
                currentSegment,
                featureIndex,
                multiFeatureIndex,
                geometryIndex,
                segmentIndex
              ) === false)
                return false;
              segmentIndex++;
              previousCoords = currentCoord;
            }
          ) === false)
            return false;
        });
      }
      function segmentReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        var started = false;
        segmentEach2(
          geojson,
          function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
            if (started === false && initialValue === void 0)
              previousValue = currentSegment;
            else
              previousValue = callback(
                previousValue,
                currentSegment,
                featureIndex,
                multiFeatureIndex,
                geometryIndex,
                segmentIndex
              );
            started = true;
          }
        );
        return previousValue;
      }
      function lineEach(geojson, callback) {
        if (!geojson)
          throw new Error("geojson is required");
        flattenEach2(geojson, function(feature3, featureIndex, multiFeatureIndex) {
          if (feature3.geometry === null)
            return;
          var type = feature3.geometry.type;
          var coords = feature3.geometry.coordinates;
          switch (type) {
            case "LineString":
              if (callback(feature3, featureIndex, multiFeatureIndex, 0, 0) === false)
                return false;
              break;
            case "Polygon":
              for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
                if (callback(
                  helpers.lineString(coords[geometryIndex], feature3.properties),
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
              }
              break;
          }
        });
      }
      function lineReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        lineEach(
          geojson,
          function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
            if (featureIndex === 0 && initialValue === void 0)
              previousValue = currentLine;
            else
              previousValue = callback(
                previousValue,
                currentLine,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              );
          }
        );
        return previousValue;
      }
      function findSegment(geojson, options) {
        options = options || {};
        if (!helpers.isObject(options))
          throw new Error("options is invalid");
        var featureIndex = options.featureIndex || 0;
        var multiFeatureIndex = options.multiFeatureIndex || 0;
        var geometryIndex = options.geometryIndex || 0;
        var segmentIndex = options.segmentIndex || 0;
        var properties = options.properties;
        var geometry;
        switch (geojson.type) {
          case "FeatureCollection":
            if (featureIndex < 0)
              featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
          case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            geometry = geojson;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (geometry === null)
          return null;
        var coords = geometry.coordinates;
        switch (geometry.type) {
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
            if (segmentIndex < 0)
              segmentIndex = coords.length + segmentIndex - 1;
            return helpers.lineString(
              [coords[segmentIndex], coords[segmentIndex + 1]],
              properties,
              options
            );
          case "Polygon":
            if (geometryIndex < 0)
              geometryIndex = coords.length + geometryIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
            return helpers.lineString(
              [
                coords[geometryIndex][segmentIndex],
                coords[geometryIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
          case "MultiLineString":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
            return helpers.lineString(
              [
                coords[multiFeatureIndex][segmentIndex],
                coords[multiFeatureIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
          case "MultiPolygon":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0)
              geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
            return helpers.lineString(
              [
                coords[multiFeatureIndex][geometryIndex][segmentIndex],
                coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
        }
        throw new Error("geojson is invalid");
      }
      function findPoint(geojson, options) {
        options = options || {};
        if (!helpers.isObject(options))
          throw new Error("options is invalid");
        var featureIndex = options.featureIndex || 0;
        var multiFeatureIndex = options.multiFeatureIndex || 0;
        var geometryIndex = options.geometryIndex || 0;
        var coordIndex = options.coordIndex || 0;
        var properties = options.properties;
        var geometry;
        switch (geojson.type) {
          case "FeatureCollection":
            if (featureIndex < 0)
              featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
          case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            geometry = geojson;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (geometry === null)
          return null;
        var coords = geometry.coordinates;
        switch (geometry.type) {
          case "Point":
            return helpers.point(coords, properties, options);
          case "MultiPoint":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            return helpers.point(coords[multiFeatureIndex], properties, options);
          case "LineString":
            if (coordIndex < 0)
              coordIndex = coords.length + coordIndex;
            return helpers.point(coords[coordIndex], properties, options);
          case "Polygon":
            if (geometryIndex < 0)
              geometryIndex = coords.length + geometryIndex;
            if (coordIndex < 0)
              coordIndex = coords[geometryIndex].length + coordIndex;
            return helpers.point(coords[geometryIndex][coordIndex], properties, options);
          case "MultiLineString":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (coordIndex < 0)
              coordIndex = coords[multiFeatureIndex].length + coordIndex;
            return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
          case "MultiPolygon":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0)
              geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (coordIndex < 0)
              coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
            return helpers.point(
              coords[multiFeatureIndex][geometryIndex][coordIndex],
              properties,
              options
            );
        }
        throw new Error("geojson is invalid");
      }
      exports5.coordAll = coordAll2;
      exports5.coordEach = coordEach2;
      exports5.coordReduce = coordReduce2;
      exports5.featureEach = featureEach2;
      exports5.featureReduce = featureReduce2;
      exports5.findPoint = findPoint;
      exports5.findSegment = findSegment;
      exports5.flattenEach = flattenEach2;
      exports5.flattenReduce = flattenReduce;
      exports5.geomEach = geomEach2;
      exports5.geomReduce = geomReduce2;
      exports5.lineEach = lineEach;
      exports5.lineReduce = lineReduce2;
      exports5.propEach = propEach;
      exports5.propReduce = propReduce;
      exports5.segmentEach = segmentEach2;
      exports5.segmentReduce = segmentReduce2;
    }
  });

  // ../node_modules/@turf/bbox/dist/js/index.js
  var require_js3 = __commonJS({
    "../node_modules/@turf/bbox/dist/js/index.js"(exports5) {
      "use strict";
      Object.defineProperty(exports5, "__esModule", { value: true });
      var meta_1 = require_js2();
      function bbox2(geojson) {
        var result = [Infinity, Infinity, -Infinity, -Infinity];
        meta_1.coordEach(geojson, function(coord) {
          if (result[0] > coord[0]) {
            result[0] = coord[0];
          }
          if (result[1] > coord[1]) {
            result[1] = coord[1];
          }
          if (result[2] < coord[0]) {
            result[2] = coord[0];
          }
          if (result[3] < coord[1]) {
            result[3] = coord[1];
          }
        });
        return result;
      }
      bbox2["default"] = bbox2;
      exports5.default = bbox2;
    }
  });

  // ../node_modules/geojson-rbush/index.js
  var require_geojson_rbush = __commonJS({
    "../node_modules/geojson-rbush/index.js"(exports5, module) {
      var rbush6 = require_rbush_min();
      var helpers = require_js();
      var meta = require_js2();
      var turfBBox = require_js3().default;
      var featureEach2 = meta.featureEach;
      var coordEach2 = meta.coordEach;
      var polygon2 = helpers.polygon;
      var featureCollection2 = helpers.featureCollection;
      function geojsonRbush(maxEntries) {
        var tree = new rbush6(maxEntries);
        tree.insert = function(feature3) {
          if (feature3.type !== "Feature")
            throw new Error("invalid feature");
          feature3.bbox = feature3.bbox ? feature3.bbox : turfBBox(feature3);
          return rbush6.prototype.insert.call(this, feature3);
        };
        tree.load = function(features) {
          var load = [];
          if (Array.isArray(features)) {
            features.forEach(function(feature3) {
              if (feature3.type !== "Feature")
                throw new Error("invalid features");
              feature3.bbox = feature3.bbox ? feature3.bbox : turfBBox(feature3);
              load.push(feature3);
            });
          } else {
            featureEach2(features, function(feature3) {
              if (feature3.type !== "Feature")
                throw new Error("invalid features");
              feature3.bbox = feature3.bbox ? feature3.bbox : turfBBox(feature3);
              load.push(feature3);
            });
          }
          return rbush6.prototype.load.call(this, load);
        };
        tree.remove = function(feature3, equals2) {
          if (feature3.type !== "Feature")
            throw new Error("invalid feature");
          feature3.bbox = feature3.bbox ? feature3.bbox : turfBBox(feature3);
          return rbush6.prototype.remove.call(this, feature3, equals2);
        };
        tree.clear = function() {
          return rbush6.prototype.clear.call(this);
        };
        tree.search = function(geojson) {
          var features = rbush6.prototype.search.call(this, this.toBBox(geojson));
          return featureCollection2(features);
        };
        tree.collides = function(geojson) {
          return rbush6.prototype.collides.call(this, this.toBBox(geojson));
        };
        tree.all = function() {
          var features = rbush6.prototype.all.call(this);
          return featureCollection2(features);
        };
        tree.toJSON = function() {
          return rbush6.prototype.toJSON.call(this);
        };
        tree.fromJSON = function(json) {
          return rbush6.prototype.fromJSON.call(this, json);
        };
        tree.toBBox = function(geojson) {
          var bbox2;
          if (geojson.bbox)
            bbox2 = geojson.bbox;
          else if (Array.isArray(geojson) && geojson.length === 4)
            bbox2 = geojson;
          else if (Array.isArray(geojson) && geojson.length === 6)
            bbox2 = [geojson[0], geojson[1], geojson[3], geojson[4]];
          else if (geojson.type === "Feature")
            bbox2 = turfBBox(geojson);
          else if (geojson.type === "FeatureCollection")
            bbox2 = turfBBox(geojson);
          else
            throw new Error("invalid geojson");
          return {
            minX: bbox2[0],
            minY: bbox2[1],
            maxX: bbox2[2],
            maxY: bbox2[3]
          };
        };
        return tree;
      }
      module.exports = geojsonRbush;
      module.exports.default = geojsonRbush;
    }
  });

  // ../node_modules/@turf/unkink-polygon/node_modules/quickselect/quickselect.js
  var require_quickselect2 = __commonJS({
    "../node_modules/@turf/unkink-polygon/node_modules/quickselect/quickselect.js"(exports5, module) {
      (function(global, factory) {
        typeof exports5 === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.quickselect = factory();
      })(exports5, function() {
        "use strict";
        function quickselect(arr2, k, left, right, compare3) {
          quickselectStep(arr2, k, left || 0, right || arr2.length - 1, compare3 || defaultCompare);
        }
        function quickselectStep(arr2, k, left, right, compare3) {
          while (right > left) {
            if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z2 = Math.log(n);
              var s = 0.5 * Math.exp(2 * z2 / 3);
              var sd = 0.5 * Math.sqrt(z2 * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr2, k, newLeft, newRight, compare3);
            }
            var t = arr2[k];
            var i = left;
            var j = right;
            swap2(arr2, left, k);
            if (compare3(arr2[right], t) > 0)
              swap2(arr2, left, right);
            while (i < j) {
              swap2(arr2, i, j);
              i++;
              j--;
              while (compare3(arr2[i], t) < 0)
                i++;
              while (compare3(arr2[j], t) > 0)
                j--;
            }
            if (compare3(arr2[left], t) === 0)
              swap2(arr2, left, j);
            else {
              j++;
              swap2(arr2, j, right);
            }
            if (j <= k)
              left = j + 1;
            if (k <= j)
              right = j - 1;
          }
        }
        function swap2(arr2, i, j) {
          var tmp = arr2[i];
          arr2[i] = arr2[j];
          arr2[j] = tmp;
        }
        function defaultCompare(a2, b) {
          return a2 < b ? -1 : a2 > b ? 1 : 0;
        }
        return quickselect;
      });
    }
  });

  // ../node_modules/@turf/unkink-polygon/node_modules/rbush/index.js
  var require_rbush2 = __commonJS({
    "../node_modules/@turf/unkink-polygon/node_modules/rbush/index.js"(exports5, module) {
      "use strict";
      module.exports = rbush6;
      module.exports.default = rbush6;
      var quickselect = require_quickselect2();
      function rbush6(maxEntries, format) {
        if (!(this instanceof rbush6))
          return new rbush6(maxEntries, format);
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        if (format) {
          this._initFormat(format);
        }
        this.clear();
      }
      rbush6.prototype = {
        all: function() {
          return this._all(this.data, []);
        },
        search: function(bbox2) {
          var node = this.data, result = [], toBBox = this.toBBox;
          if (!intersects(bbox2, node))
            return result;
          var nodesToSearch = [], i, len, child, childBBox;
          while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects(bbox2, childBBox)) {
                if (node.leaf)
                  result.push(child);
                else if (contains(bbox2, childBBox))
                  this._all(child, result);
                else
                  nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return result;
        },
        collides: function(bbox2) {
          var node = this.data, toBBox = this.toBBox;
          if (!intersects(bbox2, node))
            return false;
          var nodesToSearch = [], i, len, child, childBBox;
          while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects(bbox2, childBBox)) {
                if (node.leaf || contains(bbox2, childBBox))
                  return true;
                nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return false;
        },
        load: function(data) {
          if (!(data && data.length))
            return this;
          if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
              this.insert(data[i]);
            }
            return this;
          }
          var node = this._build(data.slice(), 0, data.length - 1, 0);
          if (!this.data.children.length) {
            this.data = node;
          } else if (this.data.height === node.height) {
            this._splitRoot(this.data, node);
          } else {
            if (this.data.height < node.height) {
              var tmpNode = this.data;
              this.data = node;
              node = tmpNode;
            }
            this._insert(node, this.data.height - node.height - 1, true);
          }
          return this;
        },
        insert: function(item) {
          if (item)
            this._insert(item, this.data.height - 1);
          return this;
        },
        clear: function() {
          this.data = createNode([]);
          return this;
        },
        remove: function(item, equalsFn) {
          if (!item)
            return this;
          var node = this.data, bbox2 = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
          while (node || path.length) {
            if (!node) {
              node = path.pop();
              parent = path[path.length - 1];
              i = indexes.pop();
              goingUp = true;
            }
            if (node.leaf) {
              index = findItem(item, node.children, equalsFn);
              if (index !== -1) {
                node.children.splice(index, 1);
                path.push(node);
                this._condense(path);
                return this;
              }
            }
            if (!goingUp && !node.leaf && contains(node, bbox2)) {
              path.push(node);
              indexes.push(i);
              i = 0;
              parent = node;
              node = node.children[0];
            } else if (parent) {
              i++;
              node = parent.children[i];
              goingUp = false;
            } else
              node = null;
          }
          return this;
        },
        toBBox: function(item) {
          return item;
        },
        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,
        toJSON: function() {
          return this.data;
        },
        fromJSON: function(data) {
          this.data = data;
          return this;
        },
        _all: function(node, result) {
          var nodesToSearch = [];
          while (node) {
            if (node.leaf)
              result.push.apply(result, node.children);
            else
              nodesToSearch.push.apply(nodesToSearch, node.children);
            node = nodesToSearch.pop();
          }
          return result;
        },
        _build: function(items, left, right, height) {
          var N = right - left + 1, M = this._maxEntries, node;
          if (N <= M) {
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
          }
          if (!height) {
            height = Math.ceil(Math.log(N) / Math.log(M));
            M = Math.ceil(N / Math.pow(M, height - 1));
          }
          node = createNode([]);
          node.leaf = false;
          node.height = height;
          var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
          multiSelect(items, left, right, N1, this.compareMinX);
          for (i = left; i <= right; i += N1) {
            right2 = Math.min(i + N1 - 1, right);
            multiSelect(items, i, right2, N2, this.compareMinY);
            for (j = i; j <= right2; j += N2) {
              right3 = Math.min(j + N2 - 1, right2);
              node.children.push(this._build(items, j, right3, height - 1));
            }
          }
          calcBBox(node, this.toBBox);
          return node;
        },
        _chooseSubtree: function(bbox2, node, level, path) {
          var i, len, child, targetNode, area2, enlargement, minArea, minEnlargement;
          while (true) {
            path.push(node);
            if (node.leaf || path.length - 1 === level)
              break;
            minArea = minEnlargement = Infinity;
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              area2 = bboxArea(child);
              enlargement = enlargedArea(bbox2, child) - area2;
              if (enlargement < minEnlargement) {
                minEnlargement = enlargement;
                minArea = area2 < minArea ? area2 : minArea;
                targetNode = child;
              } else if (enlargement === minEnlargement) {
                if (area2 < minArea) {
                  minArea = area2;
                  targetNode = child;
                }
              }
            }
            node = targetNode || node.children[0];
          }
          return node;
        },
        _insert: function(item, level, isNode2) {
          var toBBox = this.toBBox, bbox2 = isNode2 ? item : toBBox(item), insertPath = [];
          var node = this._chooseSubtree(bbox2, this.data, level, insertPath);
          node.children.push(item);
          extend(node, bbox2);
          while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
              this._split(insertPath, level);
              level--;
            } else
              break;
          }
          this._adjustParentBBoxes(bbox2, insertPath, level);
        },
        _split: function(insertPath, level) {
          var node = insertPath[level], M = node.children.length, m = this._minEntries;
          this._chooseSplitAxis(node, m, M);
          var splitIndex = this._chooseSplitIndex(node, m, M);
          var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
          newNode.height = node.height;
          newNode.leaf = node.leaf;
          calcBBox(node, this.toBBox);
          calcBBox(newNode, this.toBBox);
          if (level)
            insertPath[level - 1].children.push(newNode);
          else
            this._splitRoot(node, newNode);
        },
        _splitRoot: function(node, newNode) {
          this.data = createNode([node, newNode]);
          this.data.height = node.height + 1;
          this.data.leaf = false;
          calcBBox(this.data, this.toBBox);
        },
        _chooseSplitIndex: function(node, m, M) {
          var i, bbox1, bbox2, overlap, area2, minOverlap, minArea, index;
          minOverlap = minArea = Infinity;
          for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);
            overlap = intersectionArea(bbox1, bbox2);
            area2 = bboxArea(bbox1) + bboxArea(bbox2);
            if (overlap < minOverlap) {
              minOverlap = overlap;
              index = i;
              minArea = area2 < minArea ? area2 : minArea;
            } else if (overlap === minOverlap) {
              if (area2 < minArea) {
                minArea = area2;
                index = i;
              }
            }
          }
          return index;
        },
        _chooseSplitAxis: function(node, m, M) {
          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
          if (xMargin < yMargin)
            node.children.sort(compareMinX);
        },
        _allDistMargin: function(node, m, M, compare3) {
          node.children.sort(compare3);
          var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
          for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
          }
          for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
          }
          return margin;
        },
        _adjustParentBBoxes: function(bbox2, path, level) {
          for (var i = level; i >= 0; i--) {
            extend(path[i], bbox2);
          }
        },
        _condense: function(path) {
          for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
              if (i > 0) {
                siblings = path[i - 1].children;
                siblings.splice(siblings.indexOf(path[i]), 1);
              } else
                this.clear();
            } else
              calcBBox(path[i], this.toBBox);
          }
        },
        _initFormat: function(format) {
          var compareArr = ["return a", " - b", ";"];
          this.compareMinX = new Function("a", "b", compareArr.join(format[0]));
          this.compareMinY = new Function("a", "b", compareArr.join(format[1]));
          this.toBBox = new Function(
            "a",
            "return {minX: a" + format[0] + ", minY: a" + format[1] + ", maxX: a" + format[2] + ", maxY: a" + format[3] + "};"
          );
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn)
          return items.indexOf(item);
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i]))
            return i;
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode)
          destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k, child; i < p; i++) {
          child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend(a2, b) {
        a2.minX = Math.min(a2.minX, b.minX);
        a2.minY = Math.min(a2.minY, b.minY);
        a2.maxX = Math.max(a2.maxX, b.maxX);
        a2.maxY = Math.max(a2.maxY, b.maxY);
        return a2;
      }
      function compareNodeMinX(a2, b) {
        return a2.minX - b.minX;
      }
      function compareNodeMinY(a2, b) {
        return a2.minY - b.minY;
      }
      function bboxArea(a2) {
        return (a2.maxX - a2.minX) * (a2.maxY - a2.minY);
      }
      function bboxMargin(a2) {
        return a2.maxX - a2.minX + (a2.maxY - a2.minY);
      }
      function enlargedArea(a2, b) {
        return (Math.max(b.maxX, a2.maxX) - Math.min(b.minX, a2.minX)) * (Math.max(b.maxY, a2.maxY) - Math.min(b.minY, a2.minY));
      }
      function intersectionArea(a2, b) {
        var minX = Math.max(a2.minX, b.minX), minY = Math.max(a2.minY, b.minY), maxX = Math.min(a2.maxX, b.maxX), maxY = Math.min(a2.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a2, b) {
        return a2.minX <= b.minX && a2.minY <= b.minY && b.maxX <= a2.maxX && b.maxY <= a2.maxY;
      }
      function intersects(a2, b) {
        return b.minX <= a2.maxX && b.minY <= a2.maxY && b.maxX >= a2.minX && b.maxY >= a2.minY;
      }
      function createNode(children) {
        return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr2, left, right, n, compare3) {
        var stack = [left, right], mid;
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n)
            continue;
          mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr2, mid, left, right, compare3);
          stack.push(left, mid, mid, right);
        }
      }
    }
  });

  // ../node_modules/object-keys/isArguments.js
  var require_isArguments = __commonJS({
    "../node_modules/object-keys/isArguments.js"(exports5, module) {
      "use strict";
      var toStr = Object.prototype.toString;
      module.exports = function isArguments(value) {
        var str = toStr.call(value);
        var isArgs = str === "[object Arguments]";
        if (!isArgs) {
          isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
        }
        return isArgs;
      };
    }
  });

  // ../node_modules/object-keys/implementation.js
  var require_implementation = __commonJS({
    "../node_modules/object-keys/implementation.js"(exports5, module) {
      "use strict";
      var keysShim;
      if (!Object.keys) {
        has = Object.prototype.hasOwnProperty;
        toStr = Object.prototype.toString;
        isArgs = require_isArguments();
        isEnumerable = Object.prototype.propertyIsEnumerable;
        hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
        hasProtoEnumBug = isEnumerable.call(function() {
        }, "prototype");
        dontEnums = [
          "toString",
          "toLocaleString",
          "valueOf",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "constructor"
        ];
        equalsConstructorPrototype = function(o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        excludedKeys = {
          $applicationCache: true,
          $console: true,
          $external: true,
          $frame: true,
          $frameElement: true,
          $frames: true,
          $innerHeight: true,
          $innerWidth: true,
          $onmozfullscreenchange: true,
          $onmozfullscreenerror: true,
          $outerHeight: true,
          $outerWidth: true,
          $pageXOffset: true,
          $pageYOffset: true,
          $parent: true,
          $scrollLeft: true,
          $scrollTop: true,
          $scrollX: true,
          $scrollY: true,
          $self: true,
          $webkitIndexedDB: true,
          $webkitStorageInfo: true,
          $window: true
        };
        hasAutomationEqualityBug = function() {
          if (typeof window === "undefined") {
            return false;
          }
          for (var k in window) {
            try {
              if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                try {
                  equalsConstructorPrototype(window[k]);
                } catch (e) {
                  return true;
                }
              }
            } catch (e) {
              return true;
            }
          }
          return false;
        }();
        equalsConstructorPrototypeIfNotBuggy = function(o) {
          if (typeof window === "undefined" || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        keysShim = function keys(object2) {
          var isObject2 = object2 !== null && typeof object2 === "object";
          var isFunction = toStr.call(object2) === "[object Function]";
          var isArguments = isArgs(object2);
          var isString = isObject2 && toStr.call(object2) === "[object String]";
          var theKeys = [];
          if (!isObject2 && !isFunction && !isArguments) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var skipProto = hasProtoEnumBug && isFunction;
          if (isString && object2.length > 0 && !has.call(object2, 0)) {
            for (var i = 0; i < object2.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments && object2.length > 0) {
            for (var j = 0; j < object2.length; ++j) {
              theKeys.push(String(j));
            }
          } else {
            for (var name2 in object2) {
              if (!(skipProto && name2 === "prototype") && has.call(object2, name2)) {
                theKeys.push(String(name2));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
            for (var k = 0; k < dontEnums.length; ++k) {
              if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object2, dontEnums[k])) {
                theKeys.push(dontEnums[k]);
              }
            }
          }
          return theKeys;
        };
      }
      var has;
      var toStr;
      var isArgs;
      var isEnumerable;
      var hasDontEnumBug;
      var hasProtoEnumBug;
      var dontEnums;
      var equalsConstructorPrototype;
      var excludedKeys;
      var hasAutomationEqualityBug;
      var equalsConstructorPrototypeIfNotBuggy;
      module.exports = keysShim;
    }
  });

  // ../node_modules/object-keys/index.js
  var require_object_keys = __commonJS({
    "../node_modules/object-keys/index.js"(exports5, module) {
      "use strict";
      var slice3 = Array.prototype.slice;
      var isArgs = require_isArguments();
      var origKeys = Object.keys;
      var keysShim = origKeys ? function keys(o) {
        return origKeys(o);
      } : require_implementation();
      var originalKeys = Object.keys;
      keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
          var keysWorksWithArguments = function() {
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
          }(1, 2);
          if (!keysWorksWithArguments) {
            Object.keys = function keys(object2) {
              if (isArgs(object2)) {
                return originalKeys(slice3.call(object2));
              }
              return originalKeys(object2);
            };
          }
        } else {
          Object.keys = keysShim;
        }
        return Object.keys || keysShim;
      };
      module.exports = keysShim;
    }
  });

  // ../node_modules/has-tostringtag/node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "../node_modules/has-tostringtag/node_modules/has-symbols/shams.js"(exports5, module) {
      "use strict";
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // ../node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "../node_modules/has-tostringtag/shams.js"(exports5, module) {
      "use strict";
      var hasSymbols = require_shams();
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // ../node_modules/get-intrinsic/node_modules/has-symbols/shams.js
  var require_shams3 = __commonJS({
    "../node_modules/get-intrinsic/node_modules/has-symbols/shams.js"(exports5, module) {
      "use strict";
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // ../node_modules/get-intrinsic/node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "../node_modules/get-intrinsic/node_modules/has-symbols/index.js"(exports5, module) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams3();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // ../node_modules/function-bind/implementation.js
  var require_implementation2 = __commonJS({
    "../node_modules/function-bind/implementation.js"(exports5, module) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice3 = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice3.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              args.concat(slice3.call(arguments))
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(
              that,
              args.concat(slice3.call(arguments))
            );
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push("$" + i);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // ../node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "../node_modules/function-bind/index.js"(exports5, module) {
      "use strict";
      var implementation = require_implementation2();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // ../node_modules/has/src/index.js
  var require_src = __commonJS({
    "../node_modules/has/src/index.js"(exports5, module) {
      "use strict";
      var bind = require_function_bind();
      module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // ../node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "../node_modules/get-intrinsic/index.js"(exports5, module) {
      "use strict";
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = Object.getPrototypeOf || function(x3) {
        return x3.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      var doEval = function doEval2(name2) {
        var value;
        if (name2 === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name2 === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name2 === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name2 === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name2 === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name2] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match2, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
        var intrinsicName = name2;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
      };
      module.exports = function GetIntrinsic(name2, allowMissing) {
        if (typeof name2 !== "string" || name2.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/g, name2) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name2);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // ../node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "../node_modules/call-bind/index.js"(exports5, module) {
      "use strict";
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(
              func,
              "length",
              { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
            );
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // ../node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "../node_modules/call-bind/callBound.js"(exports5, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name2, allowMissing) {
        var intrinsic = GetIntrinsic(name2, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // ../node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "../node_modules/is-arguments/index.js"(exports5, module) {
      "use strict";
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // ../node_modules/define-properties/index.js
  var require_define_properties = __commonJS({
    "../node_modules/define-properties/index.js"(exports5, module) {
      "use strict";
      var keys = require_object_keys();
      var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
      var toStr = Object.prototype.toString;
      var concat2 = Array.prototype.concat;
      var origDefineProperty = Object.defineProperty;
      var isFunction = function(fn) {
        return typeof fn === "function" && toStr.call(fn) === "[object Function]";
      };
      var arePropertyDescriptorsSupported = function() {
        var obj = {};
        try {
          origDefineProperty(obj, "x", { enumerable: false, value: obj });
          for (var _ in obj) {
            return false;
          }
          return obj.x === obj;
        } catch (e) {
          return false;
        }
      };
      var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();
      var defineProperty = function(object2, name2, value, predicate) {
        if (name2 in object2 && (!isFunction(predicate) || !predicate())) {
          return;
        }
        if (supportsDescriptors) {
          origDefineProperty(object2, name2, {
            configurable: true,
            enumerable: false,
            value,
            writable: true
          });
        } else {
          object2[name2] = value;
        }
      };
      var defineProperties = function(object2, map2) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys(map2);
        if (hasSymbols) {
          props = concat2.call(props, Object.getOwnPropertySymbols(map2));
        }
        for (var i = 0; i < props.length; i += 1) {
          defineProperty(object2, props[i], map2[props[i]], predicates[props[i]]);
        }
      };
      defineProperties.supportsDescriptors = !!supportsDescriptors;
      module.exports = defineProperties;
    }
  });

  // ../node_modules/object-is/implementation.js
  var require_implementation3 = __commonJS({
    "../node_modules/object-is/implementation.js"(exports5, module) {
      "use strict";
      var numberIsNaN = function(value) {
        return value !== value;
      };
      module.exports = function is(a2, b) {
        if (a2 === 0 && b === 0) {
          return 1 / a2 === 1 / b;
        }
        if (a2 === b) {
          return true;
        }
        if (numberIsNaN(a2) && numberIsNaN(b)) {
          return true;
        }
        return false;
      };
    }
  });

  // ../node_modules/object-is/polyfill.js
  var require_polyfill = __commonJS({
    "../node_modules/object-is/polyfill.js"(exports5, module) {
      "use strict";
      var implementation = require_implementation3();
      module.exports = function getPolyfill() {
        return typeof Object.is === "function" ? Object.is : implementation;
      };
    }
  });

  // ../node_modules/object-is/shim.js
  var require_shim = __commonJS({
    "../node_modules/object-is/shim.js"(exports5, module) {
      "use strict";
      var getPolyfill = require_polyfill();
      var define2 = require_define_properties();
      module.exports = function shimObjectIs() {
        var polyfill = getPolyfill();
        define2(Object, { is: polyfill }, {
          is: function testObjectIs() {
            return Object.is !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // ../node_modules/object-is/index.js
  var require_object_is = __commonJS({
    "../node_modules/object-is/index.js"(exports5, module) {
      "use strict";
      var define2 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation3();
      var getPolyfill = require_polyfill();
      var shim = require_shim();
      var polyfill = callBind(getPolyfill(), Object);
      define2(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = polyfill;
    }
  });

  // ../node_modules/is-regex/index.js
  var require_is_regex = __commonJS({
    "../node_modules/is-regex/index.js"(exports5, module) {
      "use strict";
      var callBound = require_callBound();
      var hasToStringTag = require_shams2()();
      var has;
      var $exec;
      var isRegexMarker;
      var badStringifier;
      if (hasToStringTag) {
        has = callBound("Object.prototype.hasOwnProperty");
        $exec = callBound("RegExp.prototype.exec");
        isRegexMarker = {};
        throwRegexMarker = function() {
          throw isRegexMarker;
        };
        badStringifier = {
          toString: throwRegexMarker,
          valueOf: throwRegexMarker
        };
        if (typeof Symbol.toPrimitive === "symbol") {
          badStringifier[Symbol.toPrimitive] = throwRegexMarker;
        }
      }
      var throwRegexMarker;
      var $toString = callBound("Object.prototype.toString");
      var gOPD = Object.getOwnPropertyDescriptor;
      var regexClass = "[object RegExp]";
      module.exports = hasToStringTag ? function isRegex(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        var descriptor = gOPD(value, "lastIndex");
        var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
        if (!hasLastIndexDataProperty) {
          return false;
        }
        try {
          $exec(value, badStringifier);
        } catch (e) {
          return e === isRegexMarker;
        }
      } : function isRegex(value) {
        if (!value || typeof value !== "object" && typeof value !== "function") {
          return false;
        }
        return $toString(value) === regexClass;
      };
    }
  });

  // ../node_modules/functions-have-names/index.js
  var require_functions_have_names = __commonJS({
    "../node_modules/functions-have-names/index.js"(exports5, module) {
      "use strict";
      var functionsHaveNames = function functionsHaveNames2() {
        return typeof function f() {
        }.name === "string";
      };
      var gOPD = Object.getOwnPropertyDescriptor;
      if (gOPD) {
        try {
          gOPD([], "length");
        } catch (e) {
          gOPD = null;
        }
      }
      functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
        if (!functionsHaveNames() || !gOPD) {
          return false;
        }
        var desc = gOPD(function() {
        }, "name");
        return !!desc && !!desc.configurable;
      };
      var $bind = Function.prototype.bind;
      functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
        return functionsHaveNames() && typeof $bind === "function" && function f() {
        }.bind().name !== "";
      };
      module.exports = functionsHaveNames;
    }
  });

  // ../node_modules/regexp.prototype.flags/implementation.js
  var require_implementation4 = __commonJS({
    "../node_modules/regexp.prototype.flags/implementation.js"(exports5, module) {
      "use strict";
      var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
      var $Object = Object;
      var $TypeError = TypeError;
      module.exports = function flags() {
        if (this != null && this !== $Object(this)) {
          throw new $TypeError("RegExp.prototype.flags getter called on non-object");
        }
        var result = "";
        if (this.hasIndices) {
          result += "d";
        }
        if (this.global) {
          result += "g";
        }
        if (this.ignoreCase) {
          result += "i";
        }
        if (this.multiline) {
          result += "m";
        }
        if (this.dotAll) {
          result += "s";
        }
        if (this.unicode) {
          result += "u";
        }
        if (this.sticky) {
          result += "y";
        }
        return result;
      };
      if (functionsHaveConfigurableNames && Object.defineProperty) {
        Object.defineProperty(module.exports, "name", { value: "get flags" });
      }
    }
  });

  // ../node_modules/regexp.prototype.flags/polyfill.js
  var require_polyfill2 = __commonJS({
    "../node_modules/regexp.prototype.flags/polyfill.js"(exports5, module) {
      "use strict";
      var implementation = require_implementation4();
      var supportsDescriptors = require_define_properties().supportsDescriptors;
      var $gOPD = Object.getOwnPropertyDescriptor;
      module.exports = function getPolyfill() {
        if (supportsDescriptors && /a/mig.flags === "gim") {
          var descriptor = $gOPD(RegExp.prototype, "flags");
          if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
            var calls = "";
            var o = {};
            Object.defineProperty(o, "hasIndices", {
              get: function() {
                calls += "d";
              }
            });
            Object.defineProperty(o, "sticky", {
              get: function() {
                calls += "y";
              }
            });
            if (calls === "dy") {
              return descriptor.get;
            }
          }
        }
        return implementation;
      };
    }
  });

  // ../node_modules/regexp.prototype.flags/shim.js
  var require_shim2 = __commonJS({
    "../node_modules/regexp.prototype.flags/shim.js"(exports5, module) {
      "use strict";
      var supportsDescriptors = require_define_properties().supportsDescriptors;
      var getPolyfill = require_polyfill2();
      var gOPD = Object.getOwnPropertyDescriptor;
      var defineProperty = Object.defineProperty;
      var TypeErr = TypeError;
      var getProto = Object.getPrototypeOf;
      var regex = /a/;
      module.exports = function shimFlags() {
        if (!supportsDescriptors || !getProto) {
          throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
        }
        var polyfill = getPolyfill();
        var proto = getProto(regex);
        var descriptor = gOPD(proto, "flags");
        if (!descriptor || descriptor.get !== polyfill) {
          defineProperty(proto, "flags", {
            configurable: true,
            enumerable: false,
            get: polyfill
          });
        }
        return polyfill;
      };
    }
  });

  // ../node_modules/regexp.prototype.flags/index.js
  var require_regexp_prototype = __commonJS({
    "../node_modules/regexp.prototype.flags/index.js"(exports5, module) {
      "use strict";
      var define2 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation4();
      var getPolyfill = require_polyfill2();
      var shim = require_shim2();
      var flagsBound = callBind(getPolyfill());
      define2(flagsBound, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = flagsBound;
    }
  });

  // ../node_modules/is-date-object/index.js
  var require_is_date_object = __commonJS({
    "../node_modules/is-date-object/index.js"(exports5, module) {
      "use strict";
      var getDay = Date.prototype.getDay;
      var tryDateObject = function tryDateGetDayCall(value) {
        try {
          getDay.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var dateClass = "[object Date]";
      var hasToStringTag = require_shams2()();
      module.exports = function isDateObject(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
      };
    }
  });

  // ../node_modules/deep-equal/index.js
  var require_deep_equal = __commonJS({
    "../node_modules/deep-equal/index.js"(exports5, module) {
      var objectKeys = require_object_keys();
      var isArguments = require_is_arguments();
      var is = require_object_is();
      var isRegex = require_is_regex();
      var flags = require_regexp_prototype();
      var isDate = require_is_date_object();
      var getTime = Date.prototype.getTime;
      function deepEqual(actual, expected, options) {
        var opts = options || {};
        if (opts.strict ? is(actual, expected) : actual === expected) {
          return true;
        }
        if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
          return opts.strict ? is(actual, expected) : actual == expected;
        }
        return objEquiv(actual, expected, opts);
      }
      function isUndefinedOrNull(value) {
        return value === null || value === void 0;
      }
      function isBuffer3(x3) {
        if (!x3 || typeof x3 !== "object" || typeof x3.length !== "number") {
          return false;
        }
        if (typeof x3.copy !== "function" || typeof x3.slice !== "function") {
          return false;
        }
        if (x3.length > 0 && typeof x3[0] !== "number") {
          return false;
        }
        return true;
      }
      function objEquiv(a2, b, opts) {
        var i, key2;
        if (typeof a2 !== typeof b) {
          return false;
        }
        if (isUndefinedOrNull(a2) || isUndefinedOrNull(b)) {
          return false;
        }
        if (a2.prototype !== b.prototype) {
          return false;
        }
        if (isArguments(a2) !== isArguments(b)) {
          return false;
        }
        var aIsRegex = isRegex(a2);
        var bIsRegex = isRegex(b);
        if (aIsRegex !== bIsRegex) {
          return false;
        }
        if (aIsRegex || bIsRegex) {
          return a2.source === b.source && flags(a2) === flags(b);
        }
        if (isDate(a2) && isDate(b)) {
          return getTime.call(a2) === getTime.call(b);
        }
        var aIsBuffer = isBuffer3(a2);
        var bIsBuffer = isBuffer3(b);
        if (aIsBuffer !== bIsBuffer) {
          return false;
        }
        if (aIsBuffer || bIsBuffer) {
          if (a2.length !== b.length) {
            return false;
          }
          for (i = 0; i < a2.length; i++) {
            if (a2[i] !== b[i]) {
              return false;
            }
          }
          return true;
        }
        if (typeof a2 !== typeof b) {
          return false;
        }
        try {
          var ka = objectKeys(a2);
          var kb = objectKeys(b);
        } catch (e) {
          return false;
        }
        if (ka.length !== kb.length) {
          return false;
        }
        ka.sort();
        kb.sort();
        for (i = ka.length - 1; i >= 0; i--) {
          if (ka[i] != kb[i]) {
            return false;
          }
        }
        for (i = ka.length - 1; i >= 0; i--) {
          key2 = ka[i];
          if (!deepEqual(a2[key2], b[key2], opts)) {
            return false;
          }
        }
        return true;
      }
      module.exports = deepEqual;
    }
  });

  // ../node_modules/geojson-equality/index.js
  var require_geojson_equality = __commonJS({
    "../node_modules/geojson-equality/index.js"(exports5, module) {
      var deepEqual = require_deep_equal();
      var Equality = function(opt) {
        this.precision = opt && opt.precision ? opt.precision : 17;
        this.direction = opt && opt.direction ? opt.direction : false;
        this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
        this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
      };
      Equality.prototype.compare = function(g1, g2) {
        if (g1.type !== g2.type || !sameLength(g1, g2))
          return false;
        switch (g1.type) {
          case "Point":
            return this.compareCoord(g1.coordinates, g2.coordinates);
            break;
          case "LineString":
            return this.compareLine(g1.coordinates, g2.coordinates, 0, false);
            break;
          case "Polygon":
            return this.comparePolygon(g1, g2);
            break;
          case "Feature":
            return this.compareFeature(g1, g2);
          default:
            if (g1.type.indexOf("Multi") === 0) {
              var context = this;
              var g1s = explode(g1);
              var g2s = explode(g2);
              return g1s.every(function(g1part) {
                return this.some(function(g2part) {
                  return context.compare(g1part, g2part);
                });
              }, g2s);
            }
        }
        return false;
      };
      function explode(g) {
        return g.coordinates.map(function(part) {
          return {
            type: g.type.replace("Multi", ""),
            coordinates: part
          };
        });
      }
      function sameLength(g1, g2) {
        return g1.hasOwnProperty("coordinates") ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
      }
      Equality.prototype.compareCoord = function(c1, c2) {
        if (c1.length !== c2.length) {
          return false;
        }
        for (var i = 0; i < c1.length; i++) {
          if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
            return false;
          }
        }
        return true;
      };
      Equality.prototype.compareLine = function(path1, path2, ind, isPoly) {
        if (!sameLength(path1, path2))
          return false;
        var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
        var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
        if (isPoly && !this.compareCoord(p1[0], p2[0])) {
          p2 = this.fixStartIndex(p2, p1);
          if (!p2)
            return;
        }
        var sameDirection = this.compareCoord(p1[ind], p2[ind]);
        if (this.direction || sameDirection) {
          return this.comparePath(p1, p2);
        } else {
          if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
            return this.comparePath(p1.slice().reverse(), p2);
          }
          return false;
        }
      };
      Equality.prototype.fixStartIndex = function(sourcePath, targetPath) {
        var correctPath, ind = -1;
        for (var i = 0; i < sourcePath.length; i++) {
          if (this.compareCoord(sourcePath[i], targetPath[0])) {
            ind = i;
            break;
          }
        }
        if (ind >= 0) {
          correctPath = [].concat(
            sourcePath.slice(ind, sourcePath.length),
            sourcePath.slice(1, ind + 1)
          );
        }
        return correctPath;
      };
      Equality.prototype.comparePath = function(p1, p2) {
        var cont = this;
        return p1.every(function(c, i) {
          return cont.compareCoord(c, this[i]);
        }, p2);
      };
      Equality.prototype.comparePolygon = function(g1, g2) {
        if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
          var holes1 = g1.coordinates.slice(1, g1.coordinates.length);
          var holes2 = g2.coordinates.slice(1, g2.coordinates.length);
          var cont = this;
          return holes1.every(function(h1) {
            return this.some(function(h2) {
              return cont.compareLine(h1, h2, 1, true);
            });
          }, holes2);
        } else {
          return false;
        }
      };
      Equality.prototype.compareFeature = function(g1, g2) {
        if (g1.id !== g2.id || !this.objectComparator(g1.properties, g2.properties) || !this.compareBBox(g1, g2)) {
          return false;
        }
        return this.compare(g1.geometry, g2.geometry);
      };
      Equality.prototype.compareBBox = function(g1, g2) {
        if (!g1.bbox && !g2.bbox || g1.bbox && g2.bbox && this.compareCoord(g1.bbox, g2.bbox)) {
          return true;
        }
        return false;
      };
      Equality.prototype.removePseudo = function(path) {
        return path;
      };
      function objectComparator(obj1, obj2) {
        return deepEqual(obj1, obj2, { strict: true });
      }
      module.exports = Equality;
    }
  });

  // ../node_modules/density-clustering/lib/DBSCAN.js
  var require_DBSCAN = __commonJS({
    "../node_modules/density-clustering/lib/DBSCAN.js"(exports5, module) {
      function DBSCAN(dataset, epsilon4, minPts, distanceFunction) {
        this.dataset = [];
        this.epsilon = 1;
        this.minPts = 2;
        this.distance = this._euclideanDistance;
        this.clusters = [];
        this.noise = [];
        this._visited = [];
        this._assigned = [];
        this._datasetLength = 0;
        this._init(dataset, epsilon4, minPts, distanceFunction);
      }
      DBSCAN.prototype.run = function(dataset, epsilon4, minPts, distanceFunction) {
        this._init(dataset, epsilon4, minPts, distanceFunction);
        for (var pointId = 0; pointId < this._datasetLength; pointId++) {
          if (this._visited[pointId] !== 1) {
            this._visited[pointId] = 1;
            var neighbors = this._regionQuery(pointId);
            if (neighbors.length < this.minPts) {
              this.noise.push(pointId);
            } else {
              var clusterId = this.clusters.length;
              this.clusters.push([]);
              this._addToCluster(pointId, clusterId);
              this._expandCluster(clusterId, neighbors);
            }
          }
        }
        return this.clusters;
      };
      DBSCAN.prototype._init = function(dataset, epsilon4, minPts, distance) {
        if (dataset) {
          if (!(dataset instanceof Array)) {
            throw Error("Dataset must be of type array, " + typeof dataset + " given");
          }
          this.dataset = dataset;
          this.clusters = [];
          this.noise = [];
          this._datasetLength = dataset.length;
          this._visited = new Array(this._datasetLength);
          this._assigned = new Array(this._datasetLength);
        }
        if (epsilon4) {
          this.epsilon = epsilon4;
        }
        if (minPts) {
          this.minPts = minPts;
        }
        if (distance) {
          this.distance = distance;
        }
      };
      DBSCAN.prototype._expandCluster = function(clusterId, neighbors) {
        for (var i = 0; i < neighbors.length; i++) {
          var pointId2 = neighbors[i];
          if (this._visited[pointId2] !== 1) {
            this._visited[pointId2] = 1;
            var neighbors2 = this._regionQuery(pointId2);
            if (neighbors2.length >= this.minPts) {
              neighbors = this._mergeArrays(neighbors, neighbors2);
            }
          }
          if (this._assigned[pointId2] !== 1) {
            this._addToCluster(pointId2, clusterId);
          }
        }
      };
      DBSCAN.prototype._addToCluster = function(pointId, clusterId) {
        this.clusters[clusterId].push(pointId);
        this._assigned[pointId] = 1;
      };
      DBSCAN.prototype._regionQuery = function(pointId) {
        var neighbors = [];
        for (var id = 0; id < this._datasetLength; id++) {
          var dist = this.distance(this.dataset[pointId], this.dataset[id]);
          if (dist < this.epsilon) {
            neighbors.push(id);
          }
        }
        return neighbors;
      };
      DBSCAN.prototype._mergeArrays = function(a2, b) {
        var len = b.length;
        for (var i = 0; i < len; i++) {
          var P = b[i];
          if (a2.indexOf(P) < 0) {
            a2.push(P);
          }
        }
        return a2;
      };
      DBSCAN.prototype._euclideanDistance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          sum2 += (p[i] - q[i]) * (p[i] - q[i]);
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = DBSCAN;
      }
    }
  });

  // ../node_modules/density-clustering/lib/KMEANS.js
  var require_KMEANS = __commonJS({
    "../node_modules/density-clustering/lib/KMEANS.js"(exports5, module) {
      function KMEANS(dataset, k, distance) {
        this.k = 3;
        this.dataset = [];
        this.assignments = [];
        this.centroids = [];
        this.init(dataset, k, distance);
      }
      KMEANS.prototype.init = function(dataset, k, distance) {
        this.assignments = [];
        this.centroids = [];
        if (typeof dataset !== "undefined") {
          this.dataset = dataset;
        }
        if (typeof k !== "undefined") {
          this.k = k;
        }
        if (typeof distance !== "undefined") {
          this.distance = distance;
        }
      };
      KMEANS.prototype.run = function(dataset, k) {
        this.init(dataset, k);
        var len = this.dataset.length;
        for (var i = 0; i < this.k; i++) {
          this.centroids[i] = this.randomCentroid();
        }
        var change = true;
        while (change) {
          change = this.assign();
          for (var centroidId = 0; centroidId < this.k; centroidId++) {
            var mean = new Array(maxDim);
            var count = 0;
            for (var dim = 0; dim < maxDim; dim++) {
              mean[dim] = 0;
            }
            for (var j = 0; j < len; j++) {
              var maxDim = this.dataset[j].length;
              if (centroidId === this.assignments[j]) {
                for (var dim = 0; dim < maxDim; dim++) {
                  mean[dim] += this.dataset[j][dim];
                }
                count++;
              }
            }
            if (count > 0) {
              for (var dim = 0; dim < maxDim; dim++) {
                mean[dim] /= count;
              }
              this.centroids[centroidId] = mean;
            } else {
              this.centroids[centroidId] = this.randomCentroid();
              change = true;
            }
          }
        }
        return this.getClusters();
      };
      KMEANS.prototype.randomCentroid = function() {
        var maxId = this.dataset.length - 1;
        var centroid;
        var id;
        do {
          id = Math.round(Math.random() * maxId);
          centroid = this.dataset[id];
        } while (this.centroids.indexOf(centroid) >= 0);
        return centroid;
      };
      KMEANS.prototype.assign = function() {
        var change = false;
        var len = this.dataset.length;
        var closestCentroid;
        for (var i = 0; i < len; i++) {
          closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);
          if (closestCentroid != this.assignments[i]) {
            this.assignments[i] = closestCentroid;
            change = true;
          }
        }
        return change;
      };
      KMEANS.prototype.getClusters = function() {
        var clusters = new Array(this.k);
        var centroidId;
        for (var pointId = 0; pointId < this.assignments.length; pointId++) {
          centroidId = this.assignments[pointId];
          if (typeof clusters[centroidId] === "undefined") {
            clusters[centroidId] = [];
          }
          clusters[centroidId].push(pointId);
        }
        return clusters;
      };
      KMEANS.prototype.argmin = function(point2, set2, f) {
        var min = Number.MAX_VALUE;
        var arg = 0;
        var len = set2.length;
        var d;
        for (var i = 0; i < len; i++) {
          d = f(point2, set2[i]);
          if (d < min) {
            min = d;
            arg = i;
          }
        }
        return arg;
      };
      KMEANS.prototype.distance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          var diff = p[i] - q[i];
          sum2 += diff * diff;
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = KMEANS;
      }
    }
  });

  // ../node_modules/density-clustering/lib/PriorityQueue.js
  var require_PriorityQueue = __commonJS({
    "../node_modules/density-clustering/lib/PriorityQueue.js"(exports5, module) {
      function PriorityQueue(elements, priorities, sorting) {
        this._queue = [];
        this._priorities = [];
        this._sorting = "desc";
        this._init(elements, priorities, sorting);
      }
      PriorityQueue.prototype.insert = function(ele, priority) {
        var indexToInsert = this._queue.length;
        var index = indexToInsert;
        while (index--) {
          var priority2 = this._priorities[index];
          if (this._sorting === "desc") {
            if (priority > priority2) {
              indexToInsert = index;
            }
          } else {
            if (priority < priority2) {
              indexToInsert = index;
            }
          }
        }
        this._insertAt(ele, priority, indexToInsert);
      };
      PriorityQueue.prototype.remove = function(ele) {
        var index = this._queue.length;
        while (index--) {
          var ele2 = this._queue[index];
          if (ele === ele2) {
            this._queue.splice(index, 1);
            this._priorities.splice(index, 1);
            break;
          }
        }
      };
      PriorityQueue.prototype.forEach = function(func) {
        this._queue.forEach(func);
      };
      PriorityQueue.prototype.getElements = function() {
        return this._queue;
      };
      PriorityQueue.prototype.getElementPriority = function(index) {
        return this._priorities[index];
      };
      PriorityQueue.prototype.getPriorities = function() {
        return this._priorities;
      };
      PriorityQueue.prototype.getElementsWithPriorities = function() {
        var result = [];
        for (var i = 0, l = this._queue.length; i < l; i++) {
          result.push([this._queue[i], this._priorities[i]]);
        }
        return result;
      };
      PriorityQueue.prototype._init = function(elements, priorities, sorting) {
        if (elements && priorities) {
          this._queue = [];
          this._priorities = [];
          if (elements.length !== priorities.length) {
            throw new Error("Arrays must have the same length");
          }
          for (var i = 0; i < elements.length; i++) {
            this.insert(elements[i], priorities[i]);
          }
        }
        if (sorting) {
          this._sorting = sorting;
        }
      };
      PriorityQueue.prototype._insertAt = function(ele, priority, index) {
        if (this._queue.length === index) {
          this._queue.push(ele);
          this._priorities.push(priority);
        } else {
          this._queue.splice(index, 0, ele);
          this._priorities.splice(index, 0, priority);
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = PriorityQueue;
      }
    }
  });

  // ../node_modules/density-clustering/lib/OPTICS.js
  var require_OPTICS = __commonJS({
    "../node_modules/density-clustering/lib/OPTICS.js"(exports5, module) {
      if (typeof module !== "undefined" && module.exports) {
        PriorityQueue = require_PriorityQueue();
      }
      var PriorityQueue;
      function OPTICS(dataset, epsilon4, minPts, distanceFunction) {
        this.epsilon = 1;
        this.minPts = 1;
        this.distance = this._euclideanDistance;
        this._reachability = [];
        this._processed = [];
        this._coreDistance = 0;
        this._orderedList = [];
        this._init(dataset, epsilon4, minPts, distanceFunction);
      }
      OPTICS.prototype.run = function(dataset, epsilon4, minPts, distanceFunction) {
        this._init(dataset, epsilon4, minPts, distanceFunction);
        for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
          if (this._processed[pointId] !== 1) {
            this._processed[pointId] = 1;
            this.clusters.push([pointId]);
            var clusterId = this.clusters.length - 1;
            this._orderedList.push(pointId);
            var priorityQueue = new PriorityQueue(null, null, "asc");
            var neighbors = this._regionQuery(pointId);
            if (this._distanceToCore(pointId) !== void 0) {
              this._updateQueue(pointId, neighbors, priorityQueue);
              this._expandCluster(clusterId, priorityQueue);
            }
          }
        }
        return this.clusters;
      };
      OPTICS.prototype.getReachabilityPlot = function() {
        var reachabilityPlot = [];
        for (var i = 0, l = this._orderedList.length; i < l; i++) {
          var pointId = this._orderedList[i];
          var distance = this._reachability[pointId];
          reachabilityPlot.push([pointId, distance]);
        }
        return reachabilityPlot;
      };
      OPTICS.prototype._init = function(dataset, epsilon4, minPts, distance) {
        if (dataset) {
          if (!(dataset instanceof Array)) {
            throw Error("Dataset must be of type array, " + typeof dataset + " given");
          }
          this.dataset = dataset;
          this.clusters = [];
          this._reachability = new Array(this.dataset.length);
          this._processed = new Array(this.dataset.length);
          this._coreDistance = 0;
          this._orderedList = [];
        }
        if (epsilon4) {
          this.epsilon = epsilon4;
        }
        if (minPts) {
          this.minPts = minPts;
        }
        if (distance) {
          this.distance = distance;
        }
      };
      OPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {
        var self2 = this;
        this._coreDistance = this._distanceToCore(pointId);
        neighbors.forEach(function(pointId2) {
          if (self2._processed[pointId2] === void 0) {
            var dist = self2.distance(self2.dataset[pointId], self2.dataset[pointId2]);
            var newReachableDistance = Math.max(self2._coreDistance, dist);
            if (self2._reachability[pointId2] === void 0) {
              self2._reachability[pointId2] = newReachableDistance;
              queue.insert(pointId2, newReachableDistance);
            } else {
              if (newReachableDistance < self2._reachability[pointId2]) {
                self2._reachability[pointId2] = newReachableDistance;
                queue.remove(pointId2);
                queue.insert(pointId2, newReachableDistance);
              }
            }
          }
        });
      };
      OPTICS.prototype._expandCluster = function(clusterId, queue) {
        var queueElements = queue.getElements();
        for (var p = 0, l = queueElements.length; p < l; p++) {
          var pointId = queueElements[p];
          if (this._processed[pointId] === void 0) {
            var neighbors = this._regionQuery(pointId);
            this._processed[pointId] = 1;
            this.clusters[clusterId].push(pointId);
            this._orderedList.push(pointId);
            if (this._distanceToCore(pointId) !== void 0) {
              this._updateQueue(pointId, neighbors, queue);
              this._expandCluster(clusterId, queue);
            }
          }
        }
      };
      OPTICS.prototype._distanceToCore = function(pointId) {
        var l = this.epsilon;
        for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
          var neighbors = this._regionQuery(pointId, coreDistCand);
          if (neighbors.length >= this.minPts) {
            return coreDistCand;
          }
        }
        return;
      };
      OPTICS.prototype._regionQuery = function(pointId, epsilon4) {
        epsilon4 = epsilon4 || this.epsilon;
        var neighbors = [];
        for (var id = 0, l = this.dataset.length; id < l; id++) {
          if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon4) {
            neighbors.push(id);
          }
        }
        return neighbors;
      };
      OPTICS.prototype._euclideanDistance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          sum2 += (p[i] - q[i]) * (p[i] - q[i]);
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = OPTICS;
      }
    }
  });

  // ../node_modules/density-clustering/lib/index.js
  var require_lib = __commonJS({
    "../node_modules/density-clustering/lib/index.js"(exports5, module) {
      if (typeof module !== "undefined" && module.exports) {
        module.exports = {
          DBSCAN: require_DBSCAN(),
          KMEANS: require_KMEANS(),
          OPTICS: require_OPTICS(),
          PriorityQueue: require_PriorityQueue()
        };
      }
    }
  });

  // ../node_modules/skmeans/dist/node/distance.js
  var require_distance = __commonJS({
    "../node_modules/skmeans/dist/node/distance.js"(exports5, module) {
      "use strict";
      module.exports = {
        eudist: function eudist(v1, v2, sqrt2) {
          var len = v1.length;
          var sum2 = 0;
          for (var i = 0; i < len; i++) {
            var d = (v1[i] || 0) - (v2[i] || 0);
            sum2 += d * d;
          }
          return sqrt2 ? Math.sqrt(sum2) : sum2;
        },
        mandist: function mandist(v1, v2, sqrt2) {
          var len = v1.length;
          var sum2 = 0;
          for (var i = 0; i < len; i++) {
            sum2 += Math.abs((v1[i] || 0) - (v2[i] || 0));
          }
          return sqrt2 ? Math.sqrt(sum2) : sum2;
        },
        dist: function dist(v1, v2, sqrt2) {
          var d = Math.abs(v1 - v2);
          return sqrt2 ? d : d * d;
        }
      };
    }
  });

  // ../node_modules/skmeans/dist/node/kinit.js
  var require_kinit = __commonJS({
    "../node_modules/skmeans/dist/node/kinit.js"(exports5, module) {
      "use strict";
      var Distance = require_distance();
      var eudist = Distance.eudist;
      var dist = Distance.dist;
      module.exports = {
        kmrand: function kmrand(data, k) {
          var map2 = {}, ks = [], t = k << 2;
          var len = data.length;
          var multi = data[0].length > 0;
          while (ks.length < k && t-- > 0) {
            var d = data[Math.floor(Math.random() * len)];
            var key2 = multi ? d.join("_") : "" + d;
            if (!map2[key2]) {
              map2[key2] = true;
              ks.push(d);
            }
          }
          if (ks.length < k)
            throw new Error("Error initializating clusters");
          else
            return ks;
        },
        kmpp: function kmpp(data, k) {
          var distance = data[0].length ? eudist : dist;
          var ks = [], len = data.length;
          var multi = data[0].length > 0;
          var map2 = {};
          var c = data[Math.floor(Math.random() * len)];
          var key2 = multi ? c.join("_") : "" + c;
          ks.push(c);
          map2[key2] = true;
          while (ks.length < k) {
            var dists = [], lk = ks.length;
            var dsum = 0, prs = [];
            for (var i = 0; i < len; i++) {
              var min = Infinity;
              for (var j = 0; j < lk; j++) {
                var _dist = distance(data[i], ks[j]);
                if (_dist <= min)
                  min = _dist;
              }
              dists[i] = min;
            }
            for (var _i = 0; _i < len; _i++) {
              dsum += dists[_i];
            }
            for (var _i2 = 0; _i2 < len; _i2++) {
              prs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };
            }
            prs.sort(function(a2, b) {
              return a2.pr - b.pr;
            });
            prs[0].cs = prs[0].pr;
            for (var _i3 = 1; _i3 < len; _i3++) {
              prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;
            }
            var rnd = Math.random();
            var idx = 0;
            while (idx < len - 1 && prs[idx++].cs < rnd) {
            }
            ks.push(prs[idx - 1].v);
          }
          return ks;
        }
      };
    }
  });

  // ../node_modules/skmeans/dist/node/main.js
  var require_main = __commonJS({
    "../node_modules/skmeans/dist/node/main.js"(exports5, module) {
      "use strict";
      var Distance = require_distance();
      var ClusterInit = require_kinit();
      var eudist = Distance.eudist;
      var mandist = Distance.mandist;
      var dist = Distance.dist;
      var kmrand = ClusterInit.kmrand;
      var kmpp = ClusterInit.kmpp;
      var MAX = 1e4;
      function init33(len, val, v) {
        v = v || [];
        for (var i = 0; i < len; i++) {
          v[i] = val;
        }
        return v;
      }
      function skmeans2(data, k, initial, maxit) {
        var ks = [], old = [], idxs = [], dist2 = [];
        var conv = false, it = maxit || MAX;
        var len = data.length, vlen = data[0].length, multi = vlen > 0;
        var count = [];
        if (!initial) {
          var _idxs = {};
          while (ks.length < k) {
            var idx = Math.floor(Math.random() * len);
            if (!_idxs[idx]) {
              _idxs[idx] = true;
              ks.push(data[idx]);
            }
          }
        } else if (initial == "kmrand") {
          ks = kmrand(data, k);
        } else if (initial == "kmpp") {
          ks = kmpp(data, k);
        } else {
          ks = initial;
        }
        do {
          init33(k, 0, count);
          for (var i = 0; i < len; i++) {
            var min = Infinity, _idx = 0;
            for (var j = 0; j < k; j++) {
              var dist2 = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);
              if (dist2 <= min) {
                min = dist2;
                _idx = j;
              }
            }
            idxs[i] = _idx;
            count[_idx]++;
          }
          var sum2 = [], old = [], dif = 0;
          for (var _j = 0; _j < k; _j++) {
            sum2[_j] = multi ? init33(vlen, 0, sum2[_j]) : 0;
            old[_j] = ks[_j];
          }
          if (multi) {
            for (var _j2 = 0; _j2 < k; _j2++) {
              ks[_j2] = [];
            }
            for (var _i = 0; _i < len; _i++) {
              var _idx2 = idxs[_i], vsum = sum2[_idx2], vect = data[_i];
              for (var h = 0; h < vlen; h++) {
                vsum[h] += vect[h];
              }
            }
            conv = true;
            for (var _j3 = 0; _j3 < k; _j3++) {
              var ksj = ks[_j3], sumj = sum2[_j3], oldj = old[_j3], cj = count[_j3];
              for (var _h = 0; _h < vlen; _h++) {
                ksj[_h] = sumj[_h] / cj || 0;
              }
              if (conv) {
                for (var _h2 = 0; _h2 < vlen; _h2++) {
                  if (oldj[_h2] != ksj[_h2]) {
                    conv = false;
                    break;
                  }
                }
              }
            }
          } else {
            for (var _i2 = 0; _i2 < len; _i2++) {
              var _idx3 = idxs[_i2];
              sum2[_idx3] += data[_i2];
            }
            for (var _j4 = 0; _j4 < k; _j4++) {
              ks[_j4] = sum2[_j4] / count[_j4] || 0;
            }
            conv = true;
            for (var _j5 = 0; _j5 < k; _j5++) {
              if (old[_j5] != ks[_j5]) {
                conv = false;
                break;
              }
            }
          }
          conv = conv || --it <= 0;
        } while (!conv);
        return {
          it: MAX - it,
          k,
          idxs,
          centroids: ks
        };
      }
      module.exports = skmeans2;
    }
  });

  // ../node_modules/polygon-clipping/dist/polygon-clipping.umd.js
  var require_polygon_clipping_umd = __commonJS({
    "../node_modules/polygon-clipping/dist/polygon-clipping.umd.js"(exports5, module) {
      (function(global, factory) {
        typeof exports5 === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.polygonClipping = factory());
      })(exports5, function() {
        "use strict";
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        /**
         * splaytree v3.1.0
         * Fast Splay tree for Node and browser
         *
         * @author Alexander Milevski <info@w8r.name>
         * @license MIT
         * @preserve
         */
        var Node2 = function() {
          function Node3(key2, data) {
            this.next = null;
            this.key = key2;
            this.data = data;
            this.left = null;
            this.right = null;
          }
          return Node3;
        }();
        function DEFAULT_COMPARE(a2, b) {
          return a2 > b ? 1 : a2 < b ? -1 : 0;
        }
        function splay(i, t, comparator) {
          var N = new Node2(null, null);
          var l = N;
          var r = N;
          while (true) {
            var cmp2 = comparator(i, t.key);
            if (cmp2 < 0) {
              if (t.left === null)
                break;
              if (comparator(i, t.left.key) < 0) {
                var y3 = t.left;
                t.left = y3.right;
                y3.right = t;
                t = y3;
                if (t.left === null)
                  break;
              }
              r.left = t;
              r = t;
              t = t.left;
            } else if (cmp2 > 0) {
              if (t.right === null)
                break;
              if (comparator(i, t.right.key) > 0) {
                var y3 = t.right;
                t.right = y3.left;
                y3.left = t;
                t = y3;
                if (t.right === null)
                  break;
              }
              l.right = t;
              l = t;
              t = t.right;
            } else
              break;
          }
          l.right = t.left;
          r.left = t.right;
          t.left = N.right;
          t.right = N.left;
          return t;
        }
        function insert(i, data, t, comparator) {
          var node = new Node2(i, data);
          if (t === null) {
            node.left = node.right = null;
            return node;
          }
          t = splay(i, t, comparator);
          var cmp2 = comparator(i, t.key);
          if (cmp2 < 0) {
            node.left = t.left;
            node.right = t;
            t.left = null;
          } else if (cmp2 >= 0) {
            node.right = t.right;
            node.left = t;
            t.right = null;
          }
          return node;
        }
        function split(key2, v, comparator) {
          var left = null;
          var right = null;
          if (v) {
            v = splay(key2, v, comparator);
            var cmp2 = comparator(v.key, key2);
            if (cmp2 === 0) {
              left = v.left;
              right = v.right;
            } else if (cmp2 < 0) {
              right = v.right;
              v.right = null;
              left = v;
            } else {
              left = v.left;
              v.left = null;
              right = v;
            }
          }
          return {
            left,
            right
          };
        }
        function merge(left, right, comparator) {
          if (right === null)
            return left;
          if (left === null)
            return right;
          right = splay(left.key, right, comparator);
          right.left = left;
          return right;
        }
        function printRow(root, prefix, isTail, out, printNode) {
          if (root) {
            out("" + prefix + (isTail ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ") + printNode(root) + "\n");
            var indent = prefix + (isTail ? "    " : "\u2502   ");
            if (root.left)
              printRow(root.left, indent, false, out, printNode);
            if (root.right)
              printRow(root.right, indent, true, out, printNode);
          }
        }
        var Tree = function() {
          function Tree2(comparator) {
            if (comparator === void 0) {
              comparator = DEFAULT_COMPARE;
            }
            this._root = null;
            this._size = 0;
            this._comparator = comparator;
          }
          Tree2.prototype.insert = function(key2, data) {
            this._size++;
            return this._root = insert(key2, data, this._root, this._comparator);
          };
          Tree2.prototype.add = function(key2, data) {
            var node = new Node2(key2, data);
            if (this._root === null) {
              node.left = node.right = null;
              this._size++;
              this._root = node;
            }
            var comparator = this._comparator;
            var t = splay(key2, this._root, comparator);
            var cmp2 = comparator(key2, t.key);
            if (cmp2 === 0)
              this._root = t;
            else {
              if (cmp2 < 0) {
                node.left = t.left;
                node.right = t;
                t.left = null;
              } else if (cmp2 > 0) {
                node.right = t.right;
                node.left = t;
                t.right = null;
              }
              this._size++;
              this._root = node;
            }
            return this._root;
          };
          Tree2.prototype.remove = function(key2) {
            this._root = this._remove(key2, this._root, this._comparator);
          };
          Tree2.prototype._remove = function(i, t, comparator) {
            var x3;
            if (t === null)
              return null;
            t = splay(i, t, comparator);
            var cmp2 = comparator(i, t.key);
            if (cmp2 === 0) {
              if (t.left === null) {
                x3 = t.right;
              } else {
                x3 = splay(i, t.left, comparator);
                x3.right = t.right;
              }
              this._size--;
              return x3;
            }
            return t;
          };
          Tree2.prototype.pop = function() {
            var node = this._root;
            if (node) {
              while (node.left) {
                node = node.left;
              }
              this._root = splay(node.key, this._root, this._comparator);
              this._root = this._remove(node.key, this._root, this._comparator);
              return {
                key: node.key,
                data: node.data
              };
            }
            return null;
          };
          Tree2.prototype.findStatic = function(key2) {
            var current = this._root;
            var compare3 = this._comparator;
            while (current) {
              var cmp2 = compare3(key2, current.key);
              if (cmp2 === 0)
                return current;
              else if (cmp2 < 0)
                current = current.left;
              else
                current = current.right;
            }
            return null;
          };
          Tree2.prototype.find = function(key2) {
            if (this._root) {
              this._root = splay(key2, this._root, this._comparator);
              if (this._comparator(key2, this._root.key) !== 0)
                return null;
            }
            return this._root;
          };
          Tree2.prototype.contains = function(key2) {
            var current = this._root;
            var compare3 = this._comparator;
            while (current) {
              var cmp2 = compare3(key2, current.key);
              if (cmp2 === 0)
                return true;
              else if (cmp2 < 0)
                current = current.left;
              else
                current = current.right;
            }
            return false;
          };
          Tree2.prototype.forEach = function(visitor, ctx) {
            var current = this._root;
            var Q = [];
            var done = false;
            while (!done) {
              if (current !== null) {
                Q.push(current);
                current = current.left;
              } else {
                if (Q.length !== 0) {
                  current = Q.pop();
                  visitor.call(ctx, current);
                  current = current.right;
                } else
                  done = true;
              }
            }
            return this;
          };
          Tree2.prototype.range = function(low, high, fn, ctx) {
            var Q = [];
            var compare3 = this._comparator;
            var node = this._root;
            var cmp2;
            while (Q.length !== 0 || node) {
              if (node) {
                Q.push(node);
                node = node.left;
              } else {
                node = Q.pop();
                cmp2 = compare3(node.key, high);
                if (cmp2 > 0) {
                  break;
                } else if (compare3(node.key, low) >= 0) {
                  if (fn.call(ctx, node))
                    return this;
                }
                node = node.right;
              }
            }
            return this;
          };
          Tree2.prototype.keys = function() {
            var keys = [];
            this.forEach(function(_a) {
              var key2 = _a.key;
              return keys.push(key2);
            });
            return keys;
          };
          Tree2.prototype.values = function() {
            var values = [];
            this.forEach(function(_a) {
              var data = _a.data;
              return values.push(data);
            });
            return values;
          };
          Tree2.prototype.min = function() {
            if (this._root)
              return this.minNode(this._root).key;
            return null;
          };
          Tree2.prototype.max = function() {
            if (this._root)
              return this.maxNode(this._root).key;
            return null;
          };
          Tree2.prototype.minNode = function(t) {
            if (t === void 0) {
              t = this._root;
            }
            if (t)
              while (t.left) {
                t = t.left;
              }
            return t;
          };
          Tree2.prototype.maxNode = function(t) {
            if (t === void 0) {
              t = this._root;
            }
            if (t)
              while (t.right) {
                t = t.right;
              }
            return t;
          };
          Tree2.prototype.at = function(index2) {
            var current = this._root;
            var done = false;
            var i = 0;
            var Q = [];
            while (!done) {
              if (current) {
                Q.push(current);
                current = current.left;
              } else {
                if (Q.length > 0) {
                  current = Q.pop();
                  if (i === index2)
                    return current;
                  i++;
                  current = current.right;
                } else
                  done = true;
              }
            }
            return null;
          };
          Tree2.prototype.next = function(d) {
            var root = this._root;
            var successor = null;
            if (d.right) {
              successor = d.right;
              while (successor.left) {
                successor = successor.left;
              }
              return successor;
            }
            var comparator = this._comparator;
            while (root) {
              var cmp2 = comparator(d.key, root.key);
              if (cmp2 === 0)
                break;
              else if (cmp2 < 0) {
                successor = root;
                root = root.left;
              } else
                root = root.right;
            }
            return successor;
          };
          Tree2.prototype.prev = function(d) {
            var root = this._root;
            var predecessor = null;
            if (d.left !== null) {
              predecessor = d.left;
              while (predecessor.right) {
                predecessor = predecessor.right;
              }
              return predecessor;
            }
            var comparator = this._comparator;
            while (root) {
              var cmp2 = comparator(d.key, root.key);
              if (cmp2 === 0)
                break;
              else if (cmp2 < 0)
                root = root.left;
              else {
                predecessor = root;
                root = root.right;
              }
            }
            return predecessor;
          };
          Tree2.prototype.clear = function() {
            this._root = null;
            this._size = 0;
            return this;
          };
          Tree2.prototype.toList = function() {
            return toList(this._root);
          };
          Tree2.prototype.load = function(keys, values, presort) {
            if (values === void 0) {
              values = [];
            }
            if (presort === void 0) {
              presort = false;
            }
            var size = keys.length;
            var comparator = this._comparator;
            if (presort)
              sort(keys, values, 0, size - 1, comparator);
            if (this._root === null) {
              this._root = loadRecursive(keys, values, 0, size);
              this._size = size;
            } else {
              var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
              size = this._size + size;
              this._root = sortedListToBST({
                head: mergedList
              }, 0, size);
            }
            return this;
          };
          Tree2.prototype.isEmpty = function() {
            return this._root === null;
          };
          Object.defineProperty(Tree2.prototype, "size", {
            get: function get2() {
              return this._size;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(Tree2.prototype, "root", {
            get: function get2() {
              return this._root;
            },
            enumerable: true,
            configurable: true
          });
          Tree2.prototype.toString = function(printNode) {
            if (printNode === void 0) {
              printNode = function printNode2(n) {
                return String(n.key);
              };
            }
            var out = [];
            printRow(this._root, "", true, function(v) {
              return out.push(v);
            }, printNode);
            return out.join("");
          };
          Tree2.prototype.update = function(key2, newKey, newData) {
            var comparator = this._comparator;
            var _a = split(key2, this._root, comparator), left = _a.left, right = _a.right;
            if (comparator(key2, newKey) < 0) {
              right = insert(newKey, newData, right, comparator);
            } else {
              left = insert(newKey, newData, left, comparator);
            }
            this._root = merge(left, right, comparator);
          };
          Tree2.prototype.split = function(key2) {
            return split(key2, this._root, this._comparator);
          };
          return Tree2;
        }();
        function loadRecursive(keys, values, start2, end) {
          var size = end - start2;
          if (size > 0) {
            var middle = start2 + Math.floor(size / 2);
            var key2 = keys[middle];
            var data = values[middle];
            var node = new Node2(key2, data);
            node.left = loadRecursive(keys, values, start2, middle);
            node.right = loadRecursive(keys, values, middle + 1, end);
            return node;
          }
          return null;
        }
        function createList(keys, values) {
          var head = new Node2(null, null);
          var p = head;
          for (var i = 0; i < keys.length; i++) {
            p = p.next = new Node2(keys[i], values[i]);
          }
          p.next = null;
          return head.next;
        }
        function toList(root) {
          var current = root;
          var Q = [];
          var done = false;
          var head = new Node2(null, null);
          var p = head;
          while (!done) {
            if (current) {
              Q.push(current);
              current = current.left;
            } else {
              if (Q.length > 0) {
                current = p = p.next = Q.pop();
                current = current.right;
              } else
                done = true;
            }
          }
          p.next = null;
          return head.next;
        }
        function sortedListToBST(list, start2, end) {
          var size = end - start2;
          if (size > 0) {
            var middle = start2 + Math.floor(size / 2);
            var left = sortedListToBST(list, start2, middle);
            var root = list.head;
            root.left = left;
            list.head = list.head.next;
            root.right = sortedListToBST(list, middle + 1, end);
            return root;
          }
          return null;
        }
        function mergeLists(l1, l2, compare3) {
          var head = new Node2(null, null);
          var p = head;
          var p1 = l1;
          var p2 = l2;
          while (p1 !== null && p2 !== null) {
            if (compare3(p1.key, p2.key) < 0) {
              p.next = p1;
              p1 = p1.next;
            } else {
              p.next = p2;
              p2 = p2.next;
            }
            p = p.next;
          }
          if (p1 !== null) {
            p.next = p1;
          } else if (p2 !== null) {
            p.next = p2;
          }
          return head.next;
        }
        function sort(keys, values, left, right, compare3) {
          if (left >= right)
            return;
          var pivot = keys[left + right >> 1];
          var i = left - 1;
          var j = right + 1;
          while (true) {
            do {
              i++;
            } while (compare3(keys[i], pivot) < 0);
            do {
              j--;
            } while (compare3(keys[j], pivot) > 0);
            if (i >= j)
              break;
            var tmp = keys[i];
            keys[i] = keys[j];
            keys[j] = tmp;
            tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
          }
          sort(keys, values, left, j, compare3);
          sort(keys, values, j + 1, right, compare3);
        }
        var isInBbox = function isInBbox2(bbox2, point2) {
          return bbox2.ll.x <= point2.x && point2.x <= bbox2.ur.x && bbox2.ll.y <= point2.y && point2.y <= bbox2.ur.y;
        };
        var getBboxOverlap = function getBboxOverlap2(b1, b2) {
          if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y)
            return null;
          var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
          var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
          var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
          var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
          return {
            ll: {
              x: lowerX,
              y: lowerY
            },
            ur: {
              x: upperX,
              y: upperY
            }
          };
        };
        var epsilon4 = Number.EPSILON;
        if (epsilon4 === void 0)
          epsilon4 = Math.pow(2, -52);
        var EPSILON_SQ = epsilon4 * epsilon4;
        var cmp = function cmp2(a2, b) {
          if (-epsilon4 < a2 && a2 < epsilon4) {
            if (-epsilon4 < b && b < epsilon4) {
              return 0;
            }
          }
          var ab = a2 - b;
          if (ab * ab < EPSILON_SQ * a2 * b) {
            return 0;
          }
          return a2 < b ? -1 : 1;
        };
        var PtRounder = /* @__PURE__ */ function() {
          function PtRounder2() {
            _classCallCheck(this, PtRounder2);
            this.reset();
          }
          _createClass(PtRounder2, [{
            key: "reset",
            value: function reset() {
              this.xRounder = new CoordRounder();
              this.yRounder = new CoordRounder();
            }
          }, {
            key: "round",
            value: function round(x3, y3) {
              return {
                x: this.xRounder.round(x3),
                y: this.yRounder.round(y3)
              };
            }
          }]);
          return PtRounder2;
        }();
        var CoordRounder = /* @__PURE__ */ function() {
          function CoordRounder2() {
            _classCallCheck(this, CoordRounder2);
            this.tree = new Tree();
            this.round(0);
          }
          _createClass(CoordRounder2, [{
            key: "round",
            value: function round(coord) {
              var node = this.tree.add(coord);
              var prevNode = this.tree.prev(node);
              if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
                this.tree.remove(coord);
                return prevNode.key;
              }
              var nextNode = this.tree.next(node);
              if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
                this.tree.remove(coord);
                return nextNode.key;
              }
              return coord;
            }
          }]);
          return CoordRounder2;
        }();
        var rounder = new PtRounder();
        var crossProduct = function crossProduct2(a2, b) {
          return a2.x * b.y - a2.y * b.x;
        };
        var dotProduct = function dotProduct2(a2, b) {
          return a2.x * b.x + a2.y * b.y;
        };
        var compareVectorAngles = function compareVectorAngles2(basePt, endPt1, endPt2) {
          var v1 = {
            x: endPt1.x - basePt.x,
            y: endPt1.y - basePt.y
          };
          var v2 = {
            x: endPt2.x - basePt.x,
            y: endPt2.y - basePt.y
          };
          var kross = crossProduct(v1, v2);
          return cmp(kross, 0);
        };
        var length2 = function length3(v) {
          return Math.sqrt(dotProduct(v, v));
        };
        var sineOfAngle = function sineOfAngle2(pShared, pBase, pAngle) {
          var vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          var vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return crossProduct(vAngle, vBase) / length2(vAngle) / length2(vBase);
        };
        var cosineOfAngle = function cosineOfAngle2(pShared, pBase, pAngle) {
          var vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          var vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return dotProduct(vAngle, vBase) / length2(vAngle) / length2(vBase);
        };
        var horizontalIntersection = function horizontalIntersection2(pt, v, y3) {
          if (v.y === 0)
            return null;
          return {
            x: pt.x + v.x / v.y * (y3 - pt.y),
            y: y3
          };
        };
        var verticalIntersection = function verticalIntersection2(pt, v, x3) {
          if (v.x === 0)
            return null;
          return {
            x: x3,
            y: pt.y + v.y / v.x * (x3 - pt.x)
          };
        };
        var intersection = function intersection2(pt1, v1, pt2, v2) {
          if (v1.x === 0)
            return verticalIntersection(pt2, v2, pt1.x);
          if (v2.x === 0)
            return verticalIntersection(pt1, v1, pt2.x);
          if (v1.y === 0)
            return horizontalIntersection(pt2, v2, pt1.y);
          if (v2.y === 0)
            return horizontalIntersection(pt1, v1, pt2.y);
          var kross = crossProduct(v1, v2);
          if (kross == 0)
            return null;
          var ve = {
            x: pt2.x - pt1.x,
            y: pt2.y - pt1.y
          };
          var d1 = crossProduct(ve, v1) / kross;
          var d2 = crossProduct(ve, v2) / kross;
          var x12 = pt1.x + d2 * v1.x, x22 = pt2.x + d1 * v2.x;
          var y12 = pt1.y + d2 * v1.y, y22 = pt2.y + d1 * v2.y;
          var x3 = (x12 + x22) / 2;
          var y3 = (y12 + y22) / 2;
          return {
            x: x3,
            y: y3
          };
        };
        var SweepEvent = /* @__PURE__ */ function() {
          _createClass(SweepEvent2, null, [{
            key: "compare",
            value: function compare3(a2, b) {
              var ptCmp = SweepEvent2.comparePoints(a2.point, b.point);
              if (ptCmp !== 0)
                return ptCmp;
              if (a2.point !== b.point)
                a2.link(b);
              if (a2.isLeft !== b.isLeft)
                return a2.isLeft ? 1 : -1;
              return Segment.compare(a2.segment, b.segment);
            }
          }, {
            key: "comparePoints",
            value: function comparePoints(aPt, bPt) {
              if (aPt.x < bPt.x)
                return -1;
              if (aPt.x > bPt.x)
                return 1;
              if (aPt.y < bPt.y)
                return -1;
              if (aPt.y > bPt.y)
                return 1;
              return 0;
            }
          }]);
          function SweepEvent2(point2, isLeft) {
            _classCallCheck(this, SweepEvent2);
            if (point2.events === void 0)
              point2.events = [this];
            else
              point2.events.push(this);
            this.point = point2;
            this.isLeft = isLeft;
          }
          _createClass(SweepEvent2, [{
            key: "link",
            value: function link2(other) {
              if (other.point === this.point) {
                throw new Error("Tried to link already linked events");
              }
              var otherEvents = other.point.events;
              for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
                var evt = otherEvents[i];
                this.point.events.push(evt);
                evt.point = this.point;
              }
              this.checkForConsuming();
            }
          }, {
            key: "checkForConsuming",
            value: function checkForConsuming() {
              var numEvents = this.point.events.length;
              for (var i = 0; i < numEvents; i++) {
                var evt1 = this.point.events[i];
                if (evt1.segment.consumedBy !== void 0)
                  continue;
                for (var j = i + 1; j < numEvents; j++) {
                  var evt2 = this.point.events[j];
                  if (evt2.consumedBy !== void 0)
                    continue;
                  if (evt1.otherSE.point.events !== evt2.otherSE.point.events)
                    continue;
                  evt1.segment.consume(evt2.segment);
                }
              }
            }
          }, {
            key: "getAvailableLinkedEvents",
            value: function getAvailableLinkedEvents() {
              var events = [];
              for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
                var evt = this.point.events[i];
                if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
                  events.push(evt);
                }
              }
              return events;
            }
          }, {
            key: "getLeftmostComparator",
            value: function getLeftmostComparator(baseEvent) {
              var _this = this;
              var cache2 = /* @__PURE__ */ new Map();
              var fillCache = function fillCache2(linkedEvent) {
                var nextEvent = linkedEvent.otherSE;
                cache2.set(linkedEvent, {
                  sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
                  cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
                });
              };
              return function(a2, b) {
                if (!cache2.has(a2))
                  fillCache(a2);
                if (!cache2.has(b))
                  fillCache(b);
                var _cache$get = cache2.get(a2), asine = _cache$get.sine, acosine = _cache$get.cosine;
                var _cache$get2 = cache2.get(b), bsine = _cache$get2.sine, bcosine = _cache$get2.cosine;
                if (asine >= 0 && bsine >= 0) {
                  if (acosine < bcosine)
                    return 1;
                  if (acosine > bcosine)
                    return -1;
                  return 0;
                }
                if (asine < 0 && bsine < 0) {
                  if (acosine < bcosine)
                    return -1;
                  if (acosine > bcosine)
                    return 1;
                  return 0;
                }
                if (bsine < asine)
                  return -1;
                if (bsine > asine)
                  return 1;
                return 0;
              };
            }
          }]);
          return SweepEvent2;
        }();
        var segmentId = 0;
        var Segment = /* @__PURE__ */ function() {
          _createClass(Segment2, null, [{
            key: "compare",
            value: function compare3(a2, b) {
              var alx = a2.leftSE.point.x;
              var blx = b.leftSE.point.x;
              var arx = a2.rightSE.point.x;
              var brx = b.rightSE.point.x;
              if (brx < alx)
                return 1;
              if (arx < blx)
                return -1;
              var aly = a2.leftSE.point.y;
              var bly = b.leftSE.point.y;
              var ary = a2.rightSE.point.y;
              var bry = b.rightSE.point.y;
              if (alx < blx) {
                if (bly < aly && bly < ary)
                  return 1;
                if (bly > aly && bly > ary)
                  return -1;
                var aCmpBLeft = a2.comparePoint(b.leftSE.point);
                if (aCmpBLeft < 0)
                  return 1;
                if (aCmpBLeft > 0)
                  return -1;
                var bCmpARight = b.comparePoint(a2.rightSE.point);
                if (bCmpARight !== 0)
                  return bCmpARight;
                return -1;
              }
              if (alx > blx) {
                if (aly < bly && aly < bry)
                  return -1;
                if (aly > bly && aly > bry)
                  return 1;
                var bCmpALeft = b.comparePoint(a2.leftSE.point);
                if (bCmpALeft !== 0)
                  return bCmpALeft;
                var aCmpBRight = a2.comparePoint(b.rightSE.point);
                if (aCmpBRight < 0)
                  return 1;
                if (aCmpBRight > 0)
                  return -1;
                return 1;
              }
              if (aly < bly)
                return -1;
              if (aly > bly)
                return 1;
              if (arx < brx) {
                var _bCmpARight = b.comparePoint(a2.rightSE.point);
                if (_bCmpARight !== 0)
                  return _bCmpARight;
              }
              if (arx > brx) {
                var _aCmpBRight = a2.comparePoint(b.rightSE.point);
                if (_aCmpBRight < 0)
                  return 1;
                if (_aCmpBRight > 0)
                  return -1;
              }
              if (arx !== brx) {
                var ay = ary - aly;
                var ax = arx - alx;
                var by = bry - bly;
                var bx = brx - blx;
                if (ay > ax && by < bx)
                  return 1;
                if (ay < ax && by > bx)
                  return -1;
              }
              if (arx > brx)
                return 1;
              if (arx < brx)
                return -1;
              if (ary < bry)
                return -1;
              if (ary > bry)
                return 1;
              if (a2.id < b.id)
                return -1;
              if (a2.id > b.id)
                return 1;
              return 0;
            }
          }]);
          function Segment2(leftSE, rightSE, rings, windings) {
            _classCallCheck(this, Segment2);
            this.id = ++segmentId;
            this.leftSE = leftSE;
            leftSE.segment = this;
            leftSE.otherSE = rightSE;
            this.rightSE = rightSE;
            rightSE.segment = this;
            rightSE.otherSE = leftSE;
            this.rings = rings;
            this.windings = windings;
          }
          _createClass(Segment2, [{
            key: "replaceRightSE",
            value: function replaceRightSE(newRightSE) {
              this.rightSE = newRightSE;
              this.rightSE.segment = this;
              this.rightSE.otherSE = this.leftSE;
              this.leftSE.otherSE = this.rightSE;
            }
          }, {
            key: "bbox",
            value: function bbox2() {
              var y12 = this.leftSE.point.y;
              var y22 = this.rightSE.point.y;
              return {
                ll: {
                  x: this.leftSE.point.x,
                  y: y12 < y22 ? y12 : y22
                },
                ur: {
                  x: this.rightSE.point.x,
                  y: y12 > y22 ? y12 : y22
                }
              };
            }
          }, {
            key: "vector",
            value: function vector() {
              return {
                x: this.rightSE.point.x - this.leftSE.point.x,
                y: this.rightSE.point.y - this.leftSE.point.y
              };
            }
          }, {
            key: "isAnEndpoint",
            value: function isAnEndpoint(pt) {
              return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
            }
          }, {
            key: "comparePoint",
            value: function comparePoint(point2) {
              if (this.isAnEndpoint(point2))
                return 0;
              var lPt = this.leftSE.point;
              var rPt = this.rightSE.point;
              var v = this.vector();
              if (lPt.x === rPt.x) {
                if (point2.x === lPt.x)
                  return 0;
                return point2.x < lPt.x ? 1 : -1;
              }
              var yDist = (point2.y - lPt.y) / v.y;
              var xFromYDist = lPt.x + yDist * v.x;
              if (point2.x === xFromYDist)
                return 0;
              var xDist = (point2.x - lPt.x) / v.x;
              var yFromXDist = lPt.y + xDist * v.y;
              if (point2.y === yFromXDist)
                return 0;
              return point2.y < yFromXDist ? -1 : 1;
            }
          }, {
            key: "getIntersection",
            value: function getIntersection(other) {
              var tBbox = this.bbox();
              var oBbox = other.bbox();
              var bboxOverlap = getBboxOverlap(tBbox, oBbox);
              if (bboxOverlap === null)
                return null;
              var tlp = this.leftSE.point;
              var trp = this.rightSE.point;
              var olp = other.leftSE.point;
              var orp = other.rightSE.point;
              var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
              var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
              var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
              var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
              if (touchesThisLSE && touchesOtherLSE) {
                if (touchesThisRSE && !touchesOtherRSE)
                  return trp;
                if (!touchesThisRSE && touchesOtherRSE)
                  return orp;
                return null;
              }
              if (touchesThisLSE) {
                if (touchesOtherRSE) {
                  if (tlp.x === orp.x && tlp.y === orp.y)
                    return null;
                }
                return tlp;
              }
              if (touchesOtherLSE) {
                if (touchesThisRSE) {
                  if (trp.x === olp.x && trp.y === olp.y)
                    return null;
                }
                return olp;
              }
              if (touchesThisRSE && touchesOtherRSE)
                return null;
              if (touchesThisRSE)
                return trp;
              if (touchesOtherRSE)
                return orp;
              var pt = intersection(tlp, this.vector(), olp, other.vector());
              if (pt === null)
                return null;
              if (!isInBbox(bboxOverlap, pt))
                return null;
              return rounder.round(pt.x, pt.y);
            }
          }, {
            key: "split",
            value: function split2(point2) {
              var newEvents = [];
              var alreadyLinked = point2.events !== void 0;
              var newLeftSE = new SweepEvent(point2, true);
              var newRightSE = new SweepEvent(point2, false);
              var oldRightSE = this.rightSE;
              this.replaceRightSE(newRightSE);
              newEvents.push(newRightSE);
              newEvents.push(newLeftSE);
              var newSeg = new Segment2(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
              if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
                newSeg.swapEvents();
              }
              if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
                this.swapEvents();
              }
              if (alreadyLinked) {
                newLeftSE.checkForConsuming();
                newRightSE.checkForConsuming();
              }
              return newEvents;
            }
          }, {
            key: "swapEvents",
            value: function swapEvents() {
              var tmpEvt = this.rightSE;
              this.rightSE = this.leftSE;
              this.leftSE = tmpEvt;
              this.leftSE.isLeft = true;
              this.rightSE.isLeft = false;
              for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
                this.windings[i] *= -1;
              }
            }
          }, {
            key: "consume",
            value: function consume(other) {
              var consumer = this;
              var consumee = other;
              while (consumer.consumedBy) {
                consumer = consumer.consumedBy;
              }
              while (consumee.consumedBy) {
                consumee = consumee.consumedBy;
              }
              var cmp2 = Segment2.compare(consumer, consumee);
              if (cmp2 === 0)
                return;
              if (cmp2 > 0) {
                var tmp = consumer;
                consumer = consumee;
                consumee = tmp;
              }
              if (consumer.prev === consumee) {
                var _tmp = consumer;
                consumer = consumee;
                consumee = _tmp;
              }
              for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
                var ring = consumee.rings[i];
                var winding = consumee.windings[i];
                var index2 = consumer.rings.indexOf(ring);
                if (index2 === -1) {
                  consumer.rings.push(ring);
                  consumer.windings.push(winding);
                } else
                  consumer.windings[index2] += winding;
              }
              consumee.rings = null;
              consumee.windings = null;
              consumee.consumedBy = consumer;
              consumee.leftSE.consumedBy = consumer.leftSE;
              consumee.rightSE.consumedBy = consumer.rightSE;
            }
          }, {
            key: "prevInResult",
            value: function prevInResult() {
              if (this._prevInResult !== void 0)
                return this._prevInResult;
              if (!this.prev)
                this._prevInResult = null;
              else if (this.prev.isInResult())
                this._prevInResult = this.prev;
              else
                this._prevInResult = this.prev.prevInResult();
              return this._prevInResult;
            }
          }, {
            key: "beforeState",
            value: function beforeState() {
              if (this._beforeState !== void 0)
                return this._beforeState;
              if (!this.prev)
                this._beforeState = {
                  rings: [],
                  windings: [],
                  multiPolys: []
                };
              else {
                var seg = this.prev.consumedBy || this.prev;
                this._beforeState = seg.afterState();
              }
              return this._beforeState;
            }
          }, {
            key: "afterState",
            value: function afterState() {
              if (this._afterState !== void 0)
                return this._afterState;
              var beforeState = this.beforeState();
              this._afterState = {
                rings: beforeState.rings.slice(0),
                windings: beforeState.windings.slice(0),
                multiPolys: []
              };
              var ringsAfter = this._afterState.rings;
              var windingsAfter = this._afterState.windings;
              var mpsAfter = this._afterState.multiPolys;
              for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
                var ring = this.rings[i];
                var winding = this.windings[i];
                var index2 = ringsAfter.indexOf(ring);
                if (index2 === -1) {
                  ringsAfter.push(ring);
                  windingsAfter.push(winding);
                } else
                  windingsAfter[index2] += winding;
              }
              var polysAfter = [];
              var polysExclude = [];
              for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
                if (windingsAfter[_i] === 0)
                  continue;
                var _ring = ringsAfter[_i];
                var poly = _ring.poly;
                if (polysExclude.indexOf(poly) !== -1)
                  continue;
                if (_ring.isExterior)
                  polysAfter.push(poly);
                else {
                  if (polysExclude.indexOf(poly) === -1)
                    polysExclude.push(poly);
                  var _index = polysAfter.indexOf(_ring.poly);
                  if (_index !== -1)
                    polysAfter.splice(_index, 1);
                }
              }
              for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
                var mp = polysAfter[_i2].multiPoly;
                if (mpsAfter.indexOf(mp) === -1)
                  mpsAfter.push(mp);
              }
              return this._afterState;
            }
          }, {
            key: "isInResult",
            value: function isInResult() {
              if (this.consumedBy)
                return false;
              if (this._isInResult !== void 0)
                return this._isInResult;
              var mpsBefore = this.beforeState().multiPolys;
              var mpsAfter = this.afterState().multiPolys;
              switch (operation.type) {
                case "union": {
                  var noBefores = mpsBefore.length === 0;
                  var noAfters = mpsAfter.length === 0;
                  this._isInResult = noBefores !== noAfters;
                  break;
                }
                case "intersection": {
                  var least;
                  var most;
                  if (mpsBefore.length < mpsAfter.length) {
                    least = mpsBefore.length;
                    most = mpsAfter.length;
                  } else {
                    least = mpsAfter.length;
                    most = mpsBefore.length;
                  }
                  this._isInResult = most === operation.numMultiPolys && least < most;
                  break;
                }
                case "xor": {
                  var diff = Math.abs(mpsBefore.length - mpsAfter.length);
                  this._isInResult = diff % 2 === 1;
                  break;
                }
                case "difference": {
                  var isJustSubject = function isJustSubject2(mps) {
                    return mps.length === 1 && mps[0].isSubject;
                  };
                  this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
                  break;
                }
                default:
                  throw new Error("Unrecognized operation type found ".concat(operation.type));
              }
              return this._isInResult;
            }
          }], [{
            key: "fromRing",
            value: function fromRing(pt1, pt2, ring) {
              var leftPt, rightPt, winding;
              var cmpPts = SweepEvent.comparePoints(pt1, pt2);
              if (cmpPts < 0) {
                leftPt = pt1;
                rightPt = pt2;
                winding = 1;
              } else if (cmpPts > 0) {
                leftPt = pt2;
                rightPt = pt1;
                winding = -1;
              } else
                throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));
              var leftSE = new SweepEvent(leftPt, true);
              var rightSE = new SweepEvent(rightPt, false);
              return new Segment2(leftSE, rightSE, [ring], [winding]);
            }
          }]);
          return Segment2;
        }();
        var RingIn = /* @__PURE__ */ function() {
          function RingIn2(geomRing, poly, isExterior) {
            _classCallCheck(this, RingIn2);
            if (!Array.isArray(geomRing) || geomRing.length === 0) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.poly = poly;
            this.isExterior = isExterior;
            this.segments = [];
            if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
            this.bbox = {
              ll: {
                x: firstPoint.x,
                y: firstPoint.y
              },
              ur: {
                x: firstPoint.x,
                y: firstPoint.y
              }
            };
            var prevPoint = firstPoint;
            for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
              if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
                throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
              }
              var point2 = rounder.round(geomRing[i][0], geomRing[i][1]);
              if (point2.x === prevPoint.x && point2.y === prevPoint.y)
                continue;
              this.segments.push(Segment.fromRing(prevPoint, point2, this));
              if (point2.x < this.bbox.ll.x)
                this.bbox.ll.x = point2.x;
              if (point2.y < this.bbox.ll.y)
                this.bbox.ll.y = point2.y;
              if (point2.x > this.bbox.ur.x)
                this.bbox.ur.x = point2.x;
              if (point2.y > this.bbox.ur.y)
                this.bbox.ur.y = point2.y;
              prevPoint = point2;
            }
            if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
              this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
            }
          }
          _createClass(RingIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = [];
              for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
                var segment = this.segments[i];
                sweepEvents.push(segment.leftSE);
                sweepEvents.push(segment.rightSE);
              }
              return sweepEvents;
            }
          }]);
          return RingIn2;
        }();
        var PolyIn = /* @__PURE__ */ function() {
          function PolyIn2(geomPoly, multiPoly) {
            _classCallCheck(this, PolyIn2);
            if (!Array.isArray(geomPoly)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.exteriorRing = new RingIn(geomPoly[0], this, true);
            this.bbox = {
              ll: {
                x: this.exteriorRing.bbox.ll.x,
                y: this.exteriorRing.bbox.ll.y
              },
              ur: {
                x: this.exteriorRing.bbox.ur.x,
                y: this.exteriorRing.bbox.ur.y
              }
            };
            this.interiorRings = [];
            for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
              var ring = new RingIn(geomPoly[i], this, false);
              if (ring.bbox.ll.x < this.bbox.ll.x)
                this.bbox.ll.x = ring.bbox.ll.x;
              if (ring.bbox.ll.y < this.bbox.ll.y)
                this.bbox.ll.y = ring.bbox.ll.y;
              if (ring.bbox.ur.x > this.bbox.ur.x)
                this.bbox.ur.x = ring.bbox.ur.x;
              if (ring.bbox.ur.y > this.bbox.ur.y)
                this.bbox.ur.y = ring.bbox.ur.y;
              this.interiorRings.push(ring);
            }
            this.multiPoly = multiPoly;
          }
          _createClass(PolyIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = this.exteriorRing.getSweepEvents();
              for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
                var ringSweepEvents = this.interiorRings[i].getSweepEvents();
                for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
                  sweepEvents.push(ringSweepEvents[j]);
                }
              }
              return sweepEvents;
            }
          }]);
          return PolyIn2;
        }();
        var MultiPolyIn = /* @__PURE__ */ function() {
          function MultiPolyIn2(geom, isSubject) {
            _classCallCheck(this, MultiPolyIn2);
            if (!Array.isArray(geom)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            try {
              if (typeof geom[0][0][0] === "number")
                geom = [geom];
            } catch (ex) {
            }
            this.polys = [];
            this.bbox = {
              ll: {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
              },
              ur: {
                x: Number.NEGATIVE_INFINITY,
                y: Number.NEGATIVE_INFINITY
              }
            };
            for (var i = 0, iMax = geom.length; i < iMax; i++) {
              var poly = new PolyIn(geom[i], this);
              if (poly.bbox.ll.x < this.bbox.ll.x)
                this.bbox.ll.x = poly.bbox.ll.x;
              if (poly.bbox.ll.y < this.bbox.ll.y)
                this.bbox.ll.y = poly.bbox.ll.y;
              if (poly.bbox.ur.x > this.bbox.ur.x)
                this.bbox.ur.x = poly.bbox.ur.x;
              if (poly.bbox.ur.y > this.bbox.ur.y)
                this.bbox.ur.y = poly.bbox.ur.y;
              this.polys.push(poly);
            }
            this.isSubject = isSubject;
          }
          _createClass(MultiPolyIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = [];
              for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
                var polySweepEvents = this.polys[i].getSweepEvents();
                for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
                  sweepEvents.push(polySweepEvents[j]);
                }
              }
              return sweepEvents;
            }
          }]);
          return MultiPolyIn2;
        }();
        var RingOut = /* @__PURE__ */ function() {
          _createClass(RingOut2, null, [{
            key: "factory",
            value: function factory(allSegments) {
              var ringsOut = [];
              for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
                var segment = allSegments[i];
                if (!segment.isInResult() || segment.ringOut)
                  continue;
                var prevEvent = null;
                var event = segment.leftSE;
                var nextEvent = segment.rightSE;
                var events = [event];
                var startingPoint = event.point;
                var intersectionLEs = [];
                while (true) {
                  prevEvent = event;
                  event = nextEvent;
                  events.push(event);
                  if (event.point === startingPoint)
                    break;
                  while (true) {
                    var availableLEs = event.getAvailableLinkedEvents();
                    if (availableLEs.length === 0) {
                      var firstPt = events[0].point;
                      var lastPt = events[events.length - 1].point;
                      throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
                    }
                    if (availableLEs.length === 1) {
                      nextEvent = availableLEs[0].otherSE;
                      break;
                    }
                    var indexLE = null;
                    for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
                      if (intersectionLEs[j].point === event.point) {
                        indexLE = j;
                        break;
                      }
                    }
                    if (indexLE !== null) {
                      var intersectionLE = intersectionLEs.splice(indexLE)[0];
                      var ringEvents = events.splice(intersectionLE.index);
                      ringEvents.unshift(ringEvents[0].otherSE);
                      ringsOut.push(new RingOut2(ringEvents.reverse()));
                      continue;
                    }
                    intersectionLEs.push({
                      index: events.length,
                      point: event.point
                    });
                    var comparator = event.getLeftmostComparator(prevEvent);
                    nextEvent = availableLEs.sort(comparator)[0].otherSE;
                    break;
                  }
                }
                ringsOut.push(new RingOut2(events));
              }
              return ringsOut;
            }
          }]);
          function RingOut2(events) {
            _classCallCheck(this, RingOut2);
            this.events = events;
            for (var i = 0, iMax = events.length; i < iMax; i++) {
              events[i].segment.ringOut = this;
            }
            this.poly = null;
          }
          _createClass(RingOut2, [{
            key: "getGeom",
            value: function getGeom2() {
              var prevPt = this.events[0].point;
              var points = [prevPt];
              for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
                var _pt = this.events[i].point;
                var _nextPt = this.events[i + 1].point;
                if (compareVectorAngles(_pt, prevPt, _nextPt) === 0)
                  continue;
                points.push(_pt);
                prevPt = _pt;
              }
              if (points.length === 1)
                return null;
              var pt = points[0];
              var nextPt = points[1];
              if (compareVectorAngles(pt, prevPt, nextPt) === 0)
                points.shift();
              points.push(points[0]);
              var step = this.isExteriorRing() ? 1 : -1;
              var iStart = this.isExteriorRing() ? 0 : points.length - 1;
              var iEnd = this.isExteriorRing() ? points.length : -1;
              var orderedPoints = [];
              for (var _i = iStart; _i != iEnd; _i += step) {
                orderedPoints.push([points[_i].x, points[_i].y]);
              }
              return orderedPoints;
            }
          }, {
            key: "isExteriorRing",
            value: function isExteriorRing() {
              if (this._isExteriorRing === void 0) {
                var enclosing = this.enclosingRing();
                this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
              }
              return this._isExteriorRing;
            }
          }, {
            key: "enclosingRing",
            value: function enclosingRing() {
              if (this._enclosingRing === void 0) {
                this._enclosingRing = this._calcEnclosingRing();
              }
              return this._enclosingRing;
            }
          }, {
            key: "_calcEnclosingRing",
            value: function _calcEnclosingRing() {
              var leftMostEvt = this.events[0];
              for (var i = 1, iMax = this.events.length; i < iMax; i++) {
                var evt = this.events[i];
                if (SweepEvent.compare(leftMostEvt, evt) > 0)
                  leftMostEvt = evt;
              }
              var prevSeg = leftMostEvt.segment.prevInResult();
              var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
              while (true) {
                if (!prevSeg)
                  return null;
                if (!prevPrevSeg)
                  return prevSeg.ringOut;
                if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
                  if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
                    return prevSeg.ringOut;
                  } else
                    return prevSeg.ringOut.enclosingRing();
                }
                prevSeg = prevPrevSeg.prevInResult();
                prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
              }
            }
          }]);
          return RingOut2;
        }();
        var PolyOut = /* @__PURE__ */ function() {
          function PolyOut2(exteriorRing) {
            _classCallCheck(this, PolyOut2);
            this.exteriorRing = exteriorRing;
            exteriorRing.poly = this;
            this.interiorRings = [];
          }
          _createClass(PolyOut2, [{
            key: "addInterior",
            value: function addInterior(ring) {
              this.interiorRings.push(ring);
              ring.poly = this;
            }
          }, {
            key: "getGeom",
            value: function getGeom2() {
              var geom = [this.exteriorRing.getGeom()];
              if (geom[0] === null)
                return null;
              for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
                var ringGeom = this.interiorRings[i].getGeom();
                if (ringGeom === null)
                  continue;
                geom.push(ringGeom);
              }
              return geom;
            }
          }]);
          return PolyOut2;
        }();
        var MultiPolyOut = /* @__PURE__ */ function() {
          function MultiPolyOut2(rings) {
            _classCallCheck(this, MultiPolyOut2);
            this.rings = rings;
            this.polys = this._composePolys(rings);
          }
          _createClass(MultiPolyOut2, [{
            key: "getGeom",
            value: function getGeom2() {
              var geom = [];
              for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
                var polyGeom = this.polys[i].getGeom();
                if (polyGeom === null)
                  continue;
                geom.push(polyGeom);
              }
              return geom;
            }
          }, {
            key: "_composePolys",
            value: function _composePolys(rings) {
              var polys = [];
              for (var i = 0, iMax = rings.length; i < iMax; i++) {
                var ring = rings[i];
                if (ring.poly)
                  continue;
                if (ring.isExteriorRing())
                  polys.push(new PolyOut(ring));
                else {
                  var enclosingRing = ring.enclosingRing();
                  if (!enclosingRing.poly)
                    polys.push(new PolyOut(enclosingRing));
                  enclosingRing.poly.addInterior(ring);
                }
              }
              return polys;
            }
          }]);
          return MultiPolyOut2;
        }();
        var SweepLine = /* @__PURE__ */ function() {
          function SweepLine2(queue) {
            var comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment.compare;
            _classCallCheck(this, SweepLine2);
            this.queue = queue;
            this.tree = new Tree(comparator);
            this.segments = [];
          }
          _createClass(SweepLine2, [{
            key: "process",
            value: function process2(event) {
              var segment = event.segment;
              var newEvents = [];
              if (event.consumedBy) {
                if (event.isLeft)
                  this.queue.remove(event.otherSE);
                else
                  this.tree.remove(segment);
                return newEvents;
              }
              var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
              if (!node)
                throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
              var prevNode = node;
              var nextNode = node;
              var prevSeg = void 0;
              var nextSeg = void 0;
              while (prevSeg === void 0) {
                prevNode = this.tree.prev(prevNode);
                if (prevNode === null)
                  prevSeg = null;
                else if (prevNode.key.consumedBy === void 0)
                  prevSeg = prevNode.key;
              }
              while (nextSeg === void 0) {
                nextNode = this.tree.next(nextNode);
                if (nextNode === null)
                  nextSeg = null;
                else if (nextNode.key.consumedBy === void 0)
                  nextSeg = nextNode.key;
              }
              if (event.isLeft) {
                var prevMySplitter = null;
                if (prevSeg) {
                  var prevInter = prevSeg.getIntersection(segment);
                  if (prevInter !== null) {
                    if (!segment.isAnEndpoint(prevInter))
                      prevMySplitter = prevInter;
                    if (!prevSeg.isAnEndpoint(prevInter)) {
                      var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                      for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                        newEvents.push(newEventsFromSplit[i]);
                      }
                    }
                  }
                }
                var nextMySplitter = null;
                if (nextSeg) {
                  var nextInter = nextSeg.getIntersection(segment);
                  if (nextInter !== null) {
                    if (!segment.isAnEndpoint(nextInter))
                      nextMySplitter = nextInter;
                    if (!nextSeg.isAnEndpoint(nextInter)) {
                      var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                      for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
                        newEvents.push(_newEventsFromSplit[_i]);
                      }
                    }
                  }
                }
                if (prevMySplitter !== null || nextMySplitter !== null) {
                  var mySplitter = null;
                  if (prevMySplitter === null)
                    mySplitter = nextMySplitter;
                  else if (nextMySplitter === null)
                    mySplitter = prevMySplitter;
                  else {
                    var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
                    mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
                  }
                  this.queue.remove(segment.rightSE);
                  newEvents.push(segment.rightSE);
                  var _newEventsFromSplit2 = segment.split(mySplitter);
                  for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
                    newEvents.push(_newEventsFromSplit2[_i2]);
                  }
                }
                if (newEvents.length > 0) {
                  this.tree.remove(segment);
                  newEvents.push(event);
                } else {
                  this.segments.push(segment);
                  segment.prev = prevSeg;
                }
              } else {
                if (prevSeg && nextSeg) {
                  var inter = prevSeg.getIntersection(nextSeg);
                  if (inter !== null) {
                    if (!prevSeg.isAnEndpoint(inter)) {
                      var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);
                      for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
                        newEvents.push(_newEventsFromSplit3[_i3]);
                      }
                    }
                    if (!nextSeg.isAnEndpoint(inter)) {
                      var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);
                      for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
                        newEvents.push(_newEventsFromSplit4[_i4]);
                      }
                    }
                  }
                }
                this.tree.remove(segment);
              }
              return newEvents;
            }
          }, {
            key: "_splitSafely",
            value: function _splitSafely(seg, pt) {
              this.tree.remove(seg);
              var rightSE = seg.rightSE;
              this.queue.remove(rightSE);
              var newEvents = seg.split(pt);
              newEvents.push(rightSE);
              if (seg.consumedBy === void 0)
                this.tree.insert(seg);
              return newEvents;
            }
          }]);
          return SweepLine2;
        }();
        var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
        var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
        var Operation = /* @__PURE__ */ function() {
          function Operation2() {
            _classCallCheck(this, Operation2);
          }
          _createClass(Operation2, [{
            key: "run",
            value: function run(type, geom, moreGeoms) {
              operation.type = type;
              rounder.reset();
              var multipolys = [new MultiPolyIn(geom, true)];
              for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
                multipolys.push(new MultiPolyIn(moreGeoms[i], false));
              }
              operation.numMultiPolys = multipolys.length;
              if (operation.type === "difference") {
                var subject = multipolys[0];
                var _i = 1;
                while (_i < multipolys.length) {
                  if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null)
                    _i++;
                  else
                    multipolys.splice(_i, 1);
                }
              }
              if (operation.type === "intersection") {
                for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
                  var mpA = multipolys[_i2];
                  for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
                    if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null)
                      return [];
                  }
                }
              }
              var queue = new Tree(SweepEvent.compare);
              for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
                var sweepEvents = multipolys[_i3].getSweepEvents();
                for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
                  queue.insert(sweepEvents[_j]);
                  if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                    throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");
                  }
                }
              }
              var sweepLine = new SweepLine(queue);
              var prevQueueSize = queue.size;
              var node = queue.pop();
              while (node) {
                var evt = node.key;
                if (queue.size === prevQueueSize) {
                  var seg = evt.segment;
                  throw new Error("Unable to pop() ".concat(evt.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + "Please file a bug report.");
                }
                if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                  throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");
                }
                if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
                  throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");
                }
                var newEvents = sweepLine.process(evt);
                for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
                  var _evt = newEvents[_i4];
                  if (_evt.consumedBy === void 0)
                    queue.insert(_evt);
                }
                prevQueueSize = queue.size;
                node = queue.pop();
              }
              rounder.reset();
              var ringsOut = RingOut.factory(sweepLine.segments);
              var result = new MultiPolyOut(ringsOut);
              return result.getGeom();
            }
          }]);
          return Operation2;
        }();
        var operation = new Operation();
        var union = function union2(geom) {
          for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            moreGeoms[_key - 1] = arguments[_key];
          }
          return operation.run("union", geom, moreGeoms);
        };
        var intersection$1 = function intersection2(geom) {
          for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            moreGeoms[_key2 - 1] = arguments[_key2];
          }
          return operation.run("intersection", geom, moreGeoms);
        };
        var xor = function xor2(geom) {
          for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            moreGeoms[_key3 - 1] = arguments[_key3];
          }
          return operation.run("xor", geom, moreGeoms);
        };
        var difference = function difference2(subjectGeom) {
          for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            clippingGeoms[_key4 - 1] = arguments[_key4];
          }
          return operation.run("difference", subjectGeom, clippingGeoms);
        };
        var index = {
          union,
          intersection: intersection$1,
          xor,
          difference
        };
        return index;
      });
    }
  });

  // ../node_modules/turf-jsts/jsts.min.js
  var require_jsts_min = __commonJS({
    "../node_modules/turf-jsts/jsts.min.js"(exports5, module) {
      !function(t, e) {
        "object" == typeof exports5 && "undefined" != typeof module ? e(exports5) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.jsts = {});
      }(exports5, function(t) {
        "use strict";
        function e() {
        }
        function n(t2) {
          this.message = t2 || "";
        }
        function i(t2) {
          this.message = t2 || "";
        }
        function r(t2) {
          this.message = t2 || "";
        }
        function o() {
        }
        function s(t2) {
          return null === t2 ? Mt : t2.color;
        }
        function a2(t2) {
          return null === t2 ? null : t2.parent;
        }
        function u(t2, e3) {
          null !== t2 && (t2.color = e3);
        }
        function l(t2) {
          return null === t2 ? null : t2.left;
        }
        function c(t2) {
          return null === t2 ? null : t2.right;
        }
        function p() {
          this.root_ = null, this.size_ = 0;
        }
        function h() {
        }
        function f() {
          this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
        }
        function g() {
        }
        function d(t2) {
          this.message = t2 || "";
        }
        function y3() {
          this.array_ = [];
        }
        "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", { configurable: true, value: function(t2) {
          if (void 0 === this || null === this)
            throw new TypeError(this + " is not an object");
          var e3 = Object(this), n2 = Math.max(Math.min(e3.length, 9007199254740991), 0) || 0, i2 = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;
          i2 = i2 < 0 ? Math.max(n2 + i2, 0) : Math.min(i2, n2);
          var r2 = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n2;
          for (r2 = r2 < 0 ? Math.max(n2 + arguments[2], 0) : Math.min(r2, n2); i2 < r2; )
            e3[i2] = t2, ++i2;
          return e3;
        }, writable: true }), Number.isFinite = Number.isFinite || function(t2) {
          return "number" == typeof t2 && isFinite(t2);
        }, Number.isInteger = Number.isInteger || function(t2) {
          return "number" == typeof t2 && isFinite(t2) && Math.floor(t2) === t2;
        }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function(t2) {
          return t2 != t2;
        }, Math.trunc = Math.trunc || function(t2) {
          return t2 < 0 ? Math.ceil(t2) : Math.floor(t2);
        };
        var _ = function() {
        };
        _.prototype.interfaces_ = function() {
          return [];
        }, _.prototype.getClass = function() {
          return _;
        }, _.prototype.equalsWithTolerance = function(t2, e3, n2) {
          return Math.abs(t2 - e3) <= n2;
        };
        var m = function(t2) {
          function e3(e4) {
            t2.call(this, e4), this.name = "IllegalArgumentException", this.message = e4, this.stack = new t2().stack;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Error), v = function() {
        }, I2 = { MAX_VALUE: { configurable: true } };
        v.isNaN = function(t2) {
          return Number.isNaN(t2);
        }, v.doubleToLongBits = function(t2) {
          return t2;
        }, v.longBitsToDouble = function(t2) {
          return t2;
        }, v.isInfinite = function(t2) {
          return !Number.isFinite(t2);
        }, I2.MAX_VALUE.get = function() {
          return Number.MAX_VALUE;
        }, Object.defineProperties(v, I2);
        var E = function() {
        }, x3 = function() {
        }, N = function() {
        }, C = function t2() {
          if (this.x = null, this.y = null, this.z = null, 0 === arguments.length)
            this.x = 0, this.y = 0, this.z = t2.NULL_ORDINATE;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.x = e3.x, this.y = e3.y, this.z = e3.z;
          } else
            2 === arguments.length ? (this.x = arguments[0], this.y = arguments[1], this.z = t2.NULL_ORDINATE) : 3 === arguments.length && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]);
        }, S = { DimensionalComparator: { configurable: true }, serialVersionUID: { configurable: true }, NULL_ORDINATE: { configurable: true }, X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true } };
        C.prototype.setOrdinate = function(t2, e3) {
          switch (t2) {
            case C.X:
              this.x = e3;
              break;
            case C.Y:
              this.y = e3;
              break;
            case C.Z:
              this.z = e3;
              break;
            default:
              throw new m("Invalid ordinate index: " + t2);
          }
        }, C.prototype.equals2D = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.x === t2.x && this.y === t2.y;
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return !!_.equalsWithTolerance(this.x, e3.x, n2) && !!_.equalsWithTolerance(this.y, e3.y, n2);
          }
        }, C.prototype.getOrdinate = function(t2) {
          switch (t2) {
            case C.X:
              return this.x;
            case C.Y:
              return this.y;
            case C.Z:
              return this.z;
          }
          throw new m("Invalid ordinate index: " + t2);
        }, C.prototype.equals3D = function(t2) {
          return this.x === t2.x && this.y === t2.y && (this.z === t2.z || v.isNaN(this.z)) && v.isNaN(t2.z);
        }, C.prototype.equals = function(t2) {
          return t2 instanceof C && this.equals2D(t2);
        }, C.prototype.equalInZ = function(t2, e3) {
          return _.equalsWithTolerance(this.z, t2.z, e3);
        }, C.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.x < e3.x ? -1 : this.x > e3.x ? 1 : this.y < e3.y ? -1 : this.y > e3.y ? 1 : 0;
        }, C.prototype.clone = function() {
        }, C.prototype.copy = function() {
          return new C(this);
        }, C.prototype.toString = function() {
          return "(" + this.x + ", " + this.y + ", " + this.z + ")";
        }, C.prototype.distance3D = function(t2) {
          var e3 = this.x - t2.x, n2 = this.y - t2.y, i2 = this.z - t2.z;
          return Math.sqrt(e3 * e3 + n2 * n2 + i2 * i2);
        }, C.prototype.distance = function(t2) {
          var e3 = this.x - t2.x, n2 = this.y - t2.y;
          return Math.sqrt(e3 * e3 + n2 * n2);
        }, C.prototype.hashCode = function() {
          var t2 = 17;
          return t2 = 37 * t2 + C.hashCode(this.x), t2 = 37 * t2 + C.hashCode(this.y);
        }, C.prototype.setCoordinate = function(t2) {
          this.x = t2.x, this.y = t2.y, this.z = t2.z;
        }, C.prototype.interfaces_ = function() {
          return [E, x3, e];
        }, C.prototype.getClass = function() {
          return C;
        }, C.hashCode = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = v.doubleToLongBits(t2);
            return Math.trunc((e3 ^ e3) >>> 32);
          }
        }, S.DimensionalComparator.get = function() {
          return L;
        }, S.serialVersionUID.get = function() {
          return 6683108902428367e3;
        }, S.NULL_ORDINATE.get = function() {
          return v.NaN;
        }, S.X.get = function() {
          return 0;
        }, S.Y.get = function() {
          return 1;
        }, S.Z.get = function() {
          return 2;
        }, Object.defineProperties(C, S);
        var L = function(t2) {
          if (this._dimensionsToTest = 2, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            if (2 !== e3 && 3 !== e3)
              throw new m("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = e3;
          }
        };
        L.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3, r2 = L.compare(n2.x, i2.x);
          if (0 !== r2)
            return r2;
          var o2 = L.compare(n2.y, i2.y);
          if (0 !== o2)
            return o2;
          if (this._dimensionsToTest <= 2)
            return 0;
          return L.compare(n2.z, i2.z);
        }, L.prototype.interfaces_ = function() {
          return [N];
        }, L.prototype.getClass = function() {
          return L;
        }, L.compare = function(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : v.isNaN(t2) ? v.isNaN(e3) ? 0 : -1 : v.isNaN(e3) ? 1 : 0;
        };
        var b = function() {
        };
        b.prototype.create = function() {
        }, b.prototype.interfaces_ = function() {
          return [];
        }, b.prototype.getClass = function() {
          return b;
        };
        var w = function() {
        }, O2 = { INTERIOR: { configurable: true }, BOUNDARY: { configurable: true }, EXTERIOR: { configurable: true }, NONE: { configurable: true } };
        w.prototype.interfaces_ = function() {
          return [];
        }, w.prototype.getClass = function() {
          return w;
        }, w.toLocationSymbol = function(t2) {
          switch (t2) {
            case w.EXTERIOR:
              return "e";
            case w.BOUNDARY:
              return "b";
            case w.INTERIOR:
              return "i";
            case w.NONE:
              return "-";
          }
          throw new m("Unknown location value: " + t2);
        }, O2.INTERIOR.get = function() {
          return 0;
        }, O2.BOUNDARY.get = function() {
          return 1;
        }, O2.EXTERIOR.get = function() {
          return 2;
        }, O2.NONE.get = function() {
          return -1;
        }, Object.defineProperties(w, O2);
        var T = function(t2, e3) {
          return t2.interfaces_ && t2.interfaces_().indexOf(e3) > -1;
        }, R = function() {
        }, P = { LOG_10: { configurable: true } };
        R.prototype.interfaces_ = function() {
          return [];
        }, R.prototype.getClass = function() {
          return R;
        }, R.log10 = function(t2) {
          var e3 = Math.log(t2);
          return v.isInfinite(e3) ? e3 : v.isNaN(e3) ? e3 : e3 / R.LOG_10;
        }, R.min = function(t2, e3, n2, i2) {
          var r2 = t2;
          return e3 < r2 && (r2 = e3), n2 < r2 && (r2 = n2), i2 < r2 && (r2 = i2), r2;
        }, R.clamp = function() {
          if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
            return t2 < e3 ? e3 : t2 > n2 ? n2 : t2;
          }
          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            return i2 < r2 ? r2 : i2 > o2 ? o2 : i2;
          }
        }, R.wrap = function(t2, e3) {
          return t2 < 0 ? e3 - -t2 % e3 : t2 % e3;
        }, R.max = function() {
          if (3 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = t2;
            return e3 > i2 && (i2 = e3), n2 > i2 && (i2 = n2), i2;
          }
          if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a3 = arguments[3], u2 = r2;
            return o2 > u2 && (u2 = o2), s2 > u2 && (u2 = s2), a3 > u2 && (u2 = a3), u2;
          }
        }, R.average = function(t2, e3) {
          return (t2 + e3) / 2;
        }, P.LOG_10.get = function() {
          return Math.log(10);
        }, Object.defineProperties(R, P);
        var D = function(t2) {
          this.str = t2;
        };
        D.prototype.append = function(t2) {
          this.str += t2;
        }, D.prototype.setCharAt = function(t2, e3) {
          this.str = this.str.substr(0, t2) + e3 + this.str.substr(t2 + 1);
        }, D.prototype.toString = function(t2) {
          return this.str;
        };
        var M = function(t2) {
          this.value = t2;
        };
        M.prototype.intValue = function() {
          return this.value;
        }, M.prototype.compareTo = function(t2) {
          return this.value < t2 ? -1 : this.value > t2 ? 1 : 0;
        }, M.isNaN = function(t2) {
          return Number.isNaN(t2);
        };
        var A2 = function() {
        };
        A2.isWhitespace = function(t2) {
          return t2 <= 32 && t2 >= 0 || 127 === t2;
        }, A2.toUpperCase = function(t2) {
          return t2.toUpperCase();
        };
        var F = function t2() {
          if (this._hi = 0, this._lo = 0, 0 === arguments.length)
            this.init(0);
          else if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0];
              this.init(e3);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.init(n2);
            } else if ("string" == typeof arguments[0]) {
              var i2 = arguments[0];
              t2.call(this, t2.parse(i2));
            }
          } else if (2 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1];
            this.init(r2, o2);
          }
        }, G = { PI: { configurable: true }, TWO_PI: { configurable: true }, PI_2: { configurable: true }, E: { configurable: true }, NaN: { configurable: true }, EPS: { configurable: true }, SPLIT: { configurable: true }, MAX_PRINT_DIGITS: { configurable: true }, TEN: { configurable: true }, ONE: { configurable: true }, SCI_NOT_EXPONENT_CHAR: { configurable: true }, SCI_NOT_ZERO: { configurable: true } };
        F.prototype.le = function(t2) {
          return (this._hi < t2._hi || this._hi === t2._hi) && this._lo <= t2._lo;
        }, F.prototype.extractSignificantDigits = function(t2, e3) {
          var n2 = this.abs(), i2 = F.magnitude(n2._hi), r2 = F.TEN.pow(i2);
          (n2 = n2.divide(r2)).gt(F.TEN) ? (n2 = n2.divide(F.TEN), i2 += 1) : n2.lt(F.ONE) && (n2 = n2.multiply(F.TEN), i2 -= 1);
          for (var o2 = i2 + 1, s2 = new D(), a3 = F.MAX_PRINT_DIGITS - 1, u2 = 0; u2 <= a3; u2++) {
            t2 && u2 === o2 && s2.append(".");
            var l2 = Math.trunc(n2._hi);
            if (l2 < 0)
              break;
            var c2 = false, p2 = 0;
            l2 > 9 ? (c2 = true, p2 = "9") : p2 = "0" + l2, s2.append(p2), n2 = n2.subtract(F.valueOf(l2)).multiply(F.TEN), c2 && n2.selfAdd(F.TEN);
            var h2 = true, f2 = F.magnitude(n2._hi);
            if (f2 < 0 && Math.abs(f2) >= a3 - u2 && (h2 = false), !h2)
              break;
          }
          return e3[0] = i2, s2.toString();
        }, F.prototype.sqr = function() {
          return this.multiply(this);
        }, F.prototype.doubleValue = function() {
          return this._hi + this._lo;
        }, F.prototype.subtract = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.add(t2.negate());
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return this.add(-e3);
          }
        }, F.prototype.equals = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this._hi === t2._hi && this._lo === t2._lo;
          }
        }, F.prototype.isZero = function() {
          return 0 === this._hi && 0 === this._lo;
        }, F.prototype.selfSubtract = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-t2._hi, -t2._lo);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-e3, 0);
          }
        }, F.prototype.getSpecialNumberString = function() {
          return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
        }, F.prototype.min = function(t2) {
          return this.le(t2) ? this : t2;
        }, F.prototype.selfDivide = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfDivide(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0];
              return this.selfDivide(e3, 0);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = null, o2 = null, s2 = null, a3 = null, u2 = null, l2 = null, c2 = null, p2 = null;
            return u2 = this._hi / n2, l2 = F.SPLIT * u2, r2 = l2 - u2, p2 = F.SPLIT * n2, r2 = l2 - r2, o2 = u2 - r2, s2 = p2 - n2, c2 = u2 * n2, s2 = p2 - s2, a3 = n2 - s2, p2 = r2 * s2 - c2 + r2 * a3 + o2 * s2 + o2 * a3, l2 = (this._hi - c2 - p2 + this._lo - u2 * i2) / n2, p2 = u2 + l2, this._hi = p2, this._lo = u2 - p2 + l2, this;
          }
        }, F.prototype.dump = function() {
          return "DD<" + this._hi + ", " + this._lo + ">";
        }, F.prototype.divide = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0], e3 = null, n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a3 = null, u2 = null;
            n2 = (o2 = this._hi / t2._hi) - (e3 = (s2 = F.SPLIT * o2) - (e3 = s2 - o2)), u2 = e3 * (i2 = (u2 = F.SPLIT * t2._hi) - (i2 = u2 - t2._hi)) - (a3 = o2 * t2._hi) + e3 * (r2 = t2._hi - i2) + n2 * i2 + n2 * r2, s2 = (this._hi - a3 - u2 + this._lo - o2 * t2._lo) / t2._hi;
            return new F(u2 = o2 + s2, o2 - u2 + s2);
          }
          if ("number" == typeof arguments[0]) {
            var l2 = arguments[0];
            return v.isNaN(l2) ? F.createNaN() : F.copy(this).selfDivide(l2, 0);
          }
        }, F.prototype.ge = function(t2) {
          return (this._hi > t2._hi || this._hi === t2._hi) && this._lo >= t2._lo;
        }, F.prototype.pow = function(t2) {
          if (0 === t2)
            return F.valueOf(1);
          var e3 = new F(this), n2 = F.valueOf(1), i2 = Math.abs(t2);
          if (i2 > 1)
            for (; i2 > 0; )
              i2 % 2 == 1 && n2.selfMultiply(e3), (i2 /= 2) > 0 && (e3 = e3.sqr());
          else
            n2 = e3;
          return t2 < 0 ? n2.reciprocal() : n2;
        }, F.prototype.ceil = function() {
          if (this.isNaN())
            return F.NaN;
          var t2 = Math.ceil(this._hi), e3 = 0;
          return t2 === this._hi && (e3 = Math.ceil(this._lo)), new F(t2, e3);
        }, F.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._hi < e3._hi ? -1 : this._hi > e3._hi ? 1 : this._lo < e3._lo ? -1 : this._lo > e3._lo ? 1 : 0;
        }, F.prototype.rint = function() {
          if (this.isNaN())
            return this;
          return this.add(0.5).floor();
        }, F.prototype.setValue = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.init(t2), this;
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return this.init(e3), this;
          }
        }, F.prototype.max = function(t2) {
          return this.ge(t2) ? this : t2;
        }, F.prototype.sqrt = function() {
          if (this.isZero())
            return F.valueOf(0);
          if (this.isNegative())
            return F.NaN;
          var t2 = 1 / Math.sqrt(this._hi), e3 = this._hi * t2, n2 = F.valueOf(e3), i2 = this.subtract(n2.sqr())._hi * (0.5 * t2);
          return n2.add(i2);
        }, F.prototype.selfAdd = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfAdd(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0], n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a3 = null;
              return r2 = this._hi + e3, s2 = r2 - this._hi, o2 = r2 - s2, o2 = e3 - s2 + (this._hi - o2), a3 = o2 + this._lo, n2 = r2 + a3, i2 = a3 + (r2 - n2), this._hi = n2 + i2, this._lo = i2 + (n2 - this._hi), this;
            }
          } else if (2 === arguments.length) {
            var u2 = arguments[0], l2 = arguments[1], c2 = null, p2 = null, h2 = null, f2 = null, g2 = null, d2 = null, y4 = null;
            f2 = this._hi + u2, p2 = this._lo + l2, g2 = f2 - (d2 = f2 - this._hi), h2 = p2 - (y4 = p2 - this._lo);
            var _2 = (c2 = f2 + (d2 = (g2 = u2 - d2 + (this._hi - g2)) + p2)) + (d2 = (h2 = l2 - y4 + (this._lo - h2)) + (d2 + (f2 - c2))), m2 = d2 + (c2 - _2);
            return this._hi = _2, this._lo = m2, this;
          }
        }, F.prototype.selfMultiply = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfMultiply(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0];
              return this.selfMultiply(e3, 0);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = null, o2 = null, s2 = null, a3 = null, u2 = null, l2 = null;
            r2 = (u2 = F.SPLIT * this._hi) - this._hi, l2 = F.SPLIT * n2, r2 = u2 - r2, o2 = this._hi - r2, s2 = l2 - n2;
            var c2 = (u2 = this._hi * n2) + (l2 = r2 * (s2 = l2 - s2) - u2 + r2 * (a3 = n2 - s2) + o2 * s2 + o2 * a3 + (this._hi * i2 + this._lo * n2)), p2 = l2 + (r2 = u2 - c2);
            return this._hi = c2, this._lo = p2, this;
          }
        }, F.prototype.selfSqr = function() {
          return this.selfMultiply(this);
        }, F.prototype.floor = function() {
          if (this.isNaN())
            return F.NaN;
          var t2 = Math.floor(this._hi), e3 = 0;
          return t2 === this._hi && (e3 = Math.floor(this._lo)), new F(t2, e3);
        }, F.prototype.negate = function() {
          return this.isNaN() ? this : new F(-this._hi, -this._lo);
        }, F.prototype.clone = function() {
        }, F.prototype.multiply = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return t2.isNaN() ? F.createNaN() : F.copy(this).selfMultiply(t2);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return v.isNaN(e3) ? F.createNaN() : F.copy(this).selfMultiply(e3, 0);
          }
        }, F.prototype.isNaN = function() {
          return v.isNaN(this._hi);
        }, F.prototype.intValue = function() {
          return Math.trunc(this._hi);
        }, F.prototype.toString = function() {
          var t2 = F.magnitude(this._hi);
          return t2 >= -3 && t2 <= 20 ? this.toStandardNotation() : this.toSciNotation();
        }, F.prototype.toStandardNotation = function() {
          var t2 = this.getSpecialNumberString();
          if (null !== t2)
            return t2;
          var e3 = new Array(1).fill(null), n2 = this.extractSignificantDigits(true, e3), i2 = e3[0] + 1, r2 = n2;
          if ("." === n2.charAt(0))
            r2 = "0" + n2;
          else if (i2 < 0)
            r2 = "0." + F.stringOfChar("0", -i2) + n2;
          else if (-1 === n2.indexOf(".")) {
            var o2 = i2 - n2.length;
            r2 = n2 + F.stringOfChar("0", o2) + ".0";
          }
          return this.isNegative() ? "-" + r2 : r2;
        }, F.prototype.reciprocal = function() {
          var t2 = null, e3 = null, n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a3 = null;
          e3 = (r2 = 1 / this._hi) - (t2 = (o2 = F.SPLIT * r2) - (t2 = o2 - r2)), n2 = (a3 = F.SPLIT * this._hi) - this._hi;
          var u2 = r2 + (o2 = (1 - (s2 = r2 * this._hi) - (a3 = t2 * (n2 = a3 - n2) - s2 + t2 * (i2 = this._hi - n2) + e3 * n2 + e3 * i2) - r2 * this._lo) / this._hi);
          return new F(u2, r2 - u2 + o2);
        }, F.prototype.toSciNotation = function() {
          if (this.isZero())
            return F.SCI_NOT_ZERO;
          var t2 = this.getSpecialNumberString();
          if (null !== t2)
            return t2;
          var e3 = new Array(1).fill(null), n2 = this.extractSignificantDigits(false, e3), i2 = F.SCI_NOT_EXPONENT_CHAR + e3[0];
          if ("0" === n2.charAt(0))
            throw new Error("Found leading zero: " + n2);
          var r2 = "";
          n2.length > 1 && (r2 = n2.substring(1));
          var o2 = n2.charAt(0) + "." + r2;
          return this.isNegative() ? "-" + o2 + i2 : o2 + i2;
        }, F.prototype.abs = function() {
          return this.isNaN() ? F.NaN : this.isNegative() ? this.negate() : new F(this);
        }, F.prototype.isPositive = function() {
          return (this._hi > 0 || 0 === this._hi) && this._lo > 0;
        }, F.prototype.lt = function(t2) {
          return (this._hi < t2._hi || this._hi === t2._hi) && this._lo < t2._lo;
        }, F.prototype.add = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return F.copy(this).selfAdd(t2);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return F.copy(this).selfAdd(e3);
          }
        }, F.prototype.init = function() {
          if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
              var t2 = arguments[0];
              this._hi = t2, this._lo = 0;
            } else if (arguments[0] instanceof F) {
              var e3 = arguments[0];
              this._hi = e3._hi, this._lo = e3._lo;
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this._hi = n2, this._lo = i2;
          }
        }, F.prototype.gt = function(t2) {
          return (this._hi > t2._hi || this._hi === t2._hi) && this._lo > t2._lo;
        }, F.prototype.isNegative = function() {
          return (this._hi < 0 || 0 === this._hi) && this._lo < 0;
        }, F.prototype.trunc = function() {
          return this.isNaN() ? F.NaN : this.isPositive() ? this.floor() : this.ceil();
        }, F.prototype.signum = function() {
          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
        }, F.prototype.interfaces_ = function() {
          return [e, E, x3];
        }, F.prototype.getClass = function() {
          return F;
        }, F.sqr = function(t2) {
          return F.valueOf(t2).selfMultiply(t2);
        }, F.valueOf = function() {
          if ("string" == typeof arguments[0]) {
            var t2 = arguments[0];
            return F.parse(t2);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return new F(e3);
          }
        }, F.sqrt = function(t2) {
          return F.valueOf(t2).sqrt();
        }, F.parse = function(t2) {
          for (var e3 = 0, n2 = t2.length; A2.isWhitespace(t2.charAt(e3)); )
            e3++;
          var i2 = false;
          if (e3 < n2) {
            var r2 = t2.charAt(e3);
            "-" !== r2 && "+" !== r2 || (e3++, "-" === r2 && (i2 = true));
          }
          for (var o2 = new F(), s2 = 0, a3 = 0, u2 = 0; !(e3 >= n2); ) {
            var l2 = t2.charAt(e3);
            if (e3++, A2.isDigit(l2)) {
              var c2 = l2 - "0";
              o2.selfMultiply(F.TEN), o2.selfAdd(c2), s2++;
            } else {
              if ("." !== l2) {
                if ("e" === l2 || "E" === l2) {
                  var p2 = t2.substring(e3);
                  try {
                    u2 = M.parseInt(p2);
                  } catch (e4) {
                    throw e4 instanceof Error ? new Error("Invalid exponent " + p2 + " in string " + t2) : e4;
                  }
                  break;
                }
                throw new Error("Unexpected character '" + l2 + "' at position " + e3 + " in string " + t2);
              }
              a3 = s2;
            }
          }
          var h2 = o2, f2 = s2 - a3 - u2;
          if (0 === f2)
            h2 = o2;
          else if (f2 > 0) {
            var g2 = F.TEN.pow(f2);
            h2 = o2.divide(g2);
          } else if (f2 < 0) {
            var d2 = F.TEN.pow(-f2);
            h2 = o2.multiply(d2);
          }
          return i2 ? h2.negate() : h2;
        }, F.createNaN = function() {
          return new F(v.NaN, v.NaN);
        }, F.copy = function(t2) {
          return new F(t2);
        }, F.magnitude = function(t2) {
          var e3 = Math.abs(t2), n2 = Math.log(e3) / Math.log(10), i2 = Math.trunc(Math.floor(n2));
          return 10 * Math.pow(10, i2) <= e3 && (i2 += 1), i2;
        }, F.stringOfChar = function(t2, e3) {
          for (var n2 = new D(), i2 = 0; i2 < e3; i2++)
            n2.append(t2);
          return n2.toString();
        }, G.PI.get = function() {
          return new F(3.141592653589793, 12246467991473532e-32);
        }, G.TWO_PI.get = function() {
          return new F(6.283185307179586, 24492935982947064e-32);
        }, G.PI_2.get = function() {
          return new F(1.5707963267948966, 6123233995736766e-32);
        }, G.E.get = function() {
          return new F(2.718281828459045, 14456468917292502e-32);
        }, G.NaN.get = function() {
          return new F(v.NaN, v.NaN);
        }, G.EPS.get = function() {
          return 123259516440783e-46;
        }, G.SPLIT.get = function() {
          return 134217729;
        }, G.MAX_PRINT_DIGITS.get = function() {
          return 32;
        }, G.TEN.get = function() {
          return F.valueOf(10);
        }, G.ONE.get = function() {
          return F.valueOf(1);
        }, G.SCI_NOT_EXPONENT_CHAR.get = function() {
          return "E";
        }, G.SCI_NOT_ZERO.get = function() {
          return "0.0E0";
        }, Object.defineProperties(F, G);
        var q = function() {
        }, B2 = { DP_SAFE_EPSILON: { configurable: true } };
        q.prototype.interfaces_ = function() {
          return [];
        }, q.prototype.getClass = function() {
          return q;
        }, q.orientationIndex = function(t2, e3, n2) {
          var i2 = q.orientationIndexFilter(t2, e3, n2);
          if (i2 <= 1)
            return i2;
          var r2 = F.valueOf(e3.x).selfAdd(-t2.x), o2 = F.valueOf(e3.y).selfAdd(-t2.y), s2 = F.valueOf(n2.x).selfAdd(-e3.x), a3 = F.valueOf(n2.y).selfAdd(-e3.y);
          return r2.selfMultiply(a3).selfSubtract(o2.selfMultiply(s2)).signum();
        }, q.signOfDet2x2 = function(t2, e3, n2, i2) {
          return t2.multiply(i2).selfSubtract(e3.multiply(n2)).signum();
        }, q.intersection = function(t2, e3, n2, i2) {
          var r2 = F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(F.valueOf(e3.x).selfSubtract(t2.x)), o2 = F.valueOf(i2.x).selfSubtract(n2.x).selfMultiply(F.valueOf(e3.y).selfSubtract(t2.y)), s2 = r2.subtract(o2), a3 = F.valueOf(i2.x).selfSubtract(n2.x).selfMultiply(F.valueOf(t2.y).selfSubtract(n2.y)), u2 = F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(F.valueOf(t2.x).selfSubtract(n2.x)), l2 = a3.subtract(u2).selfDivide(s2).doubleValue(), c2 = F.valueOf(t2.x).selfAdd(F.valueOf(e3.x).selfSubtract(t2.x).selfMultiply(l2)).doubleValue(), p2 = F.valueOf(e3.x).selfSubtract(t2.x).selfMultiply(F.valueOf(t2.y).selfSubtract(n2.y)), h2 = F.valueOf(e3.y).selfSubtract(t2.y).selfMultiply(F.valueOf(t2.x).selfSubtract(n2.x)), f2 = p2.subtract(h2).selfDivide(s2).doubleValue(), g2 = F.valueOf(n2.y).selfAdd(F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(f2)).doubleValue();
          return new C(c2, g2);
        }, q.orientationIndexFilter = function(t2, e3, n2) {
          var i2 = null, r2 = (t2.x - n2.x) * (e3.y - n2.y), o2 = (t2.y - n2.y) * (e3.x - n2.x), s2 = r2 - o2;
          if (r2 > 0) {
            if (o2 <= 0)
              return q.signum(s2);
            i2 = r2 + o2;
          } else {
            if (!(r2 < 0))
              return q.signum(s2);
            if (o2 >= 0)
              return q.signum(s2);
            i2 = -r2 - o2;
          }
          var a3 = q.DP_SAFE_EPSILON * i2;
          return s2 >= a3 || -s2 >= a3 ? q.signum(s2) : 2;
        }, q.signum = function(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }, B2.DP_SAFE_EPSILON.get = function() {
          return 1e-15;
        }, Object.defineProperties(q, B2);
        var V2 = function() {
        }, U = { X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true }, M: { configurable: true } };
        U.X.get = function() {
          return 0;
        }, U.Y.get = function() {
          return 1;
        }, U.Z.get = function() {
          return 2;
        }, U.M.get = function() {
          return 3;
        }, V2.prototype.setOrdinate = function(t2, e3, n2) {
        }, V2.prototype.size = function() {
        }, V2.prototype.getOrdinate = function(t2, e3) {
        }, V2.prototype.getCoordinate = function() {
        }, V2.prototype.getCoordinateCopy = function(t2) {
        }, V2.prototype.getDimension = function() {
        }, V2.prototype.getX = function(t2) {
        }, V2.prototype.clone = function() {
        }, V2.prototype.expandEnvelope = function(t2) {
        }, V2.prototype.copy = function() {
        }, V2.prototype.getY = function(t2) {
        }, V2.prototype.toCoordinateArray = function() {
        }, V2.prototype.interfaces_ = function() {
          return [x3];
        }, V2.prototype.getClass = function() {
          return V2;
        }, Object.defineProperties(V2, U);
        var z2 = function() {
        }, X = function(t2) {
          function e3() {
            t2.call(this, "Projective point not representable on the Cartesian plane.");
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(z2), Y = function() {
        };
        Y.arraycopy = function(t2, e3, n2, i2, r2) {
          for (var o2 = 0, s2 = e3; s2 < e3 + r2; s2++)
            n2[i2 + o2] = t2[s2], o2++;
        }, Y.getProperty = function(t2) {
          return { "line.separator": "\n" }[t2];
        };
        var k = function t2() {
          if (this.x = null, this.y = null, this.w = null, 0 === arguments.length)
            this.x = 0, this.y = 0, this.w = 1;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.x = e3.x, this.y = e3.y, this.w = 1;
          } else if (2 === arguments.length) {
            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
              var n2 = arguments[0], i2 = arguments[1];
              this.x = n2, this.y = i2, this.w = 1;
            } else if (arguments[0] instanceof t2 && arguments[1] instanceof t2) {
              var r2 = arguments[0], o2 = arguments[1];
              this.x = r2.y * o2.w - o2.y * r2.w, this.y = o2.x * r2.w - r2.x * o2.w, this.w = r2.x * o2.y - o2.x * r2.y;
            } else if (arguments[0] instanceof C && arguments[1] instanceof C) {
              var s2 = arguments[0], a3 = arguments[1];
              this.x = s2.y - a3.y, this.y = a3.x - s2.x, this.w = s2.x * a3.y - a3.x * s2.y;
            }
          } else if (3 === arguments.length) {
            var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2];
            this.x = u2, this.y = l2, this.w = c2;
          } else if (4 === arguments.length) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2], g2 = arguments[3], d2 = p2.y - h2.y, y4 = h2.x - p2.x, _2 = p2.x * h2.y - h2.x * p2.y, m2 = f2.y - g2.y, v2 = g2.x - f2.x, I3 = f2.x * g2.y - g2.x * f2.y;
            this.x = y4 * I3 - v2 * _2, this.y = m2 * _2 - d2 * I3, this.w = d2 * v2 - m2 * y4;
          }
        };
        k.prototype.getY = function() {
          var t2 = this.y / this.w;
          if (v.isNaN(t2) || v.isInfinite(t2))
            throw new X();
          return t2;
        }, k.prototype.getX = function() {
          var t2 = this.x / this.w;
          if (v.isNaN(t2) || v.isInfinite(t2))
            throw new X();
          return t2;
        }, k.prototype.getCoordinate = function() {
          var t2 = new C();
          return t2.x = this.getX(), t2.y = this.getY(), t2;
        }, k.prototype.interfaces_ = function() {
          return [];
        }, k.prototype.getClass = function() {
          return k;
        }, k.intersection = function(t2, e3, n2, i2) {
          var r2 = t2.y - e3.y, o2 = e3.x - t2.x, s2 = t2.x * e3.y - e3.x * t2.y, a3 = n2.y - i2.y, u2 = i2.x - n2.x, l2 = n2.x * i2.y - i2.x * n2.y, c2 = r2 * u2 - a3 * o2, p2 = (o2 * l2 - u2 * s2) / c2, h2 = (a3 * s2 - r2 * l2) / c2;
          if (v.isNaN(p2) || v.isInfinite(p2) || v.isNaN(h2) || v.isInfinite(h2))
            throw new X();
          return new C(p2, h2);
        };
        var j = function t2() {
          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length)
            this.init();
          else if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              this.init(e3.x, e3.x, e3.y, e3.y);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.init(n2);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.init(i2.x, r2.x, i2.y, r2.y);
          } else if (4 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a3 = arguments[2], u2 = arguments[3];
            this.init(o2, s2, a3, u2);
          }
        }, H = { serialVersionUID: { configurable: true } };
        j.prototype.getArea = function() {
          return this.getWidth() * this.getHeight();
        }, j.prototype.equals = function(t2) {
          if (!(t2 instanceof j))
            return false;
          var e3 = t2;
          return this.isNull() ? e3.isNull() : this._maxx === e3.getMaxX() && this._maxy === e3.getMaxY() && this._minx === e3.getMinX() && this._miny === e3.getMinY();
        }, j.prototype.intersection = function(t2) {
          if (this.isNull() || t2.isNull() || !this.intersects(t2))
            return new j();
          var e3 = this._minx > t2._minx ? this._minx : t2._minx, n2 = this._miny > t2._miny ? this._miny : t2._miny, i2 = this._maxx < t2._maxx ? this._maxx : t2._maxx, r2 = this._maxy < t2._maxy ? this._maxy : t2._maxy;
          return new j(e3, i2, n2, r2);
        }, j.prototype.isNull = function() {
          return this._maxx < this._minx;
        }, j.prototype.getMaxX = function() {
          return this._maxx;
        }, j.prototype.covers = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              return this.covers(t2.x, t2.y);
            }
            if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              return !this.isNull() && !e3.isNull() && (e3.getMinX() >= this._minx && e3.getMaxX() <= this._maxx && e3.getMinY() >= this._miny && e3.getMaxY() <= this._maxy);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return !this.isNull() && (n2 >= this._minx && n2 <= this._maxx && i2 >= this._miny && i2 <= this._maxy);
          }
        }, j.prototype.intersects = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof j) {
              var t2 = arguments[0];
              return !this.isNull() && !t2.isNull() && !(t2._minx > this._maxx || t2._maxx < this._minx || t2._miny > this._maxy || t2._maxy < this._miny);
            }
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              return this.intersects(e3.x, e3.y);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return !this.isNull() && !(n2 > this._maxx || n2 < this._minx || i2 > this._maxy || i2 < this._miny);
          }
        }, j.prototype.getMinY = function() {
          return this._miny;
        }, j.prototype.getMinX = function() {
          return this._minx;
        }, j.prototype.expandToInclude = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              this.expandToInclude(t2.x, t2.y);
            } else if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              if (e3.isNull())
                return null;
              this.isNull() ? (this._minx = e3.getMinX(), this._maxx = e3.getMaxX(), this._miny = e3.getMinY(), this._maxy = e3.getMaxY()) : (e3._minx < this._minx && (this._minx = e3._minx), e3._maxx > this._maxx && (this._maxx = e3._maxx), e3._miny < this._miny && (this._miny = e3._miny), e3._maxy > this._maxy && (this._maxy = e3._maxy));
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.isNull() ? (this._minx = n2, this._maxx = n2, this._miny = i2, this._maxy = i2) : (n2 < this._minx && (this._minx = n2), n2 > this._maxx && (this._maxx = n2), i2 < this._miny && (this._miny = i2), i2 > this._maxy && (this._maxy = i2));
          }
        }, j.prototype.minExtent = function() {
          if (this.isNull())
            return 0;
          var t2 = this.getWidth(), e3 = this.getHeight();
          return t2 < e3 ? t2 : e3;
        }, j.prototype.getWidth = function() {
          return this.isNull() ? 0 : this._maxx - this._minx;
        }, j.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.isNull() ? e3.isNull() ? 0 : -1 : e3.isNull() ? 1 : this._minx < e3._minx ? -1 : this._minx > e3._minx ? 1 : this._miny < e3._miny ? -1 : this._miny > e3._miny ? 1 : this._maxx < e3._maxx ? -1 : this._maxx > e3._maxx ? 1 : this._maxy < e3._maxy ? -1 : this._maxy > e3._maxy ? 1 : 0;
        }, j.prototype.translate = function(t2, e3) {
          if (this.isNull())
            return null;
          this.init(this.getMinX() + t2, this.getMaxX() + t2, this.getMinY() + e3, this.getMaxY() + e3);
        }, j.prototype.toString = function() {
          return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
        }, j.prototype.setToNull = function() {
          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
        }, j.prototype.getHeight = function() {
          return this.isNull() ? 0 : this._maxy - this._miny;
        }, j.prototype.maxExtent = function() {
          if (this.isNull())
            return 0;
          var t2 = this.getWidth(), e3 = this.getHeight();
          return t2 > e3 ? t2 : e3;
        }, j.prototype.expandBy = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.expandBy(t2, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this.isNull())
              return null;
            this._minx -= e3, this._maxx += e3, this._miny -= n2, this._maxy += n2, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
          }
        }, j.prototype.contains = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof j) {
              var t2 = arguments[0];
              return this.covers(t2);
            }
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              return this.covers(e3);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return this.covers(n2, i2);
          }
        }, j.prototype.centre = function() {
          return this.isNull() ? null : new C((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
        }, j.prototype.init = function() {
          if (0 === arguments.length)
            this.setToNull();
          else if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              this.init(t2.x, t2.x, t2.y, t2.y);
            } else if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              this._minx = e3._minx, this._maxx = e3._maxx, this._miny = e3._miny, this._maxy = e3._maxy;
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.init(n2.x, i2.x, n2.y, i2.y);
          } else if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a3 = arguments[3];
            r2 < o2 ? (this._minx = r2, this._maxx = o2) : (this._minx = o2, this._maxx = r2), s2 < a3 ? (this._miny = s2, this._maxy = a3) : (this._miny = a3, this._maxy = s2);
          }
        }, j.prototype.getMaxY = function() {
          return this._maxy;
        }, j.prototype.distance = function(t2) {
          if (this.intersects(t2))
            return 0;
          var e3 = 0;
          this._maxx < t2._minx ? e3 = t2._minx - this._maxx : this._minx > t2._maxx && (e3 = this._minx - t2._maxx);
          var n2 = 0;
          return this._maxy < t2._miny ? n2 = t2._miny - this._maxy : this._miny > t2._maxy && (n2 = this._miny - t2._maxy), 0 === e3 ? n2 : 0 === n2 ? e3 : Math.sqrt(e3 * e3 + n2 * n2);
        }, j.prototype.hashCode = function() {
          var t2 = 17;
          return t2 = 37 * t2 + C.hashCode(this._minx), t2 = 37 * t2 + C.hashCode(this._maxx), t2 = 37 * t2 + C.hashCode(this._miny), t2 = 37 * t2 + C.hashCode(this._maxy);
        }, j.prototype.interfaces_ = function() {
          return [E, e];
        }, j.prototype.getClass = function() {
          return j;
        }, j.intersects = function() {
          if (3 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
            return n2.x >= (t2.x < e3.x ? t2.x : e3.x) && n2.x <= (t2.x > e3.x ? t2.x : e3.x) && n2.y >= (t2.y < e3.y ? t2.y : e3.y) && n2.y <= (t2.y > e3.y ? t2.y : e3.y);
          }
          if (4 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = arguments[3], a3 = Math.min(o2.x, s2.x), u2 = Math.max(o2.x, s2.x), l2 = Math.min(i2.x, r2.x), c2 = Math.max(i2.x, r2.x);
            return !(l2 > u2) && (!(c2 < a3) && (a3 = Math.min(o2.y, s2.y), u2 = Math.max(o2.y, s2.y), l2 = Math.min(i2.y, r2.y), c2 = Math.max(i2.y, r2.y), !(l2 > u2) && !(c2 < a3)));
          }
        }, H.serialVersionUID.get = function() {
          return 5873921885273102e3;
        }, Object.defineProperties(j, H);
        var W = { typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/, emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/, spaces: /\s+/, parenComma: /\)\s*,\s*\(/, doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, trimParens: /^\s*\(?(.*?)\)?\s*$/ }, K = function(t2) {
          this.geometryFactory = t2 || new _e();
        };
        K.prototype.read = function(t2) {
          var e3, n2, i2;
          t2 = t2.replace(/[\n\r]/g, " ");
          var r2 = W.typeStr.exec(t2);
          if (-1 !== t2.search("EMPTY") && ((r2 = W.emptyTypeStr.exec(t2))[2] = void 0), r2 && (n2 = r2[1].toLowerCase(), i2 = r2[2], Q[n2] && (e3 = Q[n2].apply(this, [i2]))), void 0 === e3)
            throw new Error("Could not parse WKT " + t2);
          return e3;
        }, K.prototype.write = function(t2) {
          return this.extractGeometry(t2);
        }, K.prototype.extractGeometry = function(t2) {
          var e3 = t2.getGeometryType().toLowerCase();
          if (!J[e3])
            return null;
          var n2 = e3.toUpperCase();
          return t2.isEmpty() ? n2 + " EMPTY" : n2 + "(" + J[e3].apply(this, [t2]) + ")";
        };
        var J = { coordinate: function(t2) {
          return t2.x + " " + t2.y;
        }, point: function(t2) {
          return J.coordinate.call(this, t2._coordinates._coordinates[0]);
        }, multipoint: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.point.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, linestring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._points._coordinates.length; n2 < i2; ++n2)
            e3.push(J.coordinate.apply(this, [t2._points._coordinates[n2]]));
          return e3.join(",");
        }, linearring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._points._coordinates.length; n2 < i2; ++n2)
            e3.push(J.coordinate.apply(this, [t2._points._coordinates[n2]]));
          return e3.join(",");
        }, multilinestring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.linestring.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, polygon: function(t2) {
          var e3 = [];
          e3.push("(" + J.linestring.apply(this, [t2._shell]) + ")");
          for (var n2 = 0, i2 = t2._holes.length; n2 < i2; ++n2)
            e3.push("(" + J.linestring.apply(this, [t2._holes[n2]]) + ")");
          return e3.join(",");
        }, multipolygon: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.polygon.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, geometrycollection: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push(this.extractGeometry(t2._geometries[n2]));
          return e3.join(",");
        } }, Q = { point: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createPoint();
          var e3 = t2.trim().split(W.spaces);
          return this.geometryFactory.createPoint(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
        }, multipoint: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createMultiPoint();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.point.apply(this, [e3]));
          return this.geometryFactory.createMultiPoint(i2);
        }, linestring: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createLineString();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].trim().split(W.spaces), i2.push(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
          return this.geometryFactory.createLineString(i2);
        }, linearring: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createLinearRing();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].trim().split(W.spaces), i2.push(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
          return this.geometryFactory.createLinearRing(i2);
        }, multilinestring: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createMultiLineString();
          for (var e3, n2 = t2.trim().split(W.parenComma), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.linestring.apply(this, [e3]));
          return this.geometryFactory.createMultiLineString(i2);
        }, polygon: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createPolygon();
          for (var e3, n2, i2, r2, o2 = t2.trim().split(W.parenComma), s2 = [], a3 = 0, u2 = o2.length; a3 < u2; ++a3)
            e3 = o2[a3].replace(W.trimParens, "$1"), n2 = Q.linestring.apply(this, [e3]), i2 = this.geometryFactory.createLinearRing(n2._points), 0 === a3 ? r2 = i2 : s2.push(i2);
          return this.geometryFactory.createPolygon(r2, s2);
        }, multipolygon: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createMultiPolygon();
          for (var e3, n2 = t2.trim().split(W.doubleParenComma), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.polygon.apply(this, [e3]));
          return this.geometryFactory.createMultiPolygon(i2);
        }, geometrycollection: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createGeometryCollection();
          for (var e3 = (t2 = t2.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"), n2 = [], i2 = 0, r2 = e3.length; i2 < r2; ++i2)
            n2.push(this.read(e3[i2]));
          return this.geometryFactory.createGeometryCollection(n2);
        } }, Z2 = function(t2) {
          this.parser = new K(t2);
        };
        Z2.prototype.write = function(t2) {
          return this.parser.write(t2);
        }, Z2.toLineString = function(t2, e3) {
          if (2 !== arguments.length)
            throw new Error("Not implemented");
          return "LINESTRING ( " + t2.x + " " + t2.y + ", " + e3.x + " " + e3.y + " )";
        };
        var $ = function(t2) {
          function e3(e4) {
            t2.call(this, e4), this.name = "RuntimeException", this.message = e4, this.stack = new t2().stack;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Error), tt = function(t2) {
          function e3() {
            if (t2.call(this), 0 === arguments.length)
              t2.call(this);
            else if (1 === arguments.length) {
              var e4 = arguments[0];
              t2.call(this, e4);
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }($), et = function() {
        };
        et.prototype.interfaces_ = function() {
          return [];
        }, et.prototype.getClass = function() {
          return et;
        }, et.shouldNeverReachHere = function() {
          if (0 === arguments.length)
            et.shouldNeverReachHere(null);
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            throw new tt("Should never reach here" + (null !== t2 ? ": " + t2 : ""));
          }
        }, et.isTrue = function() {
          var t2, e3;
          if (1 === arguments.length)
            t2 = arguments[0], et.isTrue(t2, null);
          else if (2 === arguments.length && (t2 = arguments[0], e3 = arguments[1], !t2))
            throw null === e3 ? new tt() : new tt(e3);
        }, et.equals = function() {
          var t2, e3, n2;
          if (2 === arguments.length)
            t2 = arguments[0], e3 = arguments[1], et.equals(t2, e3, null);
          else if (3 === arguments.length && (t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], !e3.equals(t2)))
            throw new tt("Expected " + t2 + " but encountered " + e3 + (null !== n2 ? ": " + n2 : ""));
        };
        var nt = function() {
          this._result = null, this._inputLines = Array(2).fill().map(function() {
            return Array(2);
          }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new C(), this._intPt[1] = new C(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
        }, it = { DONT_INTERSECT: { configurable: true }, DO_INTERSECT: { configurable: true }, COLLINEAR: { configurable: true }, NO_INTERSECTION: { configurable: true }, POINT_INTERSECTION: { configurable: true }, COLLINEAR_INTERSECTION: { configurable: true } };
        nt.prototype.getIndexAlongSegment = function(t2, e3) {
          return this.computeIntLineIndex(), this._intLineIndex[t2][e3];
        }, nt.prototype.getTopologySummary = function() {
          var t2 = new D();
          return this.isEndPoint() && t2.append(" endpoint"), this._isProper && t2.append(" proper"), this.isCollinear() && t2.append(" collinear"), t2.toString();
        }, nt.prototype.computeIntersection = function(t2, e3, n2, i2) {
          this._inputLines[0][0] = t2, this._inputLines[0][1] = e3, this._inputLines[1][0] = n2, this._inputLines[1][1] = i2, this._result = this.computeIntersect(t2, e3, n2, i2);
        }, nt.prototype.getIntersectionNum = function() {
          return this._result;
        }, nt.prototype.computeIntLineIndex = function() {
          if (0 === arguments.length)
            null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function() {
              return Array(2);
            }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.getEdgeDistance(t2, 0) > this.getEdgeDistance(t2, 1) ? (this._intLineIndex[t2][0] = 0, this._intLineIndex[t2][1] = 1) : (this._intLineIndex[t2][0] = 1, this._intLineIndex[t2][1] = 0);
          }
        }, nt.prototype.isProper = function() {
          return this.hasIntersection() && this._isProper;
        }, nt.prototype.setPrecisionModel = function(t2) {
          this._precisionModel = t2;
        }, nt.prototype.isInteriorIntersection = function() {
          if (0 === arguments.length)
            return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = 0; e3 < this._result; e3++)
              if (!this._intPt[e3].equals2D(this._inputLines[t2][0]) && !this._intPt[e3].equals2D(this._inputLines[t2][1]))
                return true;
            return false;
          }
        }, nt.prototype.getIntersection = function(t2) {
          return this._intPt[t2];
        }, nt.prototype.isEndPoint = function() {
          return this.hasIntersection() && !this._isProper;
        }, nt.prototype.hasIntersection = function() {
          return this._result !== nt.NO_INTERSECTION;
        }, nt.prototype.getEdgeDistance = function(t2, e3) {
          return nt.computeEdgeDistance(this._intPt[e3], this._inputLines[t2][0], this._inputLines[t2][1]);
        }, nt.prototype.isCollinear = function() {
          return this._result === nt.COLLINEAR_INTERSECTION;
        }, nt.prototype.toString = function() {
          return Z2.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Z2.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
        }, nt.prototype.getEndpoint = function(t2, e3) {
          return this._inputLines[t2][e3];
        }, nt.prototype.isIntersection = function(t2) {
          for (var e3 = 0; e3 < this._result; e3++)
            if (this._intPt[e3].equals2D(t2))
              return true;
          return false;
        }, nt.prototype.getIntersectionAlongSegment = function(t2, e3) {
          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t2][e3]];
        }, nt.prototype.interfaces_ = function() {
          return [];
        }, nt.prototype.getClass = function() {
          return nt;
        }, nt.computeEdgeDistance = function(t2, e3, n2) {
          var i2 = Math.abs(n2.x - e3.x), r2 = Math.abs(n2.y - e3.y), o2 = -1;
          if (t2.equals(e3))
            o2 = 0;
          else if (t2.equals(n2))
            o2 = i2 > r2 ? i2 : r2;
          else {
            var s2 = Math.abs(t2.x - e3.x), a3 = Math.abs(t2.y - e3.y);
            0 !== (o2 = i2 > r2 ? s2 : a3) || t2.equals(e3) || (o2 = Math.max(s2, a3));
          }
          return et.isTrue(!(0 === o2 && !t2.equals(e3)), "Bad distance calculation"), o2;
        }, nt.nonRobustComputeEdgeDistance = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y, o2 = Math.sqrt(i2 * i2 + r2 * r2);
          return et.isTrue(!(0 === o2 && !t2.equals(e3)), "Invalid distance calculation"), o2;
        }, it.DONT_INTERSECT.get = function() {
          return 0;
        }, it.DO_INTERSECT.get = function() {
          return 1;
        }, it.COLLINEAR.get = function() {
          return 2;
        }, it.NO_INTERSECTION.get = function() {
          return 0;
        }, it.POINT_INTERSECTION.get = function() {
          return 1;
        }, it.COLLINEAR_INTERSECTION.get = function() {
          return 2;
        }, Object.defineProperties(nt, it);
        var rt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isInSegmentEnvelopes = function(t3) {
            var e4 = new j(this._inputLines[0][0], this._inputLines[0][1]), n2 = new j(this._inputLines[1][0], this._inputLines[1][1]);
            return e4.contains(t3) && n2.contains(t3);
          }, e3.prototype.computeIntersection = function() {
            if (3 !== arguments.length)
              return t2.prototype.computeIntersection.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            if (this._isProper = false, j.intersects(n2, i2, e4) && 0 === at.orientationIndex(n2, i2, e4) && 0 === at.orientationIndex(i2, n2, e4))
              return this._isProper = true, (e4.equals(n2) || e4.equals(i2)) && (this._isProper = false), this._result = t2.POINT_INTERSECTION, null;
            this._result = t2.NO_INTERSECTION;
          }, e3.prototype.normalizeToMinimum = function(t3, e4, n2, i2, r2) {
            r2.x = this.smallestInAbsValue(t3.x, e4.x, n2.x, i2.x), r2.y = this.smallestInAbsValue(t3.y, e4.y, n2.y, i2.y), t3.x -= r2.x, t3.y -= r2.y, e4.x -= r2.x, e4.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i2.x -= r2.x, i2.y -= r2.y;
          }, e3.prototype.safeHCoordinateIntersection = function(t3, n2, i2, r2) {
            var o2 = null;
            try {
              o2 = k.intersection(t3, n2, i2, r2);
            } catch (s2) {
              if (!(s2 instanceof X))
                throw s2;
              o2 = e3.nearestEndpoint(t3, n2, i2, r2);
            }
            return o2;
          }, e3.prototype.intersection = function(t3, n2, i2, r2) {
            var o2 = this.intersectionWithNormalization(t3, n2, i2, r2);
            return this.isInSegmentEnvelopes(o2) || (o2 = new C(e3.nearestEndpoint(t3, n2, i2, r2))), null !== this._precisionModel && this._precisionModel.makePrecise(o2), o2;
          }, e3.prototype.smallestInAbsValue = function(t3, e4, n2, i2) {
            var r2 = t3, o2 = Math.abs(r2);
            return Math.abs(e4) < o2 && (r2 = e4, o2 = Math.abs(e4)), Math.abs(n2) < o2 && (r2 = n2, o2 = Math.abs(n2)), Math.abs(i2) < o2 && (r2 = i2), r2;
          }, e3.prototype.checkDD = function(t3, e4, n2, i2, r2) {
            var o2 = q.intersection(t3, e4, n2, i2), s2 = this.isInSegmentEnvelopes(o2);
            Y.out.println("DD in env = " + s2 + "  --------------------- " + o2), r2.distance(o2) > 1e-4 && Y.out.println("Distance = " + r2.distance(o2));
          }, e3.prototype.intersectionWithNormalization = function(t3, e4, n2, i2) {
            var r2 = new C(t3), o2 = new C(e4), s2 = new C(n2), a3 = new C(i2), u2 = new C();
            this.normalizeToEnvCentre(r2, o2, s2, a3, u2);
            var l2 = this.safeHCoordinateIntersection(r2, o2, s2, a3);
            return l2.x += u2.x, l2.y += u2.y, l2;
          }, e3.prototype.computeCollinearIntersection = function(e4, n2, i2, r2) {
            var o2 = j.intersects(e4, n2, i2), s2 = j.intersects(e4, n2, r2), a3 = j.intersects(i2, r2, e4), u2 = j.intersects(i2, r2, n2);
            return o2 && s2 ? (this._intPt[0] = i2, this._intPt[1] = r2, t2.COLLINEAR_INTERSECTION) : a3 && u2 ? (this._intPt[0] = e4, this._intPt[1] = n2, t2.COLLINEAR_INTERSECTION) : o2 && a3 ? (this._intPt[0] = i2, this._intPt[1] = e4, !i2.equals(e4) || s2 || u2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : o2 && u2 ? (this._intPt[0] = i2, this._intPt[1] = n2, !i2.equals(n2) || s2 || a3 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : s2 && a3 ? (this._intPt[0] = r2, this._intPt[1] = e4, !r2.equals(e4) || o2 || u2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : s2 && u2 ? (this._intPt[0] = r2, this._intPt[1] = n2, !r2.equals(n2) || o2 || a3 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : t2.NO_INTERSECTION;
          }, e3.prototype.normalizeToEnvCentre = function(t3, e4, n2, i2, r2) {
            var o2 = t3.x < e4.x ? t3.x : e4.x, s2 = t3.y < e4.y ? t3.y : e4.y, a3 = t3.x > e4.x ? t3.x : e4.x, u2 = t3.y > e4.y ? t3.y : e4.y, l2 = n2.x < i2.x ? n2.x : i2.x, c2 = n2.y < i2.y ? n2.y : i2.y, p2 = n2.x > i2.x ? n2.x : i2.x, h2 = n2.y > i2.y ? n2.y : i2.y, f2 = ((o2 > l2 ? o2 : l2) + (a3 < p2 ? a3 : p2)) / 2, g2 = ((s2 > c2 ? s2 : c2) + (u2 < h2 ? u2 : h2)) / 2;
            r2.x = f2, r2.y = g2, t3.x -= r2.x, t3.y -= r2.y, e4.x -= r2.x, e4.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i2.x -= r2.x, i2.y -= r2.y;
          }, e3.prototype.computeIntersect = function(e4, n2, i2, r2) {
            if (this._isProper = false, !j.intersects(e4, n2, i2, r2))
              return t2.NO_INTERSECTION;
            var o2 = at.orientationIndex(e4, n2, i2), s2 = at.orientationIndex(e4, n2, r2);
            if (o2 > 0 && s2 > 0 || o2 < 0 && s2 < 0)
              return t2.NO_INTERSECTION;
            var a3 = at.orientationIndex(i2, r2, e4), u2 = at.orientationIndex(i2, r2, n2);
            if (a3 > 0 && u2 > 0 || a3 < 0 && u2 < 0)
              return t2.NO_INTERSECTION;
            return 0 === o2 && 0 === s2 && 0 === a3 && 0 === u2 ? this.computeCollinearIntersection(e4, n2, i2, r2) : (0 === o2 || 0 === s2 || 0 === a3 || 0 === u2 ? (this._isProper = false, e4.equals2D(i2) || e4.equals2D(r2) ? this._intPt[0] = e4 : n2.equals2D(i2) || n2.equals2D(r2) ? this._intPt[0] = n2 : 0 === o2 ? this._intPt[0] = new C(i2) : 0 === s2 ? this._intPt[0] = new C(r2) : 0 === a3 ? this._intPt[0] = new C(e4) : 0 === u2 && (this._intPt[0] = new C(n2))) : (this._isProper = true, this._intPt[0] = this.intersection(e4, n2, i2, r2)), t2.POINT_INTERSECTION);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.nearestEndpoint = function(t3, e4, n2, i2) {
            var r2 = t3, o2 = at.distancePointLine(t3, n2, i2), s2 = at.distancePointLine(e4, n2, i2);
            return s2 < o2 && (o2 = s2, r2 = e4), (s2 = at.distancePointLine(n2, t3, e4)) < o2 && (o2 = s2, r2 = n2), (s2 = at.distancePointLine(i2, t3, e4)) < o2 && (o2 = s2, r2 = i2), r2;
          }, e3;
        }(nt), ot = function() {
        };
        ot.prototype.interfaces_ = function() {
          return [];
        }, ot.prototype.getClass = function() {
          return ot;
        }, ot.orientationIndex = function(t2, e3, n2) {
          var i2 = e3.x - t2.x, r2 = e3.y - t2.y, o2 = n2.x - e3.x, s2 = n2.y - e3.y;
          return ot.signOfDet2x2(i2, r2, o2, s2);
        }, ot.signOfDet2x2 = function(t2, e3, n2, i2) {
          var r2 = null, o2 = null, s2 = null;
          if (r2 = 1, 0 === t2 || 0 === i2)
            return 0 === e3 || 0 === n2 ? 0 : e3 > 0 ? n2 > 0 ? -r2 : r2 : n2 > 0 ? r2 : -r2;
          if (0 === e3 || 0 === n2)
            return i2 > 0 ? t2 > 0 ? r2 : -r2 : t2 > 0 ? -r2 : r2;
          if (e3 > 0 ? i2 > 0 ? e3 <= i2 || (r2 = -r2, o2 = t2, t2 = n2, n2 = o2, o2 = e3, e3 = i2, i2 = o2) : e3 <= -i2 ? (r2 = -r2, n2 = -n2, i2 = -i2) : (o2 = t2, t2 = -n2, n2 = o2, o2 = e3, e3 = -i2, i2 = o2) : i2 > 0 ? -e3 <= i2 ? (r2 = -r2, t2 = -t2, e3 = -e3) : (o2 = -t2, t2 = n2, n2 = o2, o2 = -e3, e3 = i2, i2 = o2) : e3 >= i2 ? (t2 = -t2, e3 = -e3, n2 = -n2, i2 = -i2) : (r2 = -r2, o2 = -t2, t2 = -n2, n2 = o2, o2 = -e3, e3 = -i2, i2 = o2), t2 > 0) {
            if (!(n2 > 0))
              return r2;
            if (!(t2 <= n2))
              return r2;
          } else {
            if (n2 > 0)
              return -r2;
            if (!(t2 >= n2))
              return -r2;
            r2 = -r2, t2 = -t2, n2 = -n2;
          }
          for (; ; ) {
            if (s2 = Math.floor(n2 / t2), n2 -= s2 * t2, (i2 -= s2 * e3) < 0)
              return -r2;
            if (i2 > e3)
              return r2;
            if (t2 > n2 + n2) {
              if (e3 < i2 + i2)
                return r2;
            } else {
              if (e3 > i2 + i2)
                return -r2;
              n2 = t2 - n2, i2 = e3 - i2, r2 = -r2;
            }
            if (0 === i2)
              return 0 === n2 ? 0 : -r2;
            if (0 === n2)
              return r2;
            if (s2 = Math.floor(t2 / n2), t2 -= s2 * n2, (e3 -= s2 * i2) < 0)
              return r2;
            if (e3 > i2)
              return -r2;
            if (n2 > t2 + t2) {
              if (i2 < e3 + e3)
                return -r2;
            } else {
              if (i2 > e3 + e3)
                return r2;
              t2 = n2 - t2, e3 = i2 - e3, r2 = -r2;
            }
            if (0 === e3)
              return 0 === t2 ? 0 : r2;
            if (0 === t2)
              return -r2;
          }
        };
        var st = function() {
          this._p = null, this._crossingCount = 0, this._isPointOnSegment = false;
          var t2 = arguments[0];
          this._p = t2;
        };
        st.prototype.countSegment = function(t2, e3) {
          if (t2.x < this._p.x && e3.x < this._p.x)
            return null;
          if (this._p.x === e3.x && this._p.y === e3.y)
            return this._isPointOnSegment = true, null;
          if (t2.y === this._p.y && e3.y === this._p.y) {
            var n2 = t2.x, i2 = e3.x;
            return n2 > i2 && (n2 = e3.x, i2 = t2.x), this._p.x >= n2 && this._p.x <= i2 && (this._isPointOnSegment = true), null;
          }
          if (t2.y > this._p.y && e3.y <= this._p.y || e3.y > this._p.y && t2.y <= this._p.y) {
            var r2 = t2.x - this._p.x, o2 = t2.y - this._p.y, s2 = e3.x - this._p.x, a3 = e3.y - this._p.y, u2 = ot.signOfDet2x2(r2, o2, s2, a3);
            if (0 === u2)
              return this._isPointOnSegment = true, null;
            a3 < o2 && (u2 = -u2), u2 > 0 && this._crossingCount++;
          }
        }, st.prototype.isPointInPolygon = function() {
          return this.getLocation() !== w.EXTERIOR;
        }, st.prototype.getLocation = function() {
          return this._isPointOnSegment ? w.BOUNDARY : this._crossingCount % 2 == 1 ? w.INTERIOR : w.EXTERIOR;
        }, st.prototype.isOnSegment = function() {
          return this._isPointOnSegment;
        }, st.prototype.interfaces_ = function() {
          return [];
        }, st.prototype.getClass = function() {
          return st;
        }, st.locatePointInRing = function() {
          if (arguments[0] instanceof C && T(arguments[1], V2)) {
            for (var t2 = arguments[0], e3 = arguments[1], n2 = new st(t2), i2 = new C(), r2 = new C(), o2 = 1; o2 < e3.size(); o2++)
              if (e3.getCoordinate(o2, i2), e3.getCoordinate(o2 - 1, r2), n2.countSegment(i2, r2), n2.isOnSegment())
                return n2.getLocation();
            return n2.getLocation();
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Array) {
            for (var s2 = arguments[0], a3 = arguments[1], u2 = new st(s2), l2 = 1; l2 < a3.length; l2++) {
              var c2 = a3[l2], p2 = a3[l2 - 1];
              if (u2.countSegment(c2, p2), u2.isOnSegment())
                return u2.getLocation();
            }
            return u2.getLocation();
          }
        };
        var at = function() {
        }, ut = { CLOCKWISE: { configurable: true }, RIGHT: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, LEFT: { configurable: true }, COLLINEAR: { configurable: true }, STRAIGHT: { configurable: true } };
        at.prototype.interfaces_ = function() {
          return [];
        }, at.prototype.getClass = function() {
          return at;
        }, at.orientationIndex = function(t2, e3, n2) {
          return q.orientationIndex(t2, e3, n2);
        }, at.signedArea = function() {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            if (t2.length < 3)
              return 0;
            for (var e3 = 0, n2 = t2[0].x, i2 = 1; i2 < t2.length - 1; i2++) {
              var r2 = t2[i2].x - n2, o2 = t2[i2 + 1].y;
              e3 += r2 * (t2[i2 - 1].y - o2);
            }
            return e3 / 2;
          }
          if (T(arguments[0], V2)) {
            var s2 = arguments[0], a3 = s2.size();
            if (a3 < 3)
              return 0;
            var u2 = new C(), l2 = new C(), c2 = new C();
            s2.getCoordinate(0, l2), s2.getCoordinate(1, c2);
            var p2 = l2.x;
            c2.x -= p2;
            for (var h2 = 0, f2 = 1; f2 < a3 - 1; f2++)
              u2.y = l2.y, l2.x = c2.x, l2.y = c2.y, s2.getCoordinate(f2 + 1, c2), c2.x -= p2, h2 += l2.x * (u2.y - c2.y);
            return h2 / 2;
          }
        }, at.distanceLineLine = function(t2, e3, n2, i2) {
          if (t2.equals(e3))
            return at.distancePointLine(t2, n2, i2);
          if (n2.equals(i2))
            return at.distancePointLine(i2, t2, e3);
          var r2 = false;
          if (j.intersects(t2, e3, n2, i2)) {
            var o2 = (e3.x - t2.x) * (i2.y - n2.y) - (e3.y - t2.y) * (i2.x - n2.x);
            if (0 === o2)
              r2 = true;
            else {
              var s2 = (t2.y - n2.y) * (i2.x - n2.x) - (t2.x - n2.x) * (i2.y - n2.y), a3 = ((t2.y - n2.y) * (e3.x - t2.x) - (t2.x - n2.x) * (e3.y - t2.y)) / o2, u2 = s2 / o2;
              (u2 < 0 || u2 > 1 || a3 < 0 || a3 > 1) && (r2 = true);
            }
          } else
            r2 = true;
          return r2 ? R.min(at.distancePointLine(t2, n2, i2), at.distancePointLine(e3, n2, i2), at.distancePointLine(n2, t2, e3), at.distancePointLine(i2, t2, e3)) : 0;
        }, at.isPointInRing = function(t2, e3) {
          return at.locatePointInRing(t2, e3) !== w.EXTERIOR;
        }, at.computeLength = function(t2) {
          var e3 = t2.size();
          if (e3 <= 1)
            return 0;
          var n2 = 0, i2 = new C();
          t2.getCoordinate(0, i2);
          for (var r2 = i2.x, o2 = i2.y, s2 = 1; s2 < e3; s2++) {
            t2.getCoordinate(s2, i2);
            var a3 = i2.x, u2 = i2.y, l2 = a3 - r2, c2 = u2 - o2;
            n2 += Math.sqrt(l2 * l2 + c2 * c2), r2 = a3, o2 = u2;
          }
          return n2;
        }, at.isCCW = function(t2) {
          var e3 = t2.length - 1;
          if (e3 < 3)
            throw new m("Ring has fewer than 4 points, so orientation cannot be determined");
          for (var n2 = t2[0], i2 = 0, r2 = 1; r2 <= e3; r2++) {
            var o2 = t2[r2];
            o2.y > n2.y && (n2 = o2, i2 = r2);
          }
          var s2 = i2;
          do {
            (s2 -= 1) < 0 && (s2 = e3);
          } while (t2[s2].equals2D(n2) && s2 !== i2);
          var a3 = i2;
          do {
            a3 = (a3 + 1) % e3;
          } while (t2[a3].equals2D(n2) && a3 !== i2);
          var u2 = t2[s2], l2 = t2[a3];
          if (u2.equals2D(n2) || l2.equals2D(n2) || u2.equals2D(l2))
            return false;
          var c2 = at.computeOrientation(u2, n2, l2), p2 = false;
          return p2 = 0 === c2 ? u2.x > l2.x : c2 > 0, p2;
        }, at.locatePointInRing = function(t2, e3) {
          return st.locatePointInRing(t2, e3);
        }, at.distancePointLinePerpendicular = function(t2, e3, n2) {
          var i2 = (n2.x - e3.x) * (n2.x - e3.x) + (n2.y - e3.y) * (n2.y - e3.y), r2 = ((e3.y - t2.y) * (n2.x - e3.x) - (e3.x - t2.x) * (n2.y - e3.y)) / i2;
          return Math.abs(r2) * Math.sqrt(i2);
        }, at.computeOrientation = function(t2, e3, n2) {
          return at.orientationIndex(t2, e3, n2);
        }, at.distancePointLine = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            if (0 === e3.length)
              throw new m("Line array must contain at least one vertex");
            for (var n2 = t2.distance(e3[0]), i2 = 0; i2 < e3.length - 1; i2++) {
              var r2 = at.distancePointLine(t2, e3[i2], e3[i2 + 1]);
              r2 < n2 && (n2 = r2);
            }
            return n2;
          }
          if (3 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a3 = arguments[2];
            if (s2.x === a3.x && s2.y === a3.y)
              return o2.distance(s2);
            var u2 = (a3.x - s2.x) * (a3.x - s2.x) + (a3.y - s2.y) * (a3.y - s2.y), l2 = ((o2.x - s2.x) * (a3.x - s2.x) + (o2.y - s2.y) * (a3.y - s2.y)) / u2;
            if (l2 <= 0)
              return o2.distance(s2);
            if (l2 >= 1)
              return o2.distance(a3);
            var c2 = ((s2.y - o2.y) * (a3.x - s2.x) - (s2.x - o2.x) * (a3.y - s2.y)) / u2;
            return Math.abs(c2) * Math.sqrt(u2);
          }
        }, at.isOnLine = function(t2, e3) {
          for (var n2 = new rt(), i2 = 1; i2 < e3.length; i2++) {
            var r2 = e3[i2 - 1], o2 = e3[i2];
            if (n2.computeIntersection(t2, r2, o2), n2.hasIntersection())
              return true;
          }
          return false;
        }, ut.CLOCKWISE.get = function() {
          return -1;
        }, ut.RIGHT.get = function() {
          return at.CLOCKWISE;
        }, ut.COUNTERCLOCKWISE.get = function() {
          return 1;
        }, ut.LEFT.get = function() {
          return at.COUNTERCLOCKWISE;
        }, ut.COLLINEAR.get = function() {
          return 0;
        }, ut.STRAIGHT.get = function() {
          return at.COLLINEAR;
        }, Object.defineProperties(at, ut);
        var lt = function() {
        };
        lt.prototype.filter = function(t2) {
        }, lt.prototype.interfaces_ = function() {
          return [];
        }, lt.prototype.getClass = function() {
          return lt;
        };
        var ct = function() {
          var t2 = arguments[0];
          this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t2, this._SRID = t2.getSRID();
        }, pt = { serialVersionUID: { configurable: true }, SORTINDEX_POINT: { configurable: true }, SORTINDEX_MULTIPOINT: { configurable: true }, SORTINDEX_LINESTRING: { configurable: true }, SORTINDEX_LINEARRING: { configurable: true }, SORTINDEX_MULTILINESTRING: { configurable: true }, SORTINDEX_POLYGON: { configurable: true }, SORTINDEX_MULTIPOLYGON: { configurable: true }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: true }, geometryChangedFilter: { configurable: true } };
        ct.prototype.isGeometryCollection = function() {
          return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION;
        }, ct.prototype.getFactory = function() {
          return this._factory;
        }, ct.prototype.getGeometryN = function(t2) {
          return this;
        }, ct.prototype.getArea = function() {
          return 0;
        }, ct.prototype.isRectangle = function() {
          return false;
        }, ct.prototype.equals = function() {
          if (arguments[0] instanceof ct) {
            var t2 = arguments[0];
            return null !== t2 && this.equalsTopo(t2);
          }
          if (arguments[0] instanceof Object) {
            var e3 = arguments[0];
            if (!(e3 instanceof ct))
              return false;
            var n2 = e3;
            return this.equalsExact(n2);
          }
        }, ct.prototype.equalsExact = function(t2) {
          return this === t2 || this.equalsExact(t2, 0);
        }, ct.prototype.geometryChanged = function() {
          this.apply(ct.geometryChangedFilter);
        }, ct.prototype.geometryChangedAction = function() {
          this._envelope = null;
        }, ct.prototype.equalsNorm = function(t2) {
          return null !== t2 && this.norm().equalsExact(t2.norm());
        }, ct.prototype.getLength = function() {
          return 0;
        }, ct.prototype.getNumGeometries = function() {
          return 1;
        }, ct.prototype.compareTo = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = t2;
            return this.getSortIndex() !== e3.getSortIndex() ? this.getSortIndex() - e3.getSortIndex() : this.isEmpty() && e3.isEmpty() ? 0 : this.isEmpty() ? -1 : e3.isEmpty() ? 1 : this.compareToSameClass(t2);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return this.getSortIndex() !== n2.getSortIndex() ? this.getSortIndex() - n2.getSortIndex() : this.isEmpty() && n2.isEmpty() ? 0 : this.isEmpty() ? -1 : n2.isEmpty() ? 1 : this.compareToSameClass(n2, i2);
          }
        }, ct.prototype.getUserData = function() {
          return this._userData;
        }, ct.prototype.getSRID = function() {
          return this._SRID;
        }, ct.prototype.getEnvelope = function() {
          return this.getFactory().toGeometry(this.getEnvelopeInternal());
        }, ct.prototype.checkNotGeometryCollection = function(t2) {
          if (t2.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION)
            throw new m("This method does not support GeometryCollection arguments");
        }, ct.prototype.equal = function(t2, e3, n2) {
          return 0 === n2 ? t2.equals(e3) : t2.distance(e3) <= n2;
        }, ct.prototype.norm = function() {
          var t2 = this.copy();
          return t2.normalize(), t2;
        }, ct.prototype.getPrecisionModel = function() {
          return this._factory.getPrecisionModel();
        }, ct.prototype.getEnvelopeInternal = function() {
          return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new j(this._envelope);
        }, ct.prototype.setSRID = function(t2) {
          this._SRID = t2;
        }, ct.prototype.setUserData = function(t2) {
          this._userData = t2;
        }, ct.prototype.compare = function(t2, e3) {
          for (var n2 = t2.iterator(), i2 = e3.iterator(); n2.hasNext() && i2.hasNext(); ) {
            var r2 = n2.next(), o2 = i2.next(), s2 = r2.compareTo(o2);
            if (0 !== s2)
              return s2;
          }
          return n2.hasNext() ? 1 : i2.hasNext() ? -1 : 0;
        }, ct.prototype.hashCode = function() {
          return this.getEnvelopeInternal().hashCode();
        }, ct.prototype.isGeometryCollectionOrDerived = function() {
          return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === ct.SORTINDEX_MULTIPOINT || this.getSortIndex() === ct.SORTINDEX_MULTILINESTRING || this.getSortIndex() === ct.SORTINDEX_MULTIPOLYGON;
        }, ct.prototype.interfaces_ = function() {
          return [x3, E, e];
        }, ct.prototype.getClass = function() {
          return ct;
        }, ct.hasNonEmptyElements = function(t2) {
          for (var e3 = 0; e3 < t2.length; e3++)
            if (!t2[e3].isEmpty())
              return true;
          return false;
        }, ct.hasNullElements = function(t2) {
          for (var e3 = 0; e3 < t2.length; e3++)
            if (null === t2[e3])
              return true;
          return false;
        }, pt.serialVersionUID.get = function() {
          return 8763622679187377e3;
        }, pt.SORTINDEX_POINT.get = function() {
          return 0;
        }, pt.SORTINDEX_MULTIPOINT.get = function() {
          return 1;
        }, pt.SORTINDEX_LINESTRING.get = function() {
          return 2;
        }, pt.SORTINDEX_LINEARRING.get = function() {
          return 3;
        }, pt.SORTINDEX_MULTILINESTRING.get = function() {
          return 4;
        }, pt.SORTINDEX_POLYGON.get = function() {
          return 5;
        }, pt.SORTINDEX_MULTIPOLYGON.get = function() {
          return 6;
        }, pt.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
          return 7;
        }, pt.geometryChangedFilter.get = function() {
          return ht;
        }, Object.defineProperties(ct, pt);
        var ht = function() {
        };
        ht.interfaces_ = function() {
          return [lt];
        }, ht.filter = function(t2) {
          t2.geometryChangedAction();
        };
        var ft = function() {
        };
        ft.prototype.filter = function(t2) {
        }, ft.prototype.interfaces_ = function() {
          return [];
        }, ft.prototype.getClass = function() {
          return ft;
        };
        var gt = function() {
        }, dt = { Mod2BoundaryNodeRule: { configurable: true }, EndPointBoundaryNodeRule: { configurable: true }, MultiValentEndPointBoundaryNodeRule: { configurable: true }, MonoValentEndPointBoundaryNodeRule: { configurable: true }, MOD2_BOUNDARY_RULE: { configurable: true }, ENDPOINT_BOUNDARY_RULE: { configurable: true }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, OGC_SFS_BOUNDARY_RULE: { configurable: true } };
        gt.prototype.isInBoundary = function(t2) {
        }, gt.prototype.interfaces_ = function() {
          return [];
        }, gt.prototype.getClass = function() {
          return gt;
        }, dt.Mod2BoundaryNodeRule.get = function() {
          return yt;
        }, dt.EndPointBoundaryNodeRule.get = function() {
          return _t;
        }, dt.MultiValentEndPointBoundaryNodeRule.get = function() {
          return mt;
        }, dt.MonoValentEndPointBoundaryNodeRule.get = function() {
          return vt;
        }, dt.MOD2_BOUNDARY_RULE.get = function() {
          return new yt();
        }, dt.ENDPOINT_BOUNDARY_RULE.get = function() {
          return new _t();
        }, dt.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
          return new mt();
        }, dt.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
          return new vt();
        }, dt.OGC_SFS_BOUNDARY_RULE.get = function() {
          return gt.MOD2_BOUNDARY_RULE;
        }, Object.defineProperties(gt, dt);
        var yt = function() {
        };
        yt.prototype.isInBoundary = function(t2) {
          return t2 % 2 == 1;
        }, yt.prototype.interfaces_ = function() {
          return [gt];
        }, yt.prototype.getClass = function() {
          return yt;
        };
        var _t = function() {
        };
        _t.prototype.isInBoundary = function(t2) {
          return t2 > 0;
        }, _t.prototype.interfaces_ = function() {
          return [gt];
        }, _t.prototype.getClass = function() {
          return _t;
        };
        var mt = function() {
        };
        mt.prototype.isInBoundary = function(t2) {
          return t2 > 1;
        }, mt.prototype.interfaces_ = function() {
          return [gt];
        }, mt.prototype.getClass = function() {
          return mt;
        };
        var vt = function() {
        };
        vt.prototype.isInBoundary = function(t2) {
          return 1 === t2;
        }, vt.prototype.interfaces_ = function() {
          return [gt];
        }, vt.prototype.getClass = function() {
          return vt;
        };
        var It = function() {
        };
        It.prototype.add = function() {
        }, It.prototype.addAll = function() {
        }, It.prototype.isEmpty = function() {
        }, It.prototype.iterator = function() {
        }, It.prototype.size = function() {
        }, It.prototype.toArray = function() {
        }, It.prototype.remove = function() {
        }, (n.prototype = new Error()).name = "IndexOutOfBoundsException";
        var Et = function() {
        };
        Et.prototype.hasNext = function() {
        }, Et.prototype.next = function() {
        }, Et.prototype.remove = function() {
        };
        var xt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.get = function() {
          }, e3.prototype.set = function() {
          }, e3.prototype.isEmpty = function() {
          }, e3;
        }(It);
        (i.prototype = new Error()).name = "NoSuchElementException";
        var Nt = function(t2) {
          function e3() {
            t2.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.ensureCapacity = function() {
          }, e3.prototype.interfaces_ = function() {
            return [t2, It];
          }, e3.prototype.add = function(t3) {
            return 1 === arguments.length ? this.array_.push(t3) : this.array_.splice(arguments[0], arguments[1]), true;
          }, e3.prototype.clear = function() {
            this.array_ = [];
          }, e3.prototype.addAll = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            return true;
          }, e3.prototype.set = function(t3, e4) {
            var n2 = this.array_[t3];
            return this.array_[t3] = e4, n2;
          }, e3.prototype.iterator = function() {
            return new Ct(this);
          }, e3.prototype.get = function(t3) {
            if (t3 < 0 || t3 >= this.size())
              throw new n();
            return this.array_[t3];
          }, e3.prototype.isEmpty = function() {
            return 0 === this.array_.length;
          }, e3.prototype.size = function() {
            return this.array_.length;
          }, e3.prototype.toArray = function() {
            for (var t3 = [], e4 = 0, n2 = this.array_.length; e4 < n2; e4++)
              t3.push(this.array_[e4]);
            return t3;
          }, e3.prototype.remove = function(t3) {
            for (var e4 = false, n2 = 0, i2 = this.array_.length; n2 < i2; n2++)
              if (this.array_[n2] === t3) {
                this.array_.splice(n2, 1), e4 = true;
                break;
              }
            return e4;
          }, e3;
        }(xt), Ct = function(t2) {
          function e3(e4) {
            t2.call(this), this.arrayList_ = e4, this.position_ = 0;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.next = function() {
            if (this.position_ === this.arrayList_.size())
              throw new i();
            return this.arrayList_.get(this.position_++);
          }, e3.prototype.hasNext = function() {
            return this.position_ < this.arrayList_.size();
          }, e3.prototype.set = function(t3) {
            return this.arrayList_.set(this.position_ - 1, t3);
          }, e3.prototype.remove = function() {
            this.arrayList_.remove(this.arrayList_.get(this.position_));
          }, e3;
        }(Et), St = function(t2) {
          function e3() {
            if (t2.call(this), 0 === arguments.length)
              ;
            else if (1 === arguments.length) {
              var e4 = arguments[0];
              this.ensureCapacity(e4.length), this.add(e4, true);
            } else if (2 === arguments.length) {
              var n3 = arguments[0], i2 = arguments[1];
              this.ensureCapacity(n3.length), this.add(n3, i2);
            }
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { coordArrayType: { configurable: true } };
          return n2.coordArrayType.get = function() {
            return new Array(0).fill(null);
          }, e3.prototype.getCoordinate = function(t3) {
            return this.get(t3);
          }, e3.prototype.addAll = function() {
            if (2 === arguments.length) {
              for (var e4 = arguments[0], n3 = arguments[1], i2 = false, r2 = e4.iterator(); r2.hasNext(); )
                this.add(r2.next(), n3), i2 = true;
              return i2;
            }
            return t2.prototype.addAll.apply(this, arguments);
          }, e3.prototype.clone = function() {
            for (var e4 = t2.prototype.clone.call(this), n3 = 0; n3 < this.size(); n3++)
              e4.add(n3, this.get(n3).copy());
            return e4;
          }, e3.prototype.toCoordinateArray = function() {
            return this.toArray(e3.coordArrayType);
          }, e3.prototype.add = function() {
            if (1 === arguments.length) {
              var e4 = arguments[0];
              t2.prototype.add.call(this, e4);
            } else if (2 === arguments.length) {
              if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                var n3 = arguments[0], i2 = arguments[1];
                return this.add(n3, i2, true), true;
              }
              if (arguments[0] instanceof C && "boolean" == typeof arguments[1]) {
                var r2 = arguments[0];
                if (!arguments[1] && this.size() >= 1) {
                  if (this.get(this.size() - 1).equals2D(r2))
                    return null;
                }
                t2.prototype.add.call(this, r2);
              } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
                var o2 = arguments[0], s2 = arguments[1];
                return this.add(o2, s2), true;
              }
            } else if (3 === arguments.length) {
              if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                var a3 = arguments[0], u2 = arguments[1];
                if (arguments[2])
                  for (var l2 = 0; l2 < a3.length; l2++)
                    this.add(a3[l2], u2);
                else
                  for (var c2 = a3.length - 1; c2 >= 0; c2--)
                    this.add(a3[c2], u2);
                return true;
              }
              if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof C) {
                var p2 = arguments[0], h2 = arguments[1];
                if (!arguments[2]) {
                  var f2 = this.size();
                  if (f2 > 0) {
                    if (p2 > 0) {
                      if (this.get(p2 - 1).equals2D(h2))
                        return null;
                    }
                    if (p2 < f2) {
                      if (this.get(p2).equals2D(h2))
                        return null;
                    }
                  }
                }
                t2.prototype.add.call(this, p2, h2);
              }
            } else if (4 === arguments.length) {
              var g2 = arguments[0], d2 = arguments[1], y4 = arguments[2], _2 = arguments[3], m2 = 1;
              y4 > _2 && (m2 = -1);
              for (var v2 = y4; v2 !== _2; v2 += m2)
                this.add(g2[v2], d2);
              return true;
            }
          }, e3.prototype.closeRing = function() {
            this.size() > 0 && this.add(new C(this.get(0)), false);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, Object.defineProperties(e3, n2), e3;
        }(Nt), Lt = function() {
        }, bt = { ForwardComparator: { configurable: true }, BidirectionalComparator: { configurable: true }, coordArrayType: { configurable: true } };
        bt.ForwardComparator.get = function() {
          return wt;
        }, bt.BidirectionalComparator.get = function() {
          return Ot;
        }, bt.coordArrayType.get = function() {
          return new Array(0).fill(null);
        }, Lt.prototype.interfaces_ = function() {
          return [];
        }, Lt.prototype.getClass = function() {
          return Lt;
        }, Lt.isRing = function(t2) {
          return !(t2.length < 4) && !!t2[0].equals2D(t2[t2.length - 1]);
        }, Lt.ptNotInList = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            if (Lt.indexOf(i2, e3) < 0)
              return i2;
          }
          return null;
        }, Lt.scroll = function(t2, e3) {
          var n2 = Lt.indexOf(e3, t2);
          if (n2 < 0)
            return null;
          var i2 = new Array(t2.length).fill(null);
          Y.arraycopy(t2, n2, i2, 0, t2.length - n2), Y.arraycopy(t2, 0, i2, t2.length - n2, n2), Y.arraycopy(i2, 0, t2, 0, t2.length);
        }, Lt.equals = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            if (t2 === e3)
              return true;
            if (null === t2 || null === e3)
              return false;
            if (t2.length !== e3.length)
              return false;
            for (var n2 = 0; n2 < t2.length; n2++)
              if (!t2[n2].equals(e3[n2]))
                return false;
            return true;
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            if (i2 === r2)
              return true;
            if (null === i2 || null === r2)
              return false;
            if (i2.length !== r2.length)
              return false;
            for (var s2 = 0; s2 < i2.length; s2++)
              if (0 !== o2.compare(i2[s2], r2[s2]))
                return false;
            return true;
          }
        }, Lt.intersection = function(t2, e3) {
          for (var n2 = new St(), i2 = 0; i2 < t2.length; i2++)
            e3.intersects(t2[i2]) && n2.add(t2[i2], true);
          return n2.toCoordinateArray();
        }, Lt.hasRepeatedPoints = function(t2) {
          for (var e3 = 1; e3 < t2.length; e3++)
            if (t2[e3 - 1].equals(t2[e3]))
              return true;
          return false;
        }, Lt.removeRepeatedPoints = function(t2) {
          if (!Lt.hasRepeatedPoints(t2))
            return t2;
          return new St(t2, false).toCoordinateArray();
        }, Lt.reverse = function(t2) {
          for (var e3 = t2.length - 1, n2 = Math.trunc(e3 / 2), i2 = 0; i2 <= n2; i2++) {
            var r2 = t2[i2];
            t2[i2] = t2[e3 - i2], t2[e3 - i2] = r2;
          }
        }, Lt.removeNull = function(t2) {
          for (var e3 = 0, n2 = 0; n2 < t2.length; n2++)
            null !== t2[n2] && e3++;
          var i2 = new Array(e3).fill(null);
          if (0 === e3)
            return i2;
          for (var r2 = 0, o2 = 0; o2 < t2.length; o2++)
            null !== t2[o2] && (i2[r2++] = t2[o2]);
          return i2;
        }, Lt.copyDeep = function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = new Array(t2.length).fill(null), n2 = 0; n2 < t2.length; n2++)
              e3[n2] = new C(t2[n2]);
            return e3;
          }
          if (5 === arguments.length)
            for (var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = arguments[3], a3 = arguments[4], u2 = 0; u2 < a3; u2++)
              o2[s2 + u2] = new C(i2[r2 + u2]);
        }, Lt.isEqualReversed = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2], r2 = e3[t2.length - n2 - 1];
            if (0 !== i2.compareTo(r2))
              return false;
          }
          return true;
        }, Lt.envelope = function(t2) {
          for (var e3 = new j(), n2 = 0; n2 < t2.length; n2++)
            e3.expandToInclude(t2[n2]);
          return e3;
        }, Lt.toCoordinateArray = function(t2) {
          return t2.toArray(Lt.coordArrayType);
        }, Lt.atLeastNCoordinatesOrNothing = function(t2, e3) {
          return e3.length >= t2 ? e3 : [];
        }, Lt.indexOf = function(t2, e3) {
          for (var n2 = 0; n2 < e3.length; n2++)
            if (t2.equals(e3[n2]))
              return n2;
          return -1;
        }, Lt.increasingDirection = function(t2) {
          for (var e3 = 0; e3 < Math.trunc(t2.length / 2); e3++) {
            var n2 = t2.length - 1 - e3, i2 = t2[e3].compareTo(t2[n2]);
            if (0 !== i2)
              return i2;
          }
          return 1;
        }, Lt.compare = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length && n2 < e3.length; ) {
            var i2 = t2[n2].compareTo(e3[n2]);
            if (0 !== i2)
              return i2;
            n2++;
          }
          return n2 < e3.length ? -1 : n2 < t2.length ? 1 : 0;
        }, Lt.minCoordinate = function(t2) {
          for (var e3 = null, n2 = 0; n2 < t2.length; n2++)
            (null === e3 || e3.compareTo(t2[n2]) > 0) && (e3 = t2[n2]);
          return e3;
        }, Lt.extract = function(t2, e3, n2) {
          e3 = R.clamp(e3, 0, t2.length);
          var i2 = (n2 = R.clamp(n2, -1, t2.length)) - e3 + 1;
          n2 < 0 && (i2 = 0), e3 >= t2.length && (i2 = 0), n2 < e3 && (i2 = 0);
          var r2 = new Array(i2).fill(null);
          if (0 === i2)
            return r2;
          for (var o2 = 0, s2 = e3; s2 <= n2; s2++)
            r2[o2++] = t2[s2];
          return r2;
        }, Object.defineProperties(Lt, bt);
        var wt = function() {
        };
        wt.prototype.compare = function(t2, e3) {
          return Lt.compare(t2, e3);
        }, wt.prototype.interfaces_ = function() {
          return [N];
        }, wt.prototype.getClass = function() {
          return wt;
        };
        var Ot = function() {
        };
        Ot.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3;
          if (n2.length < i2.length)
            return -1;
          if (n2.length > i2.length)
            return 1;
          if (0 === n2.length)
            return 0;
          var r2 = Lt.compare(n2, i2);
          return Lt.isEqualReversed(n2, i2) ? 0 : r2;
        }, Ot.prototype.OLDcompare = function(t2, e3) {
          var n2 = t2, i2 = e3;
          if (n2.length < i2.length)
            return -1;
          if (n2.length > i2.length)
            return 1;
          if (0 === n2.length)
            return 0;
          for (var r2 = Lt.increasingDirection(n2), o2 = Lt.increasingDirection(i2), s2 = r2 > 0 ? 0 : n2.length - 1, a3 = o2 > 0 ? 0 : n2.length - 1, u2 = 0; u2 < n2.length; u2++) {
            var l2 = n2[s2].compareTo(i2[a3]);
            if (0 !== l2)
              return l2;
            s2 += r2, a3 += o2;
          }
          return 0;
        }, Ot.prototype.interfaces_ = function() {
          return [N];
        }, Ot.prototype.getClass = function() {
          return Ot;
        };
        var Tt = function() {
        };
        Tt.prototype.get = function() {
        }, Tt.prototype.put = function() {
        }, Tt.prototype.size = function() {
        }, Tt.prototype.values = function() {
        }, Tt.prototype.entrySet = function() {
        };
        var Rt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Tt);
        (r.prototype = new Error()).name = "OperationNotSupported", (o.prototype = new It()).contains = function() {
        };
        var Pt = function(t2) {
          function e3() {
            t2.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.contains = function(t3) {
            for (var e4 = 0, n2 = this.array_.length; e4 < n2; e4++) {
              if (this.array_[e4] === t3)
                return true;
            }
            return false;
          }, e3.prototype.add = function(t3) {
            return !this.contains(t3) && (this.array_.push(t3), true);
          }, e3.prototype.addAll = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            return true;
          }, e3.prototype.remove = function(t3) {
            throw new Error();
          }, e3.prototype.size = function() {
            return this.array_.length;
          }, e3.prototype.isEmpty = function() {
            return 0 === this.array_.length;
          }, e3.prototype.toArray = function() {
            for (var t3 = [], e4 = 0, n2 = this.array_.length; e4 < n2; e4++)
              t3.push(this.array_[e4]);
            return t3;
          }, e3.prototype.iterator = function() {
            return new Dt(this);
          }, e3;
        }(o), Dt = function(t2) {
          function e3(e4) {
            t2.call(this), this.hashSet_ = e4, this.position_ = 0;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.next = function() {
            if (this.position_ === this.hashSet_.size())
              throw new i();
            return this.hashSet_.array_[this.position_++];
          }, e3.prototype.hasNext = function() {
            return this.position_ < this.hashSet_.size();
          }, e3.prototype.remove = function() {
            throw new r();
          }, e3;
        }(Et), Mt = 0;
        (p.prototype = new Rt()).get = function(t2) {
          for (var e3 = this.root_; null !== e3; ) {
            var n2 = t2.compareTo(e3.key);
            if (n2 < 0)
              e3 = e3.left;
            else {
              if (!(n2 > 0))
                return e3.value;
              e3 = e3.right;
            }
          }
          return null;
        }, p.prototype.put = function(t2, e3) {
          if (null === this.root_)
            return this.root_ = { key: t2, value: e3, left: null, right: null, parent: null, color: Mt, getValue: function() {
              return this.value;
            }, getKey: function() {
              return this.key;
            } }, this.size_ = 1, null;
          var n2, i2, r2 = this.root_;
          do {
            if (n2 = r2, (i2 = t2.compareTo(r2.key)) < 0)
              r2 = r2.left;
            else {
              if (!(i2 > 0)) {
                var o2 = r2.value;
                return r2.value = e3, o2;
              }
              r2 = r2.right;
            }
          } while (null !== r2);
          var s2 = { key: t2, left: null, right: null, value: e3, parent: n2, color: Mt, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } };
          return i2 < 0 ? n2.left = s2 : n2.right = s2, this.fixAfterInsertion(s2), this.size_++, null;
        }, p.prototype.fixAfterInsertion = function(t2) {
          for (t2.color = 1; null != t2 && t2 !== this.root_ && 1 === t2.parent.color; )
            if (a2(t2) === l(a2(a2(t2)))) {
              var e3 = c(a2(a2(t2)));
              1 === s(e3) ? (u(a2(t2), Mt), u(e3, Mt), u(a2(a2(t2)), 1), t2 = a2(a2(t2))) : (t2 === c(a2(t2)) && (t2 = a2(t2), this.rotateLeft(t2)), u(a2(t2), Mt), u(a2(a2(t2)), 1), this.rotateRight(a2(a2(t2))));
            } else {
              var n2 = l(a2(a2(t2)));
              1 === s(n2) ? (u(a2(t2), Mt), u(n2, Mt), u(a2(a2(t2)), 1), t2 = a2(a2(t2))) : (t2 === l(a2(t2)) && (t2 = a2(t2), this.rotateRight(t2)), u(a2(t2), Mt), u(a2(a2(t2)), 1), this.rotateLeft(a2(a2(t2))));
            }
          this.root_.color = Mt;
        }, p.prototype.values = function() {
          var t2 = new Nt(), e3 = this.getFirstEntry();
          if (null !== e3)
            for (t2.add(e3.value); null !== (e3 = p.successor(e3)); )
              t2.add(e3.value);
          return t2;
        }, p.prototype.entrySet = function() {
          var t2 = new Pt(), e3 = this.getFirstEntry();
          if (null !== e3)
            for (t2.add(e3); null !== (e3 = p.successor(e3)); )
              t2.add(e3);
          return t2;
        }, p.prototype.rotateLeft = function(t2) {
          if (null != t2) {
            var e3 = t2.right;
            t2.right = e3.left, null != e3.left && (e3.left.parent = t2), e3.parent = t2.parent, null === t2.parent ? this.root_ = e3 : t2.parent.left === t2 ? t2.parent.left = e3 : t2.parent.right = e3, e3.left = t2, t2.parent = e3;
          }
        }, p.prototype.rotateRight = function(t2) {
          if (null != t2) {
            var e3 = t2.left;
            t2.left = e3.right, null != e3.right && (e3.right.parent = t2), e3.parent = t2.parent, null === t2.parent ? this.root_ = e3 : t2.parent.right === t2 ? t2.parent.right = e3 : t2.parent.left = e3, e3.right = t2, t2.parent = e3;
          }
        }, p.prototype.getFirstEntry = function() {
          var t2 = this.root_;
          if (null != t2)
            for (; null != t2.left; )
              t2 = t2.left;
          return t2;
        }, p.successor = function(t2) {
          if (null === t2)
            return null;
          if (null !== t2.right) {
            for (var e3 = t2.right; null !== e3.left; )
              e3 = e3.left;
            return e3;
          }
          for (var n2 = t2.parent, i2 = t2; null !== n2 && i2 === n2.right; )
            i2 = n2, n2 = n2.parent;
          return n2;
        }, p.prototype.size = function() {
          return this.size_;
        };
        var At = function() {
        };
        At.prototype.interfaces_ = function() {
          return [];
        }, At.prototype.getClass = function() {
          return At;
        }, h.prototype = new o(), (f.prototype = new h()).contains = function(t2) {
          for (var e3 = 0, n2 = this.array_.length; e3 < n2; e3++) {
            if (0 === this.array_[e3].compareTo(t2))
              return true;
          }
          return false;
        }, f.prototype.add = function(t2) {
          if (this.contains(t2))
            return false;
          for (var e3 = 0, n2 = this.array_.length; e3 < n2; e3++) {
            if (1 === this.array_[e3].compareTo(t2))
              return this.array_.splice(e3, 0, t2), true;
          }
          return this.array_.push(t2), true;
        }, f.prototype.addAll = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); )
            this.add(e3.next());
          return true;
        }, f.prototype.remove = function(t2) {
          throw new r();
        }, f.prototype.size = function() {
          return this.array_.length;
        }, f.prototype.isEmpty = function() {
          return 0 === this.array_.length;
        }, f.prototype.toArray = function() {
          for (var t2 = [], e3 = 0, n2 = this.array_.length; e3 < n2; e3++)
            t2.push(this.array_[e3]);
          return t2;
        }, f.prototype.iterator = function() {
          return new Ft(this);
        };
        var Ft = function(t2) {
          this.treeSet_ = t2, this.position_ = 0;
        };
        Ft.prototype.next = function() {
          if (this.position_ === this.treeSet_.size())
            throw new i();
          return this.treeSet_.array_[this.position_++];
        }, Ft.prototype.hasNext = function() {
          return this.position_ < this.treeSet_.size();
        }, Ft.prototype.remove = function() {
          throw new r();
        };
        var Gt = function() {
        };
        Gt.sort = function() {
          var t2, e3, n2, i2, r2 = arguments[0];
          if (1 === arguments.length)
            i2 = function(t3, e4) {
              return t3.compareTo(e4);
            }, r2.sort(i2);
          else if (2 === arguments.length)
            n2 = arguments[1], i2 = function(t3, e4) {
              return n2.compare(t3, e4);
            }, r2.sort(i2);
          else if (3 === arguments.length) {
            (e3 = r2.slice(arguments[1], arguments[2])).sort();
            var o2 = r2.slice(0, arguments[1]).concat(e3, r2.slice(arguments[2], r2.length));
            for (r2.splice(0, r2.length), t2 = 0; t2 < o2.length; t2++)
              r2.push(o2[t2]);
          } else if (4 === arguments.length)
            for (e3 = r2.slice(arguments[1], arguments[2]), n2 = arguments[3], i2 = function(t3, e4) {
              return n2.compare(t3, e4);
            }, e3.sort(i2), o2 = r2.slice(0, arguments[1]).concat(e3, r2.slice(arguments[2], r2.length)), r2.splice(0, r2.length), t2 = 0; t2 < o2.length; t2++)
              r2.push(o2[t2]);
        }, Gt.asList = function(t2) {
          for (var e3 = new Nt(), n2 = 0, i2 = t2.length; n2 < i2; n2++)
            e3.add(t2[n2]);
          return e3;
        };
        var qt = function() {
        }, Bt = { P: { configurable: true }, L: { configurable: true }, A: { configurable: true }, FALSE: { configurable: true }, TRUE: { configurable: true }, DONTCARE: { configurable: true }, SYM_FALSE: { configurable: true }, SYM_TRUE: { configurable: true }, SYM_DONTCARE: { configurable: true }, SYM_P: { configurable: true }, SYM_L: { configurable: true }, SYM_A: { configurable: true } };
        Bt.P.get = function() {
          return 0;
        }, Bt.L.get = function() {
          return 1;
        }, Bt.A.get = function() {
          return 2;
        }, Bt.FALSE.get = function() {
          return -1;
        }, Bt.TRUE.get = function() {
          return -2;
        }, Bt.DONTCARE.get = function() {
          return -3;
        }, Bt.SYM_FALSE.get = function() {
          return "F";
        }, Bt.SYM_TRUE.get = function() {
          return "T";
        }, Bt.SYM_DONTCARE.get = function() {
          return "*";
        }, Bt.SYM_P.get = function() {
          return "0";
        }, Bt.SYM_L.get = function() {
          return "1";
        }, Bt.SYM_A.get = function() {
          return "2";
        }, qt.prototype.interfaces_ = function() {
          return [];
        }, qt.prototype.getClass = function() {
          return qt;
        }, qt.toDimensionSymbol = function(t2) {
          switch (t2) {
            case qt.FALSE:
              return qt.SYM_FALSE;
            case qt.TRUE:
              return qt.SYM_TRUE;
            case qt.DONTCARE:
              return qt.SYM_DONTCARE;
            case qt.P:
              return qt.SYM_P;
            case qt.L:
              return qt.SYM_L;
            case qt.A:
              return qt.SYM_A;
          }
          throw new m("Unknown dimension value: " + t2);
        }, qt.toDimensionValue = function(t2) {
          switch (A2.toUpperCase(t2)) {
            case qt.SYM_FALSE:
              return qt.FALSE;
            case qt.SYM_TRUE:
              return qt.TRUE;
            case qt.SYM_DONTCARE:
              return qt.DONTCARE;
            case qt.SYM_P:
              return qt.P;
            case qt.SYM_L:
              return qt.L;
            case qt.SYM_A:
              return qt.A;
          }
          throw new m("Unknown dimension symbol: " + t2);
        }, Object.defineProperties(qt, Bt);
        var Vt = function() {
        };
        Vt.prototype.filter = function(t2) {
        }, Vt.prototype.interfaces_ = function() {
          return [];
        }, Vt.prototype.getClass = function() {
          return Vt;
        };
        var Ut = function() {
        };
        Ut.prototype.filter = function(t2, e3) {
        }, Ut.prototype.isDone = function() {
        }, Ut.prototype.isGeometryChanged = function() {
        }, Ut.prototype.interfaces_ = function() {
          return [];
        }, Ut.prototype.getClass = function() {
          return Ut;
        };
        var zt = function(t2) {
          function e3(e4, n3) {
            if (t2.call(this, n3), this._geometries = e4 || [], t2.hasNullElements(this._geometries))
              throw new m("geometries must not contain null elements");
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            for (var t3 = new j(), e4 = 0; e4 < this._geometries.length; e4++)
              t3.expandToInclude(this._geometries[e4].getEnvelopeInternal());
            return t3;
          }, e3.prototype.getGeometryN = function(t3) {
            return this._geometries[t3];
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_GEOMETRYCOLLECTION;
          }, e3.prototype.getCoordinates = function() {
            for (var t3 = new Array(this.getNumPoints()).fill(null), e4 = -1, n3 = 0; n3 < this._geometries.length; n3++)
              for (var i2 = this._geometries[n3].getCoordinates(), r2 = 0; r2 < i2.length; r2++)
                t3[++e4] = i2[r2];
            return t3;
          }, e3.prototype.getArea = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getArea();
            return t3;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4;
              if (this._geometries.length !== i2._geometries.length)
                return false;
              for (var r2 = 0; r2 < this._geometries.length; r2++)
                if (!this._geometries[r2].equalsExact(i2._geometries[r2], n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              this._geometries[t3].normalize();
            Gt.sort(this._geometries);
          }, e3.prototype.getCoordinate = function() {
            return this.isEmpty() ? null : this._geometries[0].getCoordinate();
          }, e3.prototype.getBoundaryDimension = function() {
            for (var t3 = qt.FALSE, e4 = 0; e4 < this._geometries.length; e4++)
              t3 = Math.max(t3, this._geometries[e4].getBoundaryDimension());
            return t3;
          }, e3.prototype.getDimension = function() {
            for (var t3 = qt.FALSE, e4 = 0; e4 < this._geometries.length; e4++)
              t3 = Math.max(t3, this._geometries[e4].getDimension());
            return t3;
          }, e3.prototype.getLength = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getLength();
            return t3;
          }, e3.prototype.getNumPoints = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getNumPoints();
            return t3;
          }, e3.prototype.getNumGeometries = function() {
            return this._geometries.length;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[n3] = this._geometries[n3].reverse();
            return this.getFactory().createGeometryCollection(e4);
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0], e4 = new f(Gt.asList(this._geometries)), n3 = new f(Gt.asList(t3._geometries));
              return this.compare(e4, n3);
            }
            if (2 === arguments.length) {
              for (var i2 = arguments[0], r2 = arguments[1], o2 = i2, s2 = this.getNumGeometries(), a3 = o2.getNumGeometries(), u2 = 0; u2 < s2 && u2 < a3; ) {
                var l2 = this.getGeometryN(u2), c2 = o2.getGeometryN(u2), p2 = l2.compareToSameClass(c2, r2);
                if (0 !== p2)
                  return p2;
                u2++;
              }
              return u2 < s2 ? 1 : u2 < a3 ? -1 : 0;
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft))
              for (var t3 = arguments[0], e4 = 0; e4 < this._geometries.length; e4++)
                this._geometries[e4].apply(t3);
            else if (T(arguments[0], Ut)) {
              var n3 = arguments[0];
              if (0 === this._geometries.length)
                return null;
              for (var i2 = 0; i2 < this._geometries.length && (this._geometries[i2].apply(n3), !n3.isDone()); i2++)
                ;
              n3.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              var r2 = arguments[0];
              r2.filter(this);
              for (var o2 = 0; o2 < this._geometries.length; o2++)
                this._geometries[o2].apply(r2);
            } else if (T(arguments[0], lt)) {
              var s2 = arguments[0];
              s2.filter(this);
              for (var a3 = 0; a3 < this._geometries.length; a3++)
                this._geometries[a3].apply(s2);
            }
          }, e3.prototype.getBoundary = function() {
            return this.checkNotGeometryCollection(this), et.shouldNeverReachHere(), null;
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            e4._geometries = new Array(this._geometries.length).fill(null);
            for (var n3 = 0; n3 < this._geometries.length; n3++)
              e4._geometries[n3] = this._geometries[n3].clone();
            return e4;
          }, e3.prototype.getGeometryType = function() {
            return "GeometryCollection";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.isEmpty = function() {
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              if (!this._geometries[t3].isEmpty())
                return false;
            return true;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -5694727726395021e3;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Xt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTILINESTRING;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return this.isClosed() ? qt.FALSE : 0;
          }, e3.prototype.isClosed = function() {
            if (this.isEmpty())
              return false;
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              if (!this._geometries[t3].isClosed())
                return false;
            return true;
          }, e3.prototype.getDimension = function() {
            return 1;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[t3 - 1 - n3] = this._geometries[n3].reverse();
            return this.getFactory().createMultiLineString(e4);
          }, e3.prototype.getBoundary = function() {
            return new Yt(this).getBoundary();
          }, e3.prototype.getGeometryType = function() {
            return "MultiLineString";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [At];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 8166665132445434e3;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), Yt = function() {
          if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, 1 === arguments.length) {
            var t2 = arguments[0], e3 = gt.MOD2_BOUNDARY_RULE;
            this._geom = t2, this._geomFact = t2.getFactory(), this._bnRule = e3;
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this._geom = n2, this._geomFact = n2.getFactory(), this._bnRule = i2;
          }
        };
        Yt.prototype.boundaryMultiLineString = function(t2) {
          if (this._geom.isEmpty())
            return this.getEmptyMultiPoint();
          var e3 = this.computeBoundaryCoordinates(t2);
          return 1 === e3.length ? this._geomFact.createPoint(e3[0]) : this._geomFact.createMultiPointFromCoords(e3);
        }, Yt.prototype.getBoundary = function() {
          return this._geom instanceof Kt ? this.boundaryLineString(this._geom) : this._geom instanceof Xt ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();
        }, Yt.prototype.boundaryLineString = function(t2) {
          if (this._geom.isEmpty())
            return this.getEmptyMultiPoint();
          if (t2.isClosed()) {
            return this._bnRule.isInBoundary(2) ? t2.getStartPoint() : this._geomFact.createMultiPoint();
          }
          return this._geomFact.createMultiPoint([t2.getStartPoint(), t2.getEndPoint()]);
        }, Yt.prototype.getEmptyMultiPoint = function() {
          return this._geomFact.createMultiPoint();
        }, Yt.prototype.computeBoundaryCoordinates = function(t2) {
          var e3 = new Nt();
          this._endpointMap = new p();
          for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = t2.getGeometryN(n2);
            0 !== i2.getNumPoints() && (this.addEndpoint(i2.getCoordinateN(0)), this.addEndpoint(i2.getCoordinateN(i2.getNumPoints() - 1)));
          }
          for (var r2 = this._endpointMap.entrySet().iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = o2.getValue().count;
            this._bnRule.isInBoundary(s2) && e3.add(o2.getKey());
          }
          return Lt.toCoordinateArray(e3);
        }, Yt.prototype.addEndpoint = function(t2) {
          var e3 = this._endpointMap.get(t2);
          null === e3 && (e3 = new kt(), this._endpointMap.put(t2, e3)), e3.count++;
        }, Yt.prototype.interfaces_ = function() {
          return [];
        }, Yt.prototype.getClass = function() {
          return Yt;
        }, Yt.getBoundary = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Yt(t2).getBoundary();
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return new Yt(e3, n2).getBoundary();
          }
        };
        var kt = function() {
          this.count = null;
        };
        kt.prototype.interfaces_ = function() {
          return [];
        }, kt.prototype.getClass = function() {
          return kt;
        };
        var jt = function() {
        }, Ht = { NEWLINE: { configurable: true }, SIMPLE_ORDINATE_FORMAT: { configurable: true } };
        jt.prototype.interfaces_ = function() {
          return [];
        }, jt.prototype.getClass = function() {
          return jt;
        }, jt.chars = function(t2, e3) {
          for (var n2 = new Array(e3).fill(null), i2 = 0; i2 < e3; i2++)
            n2[i2] = t2;
          return String(n2);
        }, jt.getStackTrace = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = new function() {
            }(), n2 = new function() {
            }(e3);
            return t2.printStackTrace(n2), e3.toString();
          }
          if (2 === arguments.length) {
            for (var i2 = arguments[0], r2 = arguments[1], o2 = "", s2 = new function() {
            }(new function() {
            }(jt.getStackTrace(i2))), a3 = 0; a3 < r2; a3++)
              try {
                o2 += s2.readLine() + jt.NEWLINE;
              } catch (t3) {
                if (!(t3 instanceof g))
                  throw t3;
                et.shouldNeverReachHere();
              }
            return o2;
          }
        }, jt.split = function(t2, e3) {
          for (var n2 = e3.length, i2 = new Nt(), r2 = "" + t2, o2 = r2.indexOf(e3); o2 >= 0; ) {
            var s2 = r2.substring(0, o2);
            i2.add(s2), o2 = (r2 = r2.substring(o2 + n2)).indexOf(e3);
          }
          r2.length > 0 && i2.add(r2);
          for (var a3 = new Array(i2.size()).fill(null), u2 = 0; u2 < a3.length; u2++)
            a3[u2] = i2.get(u2);
          return a3;
        }, jt.toString = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return jt.SIMPLE_ORDINATE_FORMAT.format(t2);
          }
        }, jt.spaces = function(t2) {
          return jt.chars(" ", t2);
        }, Ht.NEWLINE.get = function() {
          return Y.getProperty("line.separator");
        }, Ht.SIMPLE_ORDINATE_FORMAT.get = function() {
          return new function() {
          }("0.#");
        }, Object.defineProperties(jt, Ht);
        var Wt = function() {
        };
        Wt.prototype.interfaces_ = function() {
          return [];
        }, Wt.prototype.getClass = function() {
          return Wt;
        }, Wt.copyCoord = function(t2, e3, n2, i2) {
          for (var r2 = Math.min(t2.getDimension(), n2.getDimension()), o2 = 0; o2 < r2; o2++)
            n2.setOrdinate(i2, o2, t2.getOrdinate(e3, o2));
        }, Wt.isRing = function(t2) {
          var e3 = t2.size();
          return 0 === e3 || !(e3 <= 3) && (t2.getOrdinate(0, V2.X) === t2.getOrdinate(e3 - 1, V2.X) && t2.getOrdinate(0, V2.Y) === t2.getOrdinate(e3 - 1, V2.Y));
        }, Wt.isEqual = function(t2, e3) {
          var n2 = t2.size();
          if (n2 !== e3.size())
            return false;
          for (var i2 = Math.min(t2.getDimension(), e3.getDimension()), r2 = 0; r2 < n2; r2++)
            for (var o2 = 0; o2 < i2; o2++) {
              var s2 = t2.getOrdinate(r2, o2), a3 = e3.getOrdinate(r2, o2);
              if (t2.getOrdinate(r2, o2) !== e3.getOrdinate(r2, o2) && (!v.isNaN(s2) || !v.isNaN(a3)))
                return false;
            }
          return true;
        }, Wt.extend = function(t2, e3, n2) {
          var i2 = t2.create(n2, e3.getDimension()), r2 = e3.size();
          if (Wt.copy(e3, 0, i2, 0, r2), r2 > 0)
            for (var o2 = r2; o2 < n2; o2++)
              Wt.copy(e3, r2 - 1, i2, o2, 1);
          return i2;
        }, Wt.reverse = function(t2) {
          for (var e3 = t2.size() - 1, n2 = Math.trunc(e3 / 2), i2 = 0; i2 <= n2; i2++)
            Wt.swap(t2, i2, e3 - i2);
        }, Wt.swap = function(t2, e3, n2) {
          if (e3 === n2)
            return null;
          for (var i2 = 0; i2 < t2.getDimension(); i2++) {
            var r2 = t2.getOrdinate(e3, i2);
            t2.setOrdinate(e3, i2, t2.getOrdinate(n2, i2)), t2.setOrdinate(n2, i2, r2);
          }
        }, Wt.copy = function(t2, e3, n2, i2, r2) {
          for (var o2 = 0; o2 < r2; o2++)
            Wt.copyCoord(t2, e3 + o2, n2, i2 + o2);
        }, Wt.toString = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = t2.size();
            if (0 === e3)
              return "()";
            var n2 = t2.getDimension(), i2 = new D();
            i2.append("(");
            for (var r2 = 0; r2 < e3; r2++) {
              r2 > 0 && i2.append(" ");
              for (var o2 = 0; o2 < n2; o2++)
                o2 > 0 && i2.append(","), i2.append(jt.toString(t2.getOrdinate(r2, o2)));
            }
            return i2.append(")"), i2.toString();
          }
        }, Wt.ensureValidRing = function(t2, e3) {
          var n2 = e3.size();
          if (0 === n2)
            return e3;
          if (n2 <= 3)
            return Wt.createClosedRing(t2, e3, 4);
          return e3.getOrdinate(0, V2.X) === e3.getOrdinate(n2 - 1, V2.X) && e3.getOrdinate(0, V2.Y) === e3.getOrdinate(n2 - 1, V2.Y) ? e3 : Wt.createClosedRing(t2, e3, n2 + 1);
        }, Wt.createClosedRing = function(t2, e3, n2) {
          var i2 = t2.create(n2, e3.getDimension()), r2 = e3.size();
          Wt.copy(e3, 0, i2, 0, r2);
          for (var o2 = r2; o2 < n2; o2++)
            Wt.copy(e3, 0, i2, o2, 1);
          return i2;
        };
        var Kt = function(t2) {
          function e3(e4, n3) {
            t2.call(this, n3), this._points = null, this.init(e4);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            return this.isEmpty() ? new j() : this._points.expandEnvelope(new j());
          }, e3.prototype.isRing = function() {
            return this.isClosed() && this.isSimple();
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_LINESTRING;
          }, e3.prototype.getCoordinates = function() {
            return this._points.toCoordinateArray();
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4;
              if (this._points.size() !== i2._points.size())
                return false;
              for (var r2 = 0; r2 < this._points.size(); r2++)
                if (!this.equal(this._points.getCoordinate(r2), i2._points.getCoordinate(r2), n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            for (var t3 = 0; t3 < Math.trunc(this._points.size() / 2); t3++) {
              var e4 = this._points.size() - 1 - t3;
              if (!this._points.getCoordinate(t3).equals(this._points.getCoordinate(e4)))
                return this._points.getCoordinate(t3).compareTo(this._points.getCoordinate(e4)) > 0 && Wt.reverse(this._points), null;
            }
          }, e3.prototype.getCoordinate = function() {
            return this.isEmpty() ? null : this._points.getCoordinate(0);
          }, e3.prototype.getBoundaryDimension = function() {
            return this.isClosed() ? qt.FALSE : 0;
          }, e3.prototype.isClosed = function() {
            return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
          }, e3.prototype.getEndPoint = function() {
            return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
          }, e3.prototype.getDimension = function() {
            return 1;
          }, e3.prototype.getLength = function() {
            return at.computeLength(this._points);
          }, e3.prototype.getNumPoints = function() {
            return this._points.size();
          }, e3.prototype.reverse = function() {
            var t3 = this._points.copy();
            Wt.reverse(t3);
            return this.getFactory().createLineString(t3);
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              for (var t3 = arguments[0], e4 = 0, n3 = 0; e4 < this._points.size() && n3 < t3._points.size(); ) {
                var i2 = this._points.getCoordinate(e4).compareTo(t3._points.getCoordinate(n3));
                if (0 !== i2)
                  return i2;
                e4++, n3++;
              }
              return e4 < this._points.size() ? 1 : n3 < t3._points.size() ? -1 : 0;
            }
            if (2 === arguments.length) {
              var r2 = arguments[0];
              return arguments[1].compare(this._points, r2._points);
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft))
              for (var t3 = arguments[0], e4 = 0; e4 < this._points.size(); e4++)
                t3.filter(this._points.getCoordinate(e4));
            else if (T(arguments[0], Ut)) {
              var n3 = arguments[0];
              if (0 === this._points.size())
                return null;
              for (var i2 = 0; i2 < this._points.size() && (n3.filter(this._points, i2), !n3.isDone()); i2++)
                ;
              n3.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              arguments[0].filter(this);
            } else if (T(arguments[0], lt)) {
              arguments[0].filter(this);
            }
          }, e3.prototype.getBoundary = function() {
            return new Yt(this).getBoundary();
          }, e3.prototype.isEquivalentClass = function(t3) {
            return t3 instanceof e3;
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            return e4._points = this._points.clone(), e4;
          }, e3.prototype.getCoordinateN = function(t3) {
            return this._points.getCoordinate(t3);
          }, e3.prototype.getGeometryType = function() {
            return "LineString";
          }, e3.prototype.copy = function() {
            return new e3(this._points.copy(), this._factory);
          }, e3.prototype.getCoordinateSequence = function() {
            return this._points;
          }, e3.prototype.isEmpty = function() {
            return 0 === this._points.size();
          }, e3.prototype.init = function(t3) {
            if (null === t3 && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t3.size())
              throw new m("Invalid number of points in LineString (found " + t3.size() + " - must be 0 or >= 2)");
            this._points = t3;
          }, e3.prototype.isCoordinate = function(t3) {
            for (var e4 = 0; e4 < this._points.size(); e4++)
              if (this._points.getCoordinate(e4).equals(t3))
                return true;
            return false;
          }, e3.prototype.getStartPoint = function() {
            return this.isEmpty() ? null : this.getPointN(0);
          }, e3.prototype.getPointN = function(t3) {
            return this.getFactory().createPoint(this._points.getCoordinate(t3));
          }, e3.prototype.interfaces_ = function() {
            return [At];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 3110669828065365500;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Jt = function() {
        };
        Jt.prototype.interfaces_ = function() {
          return [];
        }, Jt.prototype.getClass = function() {
          return Jt;
        };
        var Qt = function(t2) {
          function e3(e4, n3) {
            t2.call(this, n3), this._coordinates = e4 || null, this.init(this._coordinates);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            if (this.isEmpty())
              return new j();
            var t3 = new j();
            return t3.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t3;
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_POINT;
          }, e3.prototype.getCoordinates = function() {
            return this.isEmpty() ? [] : [this.getCoordinate()];
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && (!(!this.isEmpty() || !e4.isEmpty()) || this.isEmpty() === e4.isEmpty() && this.equal(e4.getCoordinate(), this.getCoordinate(), n3));
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
          }, e3.prototype.getCoordinate = function() {
            return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.getDimension = function() {
            return 0;
          }, e3.prototype.getNumPoints = function() {
            return this.isEmpty() ? 0 : 1;
          }, e3.prototype.reverse = function() {
            return this.copy();
          }, e3.prototype.getX = function() {
            if (null === this.getCoordinate())
              throw new Error("getX called on empty Point");
            return this.getCoordinate().x;
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0];
              return this.getCoordinate().compareTo(t3.getCoordinate());
            }
            if (2 === arguments.length) {
              var e4 = arguments[0];
              return arguments[1].compare(this._coordinates, e4._coordinates);
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft)) {
              var t3 = arguments[0];
              if (this.isEmpty())
                return null;
              t3.filter(this.getCoordinate());
            } else if (T(arguments[0], Ut)) {
              var e4 = arguments[0];
              if (this.isEmpty())
                return null;
              e4.filter(this._coordinates, 0), e4.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              arguments[0].filter(this);
            } else if (T(arguments[0], lt)) {
              arguments[0].filter(this);
            }
          }, e3.prototype.getBoundary = function() {
            return this.getFactory().createGeometryCollection(null);
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            return e4._coordinates = this._coordinates.clone(), e4;
          }, e3.prototype.getGeometryType = function() {
            return "Point";
          }, e3.prototype.copy = function() {
            return new e3(this._coordinates.copy(), this._factory);
          }, e3.prototype.getCoordinateSequence = function() {
            return this._coordinates;
          }, e3.prototype.getY = function() {
            if (null === this.getCoordinate())
              throw new Error("getY called on empty Point");
            return this.getCoordinate().y;
          }, e3.prototype.isEmpty = function() {
            return 0 === this._coordinates.size();
          }, e3.prototype.init = function(t3) {
            null === t3 && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), et.isTrue(t3.size() <= 1), this._coordinates = t3;
          }, e3.prototype.isSimple = function() {
            return true;
          }, e3.prototype.interfaces_ = function() {
            return [Jt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 4902022702746615e3;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Zt = function() {
        };
        Zt.prototype.interfaces_ = function() {
          return [];
        }, Zt.prototype.getClass = function() {
          return Zt;
        };
        var $t = function(t2) {
          function e3(e4, n3, i2) {
            if (t2.call(this, i2), this._shell = null, this._holes = null, null === e4 && (e4 = this.getFactory().createLinearRing()), null === n3 && (n3 = []), t2.hasNullElements(n3))
              throw new m("holes must not contain null elements");
            if (e4.isEmpty() && t2.hasNonEmptyElements(n3))
              throw new m("shell is empty but holes are not");
            this._shell = e4, this._holes = n3;
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            return this._shell.getEnvelopeInternal();
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_POLYGON;
          }, e3.prototype.getCoordinates = function() {
            if (this.isEmpty())
              return [];
            for (var t3 = new Array(this.getNumPoints()).fill(null), e4 = -1, n3 = this._shell.getCoordinates(), i2 = 0; i2 < n3.length; i2++)
              t3[++e4] = n3[i2];
            for (var r2 = 0; r2 < this._holes.length; r2++)
              for (var o2 = this._holes[r2].getCoordinates(), s2 = 0; s2 < o2.length; s2++)
                t3[++e4] = o2[s2];
            return t3;
          }, e3.prototype.getArea = function() {
            var t3 = 0;
            t3 += Math.abs(at.signedArea(this._shell.getCoordinateSequence()));
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3 -= Math.abs(at.signedArea(this._holes[e4].getCoordinateSequence()));
            return t3;
          }, e3.prototype.isRectangle = function() {
            if (0 !== this.getNumInteriorRing())
              return false;
            if (null === this._shell)
              return false;
            if (5 !== this._shell.getNumPoints())
              return false;
            for (var t3 = this._shell.getCoordinateSequence(), e4 = this.getEnvelopeInternal(), n3 = 0; n3 < 5; n3++) {
              var i2 = t3.getX(n3);
              if (i2 !== e4.getMinX() && i2 !== e4.getMaxX())
                return false;
              var r2 = t3.getY(n3);
              if (r2 !== e4.getMinY() && r2 !== e4.getMaxY())
                return false;
            }
            for (var o2 = t3.getX(0), s2 = t3.getY(0), a3 = 1; a3 <= 4; a3++) {
              var u2 = t3.getX(a3), l2 = t3.getY(a3);
              if (u2 !== o2 === (l2 !== s2))
                return false;
              o2 = u2, s2 = l2;
            }
            return true;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4, r2 = this._shell, o2 = i2._shell;
              if (!r2.equalsExact(o2, n3))
                return false;
              if (this._holes.length !== i2._holes.length)
                return false;
              for (var s2 = 0; s2 < this._holes.length; s2++)
                if (!this._holes[s2].equalsExact(i2._holes[s2], n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            if (0 === arguments.length) {
              this.normalize(this._shell, true);
              for (var t3 = 0; t3 < this._holes.length; t3++)
                this.normalize(this._holes[t3], false);
              Gt.sort(this._holes);
            } else if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (e4.isEmpty())
                return null;
              var i2 = new Array(e4.getCoordinates().length - 1).fill(null);
              Y.arraycopy(e4.getCoordinates(), 0, i2, 0, i2.length);
              var r2 = Lt.minCoordinate(e4.getCoordinates());
              Lt.scroll(i2, r2), Y.arraycopy(i2, 0, e4.getCoordinates(), 0, i2.length), e4.getCoordinates()[i2.length] = i2[0], at.isCCW(e4.getCoordinates()) === n3 && Lt.reverse(e4.getCoordinates());
            }
          }, e3.prototype.getCoordinate = function() {
            return this._shell.getCoordinate();
          }, e3.prototype.getNumInteriorRing = function() {
            return this._holes.length;
          }, e3.prototype.getBoundaryDimension = function() {
            return 1;
          }, e3.prototype.getDimension = function() {
            return 2;
          }, e3.prototype.getLength = function() {
            var t3 = 0;
            t3 += this._shell.getLength();
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3 += this._holes[e4].getLength();
            return t3;
          }, e3.prototype.getNumPoints = function() {
            for (var t3 = this._shell.getNumPoints(), e4 = 0; e4 < this._holes.length; e4++)
              t3 += this._holes[e4].getNumPoints();
            return t3;
          }, e3.prototype.reverse = function() {
            var t3 = this.copy();
            t3._shell = this._shell.copy().reverse(), t3._holes = new Array(this._holes.length).fill(null);
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3._holes[e4] = this._holes[e4].copy().reverse();
            return t3;
          }, e3.prototype.convexHull = function() {
            return this.getExteriorRing().convexHull();
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0], e4 = this._shell, n3 = t3._shell;
              return e4.compareToSameClass(n3);
            }
            if (2 === arguments.length) {
              var i2 = arguments[0], r2 = arguments[1], o2 = i2, s2 = this._shell, a3 = o2._shell, u2 = s2.compareToSameClass(a3, r2);
              if (0 !== u2)
                return u2;
              for (var l2 = this.getNumInteriorRing(), c2 = o2.getNumInteriorRing(), p2 = 0; p2 < l2 && p2 < c2; ) {
                var h2 = this.getInteriorRingN(p2), f2 = o2.getInteriorRingN(p2), g2 = h2.compareToSameClass(f2, r2);
                if (0 !== g2)
                  return g2;
                p2++;
              }
              return p2 < l2 ? 1 : p2 < c2 ? -1 : 0;
            }
          }, e3.prototype.apply = function(t3) {
            if (T(t3, ft)) {
              this._shell.apply(t3);
              for (var e4 = 0; e4 < this._holes.length; e4++)
                this._holes[e4].apply(t3);
            } else if (T(t3, Ut)) {
              if (this._shell.apply(t3), !t3.isDone())
                for (var n3 = 0; n3 < this._holes.length && (this._holes[n3].apply(t3), !t3.isDone()); n3++)
                  ;
              t3.isGeometryChanged() && this.geometryChanged();
            } else if (T(t3, Vt))
              t3.filter(this);
            else if (T(t3, lt)) {
              t3.filter(this), this._shell.apply(t3);
              for (var i2 = 0; i2 < this._holes.length; i2++)
                this._holes[i2].apply(t3);
            }
          }, e3.prototype.getBoundary = function() {
            if (this.isEmpty())
              return this.getFactory().createMultiLineString();
            var t3 = new Array(this._holes.length + 1).fill(null);
            t3[0] = this._shell;
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3[e4 + 1] = this._holes[e4];
            return t3.length <= 1 ? this.getFactory().createLinearRing(t3[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t3);
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            e4._shell = this._shell.clone(), e4._holes = new Array(this._holes.length).fill(null);
            for (var n3 = 0; n3 < this._holes.length; n3++)
              e4._holes[n3] = this._holes[n3].clone();
            return e4;
          }, e3.prototype.getGeometryType = function() {
            return "Polygon";
          }, e3.prototype.copy = function() {
            for (var t3 = this._shell.copy(), n3 = new Array(this._holes.length).fill(null), i2 = 0; i2 < n3.length; i2++)
              n3[i2] = this._holes[i2].copy();
            return new e3(t3, n3, this._factory);
          }, e3.prototype.getExteriorRing = function() {
            return this._shell;
          }, e3.prototype.isEmpty = function() {
            return this._shell.isEmpty();
          }, e3.prototype.getInteriorRingN = function(t3) {
            return this._holes[t3];
          }, e3.prototype.interfaces_ = function() {
            return [Zt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -3494792200821764600;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), te = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTIPOINT;
          }, e3.prototype.isValid = function() {
            return true;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getCoordinate = function() {
            if (1 === arguments.length) {
              var e4 = arguments[0];
              return this._geometries[e4].getCoordinate();
            }
            return t2.prototype.getCoordinate.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.getDimension = function() {
            return 0;
          }, e3.prototype.getBoundary = function() {
            return this.getFactory().createGeometryCollection(null);
          }, e3.prototype.getGeometryType = function() {
            return "MultiPoint";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [Jt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -8048474874175356e3;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), ee2 = function(t2) {
          function e3(e4, n3) {
            e4 instanceof C && n3 instanceof _e && (e4 = n3.getCoordinateSequenceFactory().create(e4)), t2.call(this, e4, n3), this.validateConstruction();
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { MINIMUM_VALID_SIZE: { configurable: true }, serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_LINEARRING;
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.isClosed = function() {
            return !!this.isEmpty() || t2.prototype.isClosed.call(this);
          }, e3.prototype.reverse = function() {
            var t3 = this._points.copy();
            Wt.reverse(t3);
            return this.getFactory().createLinearRing(t3);
          }, e3.prototype.validateConstruction = function() {
            if (!this.isEmpty() && !t2.prototype.isClosed.call(this))
              throw new m("Points of LinearRing do not form a closed linestring");
            if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e3.MINIMUM_VALID_SIZE)
              throw new m("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
          }, e3.prototype.getGeometryType = function() {
            return "LinearRing";
          }, e3.prototype.copy = function() {
            return new e3(this._points.copy(), this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.MINIMUM_VALID_SIZE.get = function() {
            return 4;
          }, n2.serialVersionUID.get = function() {
            return -4261142084085851600;
          }, Object.defineProperties(e3, n2), e3;
        }(Kt), ne = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTIPOLYGON;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return 1;
          }, e3.prototype.getDimension = function() {
            return 2;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[n3] = this._geometries[n3].reverse();
            return this.getFactory().createMultiPolygon(e4);
          }, e3.prototype.getBoundary = function() {
            if (this.isEmpty())
              return this.getFactory().createMultiLineString();
            for (var t3 = new Nt(), e4 = 0; e4 < this._geometries.length; e4++)
              for (var n3 = this._geometries[e4].getBoundary(), i2 = 0; i2 < n3.getNumGeometries(); i2++)
                t3.add(n3.getGeometryN(i2));
            var r2 = new Array(t3.size()).fill(null);
            return this.getFactory().createMultiLineString(t3.toArray(r2));
          }, e3.prototype.getGeometryType = function() {
            return "MultiPolygon";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [Zt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -551033529766975900;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), ie = function(t2) {
          this._factory = t2 || null, this._isUserDataCopied = false;
        }, re = { NoOpGeometryOperation: { configurable: true }, CoordinateOperation: { configurable: true }, CoordinateSequenceOperation: { configurable: true } };
        ie.prototype.setCopyUserData = function(t2) {
          this._isUserDataCopied = t2;
        }, ie.prototype.edit = function(t2, e3) {
          if (null === t2)
            return null;
          var n2 = this.editInternal(t2, e3);
          return this._isUserDataCopied && n2.setUserData(t2.getUserData()), n2;
        }, ie.prototype.editInternal = function(t2, e3) {
          return null === this._factory && (this._factory = t2.getFactory()), t2 instanceof zt ? this.editGeometryCollection(t2, e3) : t2 instanceof $t ? this.editPolygon(t2, e3) : t2 instanceof Qt ? e3.edit(t2, this._factory) : t2 instanceof Kt ? e3.edit(t2, this._factory) : (et.shouldNeverReachHere("Unsupported Geometry class: " + t2.getClass().getName()), null);
        }, ie.prototype.editGeometryCollection = function(t2, e3) {
          for (var n2 = e3.edit(t2, this._factory), i2 = new Nt(), r2 = 0; r2 < n2.getNumGeometries(); r2++) {
            var o2 = this.edit(n2.getGeometryN(r2), e3);
            null === o2 || o2.isEmpty() || i2.add(o2);
          }
          return n2.getClass() === te ? this._factory.createMultiPoint(i2.toArray([])) : n2.getClass() === Xt ? this._factory.createMultiLineString(i2.toArray([])) : n2.getClass() === ne ? this._factory.createMultiPolygon(i2.toArray([])) : this._factory.createGeometryCollection(i2.toArray([]));
        }, ie.prototype.editPolygon = function(t2, e3) {
          var n2 = e3.edit(t2, this._factory);
          if (null === n2 && (n2 = this._factory.createPolygon(null)), n2.isEmpty())
            return n2;
          var i2 = this.edit(n2.getExteriorRing(), e3);
          if (null === i2 || i2.isEmpty())
            return this._factory.createPolygon();
          for (var r2 = new Nt(), o2 = 0; o2 < n2.getNumInteriorRing(); o2++) {
            var s2 = this.edit(n2.getInteriorRingN(o2), e3);
            null === s2 || s2.isEmpty() || r2.add(s2);
          }
          return this._factory.createPolygon(i2, r2.toArray([]));
        }, ie.prototype.interfaces_ = function() {
          return [];
        }, ie.prototype.getClass = function() {
          return ie;
        }, ie.GeometryEditorOperation = function() {
        }, re.NoOpGeometryOperation.get = function() {
          return oe;
        }, re.CoordinateOperation.get = function() {
          return se;
        }, re.CoordinateSequenceOperation.get = function() {
          return ae;
        }, Object.defineProperties(ie, re);
        var oe = function() {
        };
        oe.prototype.edit = function(t2, e3) {
          return t2;
        }, oe.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, oe.prototype.getClass = function() {
          return oe;
        };
        var se = function() {
        };
        se.prototype.edit = function(t2, e3) {
          var n2 = this.editCoordinates(t2.getCoordinates(), t2);
          return null === n2 ? t2 : t2 instanceof ee2 ? e3.createLinearRing(n2) : t2 instanceof Kt ? e3.createLineString(n2) : t2 instanceof Qt ? n2.length > 0 ? e3.createPoint(n2[0]) : e3.createPoint() : t2;
        }, se.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, se.prototype.getClass = function() {
          return se;
        };
        var ae = function() {
        };
        ae.prototype.edit = function(t2, e3) {
          return t2 instanceof ee2 ? e3.createLinearRing(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Kt ? e3.createLineString(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Qt ? e3.createPoint(this.edit(t2.getCoordinateSequence(), t2)) : t2;
        }, ae.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, ae.prototype.getClass = function() {
          return ae;
        };
        var ue = function() {
          if (this._dimension = 3, this._coordinates = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array)
              this._coordinates = arguments[0], this._dimension = 3;
            else if (Number.isInteger(arguments[0])) {
              var t2 = arguments[0];
              this._coordinates = new Array(t2).fill(null);
              for (var e3 = 0; e3 < t2; e3++)
                this._coordinates[e3] = new C();
            } else if (T(arguments[0], V2)) {
              var n2 = arguments[0];
              if (null === n2)
                return this._coordinates = new Array(0).fill(null), null;
              this._dimension = n2.getDimension(), this._coordinates = new Array(n2.size()).fill(null);
              for (var i2 = 0; i2 < this._coordinates.length; i2++)
                this._coordinates[i2] = n2.getCoordinateCopy(i2);
            }
          } else if (2 === arguments.length) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var r2 = arguments[0], o2 = arguments[1];
              this._coordinates = r2, this._dimension = o2, null === r2 && (this._coordinates = new Array(0).fill(null));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var s2 = arguments[0], a3 = arguments[1];
              this._coordinates = new Array(s2).fill(null), this._dimension = a3;
              for (var u2 = 0; u2 < s2; u2++)
                this._coordinates[u2] = new C();
            }
          }
        }, le = { serialVersionUID: { configurable: true } };
        ue.prototype.setOrdinate = function(t2, e3, n2) {
          switch (e3) {
            case V2.X:
              this._coordinates[t2].x = n2;
              break;
            case V2.Y:
              this._coordinates[t2].y = n2;
              break;
            case V2.Z:
              this._coordinates[t2].z = n2;
              break;
            default:
              throw new m("invalid ordinateIndex");
          }
        }, ue.prototype.size = function() {
          return this._coordinates.length;
        }, ue.prototype.getOrdinate = function(t2, e3) {
          switch (e3) {
            case V2.X:
              return this._coordinates[t2].x;
            case V2.Y:
              return this._coordinates[t2].y;
            case V2.Z:
              return this._coordinates[t2].z;
          }
          return v.NaN;
        }, ue.prototype.getCoordinate = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this._coordinates[t2];
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            n2.x = this._coordinates[e3].x, n2.y = this._coordinates[e3].y, n2.z = this._coordinates[e3].z;
          }
        }, ue.prototype.getCoordinateCopy = function(t2) {
          return new C(this._coordinates[t2]);
        }, ue.prototype.getDimension = function() {
          return this._dimension;
        }, ue.prototype.getX = function(t2) {
          return this._coordinates[t2].x;
        }, ue.prototype.clone = function() {
          for (var t2 = new Array(this.size()).fill(null), e3 = 0; e3 < this._coordinates.length; e3++)
            t2[e3] = this._coordinates[e3].clone();
          return new ue(t2, this._dimension);
        }, ue.prototype.expandEnvelope = function(t2) {
          for (var e3 = 0; e3 < this._coordinates.length; e3++)
            t2.expandToInclude(this._coordinates[e3]);
          return t2;
        }, ue.prototype.copy = function() {
          for (var t2 = new Array(this.size()).fill(null), e3 = 0; e3 < this._coordinates.length; e3++)
            t2[e3] = this._coordinates[e3].copy();
          return new ue(t2, this._dimension);
        }, ue.prototype.toString = function() {
          if (this._coordinates.length > 0) {
            var t2 = new D(17 * this._coordinates.length);
            t2.append("("), t2.append(this._coordinates[0]);
            for (var e3 = 1; e3 < this._coordinates.length; e3++)
              t2.append(", "), t2.append(this._coordinates[e3]);
            return t2.append(")"), t2.toString();
          }
          return "()";
        }, ue.prototype.getY = function(t2) {
          return this._coordinates[t2].y;
        }, ue.prototype.toCoordinateArray = function() {
          return this._coordinates;
        }, ue.prototype.interfaces_ = function() {
          return [V2, e];
        }, ue.prototype.getClass = function() {
          return ue;
        }, le.serialVersionUID.get = function() {
          return -915438501601840600;
        }, Object.defineProperties(ue, le);
        var ce = function() {
        }, pe = { serialVersionUID: { configurable: true }, instanceObject: { configurable: true } };
        ce.prototype.readResolve = function() {
          return ce.instance();
        }, ce.prototype.create = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return new ue(t2);
            }
            if (T(arguments[0], V2)) {
              var e3 = arguments[0];
              return new ue(e3);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return i2 > 3 && (i2 = 3), i2 < 2 ? new ue(n2) : new ue(n2, i2);
          }
        }, ce.prototype.interfaces_ = function() {
          return [b, e];
        }, ce.prototype.getClass = function() {
          return ce;
        }, ce.instance = function() {
          return ce.instanceObject;
        }, pe.serialVersionUID.get = function() {
          return -4099577099607551500;
        }, pe.instanceObject.get = function() {
          return new ce();
        }, Object.defineProperties(ce, pe);
        var he = function(t2) {
          function e3() {
            t2.call(this), this.map_ = /* @__PURE__ */ new Map();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.get = function(t3) {
            return this.map_.get(t3) || null;
          }, e3.prototype.put = function(t3, e4) {
            return this.map_.set(t3, e4), e4;
          }, e3.prototype.values = function() {
            for (var t3 = new Nt(), e4 = this.map_.values(), n2 = e4.next(); !n2.done; )
              t3.add(n2.value), n2 = e4.next();
            return t3;
          }, e3.prototype.entrySet = function() {
            var t3 = new Pt();
            return this.map_.entries().forEach(function(e4) {
              return t3.add(e4);
            }), t3;
          }, e3.prototype.size = function() {
            return this.map_.size();
          }, e3;
        }(Tt), fe = function t2() {
          if (this._modelType = null, this._scale = null, 0 === arguments.length)
            this._modelType = t2.FLOATING;
          else if (1 === arguments.length) {
            if (arguments[0] instanceof de) {
              var e3 = arguments[0];
              this._modelType = e3, e3 === t2.FIXED && this.setScale(1);
            } else if ("number" == typeof arguments[0]) {
              var n2 = arguments[0];
              this._modelType = t2.FIXED, this.setScale(n2);
            } else if (arguments[0] instanceof t2) {
              var i2 = arguments[0];
              this._modelType = i2._modelType, this._scale = i2._scale;
            }
          }
        }, ge = { serialVersionUID: { configurable: true }, maximumPreciseValue: { configurable: true } };
        fe.prototype.equals = function(t2) {
          if (!(t2 instanceof fe))
            return false;
          var e3 = t2;
          return this._modelType === e3._modelType && this._scale === e3._scale;
        }, fe.prototype.compareTo = function(t2) {
          var e3 = t2, n2 = this.getMaximumSignificantDigits(), i2 = e3.getMaximumSignificantDigits();
          return new M(n2).compareTo(new M(i2));
        }, fe.prototype.getScale = function() {
          return this._scale;
        }, fe.prototype.isFloating = function() {
          return this._modelType === fe.FLOATING || this._modelType === fe.FLOATING_SINGLE;
        }, fe.prototype.getType = function() {
          return this._modelType;
        }, fe.prototype.toString = function() {
          var t2 = "UNKNOWN";
          return this._modelType === fe.FLOATING ? t2 = "Floating" : this._modelType === fe.FLOATING_SINGLE ? t2 = "Floating-Single" : this._modelType === fe.FIXED && (t2 = "Fixed (Scale=" + this.getScale() + ")"), t2;
        }, fe.prototype.makePrecise = function() {
          if ("number" == typeof arguments[0]) {
            var t2 = arguments[0];
            if (v.isNaN(t2))
              return t2;
            if (this._modelType === fe.FLOATING_SINGLE) {
              return t2;
            }
            return this._modelType === fe.FIXED ? Math.round(t2 * this._scale) / this._scale : t2;
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            if (this._modelType === fe.FLOATING)
              return null;
            e3.x = this.makePrecise(e3.x), e3.y = this.makePrecise(e3.y);
          }
        }, fe.prototype.getMaximumSignificantDigits = function() {
          var t2 = 16;
          return this._modelType === fe.FLOATING ? t2 = 16 : this._modelType === fe.FLOATING_SINGLE ? t2 = 6 : this._modelType === fe.FIXED && (t2 = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t2;
        }, fe.prototype.setScale = function(t2) {
          this._scale = Math.abs(t2);
        }, fe.prototype.interfaces_ = function() {
          return [e, E];
        }, fe.prototype.getClass = function() {
          return fe;
        }, fe.mostPrecise = function(t2, e3) {
          return t2.compareTo(e3) >= 0 ? t2 : e3;
        }, ge.serialVersionUID.get = function() {
          return 7777263578777804e3;
        }, ge.maximumPreciseValue.get = function() {
          return 9007199254740992;
        }, Object.defineProperties(fe, ge);
        var de = function t2(e3) {
          this._name = e3 || null, t2.nameToTypeMap.put(e3, this);
        }, ye = { serialVersionUID: { configurable: true }, nameToTypeMap: { configurable: true } };
        de.prototype.readResolve = function() {
          return de.nameToTypeMap.get(this._name);
        }, de.prototype.toString = function() {
          return this._name;
        }, de.prototype.interfaces_ = function() {
          return [e];
        }, de.prototype.getClass = function() {
          return de;
        }, ye.serialVersionUID.get = function() {
          return -552860263173159e4;
        }, ye.nameToTypeMap.get = function() {
          return new he();
        }, Object.defineProperties(de, ye), fe.Type = de, fe.FIXED = new de("FIXED"), fe.FLOATING = new de("FLOATING"), fe.FLOATING_SINGLE = new de("FLOATING SINGLE");
        var _e = function t2() {
          this._precisionModel = new fe(), this._SRID = 0, this._coordinateSequenceFactory = t2.getDefaultCoordinateSequenceFactory(), 0 === arguments.length || (1 === arguments.length ? T(arguments[0], b) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof fe && (this._precisionModel = arguments[0]) : 2 === arguments.length ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : 3 === arguments.length && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]));
        }, me = { serialVersionUID: { configurable: true } };
        _e.prototype.toGeometry = function(t2) {
          return t2.isNull() ? this.createPoint(null) : t2.getMinX() === t2.getMaxX() && t2.getMinY() === t2.getMaxY() ? this.createPoint(new C(t2.getMinX(), t2.getMinY())) : t2.getMinX() === t2.getMaxX() || t2.getMinY() === t2.getMaxY() ? this.createLineString([new C(t2.getMinX(), t2.getMinY()), new C(t2.getMaxX(), t2.getMaxY())]) : this.createPolygon(this.createLinearRing([new C(t2.getMinX(), t2.getMinY()), new C(t2.getMinX(), t2.getMaxY()), new C(t2.getMaxX(), t2.getMaxY()), new C(t2.getMaxX(), t2.getMinY()), new C(t2.getMinX(), t2.getMinY())]), null);
        }, _e.prototype.createLineString = function(t2) {
          return t2 ? t2 instanceof Array ? new Kt(this.getCoordinateSequenceFactory().create(t2), this) : T(t2, V2) ? new Kt(t2, this) : void 0 : new Kt(this.getCoordinateSequenceFactory().create([]), this);
        }, _e.prototype.createMultiLineString = function() {
          if (0 === arguments.length)
            return new Xt(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Xt(t2, this);
          }
        }, _e.prototype.buildGeometry = function(t2) {
          for (var e3 = null, n2 = false, i2 = false, r2 = t2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = o2.getClass();
            null === e3 && (e3 = s2), s2 !== e3 && (n2 = true), o2.isGeometryCollectionOrDerived() && (i2 = true);
          }
          if (null === e3)
            return this.createGeometryCollection();
          if (n2 || i2)
            return this.createGeometryCollection(_e.toGeometryArray(t2));
          var a3 = t2.iterator().next();
          if (t2.size() > 1) {
            if (a3 instanceof $t)
              return this.createMultiPolygon(_e.toPolygonArray(t2));
            if (a3 instanceof Kt)
              return this.createMultiLineString(_e.toLineStringArray(t2));
            if (a3 instanceof Qt)
              return this.createMultiPoint(_e.toPointArray(t2));
            et.shouldNeverReachHere("Unhandled class: " + a3.getClass().getName());
          }
          return a3;
        }, _e.prototype.createMultiPointFromCoords = function(t2) {
          return this.createMultiPoint(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
        }, _e.prototype.createPoint = function() {
          if (0 === arguments.length)
            return this.createPoint(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              return this.createPoint(null !== t2 ? this.getCoordinateSequenceFactory().create([t2]) : null);
            }
            if (T(arguments[0], V2)) {
              var e3 = arguments[0];
              return new Qt(e3, this);
            }
          }
        }, _e.prototype.getCoordinateSequenceFactory = function() {
          return this._coordinateSequenceFactory;
        }, _e.prototype.createPolygon = function() {
          if (0 === arguments.length)
            return new $t(null, null, this);
          if (1 === arguments.length) {
            if (T(arguments[0], V2)) {
              var t2 = arguments[0];
              return this.createPolygon(this.createLinearRing(t2));
            }
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              return this.createPolygon(this.createLinearRing(e3));
            }
            if (arguments[0] instanceof ee2) {
              var n2 = arguments[0];
              return this.createPolygon(n2, null);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return new $t(i2, r2, this);
          }
        }, _e.prototype.getSRID = function() {
          return this._SRID;
        }, _e.prototype.createGeometryCollection = function() {
          if (0 === arguments.length)
            return new zt(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new zt(t2, this);
          }
        }, _e.prototype.createGeometry = function(t2) {
          return new ie(this).edit(t2, { edit: function() {
            if (2 === arguments.length) {
              var t3 = arguments[0];
              return this._coordinateSequenceFactory.create(t3);
            }
          } });
        }, _e.prototype.getPrecisionModel = function() {
          return this._precisionModel;
        }, _e.prototype.createLinearRing = function() {
          if (0 === arguments.length)
            return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return this.createLinearRing(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
            }
            if (T(arguments[0], V2)) {
              var e3 = arguments[0];
              return new ee2(e3, this);
            }
          }
        }, _e.prototype.createMultiPolygon = function() {
          if (0 === arguments.length)
            return new ne(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new ne(t2, this);
          }
        }, _e.prototype.createMultiPoint = function() {
          if (0 === arguments.length)
            return new te(null, this);
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return new te(t2, this);
            }
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              return this.createMultiPoint(null !== e3 ? this.getCoordinateSequenceFactory().create(e3) : null);
            }
            if (T(arguments[0], V2)) {
              var n2 = arguments[0];
              if (null === n2)
                return this.createMultiPoint(new Array(0).fill(null));
              for (var i2 = new Array(n2.size()).fill(null), r2 = 0; r2 < n2.size(); r2++) {
                var o2 = this.getCoordinateSequenceFactory().create(1, n2.getDimension());
                Wt.copy(n2, r2, o2, 0, 1), i2[r2] = this.createPoint(o2);
              }
              return this.createMultiPoint(i2);
            }
          }
        }, _e.prototype.interfaces_ = function() {
          return [e];
        }, _e.prototype.getClass = function() {
          return _e;
        }, _e.toMultiPolygonArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toGeometryArray = function(t2) {
          if (null === t2)
            return null;
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.getDefaultCoordinateSequenceFactory = function() {
          return ce.instance();
        }, _e.toMultiLineStringArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toLineStringArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toMultiPointArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toLinearRingArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toPointArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toPolygonArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.createPointFromInternalCoord = function(t2, e3) {
          return e3.getPrecisionModel().makePrecise(t2), e3.getFactory().createPoint(t2);
        }, me.serialVersionUID.get = function() {
          return -6820524753094096e3;
        }, Object.defineProperties(_e, me);
        var ve = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Ie = function(t2) {
          this.geometryFactory = t2 || new _e();
        };
        Ie.prototype.read = function(t2) {
          var e3, n2 = (e3 = "string" == typeof t2 ? JSON.parse(t2) : t2).type;
          if (!Ee[n2])
            throw new Error("Unknown GeoJSON type: " + e3.type);
          return -1 !== ve.indexOf(n2) ? Ee[n2].apply(this, [e3.coordinates]) : "GeometryCollection" === n2 ? Ee[n2].apply(this, [e3.geometries]) : Ee[n2].apply(this, [e3]);
        }, Ie.prototype.write = function(t2) {
          var e3 = t2.getGeometryType();
          if (!xe[e3])
            throw new Error("Geometry is not supported");
          return xe[e3].apply(this, [t2]);
        };
        var Ee = { Feature: function(t2) {
          var e3 = {};
          for (var n2 in t2)
            e3[n2] = t2[n2];
          if (t2.geometry) {
            var i2 = t2.geometry.type;
            if (!Ee[i2])
              throw new Error("Unknown GeoJSON type: " + t2.type);
            e3.geometry = this.read(t2.geometry);
          }
          return t2.bbox && (e3.bbox = Ee.bbox.apply(this, [t2.bbox])), e3;
        }, FeatureCollection: function(t2) {
          var e3 = {};
          if (t2.features) {
            e3.features = [];
            for (var n2 = 0; n2 < t2.features.length; ++n2)
              e3.features.push(this.read(t2.features[n2]));
          }
          return t2.bbox && (e3.bbox = this.parse.bbox.apply(this, [t2.bbox])), e3;
        }, coordinates: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(new C(i2[0], i2[1]));
          }
          return e3;
        }, bbox: function(t2) {
          return this.geometryFactory.createLinearRing([new C(t2[0], t2[1]), new C(t2[2], t2[1]), new C(t2[2], t2[3]), new C(t2[0], t2[3]), new C(t2[0], t2[1])]);
        }, Point: function(t2) {
          var e3 = new C(t2[0], t2[1]);
          return this.geometryFactory.createPoint(e3);
        }, MultiPoint: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2)
            e3.push(Ee.Point.apply(this, [t2[n2]]));
          return this.geometryFactory.createMultiPoint(e3);
        }, LineString: function(t2) {
          var e3 = Ee.coordinates.apply(this, [t2]);
          return this.geometryFactory.createLineString(e3);
        }, MultiLineString: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2)
            e3.push(Ee.LineString.apply(this, [t2[n2]]));
          return this.geometryFactory.createMultiLineString(e3);
        }, Polygon: function(t2) {
          for (var e3 = Ee.coordinates.apply(this, [t2[0]]), n2 = this.geometryFactory.createLinearRing(e3), i2 = [], r2 = 1; r2 < t2.length; ++r2) {
            var o2 = t2[r2], s2 = Ee.coordinates.apply(this, [o2]), a3 = this.geometryFactory.createLinearRing(s2);
            i2.push(a3);
          }
          return this.geometryFactory.createPolygon(n2, i2);
        }, MultiPolygon: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(Ee.Polygon.apply(this, [i2]));
          }
          return this.geometryFactory.createMultiPolygon(e3);
        }, GeometryCollection: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(this.read(i2));
          }
          return this.geometryFactory.createGeometryCollection(e3);
        } }, xe = { coordinate: function(t2) {
          return [t2.x, t2.y];
        }, Point: function(t2) {
          return { type: "Point", coordinates: xe.coordinate.apply(this, [t2.getCoordinate()]) };
        }, MultiPoint: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.Point.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiPoint", coordinates: e3 };
        }, LineString: function(t2) {
          for (var e3 = [], n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; ++i2) {
            var r2 = n2[i2];
            e3.push(xe.coordinate.apply(this, [r2]));
          }
          return { type: "LineString", coordinates: e3 };
        }, MultiLineString: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.LineString.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiLineString", coordinates: e3 };
        }, Polygon: function(t2) {
          var e3 = [], n2 = xe.LineString.apply(this, [t2._shell]);
          e3.push(n2.coordinates);
          for (var i2 = 0; i2 < t2._holes.length; ++i2) {
            var r2 = t2._holes[i2], o2 = xe.LineString.apply(this, [r2]);
            e3.push(o2.coordinates);
          }
          return { type: "Polygon", coordinates: e3 };
        }, MultiPolygon: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.Polygon.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiPolygon", coordinates: e3 };
        }, GeometryCollection: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = i2.getGeometryType();
            e3.push(xe[r2].apply(this, [i2]));
          }
          return { type: "GeometryCollection", geometries: e3 };
        } }, Ne = function(t2) {
          this.geometryFactory = t2 || new _e(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Ie(this.geometryFactory);
        };
        Ne.prototype.read = function(t2) {
          var e3 = this.parser.read(t2);
          return this.precisionModel.getType() === fe.FIXED && this.reducePrecision(e3), e3;
        }, Ne.prototype.reducePrecision = function(t2) {
          var e3, n2;
          if (t2.coordinate)
            this.precisionModel.makePrecise(t2.coordinate);
          else if (t2.points)
            for (e3 = 0, n2 = t2.points.length; e3 < n2; e3++)
              this.precisionModel.makePrecise(t2.points[e3]);
          else if (t2.geometries)
            for (e3 = 0, n2 = t2.geometries.length; e3 < n2; e3++)
              this.reducePrecision(t2.geometries[e3]);
        };
        var Ce = function() {
          this.parser = new Ie(this.geometryFactory);
        };
        Ce.prototype.write = function(t2) {
          return this.parser.write(t2);
        };
        var Se = function() {
        }, Le = { ON: { configurable: true }, LEFT: { configurable: true }, RIGHT: { configurable: true } };
        Se.prototype.interfaces_ = function() {
          return [];
        }, Se.prototype.getClass = function() {
          return Se;
        }, Se.opposite = function(t2) {
          return t2 === Se.LEFT ? Se.RIGHT : t2 === Se.RIGHT ? Se.LEFT : t2;
        }, Le.ON.get = function() {
          return 0;
        }, Le.LEFT.get = function() {
          return 1;
        }, Le.RIGHT.get = function() {
          return 2;
        }, Object.defineProperties(Se, Le), (d.prototype = new Error()).name = "EmptyStackException", (y3.prototype = new xt()).add = function(t2) {
          return this.array_.push(t2), true;
        }, y3.prototype.get = function(t2) {
          if (t2 < 0 || t2 >= this.size())
            throw new Error();
          return this.array_[t2];
        }, y3.prototype.push = function(t2) {
          return this.array_.push(t2), t2;
        }, y3.prototype.pop = function(t2) {
          if (0 === this.array_.length)
            throw new d();
          return this.array_.pop();
        }, y3.prototype.peek = function() {
          if (0 === this.array_.length)
            throw new d();
          return this.array_[this.array_.length - 1];
        }, y3.prototype.empty = function() {
          return 0 === this.array_.length;
        }, y3.prototype.isEmpty = function() {
          return this.empty();
        }, y3.prototype.search = function(t2) {
          return this.array_.indexOf(t2);
        }, y3.prototype.size = function() {
          return this.array_.length;
        }, y3.prototype.toArray = function() {
          for (var t2 = [], e3 = 0, n2 = this.array_.length; e3 < n2; e3++)
            t2.push(this.array_[e3]);
          return t2;
        };
        var be = function() {
          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
        };
        be.prototype.getCoordinate = function() {
          return this._minCoord;
        }, be.prototype.getRightmostSide = function(t2, e3) {
          var n2 = this.getRightmostSideOfSegment(t2, e3);
          return n2 < 0 && (n2 = this.getRightmostSideOfSegment(t2, e3 - 1)), n2 < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t2)), n2;
        }, be.prototype.findRightmostEdgeAtVertex = function() {
          var t2 = this._minDe.getEdge().getCoordinates();
          et.isTrue(this._minIndex > 0 && this._minIndex < t2.length, "rightmost point expected to be interior vertex of edge");
          var e3 = t2[this._minIndex - 1], n2 = t2[this._minIndex + 1], i2 = at.computeOrientation(this._minCoord, n2, e3), r2 = false;
          e3.y < this._minCoord.y && n2.y < this._minCoord.y && i2 === at.COUNTERCLOCKWISE ? r2 = true : e3.y > this._minCoord.y && n2.y > this._minCoord.y && i2 === at.CLOCKWISE && (r2 = true), r2 && (this._minIndex = this._minIndex - 1);
        }, be.prototype.getRightmostSideOfSegment = function(t2, e3) {
          var n2 = t2.getEdge().getCoordinates();
          if (e3 < 0 || e3 + 1 >= n2.length)
            return -1;
          if (n2[e3].y === n2[e3 + 1].y)
            return -1;
          var i2 = Se.LEFT;
          return n2[e3].y < n2[e3 + 1].y && (i2 = Se.RIGHT), i2;
        }, be.prototype.getEdge = function() {
          return this._orientedDe;
        }, be.prototype.checkForRightmostCoordinate = function(t2) {
          for (var e3 = t2.getEdge().getCoordinates(), n2 = 0; n2 < e3.length - 1; n2++)
            (null === this._minCoord || e3[n2].x > this._minCoord.x) && (this._minDe = t2, this._minIndex = n2, this._minCoord = e3[n2]);
        }, be.prototype.findRightmostEdgeAtNode = function() {
          var t2 = this._minDe.getNode().getEdges();
          this._minDe = t2.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
        }, be.prototype.findEdge = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            n2.isForward() && this.checkForRightmostCoordinate(n2);
          }
          et.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe;
          this.getRightmostSide(this._minDe, this._minIndex) === Se.LEFT && (this._orientedDe = this._minDe.getSym());
        }, be.prototype.interfaces_ = function() {
          return [];
        }, be.prototype.getClass = function() {
          return be;
        };
        var we = function(t2) {
          function e3(n2, i2) {
            t2.call(this, e3.msgWithCoord(n2, i2)), this.pt = i2 ? new C(i2) : null, this.name = "TopologyException";
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getCoordinate = function() {
            return this.pt;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.msgWithCoord = function(t3, e4) {
            return e4 ? t3 : t3 + " [ " + e4 + " ]";
          }, e3;
        }($), Oe = function() {
          this.array_ = [];
        };
        Oe.prototype.addLast = function(t2) {
          this.array_.push(t2);
        }, Oe.prototype.removeFirst = function() {
          return this.array_.shift();
        }, Oe.prototype.isEmpty = function() {
          return 0 === this.array_.length;
        };
        var Te = function() {
          this._finder = null, this._dirEdgeList = new Nt(), this._nodes = new Nt(), this._rightMostCoord = null, this._env = null, this._finder = new be();
        };
        Te.prototype.clearVisitedEdges = function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            t2.next().setVisited(false);
          }
        }, Te.prototype.getRightmostCoordinate = function() {
          return this._rightMostCoord;
        }, Te.prototype.computeNodeDepth = function(t2) {
          for (var e3 = null, n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isVisited() || i2.getSym().isVisited()) {
              e3 = i2;
              break;
            }
          }
          if (null === e3)
            throw new we("unable to find edge to compute depths at " + t2.getCoordinate());
          t2.getEdges().computeDepths(e3);
          for (var r2 = t2.getEdges().iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            o2.setVisited(true), this.copySymDepths(o2);
          }
        }, Te.prototype.computeDepth = function(t2) {
          this.clearVisitedEdges();
          var e3 = this._finder.getEdge();
          e3.setEdgeDepths(Se.RIGHT, t2), this.copySymDepths(e3), this.computeDepths(e3);
        }, Te.prototype.create = function(t2) {
          this.addReachable(t2), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
        }, Te.prototype.findResultEdges = function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            var e3 = t2.next();
            e3.getDepth(Se.RIGHT) >= 1 && e3.getDepth(Se.LEFT) <= 0 && !e3.isInteriorAreaEdge() && e3.setInResult(true);
          }
        }, Te.prototype.computeDepths = function(t2) {
          var e3 = new Pt(), n2 = new Oe(), i2 = t2.getNode();
          for (n2.addLast(i2), e3.add(i2), t2.setVisited(true); !n2.isEmpty(); ) {
            var r2 = n2.removeFirst();
            e3.add(r2), this.computeNodeDepth(r2);
            for (var o2 = r2.getEdges().iterator(); o2.hasNext(); ) {
              var s2 = o2.next().getSym();
              if (!s2.isVisited()) {
                var a3 = s2.getNode();
                e3.contains(a3) || (n2.addLast(a3), e3.add(a3));
              }
            }
          }
        }, Te.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._rightMostCoord.x < e3._rightMostCoord.x ? -1 : this._rightMostCoord.x > e3._rightMostCoord.x ? 1 : 0;
        }, Te.prototype.getEnvelope = function() {
          if (null === this._env) {
            for (var t2 = new j(), e3 = this._dirEdgeList.iterator(); e3.hasNext(); )
              for (var n2 = e3.next().getEdge().getCoordinates(), i2 = 0; i2 < n2.length - 1; i2++)
                t2.expandToInclude(n2[i2]);
            this._env = t2;
          }
          return this._env;
        }, Te.prototype.addReachable = function(t2) {
          var e3 = new y3();
          for (e3.add(t2); !e3.empty(); ) {
            var n2 = e3.pop();
            this.add(n2, e3);
          }
        }, Te.prototype.copySymDepths = function(t2) {
          var e3 = t2.getSym();
          e3.setDepth(Se.LEFT, t2.getDepth(Se.RIGHT)), e3.setDepth(Se.RIGHT, t2.getDepth(Se.LEFT));
        }, Te.prototype.add = function(t2, e3) {
          t2.setVisited(true), this._nodes.add(t2);
          for (var n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this._dirEdgeList.add(i2);
            var r2 = i2.getSym().getNode();
            r2.isVisited() || e3.push(r2);
          }
        }, Te.prototype.getNodes = function() {
          return this._nodes;
        }, Te.prototype.getDirectedEdges = function() {
          return this._dirEdgeList;
        }, Te.prototype.interfaces_ = function() {
          return [E];
        }, Te.prototype.getClass = function() {
          return Te;
        };
        var Re = function t2() {
          if (this.location = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              this.init(e3.length);
            } else if (Number.isInteger(arguments[0])) {
              var n2 = arguments[0];
              this.init(1), this.location[Se.ON] = n2;
            } else if (arguments[0] instanceof t2) {
              var i2 = arguments[0];
              if (this.init(i2.location.length), null !== i2)
                for (var r2 = 0; r2 < this.location.length; r2++)
                  this.location[r2] = i2.location[r2];
            }
          } else if (3 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a3 = arguments[2];
            this.init(3), this.location[Se.ON] = o2, this.location[Se.LEFT] = s2, this.location[Se.RIGHT] = a3;
          }
        };
        Re.prototype.setAllLocations = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            this.location[e3] = t2;
        }, Re.prototype.isNull = function() {
          for (var t2 = 0; t2 < this.location.length; t2++)
            if (this.location[t2] !== w.NONE)
              return false;
          return true;
        }, Re.prototype.setAllLocationsIfNull = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            this.location[e3] === w.NONE && (this.location[e3] = t2);
        }, Re.prototype.isLine = function() {
          return 1 === this.location.length;
        }, Re.prototype.merge = function(t2) {
          if (t2.location.length > this.location.length) {
            var e3 = new Array(3).fill(null);
            e3[Se.ON] = this.location[Se.ON], e3[Se.LEFT] = w.NONE, e3[Se.RIGHT] = w.NONE, this.location = e3;
          }
          for (var n2 = 0; n2 < this.location.length; n2++)
            this.location[n2] === w.NONE && n2 < t2.location.length && (this.location[n2] = t2.location[n2]);
        }, Re.prototype.getLocations = function() {
          return this.location;
        }, Re.prototype.flip = function() {
          if (this.location.length <= 1)
            return null;
          var t2 = this.location[Se.LEFT];
          this.location[Se.LEFT] = this.location[Se.RIGHT], this.location[Se.RIGHT] = t2;
        }, Re.prototype.toString = function() {
          var t2 = new D();
          return this.location.length > 1 && t2.append(w.toLocationSymbol(this.location[Se.LEFT])), t2.append(w.toLocationSymbol(this.location[Se.ON])), this.location.length > 1 && t2.append(w.toLocationSymbol(this.location[Se.RIGHT])), t2.toString();
        }, Re.prototype.setLocations = function(t2, e3, n2) {
          this.location[Se.ON] = t2, this.location[Se.LEFT] = e3, this.location[Se.RIGHT] = n2;
        }, Re.prototype.get = function(t2) {
          return t2 < this.location.length ? this.location[t2] : w.NONE;
        }, Re.prototype.isArea = function() {
          return this.location.length > 1;
        }, Re.prototype.isAnyNull = function() {
          for (var t2 = 0; t2 < this.location.length; t2++)
            if (this.location[t2] === w.NONE)
              return true;
          return false;
        }, Re.prototype.setLocation = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setLocation(Se.ON, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this.location[e3] = n2;
          }
        }, Re.prototype.init = function(t2) {
          this.location = new Array(t2).fill(null), this.setAllLocations(w.NONE);
        }, Re.prototype.isEqualOnSide = function(t2, e3) {
          return this.location[e3] === t2.location[e3];
        }, Re.prototype.allPositionsEqual = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            if (this.location[e3] !== t2)
              return false;
          return true;
        }, Re.prototype.interfaces_ = function() {
          return [];
        }, Re.prototype.getClass = function() {
          return Re;
        };
        var Pe = function t2() {
          if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
            if (Number.isInteger(arguments[0])) {
              var e3 = arguments[0];
              this.elt[0] = new Re(e3), this.elt[1] = new Re(e3);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.elt[0] = new Re(n2.elt[0]), this.elt[1] = new Re(n2.elt[1]);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.elt[0] = new Re(w.NONE), this.elt[1] = new Re(w.NONE), this.elt[i2].setLocation(r2);
          } else if (3 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a3 = arguments[2];
            this.elt[0] = new Re(o2, s2, a3), this.elt[1] = new Re(o2, s2, a3);
          } else if (4 === arguments.length) {
            var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2], p2 = arguments[3];
            this.elt[0] = new Re(w.NONE, w.NONE, w.NONE), this.elt[1] = new Re(w.NONE, w.NONE, w.NONE), this.elt[u2].setLocations(l2, c2, p2);
          }
        };
        Pe.prototype.getGeometryCount = function() {
          var t2 = 0;
          return this.elt[0].isNull() || t2++, this.elt[1].isNull() || t2++, t2;
        }, Pe.prototype.setAllLocations = function(t2, e3) {
          this.elt[t2].setAllLocations(e3);
        }, Pe.prototype.isNull = function(t2) {
          return this.elt[t2].isNull();
        }, Pe.prototype.setAllLocationsIfNull = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setAllLocationsIfNull(0, t2), this.setAllLocationsIfNull(1, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this.elt[e3].setAllLocationsIfNull(n2);
          }
        }, Pe.prototype.isLine = function(t2) {
          return this.elt[t2].isLine();
        }, Pe.prototype.merge = function(t2) {
          for (var e3 = 0; e3 < 2; e3++)
            null === this.elt[e3] && null !== t2.elt[e3] ? this.elt[e3] = new Re(t2.elt[e3]) : this.elt[e3].merge(t2.elt[e3]);
        }, Pe.prototype.flip = function() {
          this.elt[0].flip(), this.elt[1].flip();
        }, Pe.prototype.getLocation = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.elt[t2].get(Se.ON);
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return this.elt[e3].get(n2);
          }
        }, Pe.prototype.toString = function() {
          var t2 = new D();
          return null !== this.elt[0] && (t2.append("A:"), t2.append(this.elt[0].toString())), null !== this.elt[1] && (t2.append(" B:"), t2.append(this.elt[1].toString())), t2.toString();
        }, Pe.prototype.isArea = function() {
          if (0 === arguments.length)
            return this.elt[0].isArea() || this.elt[1].isArea();
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.elt[t2].isArea();
          }
        }, Pe.prototype.isAnyNull = function(t2) {
          return this.elt[t2].isAnyNull();
        }, Pe.prototype.setLocation = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this.elt[t2].setLocation(Se.ON, e3);
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this.elt[n2].setLocation(i2, r2);
          }
        }, Pe.prototype.isEqualOnSide = function(t2, e3) {
          return this.elt[0].isEqualOnSide(t2.elt[0], e3) && this.elt[1].isEqualOnSide(t2.elt[1], e3);
        }, Pe.prototype.allPositionsEqual = function(t2, e3) {
          return this.elt[t2].allPositionsEqual(e3);
        }, Pe.prototype.toLine = function(t2) {
          this.elt[t2].isArea() && (this.elt[t2] = new Re(this.elt[t2].location[0]));
        }, Pe.prototype.interfaces_ = function() {
          return [];
        }, Pe.prototype.getClass = function() {
          return Pe;
        }, Pe.toLineLabel = function(t2) {
          for (var e3 = new Pe(w.NONE), n2 = 0; n2 < 2; n2++)
            e3.setLocation(n2, t2.getLocation(n2));
          return e3;
        };
        var De = function() {
          this._startDe = null, this._maxNodeDegree = -1, this._edges = new Nt(), this._pts = new Nt(), this._label = new Pe(w.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new Nt(), this._geometryFactory = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._geometryFactory = e3, this.computePoints(t2), this.computeRing();
        };
        De.prototype.computeRing = function() {
          if (null !== this._ring)
            return null;
          for (var t2 = new Array(this._pts.size()).fill(null), e3 = 0; e3 < this._pts.size(); e3++)
            t2[e3] = this._pts.get(e3);
          this._ring = this._geometryFactory.createLinearRing(t2), this._isHole = at.isCCW(this._ring.getCoordinates());
        }, De.prototype.isIsolated = function() {
          return 1 === this._label.getGeometryCount();
        }, De.prototype.computePoints = function(t2) {
          this._startDe = t2;
          var e3 = t2, n2 = true;
          do {
            if (null === e3)
              throw new we("Found null DirectedEdge");
            if (e3.getEdgeRing() === this)
              throw new we("Directed Edge visited twice during ring-building at " + e3.getCoordinate());
            this._edges.add(e3);
            var i2 = e3.getLabel();
            et.isTrue(i2.isArea()), this.mergeLabel(i2), this.addPoints(e3.getEdge(), e3.isForward(), n2), n2 = false, this.setEdgeRing(e3, this), e3 = this.getNext(e3);
          } while (e3 !== this._startDe);
        }, De.prototype.getLinearRing = function() {
          return this._ring;
        }, De.prototype.getCoordinate = function(t2) {
          return this._pts.get(t2);
        }, De.prototype.computeMaxNodeDegree = function() {
          this._maxNodeDegree = 0;
          var t2 = this._startDe;
          do {
            var e3 = t2.getNode().getEdges().getOutgoingDegree(this);
            e3 > this._maxNodeDegree && (this._maxNodeDegree = e3), t2 = this.getNext(t2);
          } while (t2 !== this._startDe);
          this._maxNodeDegree *= 2;
        }, De.prototype.addPoints = function(t2, e3, n2) {
          var i2 = t2.getCoordinates();
          if (e3) {
            var r2 = 1;
            n2 && (r2 = 0);
            for (var o2 = r2; o2 < i2.length; o2++)
              this._pts.add(i2[o2]);
          } else {
            var s2 = i2.length - 2;
            n2 && (s2 = i2.length - 1);
            for (var a3 = s2; a3 >= 0; a3--)
              this._pts.add(i2[a3]);
          }
        }, De.prototype.isHole = function() {
          return this._isHole;
        }, De.prototype.setInResult = function() {
          var t2 = this._startDe;
          do {
            t2.getEdge().setInResult(true), t2 = t2.getNext();
          } while (t2 !== this._startDe);
        }, De.prototype.containsPoint = function(t2) {
          var e3 = this.getLinearRing();
          if (!e3.getEnvelopeInternal().contains(t2))
            return false;
          if (!at.isPointInRing(t2, e3.getCoordinates()))
            return false;
          for (var n2 = this._holes.iterator(); n2.hasNext(); ) {
            if (n2.next().containsPoint(t2))
              return false;
          }
          return true;
        }, De.prototype.addHole = function(t2) {
          this._holes.add(t2);
        }, De.prototype.isShell = function() {
          return null === this._shell;
        }, De.prototype.getLabel = function() {
          return this._label;
        }, De.prototype.getEdges = function() {
          return this._edges;
        }, De.prototype.getMaxNodeDegree = function() {
          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
        }, De.prototype.getShell = function() {
          return this._shell;
        }, De.prototype.mergeLabel = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.mergeLabel(t2, 0), this.mergeLabel(t2, 1);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = e3.getLocation(n2, Se.RIGHT);
            if (i2 === w.NONE)
              return null;
            if (this._label.getLocation(n2) === w.NONE)
              return this._label.setLocation(n2, i2), null;
          }
        }, De.prototype.setShell = function(t2) {
          this._shell = t2, null !== t2 && t2.addHole(this);
        }, De.prototype.toPolygon = function(t2) {
          for (var e3 = new Array(this._holes.size()).fill(null), n2 = 0; n2 < this._holes.size(); n2++)
            e3[n2] = this._holes.get(n2).getLinearRing();
          return t2.createPolygon(this.getLinearRing(), e3);
        }, De.prototype.interfaces_ = function() {
          return [];
        }, De.prototype.getClass = function() {
          return De;
        };
        var Me = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.setEdgeRing = function(t3, e4) {
            t3.setMinEdgeRing(e4);
          }, e3.prototype.getNext = function(t3) {
            return t3.getNextMin();
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(De), Ae = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.buildMinimalRings = function() {
            var t3 = new Nt(), e4 = this._startDe;
            do {
              if (null === e4.getMinEdgeRing()) {
                var n2 = new Me(e4, this._geometryFactory);
                t3.add(n2);
              }
              e4 = e4.getNext();
            } while (e4 !== this._startDe);
            return t3;
          }, e3.prototype.setEdgeRing = function(t3, e4) {
            t3.setEdgeRing(e4);
          }, e3.prototype.linkDirectedEdgesForMinimalEdgeRings = function() {
            var t3 = this._startDe;
            do {
              t3.getNode().getEdges().linkMinimalDirectedEdges(this), t3 = t3.getNext();
            } while (t3 !== this._startDe);
          }, e3.prototype.getNext = function(t3) {
            return t3.getNext();
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(De), Fe = function() {
          if (this._label = null, this._isInResult = false, this._isCovered = false, this._isCoveredSet = false, this._isVisited = false, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._label = t2;
          }
        };
        Fe.prototype.setVisited = function(t2) {
          this._isVisited = t2;
        }, Fe.prototype.setInResult = function(t2) {
          this._isInResult = t2;
        }, Fe.prototype.isCovered = function() {
          return this._isCovered;
        }, Fe.prototype.isCoveredSet = function() {
          return this._isCoveredSet;
        }, Fe.prototype.setLabel = function(t2) {
          this._label = t2;
        }, Fe.prototype.getLabel = function() {
          return this._label;
        }, Fe.prototype.setCovered = function(t2) {
          this._isCovered = t2, this._isCoveredSet = true;
        }, Fe.prototype.updateIM = function(t2) {
          et.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t2);
        }, Fe.prototype.isInResult = function() {
          return this._isInResult;
        }, Fe.prototype.isVisited = function() {
          return this._isVisited;
        }, Fe.prototype.interfaces_ = function() {
          return [];
        }, Fe.prototype.getClass = function() {
          return Fe;
        };
        var Ge = function(t2) {
          function e3() {
            t2.call(this), this._coord = null, this._edges = null;
            var e4 = arguments[0], n2 = arguments[1];
            this._coord = e4, this._edges = n2, this._label = new Pe(0, w.NONE);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isIncidentEdgeInResult = function() {
            for (var t3 = this.getEdges().getEdges().iterator(); t3.hasNext(); ) {
              if (t3.next().getEdge().isInResult())
                return true;
            }
            return false;
          }, e3.prototype.isIsolated = function() {
            return 1 === this._label.getGeometryCount();
          }, e3.prototype.getCoordinate = function() {
            return this._coord;
          }, e3.prototype.print = function(t3) {
            t3.println("node " + this._coord + " lbl: " + this._label);
          }, e3.prototype.computeIM = function(t3) {
          }, e3.prototype.computeMergedLocation = function(t3, e4) {
            var n2 = w.NONE;
            if (n2 = this._label.getLocation(e4), !t3.isNull(e4)) {
              var i2 = t3.getLocation(e4);
              n2 !== w.BOUNDARY && (n2 = i2);
            }
            return n2;
          }, e3.prototype.setLabel = function() {
            if (2 !== arguments.length)
              return t2.prototype.setLabel.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1];
            null === this._label ? this._label = new Pe(e4, n2) : this._label.setLocation(e4, n2);
          }, e3.prototype.getEdges = function() {
            return this._edges;
          }, e3.prototype.mergeLabel = function() {
            if (arguments[0] instanceof e3) {
              var t3 = arguments[0];
              this.mergeLabel(t3._label);
            } else if (arguments[0] instanceof Pe)
              for (var n2 = arguments[0], i2 = 0; i2 < 2; i2++) {
                var r2 = this.computeMergedLocation(n2, i2);
                this._label.getLocation(i2) === w.NONE && this._label.setLocation(i2, r2);
              }
          }, e3.prototype.add = function(t3) {
            this._edges.insert(t3), t3.setNode(this);
          }, e3.prototype.setLabelBoundary = function(t3) {
            if (null === this._label)
              return null;
            var e4 = w.NONE;
            null !== this._label && (e4 = this._label.getLocation(t3));
            var n2 = null;
            switch (e4) {
              case w.BOUNDARY:
                n2 = w.INTERIOR;
                break;
              case w.INTERIOR:
              default:
                n2 = w.BOUNDARY;
            }
            this._label.setLocation(t3, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Fe), qe = function() {
          this.nodeMap = new p(), this.nodeFact = null;
          var t2 = arguments[0];
          this.nodeFact = t2;
        };
        qe.prototype.find = function(t2) {
          return this.nodeMap.get(t2);
        }, qe.prototype.addNode = function() {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0], e3 = this.nodeMap.get(t2);
            return null === e3 && (e3 = this.nodeFact.createNode(t2), this.nodeMap.put(t2, e3)), e3;
          }
          if (arguments[0] instanceof Ge) {
            var n2 = arguments[0], i2 = this.nodeMap.get(n2.getCoordinate());
            return null === i2 ? (this.nodeMap.put(n2.getCoordinate(), n2), n2) : (i2.mergeLabel(n2), i2);
          }
        }, qe.prototype.print = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, qe.prototype.iterator = function() {
          return this.nodeMap.values().iterator();
        }, qe.prototype.values = function() {
          return this.nodeMap.values();
        }, qe.prototype.getBoundaryNodes = function(t2) {
          for (var e3 = new Nt(), n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.getLabel().getLocation(t2) === w.BOUNDARY && e3.add(i2);
          }
          return e3;
        }, qe.prototype.add = function(t2) {
          var e3 = t2.getCoordinate();
          this.addNode(e3).add(t2);
        }, qe.prototype.interfaces_ = function() {
          return [];
        }, qe.prototype.getClass = function() {
          return qe;
        };
        var Be = function() {
        }, Ve = { NE: { configurable: true }, NW: { configurable: true }, SW: { configurable: true }, SE: { configurable: true } };
        Be.prototype.interfaces_ = function() {
          return [];
        }, Be.prototype.getClass = function() {
          return Be;
        }, Be.isNorthern = function(t2) {
          return t2 === Be.NE || t2 === Be.NW;
        }, Be.isOpposite = function(t2, e3) {
          if (t2 === e3)
            return false;
          return 2 === (t2 - e3 + 4) % 4;
        }, Be.commonHalfPlane = function(t2, e3) {
          if (t2 === e3)
            return t2;
          if (2 === (t2 - e3 + 4) % 4)
            return -1;
          var n2 = t2 < e3 ? t2 : e3;
          return 0 === n2 && 3 === (t2 > e3 ? t2 : e3) ? 3 : n2;
        }, Be.isInHalfPlane = function(t2, e3) {
          return e3 === Be.SE ? t2 === Be.SE || t2 === Be.SW : t2 === e3 || t2 === e3 + 1;
        }, Be.quadrant = function() {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e3 = arguments[1];
            if (0 === t2 && 0 === e3)
              throw new m("Cannot compute the quadrant for point ( " + t2 + ", " + e3 + " )");
            return t2 >= 0 ? e3 >= 0 ? Be.NE : Be.SE : e3 >= 0 ? Be.NW : Be.SW;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof C) {
            var n2 = arguments[0], i2 = arguments[1];
            if (i2.x === n2.x && i2.y === n2.y)
              throw new m("Cannot compute the quadrant for two identical points " + n2);
            return i2.x >= n2.x ? i2.y >= n2.y ? Be.NE : Be.SE : i2.y >= n2.y ? Be.NW : Be.SW;
          }
        }, Ve.NE.get = function() {
          return 0;
        }, Ve.NW.get = function() {
          return 1;
        }, Ve.SW.get = function() {
          return 2;
        }, Ve.SE.get = function() {
          return 3;
        }, Object.defineProperties(Be, Ve);
        var Ue = function() {
          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this._edge = t2;
          } else if (3 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._edge = e3, this.init(n2, i2), this._label = null;
          } else if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a3 = arguments[3];
            this._edge = r2, this.init(o2, s2), this._label = a3;
          }
        };
        Ue.prototype.compareDirection = function(t2) {
          return this._dx === t2._dx && this._dy === t2._dy ? 0 : this._quadrant > t2._quadrant ? 1 : this._quadrant < t2._quadrant ? -1 : at.computeOrientation(t2._p0, t2._p1, this._p1);
        }, Ue.prototype.getDy = function() {
          return this._dy;
        }, Ue.prototype.getCoordinate = function() {
          return this._p0;
        }, Ue.prototype.setNode = function(t2) {
          this._node = t2;
        }, Ue.prototype.print = function(t2) {
          var e3 = Math.atan2(this._dy, this._dx), n2 = this.getClass().getName(), i2 = n2.lastIndexOf("."), r2 = n2.substring(i2 + 1);
          t2.print("  " + r2 + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e3 + "   " + this._label);
        }, Ue.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.compareDirection(e3);
        }, Ue.prototype.getDirectedCoordinate = function() {
          return this._p1;
        }, Ue.prototype.getDx = function() {
          return this._dx;
        }, Ue.prototype.getLabel = function() {
          return this._label;
        }, Ue.prototype.getEdge = function() {
          return this._edge;
        }, Ue.prototype.getQuadrant = function() {
          return this._quadrant;
        }, Ue.prototype.getNode = function() {
          return this._node;
        }, Ue.prototype.toString = function() {
          var t2 = Math.atan2(this._dy, this._dx), e3 = this.getClass().getName(), n2 = e3.lastIndexOf(".");
          return "  " + e3.substring(n2 + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t2 + "   " + this._label;
        }, Ue.prototype.computeLabel = function(t2) {
        }, Ue.prototype.init = function(t2, e3) {
          this._p0 = t2, this._p1 = e3, this._dx = e3.x - t2.x, this._dy = e3.y - t2.y, this._quadrant = Be.quadrant(this._dx, this._dy), et.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found");
        }, Ue.prototype.interfaces_ = function() {
          return [E];
        }, Ue.prototype.getClass = function() {
          return Ue;
        };
        var ze = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            if (t2.call(this, e4), this._isForward = null, this._isInResult = false, this._isVisited = false, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n2, n2)
              this.init(e4.getCoordinate(0), e4.getCoordinate(1));
            else {
              var i2 = e4.getNumPoints() - 1;
              this.init(e4.getCoordinate(i2), e4.getCoordinate(i2 - 1));
            }
            this.computeDirectedLabel();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getNextMin = function() {
            return this._nextMin;
          }, e3.prototype.getDepth = function(t3) {
            return this._depth[t3];
          }, e3.prototype.setVisited = function(t3) {
            this._isVisited = t3;
          }, e3.prototype.computeDirectedLabel = function() {
            this._label = new Pe(this._edge.getLabel()), this._isForward || this._label.flip();
          }, e3.prototype.getNext = function() {
            return this._next;
          }, e3.prototype.setDepth = function(t3, e4) {
            if (-999 !== this._depth[t3] && this._depth[t3] !== e4)
              throw new we("assigned depths do not match", this.getCoordinate());
            this._depth[t3] = e4;
          }, e3.prototype.isInteriorAreaEdge = function() {
            for (var t3 = true, e4 = 0; e4 < 2; e4++)
              this._label.isArea(e4) && this._label.getLocation(e4, Se.LEFT) === w.INTERIOR && this._label.getLocation(e4, Se.RIGHT) === w.INTERIOR || (t3 = false);
            return t3;
          }, e3.prototype.setNextMin = function(t3) {
            this._nextMin = t3;
          }, e3.prototype.print = function(e4) {
            t2.prototype.print.call(this, e4), e4.print(" " + this._depth[Se.LEFT] + "/" + this._depth[Se.RIGHT]), e4.print(" (" + this.getDepthDelta() + ")"), this._isInResult && e4.print(" inResult");
          }, e3.prototype.setMinEdgeRing = function(t3) {
            this._minEdgeRing = t3;
          }, e3.prototype.isLineEdge = function() {
            var t3 = this._label.isLine(0) || this._label.isLine(1), e4 = !this._label.isArea(0) || this._label.allPositionsEqual(0, w.EXTERIOR), n2 = !this._label.isArea(1) || this._label.allPositionsEqual(1, w.EXTERIOR);
            return t3 && e4 && n2;
          }, e3.prototype.setEdgeRing = function(t3) {
            this._edgeRing = t3;
          }, e3.prototype.getMinEdgeRing = function() {
            return this._minEdgeRing;
          }, e3.prototype.getDepthDelta = function() {
            var t3 = this._edge.getDepthDelta();
            return this._isForward || (t3 = -t3), t3;
          }, e3.prototype.setInResult = function(t3) {
            this._isInResult = t3;
          }, e3.prototype.getSym = function() {
            return this._sym;
          }, e3.prototype.isForward = function() {
            return this._isForward;
          }, e3.prototype.getEdge = function() {
            return this._edge;
          }, e3.prototype.printEdge = function(t3) {
            this.print(t3), t3.print(" "), this._isForward ? this._edge.print(t3) : this._edge.printReverse(t3);
          }, e3.prototype.setSym = function(t3) {
            this._sym = t3;
          }, e3.prototype.setVisitedEdge = function(t3) {
            this.setVisited(t3), this._sym.setVisited(t3);
          }, e3.prototype.setEdgeDepths = function(t3, e4) {
            var n2 = this.getEdge().getDepthDelta();
            this._isForward || (n2 = -n2);
            var i2 = 1;
            t3 === Se.LEFT && (i2 = -1);
            var r2 = Se.opposite(t3), o2 = e4 + n2 * i2;
            this.setDepth(t3, e4), this.setDepth(r2, o2);
          }, e3.prototype.getEdgeRing = function() {
            return this._edgeRing;
          }, e3.prototype.isInResult = function() {
            return this._isInResult;
          }, e3.prototype.setNext = function(t3) {
            this._next = t3;
          }, e3.prototype.isVisited = function() {
            return this._isVisited;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.depthFactor = function(t3, e4) {
            return t3 === w.EXTERIOR && e4 === w.INTERIOR ? 1 : t3 === w.INTERIOR && e4 === w.EXTERIOR ? -1 : 0;
          }, e3;
        }(Ue), Xe = function() {
        };
        Xe.prototype.createNode = function(t2) {
          return new Ge(t2, null);
        }, Xe.prototype.interfaces_ = function() {
          return [];
        }, Xe.prototype.getClass = function() {
          return Xe;
        };
        var Ye = function() {
          if (this._edges = new Nt(), this._nodes = null, this._edgeEndList = new Nt(), 0 === arguments.length)
            this._nodes = new qe(new Xe());
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._nodes = new qe(t2);
          }
        };
        Ye.prototype.printEdges = function(t2) {
          t2.println("Edges:");
          for (var e3 = 0; e3 < this._edges.size(); e3++) {
            t2.println("edge " + e3 + ":");
            var n2 = this._edges.get(e3);
            n2.print(t2), n2.eiList.print(t2);
          }
        }, Ye.prototype.find = function(t2) {
          return this._nodes.find(t2);
        }, Ye.prototype.addNode = function() {
          if (arguments[0] instanceof Ge) {
            var t2 = arguments[0];
            return this._nodes.addNode(t2);
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            return this._nodes.addNode(e3);
          }
        }, Ye.prototype.getNodeIterator = function() {
          return this._nodes.iterator();
        }, Ye.prototype.linkResultDirectedEdges = function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkResultDirectedEdges();
          }
        }, Ye.prototype.debugPrintln = function(t2) {
          Y.out.println(t2);
        }, Ye.prototype.isBoundaryNode = function(t2, e3) {
          var n2 = this._nodes.find(e3);
          if (null === n2)
            return false;
          var i2 = n2.getLabel();
          return null !== i2 && i2.getLocation(t2) === w.BOUNDARY;
        }, Ye.prototype.linkAllDirectedEdges = function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkAllDirectedEdges();
          }
        }, Ye.prototype.matchInSameDirection = function(t2, e3, n2, i2) {
          return !!t2.equals(n2) && (at.computeOrientation(t2, e3, i2) === at.COLLINEAR && Be.quadrant(t2, e3) === Be.quadrant(n2, i2));
        }, Ye.prototype.getEdgeEnds = function() {
          return this._edgeEndList;
        }, Ye.prototype.debugPrint = function(t2) {
          Y.out.print(t2);
        }, Ye.prototype.getEdgeIterator = function() {
          return this._edges.iterator();
        }, Ye.prototype.findEdgeInSameDirection = function(t2, e3) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (this.matchInSameDirection(t2, e3, r2[0], r2[1]))
              return i2;
            if (this.matchInSameDirection(t2, e3, r2[r2.length - 1], r2[r2.length - 2]))
              return i2;
          }
          return null;
        }, Ye.prototype.insertEdge = function(t2) {
          this._edges.add(t2);
        }, Ye.prototype.findEdgeEnd = function(t2) {
          for (var e3 = this.getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            if (n2.getEdge() === t2)
              return n2;
          }
          return null;
        }, Ye.prototype.addEdges = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this._edges.add(n2);
            var i2 = new ze(n2, true), r2 = new ze(n2, false);
            i2.setSym(r2), r2.setSym(i2), this.add(i2), this.add(r2);
          }
        }, Ye.prototype.add = function(t2) {
          this._nodes.add(t2), this._edgeEndList.add(t2);
        }, Ye.prototype.getNodes = function() {
          return this._nodes.values();
        }, Ye.prototype.findEdge = function(t2, e3) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (t2.equals(r2[0]) && e3.equals(r2[1]))
              return i2;
          }
          return null;
        }, Ye.prototype.interfaces_ = function() {
          return [];
        }, Ye.prototype.getClass = function() {
          return Ye;
        }, Ye.linkResultDirectedEdges = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            e3.next().getEdges().linkResultDirectedEdges();
          }
        };
        var ke = function() {
          this._geometryFactory = null, this._shellList = new Nt();
          var t2 = arguments[0];
          this._geometryFactory = t2;
        };
        ke.prototype.sortShellsAndHoles = function(t2, e3, n2) {
          for (var i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() ? n2.add(r2) : e3.add(r2);
          }
        }, ke.prototype.computePolygons = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().toPolygon(this._geometryFactory);
            e3.add(i2);
          }
          return e3;
        }, ke.prototype.placeFreeHoles = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (null === i2.getShell()) {
              var r2 = this.findEdgeRingContaining(i2, t2);
              if (null === r2)
                throw new we("unable to assign hole to a shell", i2.getCoordinate(0));
              i2.setShell(r2);
            }
          }
        }, ke.prototype.buildMinimalEdgeRings = function(t2, e3, n2) {
          for (var i2 = new Nt(), r2 = t2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            if (o2.getMaxNodeDegree() > 2) {
              o2.linkDirectedEdgesForMinimalEdgeRings();
              var s2 = o2.buildMinimalRings(), a3 = this.findShell(s2);
              null !== a3 ? (this.placePolygonHoles(a3, s2), e3.add(a3)) : n2.addAll(s2);
            } else
              i2.add(o2);
          }
          return i2;
        }, ke.prototype.containsPoint = function(t2) {
          for (var e3 = this._shellList.iterator(); e3.hasNext(); ) {
            if (e3.next().containsPoint(t2))
              return true;
          }
          return false;
        }, ke.prototype.buildMaximalEdgeRings = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isInResult() && i2.getLabel().isArea() && null === i2.getEdgeRing()) {
              var r2 = new Ae(i2, this._geometryFactory);
              e3.add(r2), r2.setInResult();
            }
          }
          return e3;
        }, ke.prototype.placePolygonHoles = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.isHole() && i2.setShell(t2);
          }
        }, ke.prototype.getPolygons = function() {
          return this.computePolygons(this._shellList);
        }, ke.prototype.findEdgeRingContaining = function(t2, e3) {
          for (var n2 = t2.getLinearRing(), i2 = n2.getEnvelopeInternal(), r2 = n2.getCoordinateN(0), o2 = null, s2 = null, a3 = e3.iterator(); a3.hasNext(); ) {
            var u2 = a3.next(), l2 = u2.getLinearRing(), c2 = l2.getEnvelopeInternal();
            null !== o2 && (s2 = o2.getLinearRing().getEnvelopeInternal());
            var p2 = false;
            c2.contains(i2) && at.isPointInRing(r2, l2.getCoordinates()) && (p2 = true), p2 && (null === o2 || s2.contains(c2)) && (o2 = u2);
          }
          return o2;
        }, ke.prototype.findShell = function(t2) {
          for (var e3 = 0, n2 = null, i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() || (n2 = r2, e3++);
          }
          return et.isTrue(e3 <= 1, "found two shells in MinimalEdgeRing list"), n2;
        }, ke.prototype.add = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.add(t2.getEdgeEnds(), t2.getNodes());
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            Ye.linkResultDirectedEdges(n2);
            var i2 = this.buildMaximalEdgeRings(e3), r2 = new Nt(), o2 = this.buildMinimalEdgeRings(i2, this._shellList, r2);
            this.sortShellsAndHoles(o2, this._shellList, r2), this.placeFreeHoles(this._shellList, r2);
          }
        }, ke.prototype.interfaces_ = function() {
          return [];
        }, ke.prototype.getClass = function() {
          return ke;
        };
        var je = function() {
        };
        je.prototype.getBounds = function() {
        }, je.prototype.interfaces_ = function() {
          return [];
        }, je.prototype.getClass = function() {
          return je;
        };
        var He = function() {
          this._bounds = null, this._item = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._bounds = t2, this._item = e3;
        };
        He.prototype.getItem = function() {
          return this._item;
        }, He.prototype.getBounds = function() {
          return this._bounds;
        }, He.prototype.interfaces_ = function() {
          return [je, e];
        }, He.prototype.getClass = function() {
          return He;
        };
        var We = function() {
          this._size = null, this._items = null, this._size = 0, this._items = new Nt(), this._items.add(null);
        };
        We.prototype.poll = function() {
          if (this.isEmpty())
            return null;
          var t2 = this._items.get(1);
          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t2;
        }, We.prototype.size = function() {
          return this._size;
        }, We.prototype.reorder = function(t2) {
          for (var e3 = null, n2 = this._items.get(t2); 2 * t2 <= this._size && ((e3 = 2 * t2) !== this._size && this._items.get(e3 + 1).compareTo(this._items.get(e3)) < 0 && e3++, this._items.get(e3).compareTo(n2) < 0); t2 = e3)
            this._items.set(t2, this._items.get(e3));
          this._items.set(t2, n2);
        }, We.prototype.clear = function() {
          this._size = 0, this._items.clear();
        }, We.prototype.isEmpty = function() {
          return 0 === this._size;
        }, We.prototype.add = function(t2) {
          this._items.add(null), this._size += 1;
          var e3 = this._size;
          for (this._items.set(0, t2); t2.compareTo(this._items.get(Math.trunc(e3 / 2))) < 0; e3 /= 2)
            this._items.set(e3, this._items.get(Math.trunc(e3 / 2)));
          this._items.set(e3, t2);
        }, We.prototype.interfaces_ = function() {
          return [];
        }, We.prototype.getClass = function() {
          return We;
        };
        var Ke = function() {
        };
        Ke.prototype.visitItem = function(t2) {
        }, Ke.prototype.interfaces_ = function() {
          return [];
        }, Ke.prototype.getClass = function() {
          return Ke;
        };
        var Je = function() {
        };
        Je.prototype.insert = function(t2, e3) {
        }, Je.prototype.remove = function(t2, e3) {
        }, Je.prototype.query = function() {
        }, Je.prototype.interfaces_ = function() {
          return [];
        }, Je.prototype.getClass = function() {
          return Je;
        };
        var Qe = function() {
          if (this._childBoundables = new Nt(), this._bounds = null, this._level = null, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._level = t2;
          }
        }, Ze = { serialVersionUID: { configurable: true } };
        Qe.prototype.getLevel = function() {
          return this._level;
        }, Qe.prototype.size = function() {
          return this._childBoundables.size();
        }, Qe.prototype.getChildBoundables = function() {
          return this._childBoundables;
        }, Qe.prototype.addChildBoundable = function(t2) {
          et.isTrue(null === this._bounds), this._childBoundables.add(t2);
        }, Qe.prototype.isEmpty = function() {
          return this._childBoundables.isEmpty();
        }, Qe.prototype.getBounds = function() {
          return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;
        }, Qe.prototype.interfaces_ = function() {
          return [je, e];
        }, Qe.prototype.getClass = function() {
          return Qe;
        }, Ze.serialVersionUID.get = function() {
          return 6493722185909574e3;
        }, Object.defineProperties(Qe, Ze);
        var $e = function() {
        };
        $e.reverseOrder = function() {
          return { compare: function(t2, e3) {
            return e3.compareTo(t2);
          } };
        }, $e.min = function(t2) {
          return $e.sort(t2), t2.get(0);
        }, $e.sort = function(t2, e3) {
          var n2 = t2.toArray();
          e3 ? Gt.sort(n2, e3) : Gt.sort(n2);
          for (var i2 = t2.iterator(), r2 = 0, o2 = n2.length; r2 < o2; r2++)
            i2.next(), i2.set(n2[r2]);
        }, $e.singletonList = function(t2) {
          var e3 = new Nt();
          return e3.add(t2), e3;
        };
        var tn = function() {
          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._boundable1 = t2, this._boundable2 = e3, this._itemDistance = n2, this._distance = this.distance();
        };
        tn.prototype.expandToQueue = function(t2, e3) {
          var n2 = tn.isComposite(this._boundable1), i2 = tn.isComposite(this._boundable2);
          if (n2 && i2)
            return tn.area(this._boundable1) > tn.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t2, e3), null) : (this.expand(this._boundable2, this._boundable1, t2, e3), null);
          if (n2)
            return this.expand(this._boundable1, this._boundable2, t2, e3), null;
          if (i2)
            return this.expand(this._boundable2, this._boundable1, t2, e3), null;
          throw new m("neither boundable is composite");
        }, tn.prototype.isLeaves = function() {
          return !(tn.isComposite(this._boundable1) || tn.isComposite(this._boundable2));
        }, tn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._distance < e3._distance ? -1 : this._distance > e3._distance ? 1 : 0;
        }, tn.prototype.expand = function(t2, e3, n2, i2) {
          for (var r2 = t2.getChildBoundables().iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = new tn(o2, e3, this._itemDistance);
            s2.getDistance() < i2 && n2.add(s2);
          }
        }, tn.prototype.getBoundable = function(t2) {
          return 0 === t2 ? this._boundable1 : this._boundable2;
        }, tn.prototype.getDistance = function() {
          return this._distance;
        }, tn.prototype.distance = function() {
          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
        }, tn.prototype.interfaces_ = function() {
          return [E];
        }, tn.prototype.getClass = function() {
          return tn;
        }, tn.area = function(t2) {
          return t2.getBounds().getArea();
        }, tn.isComposite = function(t2) {
          return t2 instanceof Qe;
        };
        var en = function t2() {
          if (this._root = null, this._built = false, this._itemBoundables = new Nt(), this._nodeCapacity = null, 0 === arguments.length) {
            var e3 = t2.DEFAULT_NODE_CAPACITY;
            this._nodeCapacity = e3;
          } else if (1 === arguments.length) {
            var n2 = arguments[0];
            et.isTrue(n2 > 1, "Node capacity must be greater than 1"), this._nodeCapacity = n2;
          }
        }, nn = { IntersectsOp: { configurable: true }, serialVersionUID: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
        en.prototype.getNodeCapacity = function() {
          return this._nodeCapacity;
        }, en.prototype.lastNode = function(t2) {
          return t2.get(t2.size() - 1);
        }, en.prototype.size = function() {
          if (0 === arguments.length)
            return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
          if (1 === arguments.length) {
            for (var t2 = 0, e3 = arguments[0].getChildBoundables().iterator(); e3.hasNext(); ) {
              var n2 = e3.next();
              n2 instanceof Qe ? t2 += this.size(n2) : n2 instanceof He && (t2 += 1);
            }
            return t2;
          }
        }, en.prototype.removeItem = function(t2, e3) {
          for (var n2 = null, i2 = t2.getChildBoundables().iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2 instanceof He && r2.getItem() === e3 && (n2 = r2);
          }
          return null !== n2 && (t2.getChildBoundables().remove(n2), true);
        }, en.prototype.itemsTree = function() {
          if (0 === arguments.length) {
            this.build();
            var t2 = this.itemsTree(this._root);
            return null === t2 ? new Nt() : t2;
          }
          if (1 === arguments.length) {
            for (var e3 = arguments[0], n2 = new Nt(), i2 = e3.getChildBoundables().iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              if (r2 instanceof Qe) {
                var o2 = this.itemsTree(r2);
                null !== o2 && n2.add(o2);
              } else
                r2 instanceof He ? n2.add(r2.getItem()) : et.shouldNeverReachHere();
            }
            return n2.size() <= 0 ? null : n2;
          }
        }, en.prototype.insert = function(t2, e3) {
          et.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new He(t2, e3));
        }, en.prototype.boundablesAtLevel = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = new Nt();
            return this.boundablesAtLevel(t2, this._root, e3), e3;
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            if (et.isTrue(n2 > -2), i2.getLevel() === n2)
              return r2.add(i2), null;
            for (var o2 = i2.getChildBoundables().iterator(); o2.hasNext(); ) {
              var s2 = o2.next();
              s2 instanceof Qe ? this.boundablesAtLevel(n2, s2, r2) : (et.isTrue(s2 instanceof He), -1 === n2 && r2.add(s2));
            }
            return null;
          }
        }, en.prototype.query = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.build();
            var e3 = new Nt();
            return this.isEmpty() ? e3 : (this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.query(t2, this._root, e3), e3);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            if (this.build(), this.isEmpty())
              return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), n2) && this.query(n2, this._root, i2);
          } else if (3 === arguments.length) {
            if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe)
              for (var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a3 = o2.getChildBoundables(), u2 = 0; u2 < a3.size(); u2++) {
                var l2 = a3.get(u2);
                this.getIntersectsOp().intersects(l2.getBounds(), r2) && (l2 instanceof Qe ? this.query(r2, l2, s2) : l2 instanceof He ? s2.visitItem(l2.getItem()) : et.shouldNeverReachHere());
              }
            else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe)
              for (var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = p2.getChildBoundables(), g2 = 0; g2 < f2.size(); g2++) {
                var d2 = f2.get(g2);
                this.getIntersectsOp().intersects(d2.getBounds(), c2) && (d2 instanceof Qe ? this.query(c2, d2, h2) : d2 instanceof He ? h2.add(d2.getItem()) : et.shouldNeverReachHere());
              }
          }
        }, en.prototype.build = function() {
          if (this._built)
            return null;
          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = true;
        }, en.prototype.getRoot = function() {
          return this.build(), this._root;
        }, en.prototype.remove = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.remove(t2, this._root, e3);
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = this.removeItem(i2, r2);
            if (o2)
              return true;
            for (var s2 = null, a3 = i2.getChildBoundables().iterator(); a3.hasNext(); ) {
              var u2 = a3.next();
              if (this.getIntersectsOp().intersects(u2.getBounds(), n2) && (u2 instanceof Qe && (o2 = this.remove(n2, u2, r2)))) {
                s2 = u2;
                break;
              }
            }
            return null !== s2 && s2.getChildBoundables().isEmpty() && i2.getChildBoundables().remove(s2), o2;
          }
        }, en.prototype.createHigherLevels = function(t2, e3) {
          et.isTrue(!t2.isEmpty());
          var n2 = this.createParentBoundables(t2, e3 + 1);
          return 1 === n2.size() ? n2.get(0) : this.createHigherLevels(n2, e3 + 1);
        }, en.prototype.depth = function() {
          if (0 === arguments.length)
            return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
          if (1 === arguments.length) {
            for (var t2 = 0, e3 = arguments[0].getChildBoundables().iterator(); e3.hasNext(); ) {
              var n2 = e3.next();
              if (n2 instanceof Qe) {
                var i2 = this.depth(n2);
                i2 > t2 && (t2 = i2);
              }
            }
            return t2 + 1;
          }
        }, en.prototype.createParentBoundables = function(t2, e3) {
          et.isTrue(!t2.isEmpty());
          var n2 = new Nt();
          n2.add(this.createNode(e3));
          var i2 = new Nt(t2);
          $e.sort(i2, this.getComparator());
          for (var r2 = i2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            this.lastNode(n2).getChildBoundables().size() === this.getNodeCapacity() && n2.add(this.createNode(e3)), this.lastNode(n2).addChildBoundable(o2);
          }
          return n2;
        }, en.prototype.isEmpty = function() {
          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
        }, en.prototype.interfaces_ = function() {
          return [e];
        }, en.prototype.getClass = function() {
          return en;
        }, en.compareDoubles = function(t2, e3) {
          return t2 > e3 ? 1 : t2 < e3 ? -1 : 0;
        }, nn.IntersectsOp.get = function() {
          return rn;
        }, nn.serialVersionUID.get = function() {
          return -3886435814360241e3;
        }, nn.DEFAULT_NODE_CAPACITY.get = function() {
          return 10;
        }, Object.defineProperties(en, nn);
        var rn = function() {
        }, on = function() {
        };
        on.prototype.distance = function(t2, e3) {
        }, on.prototype.interfaces_ = function() {
          return [];
        }, on.prototype.getClass = function() {
          return on;
        };
        var sn = function(t2) {
          function n2(e3) {
            e3 = e3 || n2.DEFAULT_NODE_CAPACITY, t2.call(this, e3);
          }
          t2 && (n2.__proto__ = t2), (n2.prototype = Object.create(t2 && t2.prototype)).constructor = n2;
          var i2 = { STRtreeNode: { configurable: true }, serialVersionUID: { configurable: true }, xComparator: { configurable: true }, yComparator: { configurable: true }, intersectsOp: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
          return n2.prototype.createParentBoundablesFromVerticalSlices = function(t3, e3) {
            et.isTrue(t3.length > 0);
            for (var n3 = new Nt(), i3 = 0; i3 < t3.length; i3++)
              n3.addAll(this.createParentBoundablesFromVerticalSlice(t3[i3], e3));
            return n3;
          }, n2.prototype.createNode = function(t3) {
            return new an(t3);
          }, n2.prototype.size = function() {
            return 0 === arguments.length ? t2.prototype.size.call(this) : t2.prototype.size.apply(this, arguments);
          }, n2.prototype.insert = function() {
            if (2 !== arguments.length)
              return t2.prototype.insert.apply(this, arguments);
            var e3 = arguments[0], n3 = arguments[1];
            if (e3.isNull())
              return null;
            t2.prototype.insert.call(this, e3, n3);
          }, n2.prototype.getIntersectsOp = function() {
            return n2.intersectsOp;
          }, n2.prototype.verticalSlices = function(t3, e3) {
            for (var n3 = Math.trunc(Math.ceil(t3.size() / e3)), i3 = new Array(e3).fill(null), r2 = t3.iterator(), o2 = 0; o2 < e3; o2++) {
              i3[o2] = new Nt();
              for (var s2 = 0; r2.hasNext() && s2 < n3; ) {
                var a3 = r2.next();
                i3[o2].add(a3), s2++;
              }
            }
            return i3;
          }, n2.prototype.query = function() {
            if (1 === arguments.length) {
              var e3 = arguments[0];
              return t2.prototype.query.call(this, e3);
            }
            if (2 === arguments.length) {
              var n3 = arguments[0], i3 = arguments[1];
              t2.prototype.query.call(this, n3, i3);
            } else if (3 === arguments.length) {
              if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
                var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
                t2.prototype.query.call(this, r2, o2, s2);
              } else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
                var a3 = arguments[0], u2 = arguments[1], l2 = arguments[2];
                t2.prototype.query.call(this, a3, u2, l2);
              }
            }
          }, n2.prototype.getComparator = function() {
            return n2.yComparator;
          }, n2.prototype.createParentBoundablesFromVerticalSlice = function(e3, n3) {
            return t2.prototype.createParentBoundables.call(this, e3, n3);
          }, n2.prototype.remove = function() {
            if (2 === arguments.length) {
              var e3 = arguments[0], n3 = arguments[1];
              return t2.prototype.remove.call(this, e3, n3);
            }
            return t2.prototype.remove.apply(this, arguments);
          }, n2.prototype.depth = function() {
            return 0 === arguments.length ? t2.prototype.depth.call(this) : t2.prototype.depth.apply(this, arguments);
          }, n2.prototype.createParentBoundables = function(t3, e3) {
            et.isTrue(!t3.isEmpty());
            var i3 = Math.trunc(Math.ceil(t3.size() / this.getNodeCapacity())), r2 = new Nt(t3);
            $e.sort(r2, n2.xComparator);
            var o2 = this.verticalSlices(r2, Math.trunc(Math.ceil(Math.sqrt(i3))));
            return this.createParentBoundablesFromVerticalSlices(o2, e3);
          }, n2.prototype.nearestNeighbour = function() {
            if (1 === arguments.length) {
              if (T(arguments[0], on)) {
                var t3 = arguments[0], e3 = new tn(this.getRoot(), this.getRoot(), t3);
                return this.nearestNeighbour(e3);
              }
              if (arguments[0] instanceof tn) {
                var i3 = arguments[0];
                return this.nearestNeighbour(i3, v.POSITIVE_INFINITY);
              }
            } else if (2 === arguments.length) {
              if (arguments[0] instanceof n2 && T(arguments[1], on)) {
                var r2 = arguments[0], o2 = arguments[1], s2 = new tn(this.getRoot(), r2.getRoot(), o2);
                return this.nearestNeighbour(s2);
              }
              if (arguments[0] instanceof tn && "number" == typeof arguments[1]) {
                var a3 = arguments[0], u2 = arguments[1], l2 = null, c2 = new We();
                for (c2.add(a3); !c2.isEmpty() && u2 > 0; ) {
                  var p2 = c2.poll(), h2 = p2.getDistance();
                  if (h2 >= u2)
                    break;
                  p2.isLeaves() ? (u2 = h2, l2 = p2) : p2.expandToQueue(c2, u2);
                }
                return [l2.getBoundable(0).getItem(), l2.getBoundable(1).getItem()];
              }
            } else if (3 === arguments.length) {
              var f2 = arguments[0], g2 = arguments[1], d2 = arguments[2], y4 = new He(f2, g2), _2 = new tn(this.getRoot(), y4, d2);
              return this.nearestNeighbour(_2)[0];
            }
          }, n2.prototype.interfaces_ = function() {
            return [Je, e];
          }, n2.prototype.getClass = function() {
            return n2;
          }, n2.centreX = function(t3) {
            return n2.avg(t3.getMinX(), t3.getMaxX());
          }, n2.avg = function(t3, e3) {
            return (t3 + e3) / 2;
          }, n2.centreY = function(t3) {
            return n2.avg(t3.getMinY(), t3.getMaxY());
          }, i2.STRtreeNode.get = function() {
            return an;
          }, i2.serialVersionUID.get = function() {
            return 259274702368956900;
          }, i2.xComparator.get = function() {
            return { interfaces_: function() {
              return [N];
            }, compare: function(e3, i3) {
              return t2.compareDoubles(n2.centreX(e3.getBounds()), n2.centreX(i3.getBounds()));
            } };
          }, i2.yComparator.get = function() {
            return { interfaces_: function() {
              return [N];
            }, compare: function(e3, i3) {
              return t2.compareDoubles(n2.centreY(e3.getBounds()), n2.centreY(i3.getBounds()));
            } };
          }, i2.intersectsOp.get = function() {
            return { interfaces_: function() {
              return [t2.IntersectsOp];
            }, intersects: function(t3, e3) {
              return t3.intersects(e3);
            } };
          }, i2.DEFAULT_NODE_CAPACITY.get = function() {
            return 10;
          }, Object.defineProperties(n2, i2), n2;
        }(en), an = function(t2) {
          function e3() {
            var e4 = arguments[0];
            t2.call(this, e4);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.computeBounds = function() {
            for (var t3 = null, e4 = this.getChildBoundables().iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              null === t3 ? t3 = new j(n2.getBounds()) : t3.expandToInclude(n2.getBounds());
            }
            return t3;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Qe), un = function() {
        };
        un.prototype.interfaces_ = function() {
          return [];
        }, un.prototype.getClass = function() {
          return un;
        }, un.relativeSign = function(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : 0;
        }, un.compare = function(t2, e3, n2) {
          if (e3.equals2D(n2))
            return 0;
          var i2 = un.relativeSign(e3.x, n2.x), r2 = un.relativeSign(e3.y, n2.y);
          switch (t2) {
            case 0:
              return un.compareValue(i2, r2);
            case 1:
              return un.compareValue(r2, i2);
            case 2:
              return un.compareValue(r2, -i2);
            case 3:
              return un.compareValue(-i2, r2);
            case 4:
              return un.compareValue(-i2, -r2);
            case 5:
              return un.compareValue(-r2, -i2);
            case 6:
              return un.compareValue(-r2, i2);
            case 7:
              return un.compareValue(i2, -r2);
          }
          return et.shouldNeverReachHere("invalid octant value"), 0;
        }, un.compareValue = function(t2, e3) {
          return t2 < 0 ? -1 : t2 > 0 ? 1 : e3 < 0 ? -1 : e3 > 0 ? 1 : 0;
        };
        var ln = function() {
          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._segString = t2, this.coord = new C(e3), this.segmentIndex = n2, this._segmentOctant = i2, this._isInterior = !e3.equals2D(t2.getCoordinate(n2));
        };
        ln.prototype.getCoordinate = function() {
          return this.coord;
        }, ln.prototype.print = function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex);
        }, ln.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.segmentIndex < e3.segmentIndex ? -1 : this.segmentIndex > e3.segmentIndex ? 1 : this.coord.equals2D(e3.coord) ? 0 : un.compare(this._segmentOctant, this.coord, e3.coord);
        }, ln.prototype.isEndPoint = function(t2) {
          return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t2;
        }, ln.prototype.isInterior = function() {
          return this._isInterior;
        }, ln.prototype.interfaces_ = function() {
          return [E];
        }, ln.prototype.getClass = function() {
          return ln;
        };
        var cn = function() {
          this._nodeMap = new p(), this._edge = null;
          var t2 = arguments[0];
          this._edge = t2;
        };
        cn.prototype.getSplitCoordinates = function() {
          var t2 = new St();
          this.addEndpoints();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next();
            this.addEdgeCoordinates(n2, i2, t2), n2 = i2;
          }
          return t2.toCoordinateArray();
        }, cn.prototype.addCollapsedNodes = function() {
          var t2 = new Nt();
          this.findCollapsesFromInsertedNodes(t2), this.findCollapsesFromExistingVertices(t2);
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next().intValue();
            this.add(this._edge.getCoordinate(n2), n2);
          }
        }, cn.prototype.print = function(t2) {
          t2.println("Intersections:");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, cn.prototype.findCollapsesFromExistingVertices = function(t2) {
          for (var e3 = 0; e3 < this._edge.size() - 2; e3++) {
            var n2 = this._edge.getCoordinate(e3), i2 = this._edge.getCoordinate(e3 + 2);
            n2.equals2D(i2) && t2.add(new M(e3 + 1));
          }
        }, cn.prototype.addEdgeCoordinates = function(t2, e3, n2) {
          var i2 = this._edge.getCoordinate(e3.segmentIndex), r2 = e3.isInterior() || !e3.coord.equals2D(i2);
          n2.add(new C(t2.coord), false);
          for (var o2 = t2.segmentIndex + 1; o2 <= e3.segmentIndex; o2++)
            n2.add(this._edge.getCoordinate(o2));
          r2 && n2.add(new C(e3.coord));
        }, cn.prototype.iterator = function() {
          return this._nodeMap.values().iterator();
        }, cn.prototype.addSplitEdges = function(t2) {
          this.addEndpoints(), this.addCollapsedNodes();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        }, cn.prototype.findCollapseIndex = function(t2, e3, n2) {
          if (!t2.coord.equals2D(e3.coord))
            return false;
          var i2 = e3.segmentIndex - t2.segmentIndex;
          return e3.isInterior() || i2--, 1 === i2 && (n2[0] = t2.segmentIndex + 1, true);
        }, cn.prototype.findCollapsesFromInsertedNodes = function(t2) {
          for (var e3 = new Array(1).fill(null), n2 = this.iterator(), i2 = n2.next(); n2.hasNext(); ) {
            var r2 = n2.next();
            this.findCollapseIndex(i2, r2, e3) && t2.add(new M(e3[0])), i2 = r2;
          }
        }, cn.prototype.getEdge = function() {
          return this._edge;
        }, cn.prototype.addEndpoints = function() {
          var t2 = this._edge.size() - 1;
          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t2), t2);
        }, cn.prototype.createSplitEdge = function(t2, e3) {
          var n2 = e3.segmentIndex - t2.segmentIndex + 2, i2 = this._edge.getCoordinate(e3.segmentIndex), r2 = e3.isInterior() || !e3.coord.equals2D(i2);
          r2 || n2--;
          var o2 = new Array(n2).fill(null), s2 = 0;
          o2[s2++] = new C(t2.coord);
          for (var a3 = t2.segmentIndex + 1; a3 <= e3.segmentIndex; a3++)
            o2[s2++] = this._edge.getCoordinate(a3);
          return r2 && (o2[s2] = new C(e3.coord)), new gn(o2, this._edge.getData());
        }, cn.prototype.add = function(t2, e3) {
          var n2 = new ln(this._edge, t2, e3, this._edge.getSegmentOctant(e3)), i2 = this._nodeMap.get(n2);
          return null !== i2 ? (et.isTrue(i2.coord.equals2D(t2), "Found equal nodes with different coordinates"), i2) : (this._nodeMap.put(n2, n2), n2);
        }, cn.prototype.checkSplitEdgesCorrectness = function(t2) {
          var e3 = this._edge.getCoordinates(), n2 = t2.get(0).getCoordinate(0);
          if (!n2.equals2D(e3[0]))
            throw new $("bad split edge start point at " + n2);
          var i2 = t2.get(t2.size() - 1).getCoordinates(), r2 = i2[i2.length - 1];
          if (!r2.equals2D(e3[e3.length - 1]))
            throw new $("bad split edge end point at " + r2);
        }, cn.prototype.interfaces_ = function() {
          return [];
        }, cn.prototype.getClass = function() {
          return cn;
        };
        var pn = function() {
        };
        pn.prototype.interfaces_ = function() {
          return [];
        }, pn.prototype.getClass = function() {
          return pn;
        }, pn.octant = function() {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e3 = arguments[1];
            if (0 === t2 && 0 === e3)
              throw new m("Cannot compute the octant for point ( " + t2 + ", " + e3 + " )");
            var n2 = Math.abs(t2), i2 = Math.abs(e3);
            return t2 >= 0 ? e3 >= 0 ? n2 >= i2 ? 0 : 1 : n2 >= i2 ? 7 : 6 : e3 >= 0 ? n2 >= i2 ? 3 : 2 : n2 >= i2 ? 4 : 5;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof C) {
            var r2 = arguments[0], o2 = arguments[1], s2 = o2.x - r2.x, a3 = o2.y - r2.y;
            if (0 === s2 && 0 === a3)
              throw new m("Cannot compute the octant for two identical points " + r2);
            return pn.octant(s2, a3);
          }
        };
        var hn = function() {
        };
        hn.prototype.getCoordinates = function() {
        }, hn.prototype.size = function() {
        }, hn.prototype.getCoordinate = function(t2) {
        }, hn.prototype.isClosed = function() {
        }, hn.prototype.setData = function(t2) {
        }, hn.prototype.getData = function() {
        }, hn.prototype.interfaces_ = function() {
          return [];
        }, hn.prototype.getClass = function() {
          return hn;
        };
        var fn = function() {
        };
        fn.prototype.addIntersection = function(t2, e3) {
        }, fn.prototype.interfaces_ = function() {
          return [hn];
        }, fn.prototype.getClass = function() {
          return fn;
        };
        var gn = function() {
          this._nodeList = new cn(this), this._pts = null, this._data = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._pts = t2, this._data = e3;
        };
        gn.prototype.getCoordinates = function() {
          return this._pts;
        }, gn.prototype.size = function() {
          return this._pts.length;
        }, gn.prototype.getCoordinate = function(t2) {
          return this._pts[t2];
        }, gn.prototype.isClosed = function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        }, gn.prototype.getSegmentOctant = function(t2) {
          return t2 === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
        }, gn.prototype.setData = function(t2) {
          this._data = t2;
        }, gn.prototype.safeOctant = function(t2, e3) {
          return t2.equals2D(e3) ? 0 : pn.octant(t2, e3);
        }, gn.prototype.getData = function() {
          return this._data;
        }, gn.prototype.addIntersection = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this.addIntersectionNode(t2, e3);
          } else if (4 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[3], o2 = new C(n2.getIntersection(r2));
            this.addIntersection(o2, i2);
          }
        }, gn.prototype.toString = function() {
          return Z2.toLineString(new ue(this._pts));
        }, gn.prototype.getNodeList = function() {
          return this._nodeList;
        }, gn.prototype.addIntersectionNode = function(t2, e3) {
          var n2 = e3, i2 = n2 + 1;
          if (i2 < this._pts.length) {
            var r2 = this._pts[i2];
            t2.equals2D(r2) && (n2 = i2);
          }
          return this._nodeList.add(t2, n2);
        }, gn.prototype.addIntersections = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++)
            this.addIntersection(t2, e3, n2, i2);
        }, gn.prototype.interfaces_ = function() {
          return [fn];
        }, gn.prototype.getClass = function() {
          return gn;
        }, gn.getNodedSubstrings = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = new Nt();
            return gn.getNodedSubstrings(t2, e3), e3;
          }
          if (2 === arguments.length)
            for (var n2 = arguments[0], i2 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
              r2.next().getNodeList().addSplitEdges(i2);
            }
        };
        var dn = function() {
          if (this.p0 = null, this.p1 = null, 0 === arguments.length)
            this.p0 = new C(), this.p1 = new C();
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.p0 = new C(t2.p0), this.p1 = new C(t2.p1);
          } else if (2 === arguments.length)
            this.p0 = arguments[0], this.p1 = arguments[1];
          else if (4 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3];
            this.p0 = new C(e3, n2), this.p1 = new C(i2, r2);
          }
        }, yn = { serialVersionUID: { configurable: true } };
        dn.prototype.minX = function() {
          return Math.min(this.p0.x, this.p1.x);
        }, dn.prototype.orientationIndex = function() {
          if (arguments[0] instanceof dn) {
            var t2 = arguments[0], e3 = at.orientationIndex(this.p0, this.p1, t2.p0), n2 = at.orientationIndex(this.p0, this.p1, t2.p1);
            return e3 >= 0 && n2 >= 0 ? Math.max(e3, n2) : e3 <= 0 && n2 <= 0 ? Math.max(e3, n2) : 0;
          }
          if (arguments[0] instanceof C) {
            var i2 = arguments[0];
            return at.orientationIndex(this.p0, this.p1, i2);
          }
        }, dn.prototype.toGeometry = function(t2) {
          return t2.createLineString([this.p0, this.p1]);
        }, dn.prototype.isVertical = function() {
          return this.p0.x === this.p1.x;
        }, dn.prototype.equals = function(t2) {
          if (!(t2 instanceof dn))
            return false;
          var e3 = t2;
          return this.p0.equals(e3.p0) && this.p1.equals(e3.p1);
        }, dn.prototype.intersection = function(t2) {
          var e3 = new rt();
          return e3.computeIntersection(this.p0, this.p1, t2.p0, t2.p1), e3.hasIntersection() ? e3.getIntersection(0) : null;
        }, dn.prototype.project = function() {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0];
            if (t2.equals(this.p0) || t2.equals(this.p1))
              return new C(t2);
            var e3 = this.projectionFactor(t2), n2 = new C();
            return n2.x = this.p0.x + e3 * (this.p1.x - this.p0.x), n2.y = this.p0.y + e3 * (this.p1.y - this.p0.y), n2;
          }
          if (arguments[0] instanceof dn) {
            var i2 = arguments[0], r2 = this.projectionFactor(i2.p0), o2 = this.projectionFactor(i2.p1);
            if (r2 >= 1 && o2 >= 1)
              return null;
            if (r2 <= 0 && o2 <= 0)
              return null;
            var s2 = this.project(i2.p0);
            r2 < 0 && (s2 = this.p0), r2 > 1 && (s2 = this.p1);
            var a3 = this.project(i2.p1);
            return o2 < 0 && (a3 = this.p0), o2 > 1 && (a3 = this.p1), new dn(s2, a3);
          }
        }, dn.prototype.normalize = function() {
          this.p1.compareTo(this.p0) < 0 && this.reverse();
        }, dn.prototype.angle = function() {
          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
        }, dn.prototype.getCoordinate = function(t2) {
          return 0 === t2 ? this.p0 : this.p1;
        }, dn.prototype.distancePerpendicular = function(t2) {
          return at.distancePointLinePerpendicular(t2, this.p0, this.p1);
        }, dn.prototype.minY = function() {
          return Math.min(this.p0.y, this.p1.y);
        }, dn.prototype.midPoint = function() {
          return dn.midPoint(this.p0, this.p1);
        }, dn.prototype.projectionFactor = function(t2) {
          if (t2.equals(this.p0))
            return 0;
          if (t2.equals(this.p1))
            return 1;
          var e3 = this.p1.x - this.p0.x, n2 = this.p1.y - this.p0.y, i2 = e3 * e3 + n2 * n2;
          if (i2 <= 0)
            return v.NaN;
          return ((t2.x - this.p0.x) * e3 + (t2.y - this.p0.y) * n2) / i2;
        }, dn.prototype.closestPoints = function(t2) {
          var e3 = this.intersection(t2);
          if (null !== e3)
            return [e3, e3];
          var n2 = new Array(2).fill(null), i2 = v.MAX_VALUE, r2 = null, o2 = this.closestPoint(t2.p0);
          i2 = o2.distance(t2.p0), n2[0] = o2, n2[1] = t2.p0;
          var s2 = this.closestPoint(t2.p1);
          (r2 = s2.distance(t2.p1)) < i2 && (i2 = r2, n2[0] = s2, n2[1] = t2.p1);
          var a3 = t2.closestPoint(this.p0);
          (r2 = a3.distance(this.p0)) < i2 && (i2 = r2, n2[0] = this.p0, n2[1] = a3);
          var u2 = t2.closestPoint(this.p1);
          return (r2 = u2.distance(this.p1)) < i2 && (i2 = r2, n2[0] = this.p1, n2[1] = u2), n2;
        }, dn.prototype.closestPoint = function(t2) {
          var e3 = this.projectionFactor(t2);
          if (e3 > 0 && e3 < 1)
            return this.project(t2);
          return this.p0.distance(t2) < this.p1.distance(t2) ? this.p0 : this.p1;
        }, dn.prototype.maxX = function() {
          return Math.max(this.p0.x, this.p1.x);
        }, dn.prototype.getLength = function() {
          return this.p0.distance(this.p1);
        }, dn.prototype.compareTo = function(t2) {
          var e3 = t2, n2 = this.p0.compareTo(e3.p0);
          return 0 !== n2 ? n2 : this.p1.compareTo(e3.p1);
        }, dn.prototype.reverse = function() {
          var t2 = this.p0;
          this.p0 = this.p1, this.p1 = t2;
        }, dn.prototype.equalsTopo = function(t2) {
          return this.p0.equals(t2.p0) && (this.p1.equals(t2.p1) || this.p0.equals(t2.p1)) && this.p1.equals(t2.p0);
        }, dn.prototype.lineIntersection = function(t2) {
          try {
            return k.intersection(this.p0, this.p1, t2.p0, t2.p1);
          } catch (t3) {
            if (!(t3 instanceof X))
              throw t3;
          }
          return null;
        }, dn.prototype.maxY = function() {
          return Math.max(this.p0.y, this.p1.y);
        }, dn.prototype.pointAlongOffset = function(t2, e3) {
          var n2 = this.p0.x + t2 * (this.p1.x - this.p0.x), i2 = this.p0.y + t2 * (this.p1.y - this.p0.y), r2 = this.p1.x - this.p0.x, o2 = this.p1.y - this.p0.y, s2 = Math.sqrt(r2 * r2 + o2 * o2), a3 = 0, u2 = 0;
          if (0 !== e3) {
            if (s2 <= 0)
              throw new Error("Cannot compute offset from zero-length line segment");
            a3 = e3 * r2 / s2, u2 = e3 * o2 / s2;
          }
          return new C(n2 - u2, i2 + a3);
        }, dn.prototype.setCoordinates = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setCoordinates(t2.p0, t2.p1);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this.p0.x = e3.x, this.p0.y = e3.y, this.p1.x = n2.x, this.p1.y = n2.y;
          }
        }, dn.prototype.segmentFraction = function(t2) {
          var e3 = this.projectionFactor(t2);
          return e3 < 0 ? e3 = 0 : (e3 > 1 || v.isNaN(e3)) && (e3 = 1), e3;
        }, dn.prototype.toString = function() {
          return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
        }, dn.prototype.isHorizontal = function() {
          return this.p0.y === this.p1.y;
        }, dn.prototype.distance = function() {
          if (arguments[0] instanceof dn) {
            var t2 = arguments[0];
            return at.distanceLineLine(this.p0, this.p1, t2.p0, t2.p1);
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            return at.distancePointLine(e3, this.p0, this.p1);
          }
        }, dn.prototype.pointAlong = function(t2) {
          var e3 = new C();
          return e3.x = this.p0.x + t2 * (this.p1.x - this.p0.x), e3.y = this.p0.y + t2 * (this.p1.y - this.p0.y), e3;
        }, dn.prototype.hashCode = function() {
          var t2 = v.doubleToLongBits(this.p0.x);
          t2 ^= 31 * v.doubleToLongBits(this.p0.y);
          var e3 = Math.trunc(t2) ^ Math.trunc(t2 >> 32), n2 = v.doubleToLongBits(this.p1.x);
          n2 ^= 31 * v.doubleToLongBits(this.p1.y);
          return e3 ^ (Math.trunc(n2) ^ Math.trunc(n2 >> 32));
        }, dn.prototype.interfaces_ = function() {
          return [E, e];
        }, dn.prototype.getClass = function() {
          return dn;
        }, dn.midPoint = function(t2, e3) {
          return new C((t2.x + e3.x) / 2, (t2.y + e3.y) / 2);
        }, yn.serialVersionUID.get = function() {
          return 3252005833466256400;
        }, Object.defineProperties(dn, yn);
        var _n = function() {
          this.tempEnv1 = new j(), this.tempEnv2 = new j(), this._overlapSeg1 = new dn(), this._overlapSeg2 = new dn();
        };
        _n.prototype.overlap = function() {
          if (2 === arguments.length)
            ;
          else if (4 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            t2.getLineSegment(e3, this._overlapSeg1), n2.getLineSegment(i2, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
          }
        }, _n.prototype.interfaces_ = function() {
          return [];
        }, _n.prototype.getClass = function() {
          return _n;
        };
        var mn = function() {
          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._pts = t2, this._start = e3, this._end = n2, this._context = i2;
        };
        mn.prototype.getLineSegment = function(t2, e3) {
          e3.p0 = this._pts[t2], e3.p1 = this._pts[t2 + 1];
        }, mn.prototype.computeSelect = function(t2, e3, n2, i2) {
          var r2 = this._pts[e3], o2 = this._pts[n2];
          if (i2.tempEnv1.init(r2, o2), n2 - e3 == 1)
            return i2.select(this, e3), null;
          if (!t2.intersects(i2.tempEnv1))
            return null;
          var s2 = Math.trunc((e3 + n2) / 2);
          e3 < s2 && this.computeSelect(t2, e3, s2, i2), s2 < n2 && this.computeSelect(t2, s2, n2, i2);
        }, mn.prototype.getCoordinates = function() {
          for (var t2 = new Array(this._end - this._start + 1).fill(null), e3 = 0, n2 = this._start; n2 <= this._end; n2++)
            t2[e3++] = this._pts[n2];
          return t2;
        }, mn.prototype.computeOverlaps = function(t2, e3) {
          this.computeOverlapsInternal(this._start, this._end, t2, t2._start, t2._end, e3);
        }, mn.prototype.setId = function(t2) {
          this._id = t2;
        }, mn.prototype.select = function(t2, e3) {
          this.computeSelect(t2, this._start, this._end, e3);
        }, mn.prototype.getEnvelope = function() {
          if (null === this._env) {
            var t2 = this._pts[this._start], e3 = this._pts[this._end];
            this._env = new j(t2, e3);
          }
          return this._env;
        }, mn.prototype.getEndIndex = function() {
          return this._end;
        }, mn.prototype.getStartIndex = function() {
          return this._start;
        }, mn.prototype.getContext = function() {
          return this._context;
        }, mn.prototype.getId = function() {
          return this._id;
        }, mn.prototype.computeOverlapsInternal = function(t2, e3, n2, i2, r2, o2) {
          var s2 = this._pts[t2], a3 = this._pts[e3], u2 = n2._pts[i2], l2 = n2._pts[r2];
          if (e3 - t2 == 1 && r2 - i2 == 1)
            return o2.overlap(this, t2, n2, i2), null;
          if (o2.tempEnv1.init(s2, a3), o2.tempEnv2.init(u2, l2), !o2.tempEnv1.intersects(o2.tempEnv2))
            return null;
          var c2 = Math.trunc((t2 + e3) / 2), p2 = Math.trunc((i2 + r2) / 2);
          t2 < c2 && (i2 < p2 && this.computeOverlapsInternal(t2, c2, n2, i2, p2, o2), p2 < r2 && this.computeOverlapsInternal(t2, c2, n2, p2, r2, o2)), c2 < e3 && (i2 < p2 && this.computeOverlapsInternal(c2, e3, n2, i2, p2, o2), p2 < r2 && this.computeOverlapsInternal(c2, e3, n2, p2, r2, o2));
        }, mn.prototype.interfaces_ = function() {
          return [];
        }, mn.prototype.getClass = function() {
          return mn;
        };
        var vn = function() {
        };
        vn.prototype.interfaces_ = function() {
          return [];
        }, vn.prototype.getClass = function() {
          return vn;
        }, vn.getChainStartIndices = function(t2) {
          var e3 = 0, n2 = new Nt();
          n2.add(new M(e3));
          do {
            var i2 = vn.findChainEnd(t2, e3);
            n2.add(new M(i2)), e3 = i2;
          } while (e3 < t2.length - 1);
          return vn.toIntArray(n2);
        }, vn.findChainEnd = function(t2, e3) {
          for (var n2 = e3; n2 < t2.length - 1 && t2[n2].equals2D(t2[n2 + 1]); )
            n2++;
          if (n2 >= t2.length - 1)
            return t2.length - 1;
          for (var i2 = Be.quadrant(t2[n2], t2[n2 + 1]), r2 = e3 + 1; r2 < t2.length; ) {
            if (!t2[r2 - 1].equals2D(t2[r2])) {
              if (Be.quadrant(t2[r2 - 1], t2[r2]) !== i2)
                break;
            }
            r2++;
          }
          return r2 - 1;
        }, vn.getChains = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return vn.getChains(t2, null);
          }
          if (2 === arguments.length) {
            for (var e3 = arguments[0], n2 = arguments[1], i2 = new Nt(), r2 = vn.getChainStartIndices(e3), o2 = 0; o2 < r2.length - 1; o2++) {
              var s2 = new mn(e3, r2[o2], r2[o2 + 1], n2);
              i2.add(s2);
            }
            return i2;
          }
        }, vn.toIntArray = function(t2) {
          for (var e3 = new Array(t2.size()).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = t2.get(n2).intValue();
          return e3;
        };
        var In = function() {
        };
        In.prototype.computeNodes = function(t2) {
        }, In.prototype.getNodedSubstrings = function() {
        }, In.prototype.interfaces_ = function() {
          return [];
        }, In.prototype.getClass = function() {
          return In;
        };
        var En = function() {
          if (this._segInt = null, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setSegmentIntersector(t2);
          }
        };
        En.prototype.setSegmentIntersector = function(t2) {
          this._segInt = t2;
        }, En.prototype.interfaces_ = function() {
          return [In];
        }, En.prototype.getClass = function() {
          return En;
        };
        var xn = function(t2) {
          function e3(e4) {
            e4 ? t2.call(this, e4) : t2.call(this), this._monoChains = new Nt(), this._index = new sn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0;
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { SegmentOverlapAction: { configurable: true } };
          return e3.prototype.getMonotoneChains = function() {
            return this._monoChains;
          }, e3.prototype.getNodedSubstrings = function() {
            return gn.getNodedSubstrings(this._nodedSegStrings);
          }, e3.prototype.getIndex = function() {
            return this._index;
          }, e3.prototype.add = function(t3) {
            for (var e4 = vn.getChains(t3.getCoordinates(), t3).iterator(); e4.hasNext(); ) {
              var n3 = e4.next();
              n3.setId(this._idCounter++), this._index.insert(n3.getEnvelope(), n3), this._monoChains.add(n3);
            }
          }, e3.prototype.computeNodes = function(t3) {
            this._nodedSegStrings = t3;
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            this.intersectChains();
          }, e3.prototype.intersectChains = function() {
            for (var t3 = new Nn(this._segInt), e4 = this._monoChains.iterator(); e4.hasNext(); )
              for (var n3 = e4.next(), i2 = this._index.query(n3.getEnvelope()).iterator(); i2.hasNext(); ) {
                var r2 = i2.next();
                if (r2.getId() > n3.getId() && (n3.computeOverlaps(r2, t3), this._nOverlaps++), this._segInt.isDone())
                  return null;
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.SegmentOverlapAction.get = function() {
            return Nn;
          }, Object.defineProperties(e3, n2), e3;
        }(En), Nn = function(t2) {
          function e3() {
            t2.call(this), this._si = null;
            var e4 = arguments[0];
            this._si = e4;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.overlap = function() {
            if (4 !== arguments.length)
              return t2.prototype.overlap.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3], o2 = e4.getContext(), s2 = i2.getContext();
            this._si.processIntersections(o2, n2, s2, r2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(_n), Cn = function t2() {
          if (this._quadrantSegments = t2.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t2.CAP_ROUND, this._joinStyle = t2.JOIN_ROUND, this._mitreLimit = t2.DEFAULT_MITRE_LIMIT, this._isSingleSided = false, this._simplifyFactor = t2.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.setQuadrantSegments(e3);
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.setQuadrantSegments(n2), this.setEndCapStyle(i2);
          } else if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a3 = arguments[3];
            this.setQuadrantSegments(r2), this.setEndCapStyle(o2), this.setJoinStyle(s2), this.setMitreLimit(a3);
          }
        }, Sn = { CAP_ROUND: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, JOIN_ROUND: { configurable: true }, JOIN_MITRE: { configurable: true }, JOIN_BEVEL: { configurable: true }, DEFAULT_QUADRANT_SEGMENTS: { configurable: true }, DEFAULT_MITRE_LIMIT: { configurable: true }, DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };
        Cn.prototype.getEndCapStyle = function() {
          return this._endCapStyle;
        }, Cn.prototype.isSingleSided = function() {
          return this._isSingleSided;
        }, Cn.prototype.setQuadrantSegments = function(t2) {
          this._quadrantSegments = t2, 0 === this._quadrantSegments && (this._joinStyle = Cn.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Cn.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t2 <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Cn.JOIN_ROUND && (this._quadrantSegments = Cn.DEFAULT_QUADRANT_SEGMENTS);
        }, Cn.prototype.getJoinStyle = function() {
          return this._joinStyle;
        }, Cn.prototype.setJoinStyle = function(t2) {
          this._joinStyle = t2;
        }, Cn.prototype.setSimplifyFactor = function(t2) {
          this._simplifyFactor = t2 < 0 ? 0 : t2;
        }, Cn.prototype.getSimplifyFactor = function() {
          return this._simplifyFactor;
        }, Cn.prototype.getQuadrantSegments = function() {
          return this._quadrantSegments;
        }, Cn.prototype.setEndCapStyle = function(t2) {
          this._endCapStyle = t2;
        }, Cn.prototype.getMitreLimit = function() {
          return this._mitreLimit;
        }, Cn.prototype.setMitreLimit = function(t2) {
          this._mitreLimit = t2;
        }, Cn.prototype.setSingleSided = function(t2) {
          this._isSingleSided = t2;
        }, Cn.prototype.interfaces_ = function() {
          return [];
        }, Cn.prototype.getClass = function() {
          return Cn;
        }, Cn.bufferDistanceError = function(t2) {
          var e3 = Math.PI / 2 / t2;
          return 1 - Math.cos(e3 / 2);
        }, Sn.CAP_ROUND.get = function() {
          return 1;
        }, Sn.CAP_FLAT.get = function() {
          return 2;
        }, Sn.CAP_SQUARE.get = function() {
          return 3;
        }, Sn.JOIN_ROUND.get = function() {
          return 1;
        }, Sn.JOIN_MITRE.get = function() {
          return 2;
        }, Sn.JOIN_BEVEL.get = function() {
          return 3;
        }, Sn.DEFAULT_QUADRANT_SEGMENTS.get = function() {
          return 8;
        }, Sn.DEFAULT_MITRE_LIMIT.get = function() {
          return 5;
        }, Sn.DEFAULT_SIMPLIFY_FACTOR.get = function() {
          return 0.01;
        }, Object.defineProperties(Cn, Sn);
        var Ln = function(t2) {
          this._distanceTol = null, this._isDeleted = null, this._angleOrientation = at.COUNTERCLOCKWISE, this._inputLine = t2 || null;
        }, bn = { INIT: { configurable: true }, DELETE: { configurable: true }, KEEP: { configurable: true }, NUM_PTS_TO_CHECK: { configurable: true } };
        Ln.prototype.isDeletable = function(t2, e3, n2, i2) {
          var r2 = this._inputLine[t2], o2 = this._inputLine[e3], s2 = this._inputLine[n2];
          return !!this.isConcave(r2, o2, s2) && (!!this.isShallow(r2, o2, s2, i2) && this.isShallowSampled(r2, o2, t2, n2, i2));
        }, Ln.prototype.deleteShallowConcavities = function() {
          for (var t2 = 1, e3 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e3), i2 = false; n2 < this._inputLine.length; ) {
            var r2 = false;
            this.isDeletable(t2, e3, n2, this._distanceTol) && (this._isDeleted[e3] = Ln.DELETE, r2 = true, i2 = true), t2 = r2 ? n2 : e3, e3 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e3);
          }
          return i2;
        }, Ln.prototype.isShallowConcavity = function(t2, e3, n2, i2) {
          if (!(at.computeOrientation(t2, e3, n2) === this._angleOrientation))
            return false;
          return at.distancePointLine(e3, t2, n2) < i2;
        }, Ln.prototype.isShallowSampled = function(t2, e3, n2, i2, r2) {
          var o2 = Math.trunc((i2 - n2) / Ln.NUM_PTS_TO_CHECK);
          o2 <= 0 && (o2 = 1);
          for (var s2 = n2; s2 < i2; s2 += o2)
            if (!this.isShallow(t2, e3, this._inputLine[s2], r2))
              return false;
          return true;
        }, Ln.prototype.isConcave = function(t2, e3, n2) {
          var i2 = at.computeOrientation(t2, e3, n2) === this._angleOrientation;
          return i2;
        }, Ln.prototype.simplify = function(t2) {
          this._distanceTol = Math.abs(t2), t2 < 0 && (this._angleOrientation = at.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
          var e3 = false;
          do {
            e3 = this.deleteShallowConcavities();
          } while (e3);
          return this.collapseLine();
        }, Ln.prototype.findNextNonDeletedIndex = function(t2) {
          for (var e3 = t2 + 1; e3 < this._inputLine.length && this._isDeleted[e3] === Ln.DELETE; )
            e3++;
          return e3;
        }, Ln.prototype.isShallow = function(t2, e3, n2, i2) {
          return at.distancePointLine(e3, t2, n2) < i2;
        }, Ln.prototype.collapseLine = function() {
          for (var t2 = new St(), e3 = 0; e3 < this._inputLine.length; e3++)
            this._isDeleted[e3] !== Ln.DELETE && t2.add(this._inputLine[e3]);
          return t2.toCoordinateArray();
        }, Ln.prototype.interfaces_ = function() {
          return [];
        }, Ln.prototype.getClass = function() {
          return Ln;
        }, Ln.simplify = function(t2, e3) {
          return new Ln(t2).simplify(e3);
        }, bn.INIT.get = function() {
          return 0;
        }, bn.DELETE.get = function() {
          return 1;
        }, bn.KEEP.get = function() {
          return 1;
        }, bn.NUM_PTS_TO_CHECK.get = function() {
          return 10;
        }, Object.defineProperties(Ln, bn);
        var wn = function() {
          this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new Nt();
        }, On = { COORDINATE_ARRAY_TYPE: { configurable: true } };
        wn.prototype.getCoordinates = function() {
          return this._ptList.toArray(wn.COORDINATE_ARRAY_TYPE);
        }, wn.prototype.setPrecisionModel = function(t2) {
          this._precisionModel = t2;
        }, wn.prototype.addPt = function(t2) {
          var e3 = new C(t2);
          if (this._precisionModel.makePrecise(e3), this.isRedundant(e3))
            return null;
          this._ptList.add(e3);
        }, wn.prototype.revere = function() {
        }, wn.prototype.addPts = function(t2, e3) {
          if (e3)
            for (var n2 = 0; n2 < t2.length; n2++)
              this.addPt(t2[n2]);
          else
            for (var i2 = t2.length - 1; i2 >= 0; i2--)
              this.addPt(t2[i2]);
        }, wn.prototype.isRedundant = function(t2) {
          if (this._ptList.size() < 1)
            return false;
          var e3 = this._ptList.get(this._ptList.size() - 1);
          return t2.distance(e3) < this._minimimVertexDistance;
        }, wn.prototype.toString = function() {
          return new _e().createLineString(this.getCoordinates()).toString();
        }, wn.prototype.closeRing = function() {
          if (this._ptList.size() < 1)
            return null;
          var t2 = new C(this._ptList.get(0)), e3 = this._ptList.get(this._ptList.size() - 1);
          if (t2.equals(e3))
            return null;
          this._ptList.add(t2);
        }, wn.prototype.setMinimumVertexDistance = function(t2) {
          this._minimimVertexDistance = t2;
        }, wn.prototype.interfaces_ = function() {
          return [];
        }, wn.prototype.getClass = function() {
          return wn;
        }, On.COORDINATE_ARRAY_TYPE.get = function() {
          return new Array(0).fill(null);
        }, Object.defineProperties(wn, On);
        var Tn = function() {
        }, Rn = { PI_TIMES_2: { configurable: true }, PI_OVER_2: { configurable: true }, PI_OVER_4: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, CLOCKWISE: { configurable: true }, NONE: { configurable: true } };
        Tn.prototype.interfaces_ = function() {
          return [];
        }, Tn.prototype.getClass = function() {
          return Tn;
        }, Tn.toDegrees = function(t2) {
          return 180 * t2 / Math.PI;
        }, Tn.normalize = function(t2) {
          for (; t2 > Math.PI; )
            t2 -= Tn.PI_TIMES_2;
          for (; t2 <= -Math.PI; )
            t2 += Tn.PI_TIMES_2;
          return t2;
        }, Tn.angle = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Math.atan2(t2.y, t2.x);
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = n2.x - e3.x, r2 = n2.y - e3.y;
            return Math.atan2(r2, i2);
          }
        }, Tn.isAcute = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y;
          return i2 * (n2.x - e3.x) + r2 * (n2.y - e3.y) > 0;
        }, Tn.isObtuse = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y;
          return i2 * (n2.x - e3.x) + r2 * (n2.y - e3.y) < 0;
        }, Tn.interiorAngle = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2);
          return Math.abs(r2 - i2);
        }, Tn.normalizePositive = function(t2) {
          if (t2 < 0) {
            for (; t2 < 0; )
              t2 += Tn.PI_TIMES_2;
            t2 >= Tn.PI_TIMES_2 && (t2 = 0);
          } else {
            for (; t2 >= Tn.PI_TIMES_2; )
              t2 -= Tn.PI_TIMES_2;
            t2 < 0 && (t2 = 0);
          }
          return t2;
        }, Tn.angleBetween = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2);
          return Tn.diff(i2, r2);
        }, Tn.diff = function(t2, e3) {
          var n2 = null;
          return (n2 = t2 < e3 ? e3 - t2 : t2 - e3) > Math.PI && (n2 = 2 * Math.PI - n2), n2;
        }, Tn.toRadians = function(t2) {
          return t2 * Math.PI / 180;
        }, Tn.getTurn = function(t2, e3) {
          var n2 = Math.sin(e3 - t2);
          return n2 > 0 ? Tn.COUNTERCLOCKWISE : n2 < 0 ? Tn.CLOCKWISE : Tn.NONE;
        }, Tn.angleBetweenOriented = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2) - i2;
          return r2 <= -Math.PI ? r2 + Tn.PI_TIMES_2 : r2 > Math.PI ? r2 - Tn.PI_TIMES_2 : r2;
        }, Rn.PI_TIMES_2.get = function() {
          return 2 * Math.PI;
        }, Rn.PI_OVER_2.get = function() {
          return Math.PI / 2;
        }, Rn.PI_OVER_4.get = function() {
          return Math.PI / 4;
        }, Rn.COUNTERCLOCKWISE.get = function() {
          return at.COUNTERCLOCKWISE;
        }, Rn.CLOCKWISE.get = function() {
          return at.CLOCKWISE;
        }, Rn.NONE.get = function() {
          return at.COLLINEAR;
        }, Object.defineProperties(Tn, Rn);
        var Pn = function t2() {
          this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new dn(), this._seg1 = new dn(), this._offset0 = new dn(), this._offset1 = new dn(), this._side = 0, this._hasNarrowConcaveAngle = false;
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._precisionModel = e3, this._bufParams = n2, this._li = new rt(), this._filletAngleQuantum = Math.PI / 2 / n2.getQuadrantSegments(), n2.getQuadrantSegments() >= 8 && n2.getJoinStyle() === Cn.JOIN_ROUND && (this._closingSegLengthFactor = t2.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i2);
        }, Dn = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };
        Pn.prototype.addNextSegment = function(t2, e3) {
          if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t2, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2))
            return null;
          var n2 = at.computeOrientation(this._s0, this._s1, this._s2), i2 = n2 === at.CLOCKWISE && this._side === Se.LEFT || n2 === at.COUNTERCLOCKWISE && this._side === Se.RIGHT;
          0 === n2 ? this.addCollinear(e3) : i2 ? this.addOutsideTurn(n2, e3) : this.addInsideTurn(n2, e3);
        }, Pn.prototype.addLineEndCap = function(t2, e3) {
          var n2 = new dn(t2, e3), i2 = new dn();
          this.computeOffsetSegment(n2, Se.LEFT, this._distance, i2);
          var r2 = new dn();
          this.computeOffsetSegment(n2, Se.RIGHT, this._distance, r2);
          var o2 = e3.x - t2.x, s2 = e3.y - t2.y, a3 = Math.atan2(s2, o2);
          switch (this._bufParams.getEndCapStyle()) {
            case Cn.CAP_ROUND:
              this._segList.addPt(i2.p1), this.addFilletArc(e3, a3 + Math.PI / 2, a3 - Math.PI / 2, at.CLOCKWISE, this._distance), this._segList.addPt(r2.p1);
              break;
            case Cn.CAP_FLAT:
              this._segList.addPt(i2.p1), this._segList.addPt(r2.p1);
              break;
            case Cn.CAP_SQUARE:
              var u2 = new C();
              u2.x = Math.abs(this._distance) * Math.cos(a3), u2.y = Math.abs(this._distance) * Math.sin(a3);
              var l2 = new C(i2.p1.x + u2.x, i2.p1.y + u2.y), c2 = new C(r2.p1.x + u2.x, r2.p1.y + u2.y);
              this._segList.addPt(l2), this._segList.addPt(c2);
          }
        }, Pn.prototype.getCoordinates = function() {
          return this._segList.getCoordinates();
        }, Pn.prototype.addMitreJoin = function(t2, e3, n2, i2) {
          var r2 = true, o2 = null;
          try {
            o2 = k.intersection(e3.p0, e3.p1, n2.p0, n2.p1);
            (i2 <= 0 ? 1 : o2.distance(t2) / Math.abs(i2)) > this._bufParams.getMitreLimit() && (r2 = false);
          } catch (t3) {
            if (!(t3 instanceof X))
              throw t3;
            o2 = new C(0, 0), r2 = false;
          }
          r2 ? this._segList.addPt(o2) : this.addLimitedMitreJoin(e3, n2, i2, this._bufParams.getMitreLimit());
        }, Pn.prototype.addFilletCorner = function(t2, e3, n2, i2, r2) {
          var o2 = e3.x - t2.x, s2 = e3.y - t2.y, a3 = Math.atan2(s2, o2), u2 = n2.x - t2.x, l2 = n2.y - t2.y, c2 = Math.atan2(l2, u2);
          i2 === at.CLOCKWISE ? a3 <= c2 && (a3 += 2 * Math.PI) : a3 >= c2 && (a3 -= 2 * Math.PI), this._segList.addPt(e3), this.addFilletArc(t2, a3, c2, i2, r2), this._segList.addPt(n2);
        }, Pn.prototype.addOutsideTurn = function(t2, e3) {
          if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.OFFSET_SEGMENT_SEPARATION_FACTOR)
            return this._segList.addPt(this._offset0.p1), null;
          this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e3 && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t2, this._distance), this._segList.addPt(this._offset1.p0));
        }, Pn.prototype.createSquare = function(t2) {
          this._segList.addPt(new C(t2.x + this._distance, t2.y + this._distance)), this._segList.addPt(new C(t2.x + this._distance, t2.y - this._distance)), this._segList.addPt(new C(t2.x - this._distance, t2.y - this._distance)), this._segList.addPt(new C(t2.x - this._distance, t2.y + this._distance)), this._segList.closeRing();
        }, Pn.prototype.addSegments = function(t2, e3) {
          this._segList.addPts(t2, e3);
        }, Pn.prototype.addFirstSegment = function() {
          this._segList.addPt(this._offset1.p0);
        }, Pn.prototype.addLastSegment = function() {
          this._segList.addPt(this._offset1.p1);
        }, Pn.prototype.initSideSegments = function(t2, e3, n2) {
          this._s1 = t2, this._s2 = e3, this._side = n2, this._seg1.setCoordinates(t2, e3), this.computeOffsetSegment(this._seg1, n2, this._distance, this._offset1);
        }, Pn.prototype.addLimitedMitreJoin = function(t2, e3, n2, i2) {
          var r2 = this._seg0.p1, o2 = Tn.angle(r2, this._seg0.p0), s2 = Tn.angleBetweenOriented(this._seg0.p0, r2, this._seg1.p1) / 2, a3 = Tn.normalize(o2 + s2), u2 = Tn.normalize(a3 + Math.PI), l2 = i2 * n2, c2 = n2 - l2 * Math.abs(Math.sin(s2)), p2 = r2.x + l2 * Math.cos(u2), h2 = r2.y + l2 * Math.sin(u2), f2 = new C(p2, h2), g2 = new dn(r2, f2), d2 = g2.pointAlongOffset(1, c2), y4 = g2.pointAlongOffset(1, -c2);
          this._side === Se.LEFT ? (this._segList.addPt(d2), this._segList.addPt(y4)) : (this._segList.addPt(y4), this._segList.addPt(d2));
        }, Pn.prototype.computeOffsetSegment = function(t2, e3, n2, i2) {
          var r2 = e3 === Se.LEFT ? 1 : -1, o2 = t2.p1.x - t2.p0.x, s2 = t2.p1.y - t2.p0.y, a3 = Math.sqrt(o2 * o2 + s2 * s2), u2 = r2 * n2 * o2 / a3, l2 = r2 * n2 * s2 / a3;
          i2.p0.x = t2.p0.x - l2, i2.p0.y = t2.p0.y + u2, i2.p1.x = t2.p1.x - l2, i2.p1.y = t2.p1.y + u2;
        }, Pn.prototype.addFilletArc = function(t2, e3, n2, i2, r2) {
          var o2 = i2 === at.CLOCKWISE ? -1 : 1, s2 = Math.abs(e3 - n2), a3 = Math.trunc(s2 / this._filletAngleQuantum + 0.5);
          if (a3 < 1)
            return null;
          for (var u2 = s2 / a3, l2 = 0, c2 = new C(); l2 < s2; ) {
            var p2 = e3 + o2 * l2;
            c2.x = t2.x + r2 * Math.cos(p2), c2.y = t2.y + r2 * Math.sin(p2), this._segList.addPt(c2), l2 += u2;
          }
        }, Pn.prototype.addInsideTurn = function(t2, e3) {
          if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection())
            this._segList.addPt(this._li.getIntersection(0));
          else if (this._hasNarrowConcaveAngle = true, this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
            this._segList.addPt(this._offset0.p1);
          else {
            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
              var n2 = new C((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(n2);
              var i2 = new C((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(i2);
            } else
              this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0);
          }
        }, Pn.prototype.createCircle = function(t2) {
          var e3 = new C(t2.x + this._distance, t2.y);
          this._segList.addPt(e3), this.addFilletArc(t2, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
        }, Pn.prototype.addBevelJoin = function(t2, e3) {
          this._segList.addPt(t2.p1), this._segList.addPt(e3.p0);
        }, Pn.prototype.init = function(t2) {
          this._distance = t2, this._maxCurveSegmentError = t2 * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new wn(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t2 * Pn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
        }, Pn.prototype.addCollinear = function(t2) {
          this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
          this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL || this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? (t2 && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, at.CLOCKWISE, this._distance));
        }, Pn.prototype.closeRing = function() {
          this._segList.closeRing();
        }, Pn.prototype.hasNarrowConcaveAngle = function() {
          return this._hasNarrowConcaveAngle;
        }, Pn.prototype.interfaces_ = function() {
          return [];
        }, Pn.prototype.getClass = function() {
          return Pn;
        }, Dn.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
          return 1e-3;
        }, Dn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
          return 1e-3;
        }, Dn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
          return 1e-6;
        }, Dn.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
          return 80;
        }, Object.defineProperties(Pn, Dn);
        var Mn = function() {
          this._distance = 0, this._precisionModel = null, this._bufParams = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._precisionModel = t2, this._bufParams = e3;
        };
        Mn.prototype.getOffsetCurve = function(t2, e3) {
          if (this._distance = e3, 0 === e3)
            return null;
          var n2 = e3 < 0, i2 = Math.abs(e3), r2 = this.getSegGen(i2);
          t2.length <= 1 ? this.computePointCurve(t2[0], r2) : this.computeOffsetCurve(t2, n2, r2);
          var o2 = r2.getCoordinates();
          return n2 && Lt.reverse(o2), o2;
        }, Mn.prototype.computeSingleSidedBufferCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e3) {
            n2.addSegments(t2, true);
            var r2 = Ln.simplify(t2, -i2), o2 = r2.length - 1;
            n2.initSideSegments(r2[o2], r2[o2 - 1], Se.LEFT), n2.addFirstSegment();
            for (var s2 = o2 - 2; s2 >= 0; s2--)
              n2.addNextSegment(r2[s2], true);
          } else {
            n2.addSegments(t2, false);
            var a3 = Ln.simplify(t2, i2), u2 = a3.length - 1;
            n2.initSideSegments(a3[0], a3[1], Se.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u2; l2++)
              n2.addNextSegment(a3[l2], true);
          }
          n2.addLastSegment(), n2.closeRing();
        }, Mn.prototype.computeRingBufferCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          e3 === Se.RIGHT && (i2 = -i2);
          var r2 = Ln.simplify(t2, i2), o2 = r2.length - 1;
          n2.initSideSegments(r2[o2 - 1], r2[0], e3);
          for (var s2 = 1; s2 <= o2; s2++) {
            var a3 = 1 !== s2;
            n2.addNextSegment(r2[s2], a3);
          }
          n2.closeRing();
        }, Mn.prototype.computeLineBufferCurve = function(t2, e3) {
          var n2 = this.simplifyTolerance(this._distance), i2 = Ln.simplify(t2, n2), r2 = i2.length - 1;
          e3.initSideSegments(i2[0], i2[1], Se.LEFT);
          for (var o2 = 2; o2 <= r2; o2++)
            e3.addNextSegment(i2[o2], true);
          e3.addLastSegment(), e3.addLineEndCap(i2[r2 - 1], i2[r2]);
          var s2 = Ln.simplify(t2, -n2), a3 = s2.length - 1;
          e3.initSideSegments(s2[a3], s2[a3 - 1], Se.LEFT);
          for (var u2 = a3 - 2; u2 >= 0; u2--)
            e3.addNextSegment(s2[u2], true);
          e3.addLastSegment(), e3.addLineEndCap(s2[1], s2[0]), e3.closeRing();
        }, Mn.prototype.computePointCurve = function(t2, e3) {
          switch (this._bufParams.getEndCapStyle()) {
            case Cn.CAP_ROUND:
              e3.createCircle(t2);
              break;
            case Cn.CAP_SQUARE:
              e3.createSquare(t2);
          }
        }, Mn.prototype.getLineCurve = function(t2, e3) {
          if (this._distance = e3, e3 < 0 && !this._bufParams.isSingleSided())
            return null;
          if (0 === e3)
            return null;
          var n2 = Math.abs(e3), i2 = this.getSegGen(n2);
          if (t2.length <= 1)
            this.computePointCurve(t2[0], i2);
          else if (this._bufParams.isSingleSided()) {
            var r2 = e3 < 0;
            this.computeSingleSidedBufferCurve(t2, r2, i2);
          } else
            this.computeLineBufferCurve(t2, i2);
          return i2.getCoordinates();
        }, Mn.prototype.getBufferParameters = function() {
          return this._bufParams;
        }, Mn.prototype.simplifyTolerance = function(t2) {
          return t2 * this._bufParams.getSimplifyFactor();
        }, Mn.prototype.getRingCurve = function(t2, e3, n2) {
          if (this._distance = n2, t2.length <= 2)
            return this.getLineCurve(t2, n2);
          if (0 === n2)
            return Mn.copyCoordinates(t2);
          var i2 = this.getSegGen(n2);
          return this.computeRingBufferCurve(t2, e3, i2), i2.getCoordinates();
        }, Mn.prototype.computeOffsetCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e3) {
            var r2 = Ln.simplify(t2, -i2), o2 = r2.length - 1;
            n2.initSideSegments(r2[o2], r2[o2 - 1], Se.LEFT), n2.addFirstSegment();
            for (var s2 = o2 - 2; s2 >= 0; s2--)
              n2.addNextSegment(r2[s2], true);
          } else {
            var a3 = Ln.simplify(t2, i2), u2 = a3.length - 1;
            n2.initSideSegments(a3[0], a3[1], Se.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u2; l2++)
              n2.addNextSegment(a3[l2], true);
          }
          n2.addLastSegment();
        }, Mn.prototype.getSegGen = function(t2) {
          return new Pn(this._precisionModel, this._bufParams, t2);
        }, Mn.prototype.interfaces_ = function() {
          return [];
        }, Mn.prototype.getClass = function() {
          return Mn;
        }, Mn.copyCoordinates = function(t2) {
          for (var e3 = new Array(t2.length).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = new C(t2[n2]);
          return e3;
        };
        var An = function() {
          this._subgraphs = null, this._seg = new dn(), this._cga = new at();
          var t2 = arguments[0];
          this._subgraphs = t2;
        }, Fn = { DepthSegment: { configurable: true } };
        An.prototype.findStabbedSegments = function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = new Nt(), n2 = this._subgraphs.iterator(); n2.hasNext(); ) {
              var i2 = n2.next(), r2 = i2.getEnvelope();
              t2.y < r2.getMinY() || t2.y > r2.getMaxY() || this.findStabbedSegments(t2, i2.getDirectedEdges(), e3);
            }
            return e3;
          }
          if (3 === arguments.length) {
            if (T(arguments[2], xt) && arguments[0] instanceof C && arguments[1] instanceof ze)
              for (var o2 = arguments[0], s2 = arguments[1], a3 = arguments[2], u2 = s2.getEdge().getCoordinates(), l2 = 0; l2 < u2.length - 1; l2++) {
                this._seg.p0 = u2[l2], this._seg.p1 = u2[l2 + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse();
                if (!(Math.max(this._seg.p0.x, this._seg.p1.x) < o2.x) && !(this._seg.isHorizontal() || o2.y < this._seg.p0.y || o2.y > this._seg.p1.y || at.computeOrientation(this._seg.p0, this._seg.p1, o2) === at.RIGHT)) {
                  var c2 = s2.getDepth(Se.LEFT);
                  this._seg.p0.equals(u2[l2]) || (c2 = s2.getDepth(Se.RIGHT));
                  var p2 = new Gn(this._seg, c2);
                  a3.add(p2);
                }
              }
            else if (T(arguments[2], xt) && arguments[0] instanceof C && T(arguments[1], xt))
              for (var h2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = f2.iterator(); d2.hasNext(); ) {
                var y4 = d2.next();
                y4.isForward() && this.findStabbedSegments(h2, y4, g2);
              }
          }
        }, An.prototype.getDepth = function(t2) {
          var e3 = this.findStabbedSegments(t2);
          if (0 === e3.size())
            return 0;
          return $e.min(e3)._leftDepth;
        }, An.prototype.interfaces_ = function() {
          return [];
        }, An.prototype.getClass = function() {
          return An;
        }, Fn.DepthSegment.get = function() {
          return Gn;
        }, Object.defineProperties(An, Fn);
        var Gn = function() {
          this._upwardSeg = null, this._leftDepth = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._upwardSeg = new dn(t2), this._leftDepth = e3;
        };
        Gn.prototype.compareTo = function(t2) {
          var e3 = t2;
          if (this._upwardSeg.minX() >= e3._upwardSeg.maxX())
            return 1;
          if (this._upwardSeg.maxX() <= e3._upwardSeg.minX())
            return -1;
          var n2 = this._upwardSeg.orientationIndex(e3._upwardSeg);
          return 0 !== n2 ? n2 : 0 != (n2 = -1 * e3._upwardSeg.orientationIndex(this._upwardSeg)) ? n2 : this._upwardSeg.compareTo(e3._upwardSeg);
        }, Gn.prototype.compareX = function(t2, e3) {
          var n2 = t2.p0.compareTo(e3.p0);
          return 0 !== n2 ? n2 : t2.p1.compareTo(e3.p1);
        }, Gn.prototype.toString = function() {
          return this._upwardSeg.toString();
        }, Gn.prototype.interfaces_ = function() {
          return [E];
        }, Gn.prototype.getClass = function() {
          return Gn;
        };
        var qn = function(t2, e3, n2) {
          this.p0 = t2 || null, this.p1 = e3 || null, this.p2 = n2 || null;
        };
        qn.prototype.area = function() {
          return qn.area(this.p0, this.p1, this.p2);
        }, qn.prototype.signedArea = function() {
          return qn.signedArea(this.p0, this.p1, this.p2);
        }, qn.prototype.interpolateZ = function(t2) {
          if (null === t2)
            throw new m("Supplied point is null.");
          return qn.interpolateZ(t2, this.p0, this.p1, this.p2);
        }, qn.prototype.longestSideLength = function() {
          return qn.longestSideLength(this.p0, this.p1, this.p2);
        }, qn.prototype.isAcute = function() {
          return qn.isAcute(this.p0, this.p1, this.p2);
        }, qn.prototype.circumcentre = function() {
          return qn.circumcentre(this.p0, this.p1, this.p2);
        }, qn.prototype.area3D = function() {
          return qn.area3D(this.p0, this.p1, this.p2);
        }, qn.prototype.centroid = function() {
          return qn.centroid(this.p0, this.p1, this.p2);
        }, qn.prototype.inCentre = function() {
          return qn.inCentre(this.p0, this.p1, this.p2);
        }, qn.prototype.interfaces_ = function() {
          return [];
        }, qn.prototype.getClass = function() {
          return qn;
        }, qn.area = function(t2, e3, n2) {
          return Math.abs(((n2.x - t2.x) * (e3.y - t2.y) - (e3.x - t2.x) * (n2.y - t2.y)) / 2);
        }, qn.signedArea = function(t2, e3, n2) {
          return ((n2.x - t2.x) * (e3.y - t2.y) - (e3.x - t2.x) * (n2.y - t2.y)) / 2;
        }, qn.det = function(t2, e3, n2, i2) {
          return t2 * i2 - e3 * n2;
        }, qn.interpolateZ = function(t2, e3, n2, i2) {
          var r2 = e3.x, o2 = e3.y, s2 = n2.x - r2, a3 = i2.x - r2, u2 = n2.y - o2, l2 = i2.y - o2, c2 = s2 * l2 - a3 * u2, p2 = t2.x - r2, h2 = t2.y - o2, f2 = (l2 * p2 - a3 * h2) / c2, g2 = (-u2 * p2 + s2 * h2) / c2;
          return e3.z + f2 * (n2.z - e3.z) + g2 * (i2.z - e3.z);
        }, qn.longestSideLength = function(t2, e3, n2) {
          var i2 = t2.distance(e3), r2 = e3.distance(n2), o2 = n2.distance(t2), s2 = i2;
          return r2 > s2 && (s2 = r2), o2 > s2 && (s2 = o2), s2;
        }, qn.isAcute = function(t2, e3, n2) {
          return !!Tn.isAcute(t2, e3, n2) && (!!Tn.isAcute(e3, n2, t2) && !!Tn.isAcute(n2, t2, e3));
        }, qn.circumcentre = function(t2, e3, n2) {
          var i2 = n2.x, r2 = n2.y, o2 = t2.x - i2, s2 = t2.y - r2, a3 = e3.x - i2, u2 = e3.y - r2, l2 = 2 * qn.det(o2, s2, a3, u2), c2 = qn.det(s2, o2 * o2 + s2 * s2, u2, a3 * a3 + u2 * u2), p2 = qn.det(o2, o2 * o2 + s2 * s2, a3, a3 * a3 + u2 * u2);
          return new C(i2 - c2 / l2, r2 + p2 / l2);
        }, qn.perpendicularBisector = function(t2, e3) {
          var n2 = e3.x - t2.x, i2 = e3.y - t2.y, r2 = new k(t2.x + n2 / 2, t2.y + i2 / 2, 1), o2 = new k(t2.x - i2 + n2 / 2, t2.y + n2 + i2 / 2, 1);
          return new k(r2, o2);
        }, qn.angleBisector = function(t2, e3, n2) {
          var i2 = e3.distance(t2), r2 = i2 / (i2 + e3.distance(n2)), o2 = n2.x - t2.x, s2 = n2.y - t2.y;
          return new C(t2.x + r2 * o2, t2.y + r2 * s2);
        }, qn.area3D = function(t2, e3, n2) {
          var i2 = e3.x - t2.x, r2 = e3.y - t2.y, o2 = e3.z - t2.z, s2 = n2.x - t2.x, a3 = n2.y - t2.y, u2 = n2.z - t2.z, l2 = r2 * u2 - o2 * a3, c2 = o2 * s2 - i2 * u2, p2 = i2 * a3 - r2 * s2, h2 = l2 * l2 + c2 * c2 + p2 * p2, f2 = Math.sqrt(h2) / 2;
          return f2;
        }, qn.centroid = function(t2, e3, n2) {
          var i2 = (t2.x + e3.x + n2.x) / 3, r2 = (t2.y + e3.y + n2.y) / 3;
          return new C(i2, r2);
        }, qn.inCentre = function(t2, e3, n2) {
          var i2 = e3.distance(n2), r2 = t2.distance(n2), o2 = t2.distance(e3), s2 = i2 + r2 + o2, a3 = (i2 * t2.x + r2 * e3.x + o2 * n2.x) / s2, u2 = (i2 * t2.y + r2 * e3.y + o2 * n2.y) / s2;
          return new C(a3, u2);
        };
        var Bn = function() {
          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new Nt();
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._inputGeom = t2, this._distance = e3, this._curveBuilder = n2;
        };
        Bn.prototype.addPoint = function(t2) {
          if (this._distance <= 0)
            return null;
          var e3 = t2.getCoordinates(), n2 = this._curveBuilder.getLineCurve(e3, this._distance);
          this.addCurve(n2, w.EXTERIOR, w.INTERIOR);
        }, Bn.prototype.addPolygon = function(t2) {
          var e3 = this._distance, n2 = Se.LEFT;
          this._distance < 0 && (e3 = -this._distance, n2 = Se.RIGHT);
          var i2 = t2.getExteriorRing(), r2 = Lt.removeRepeatedPoints(i2.getCoordinates());
          if (this._distance < 0 && this.isErodedCompletely(i2, this._distance))
            return null;
          if (this._distance <= 0 && r2.length < 3)
            return null;
          this.addPolygonRing(r2, e3, n2, w.EXTERIOR, w.INTERIOR);
          for (var o2 = 0; o2 < t2.getNumInteriorRing(); o2++) {
            var s2 = t2.getInteriorRingN(o2), a3 = Lt.removeRepeatedPoints(s2.getCoordinates());
            this._distance > 0 && this.isErodedCompletely(s2, -this._distance) || this.addPolygonRing(a3, e3, Se.opposite(n2), w.INTERIOR, w.EXTERIOR);
          }
        }, Bn.prototype.isTriangleErodedCompletely = function(t2, e3) {
          var n2 = new qn(t2[0], t2[1], t2[2]), i2 = n2.inCentre();
          return at.distancePointLine(i2, n2.p0, n2.p1) < Math.abs(e3);
        }, Bn.prototype.addLineString = function(t2) {
          if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided())
            return null;
          var e3 = Lt.removeRepeatedPoints(t2.getCoordinates()), n2 = this._curveBuilder.getLineCurve(e3, this._distance);
          this.addCurve(n2, w.EXTERIOR, w.INTERIOR);
        }, Bn.prototype.addCurve = function(t2, e3, n2) {
          if (null === t2 || t2.length < 2)
            return null;
          var i2 = new gn(t2, new Pe(0, w.BOUNDARY, e3, n2));
          this._curveList.add(i2);
        }, Bn.prototype.getCurves = function() {
          return this.add(this._inputGeom), this._curveList;
        }, Bn.prototype.addPolygonRing = function(t2, e3, n2, i2, r2) {
          if (0 === e3 && t2.length < ee2.MINIMUM_VALID_SIZE)
            return null;
          var o2 = i2, s2 = r2;
          t2.length >= ee2.MINIMUM_VALID_SIZE && at.isCCW(t2) && (o2 = r2, s2 = i2, n2 = Se.opposite(n2));
          var a3 = this._curveBuilder.getRingCurve(t2, n2, e3);
          this.addCurve(a3, o2, s2);
        }, Bn.prototype.add = function(t2) {
          if (t2.isEmpty())
            return null;
          t2 instanceof $t ? this.addPolygon(t2) : t2 instanceof Kt ? this.addLineString(t2) : t2 instanceof Qt ? this.addPoint(t2) : t2 instanceof te ? this.addCollection(t2) : t2 instanceof Xt ? this.addCollection(t2) : t2 instanceof ne ? this.addCollection(t2) : t2 instanceof zt && this.addCollection(t2);
        }, Bn.prototype.isErodedCompletely = function(t2, e3) {
          var n2 = t2.getCoordinates();
          if (n2.length < 4)
            return e3 < 0;
          if (4 === n2.length)
            return this.isTriangleErodedCompletely(n2, e3);
          var i2 = t2.getEnvelopeInternal(), r2 = Math.min(i2.getHeight(), i2.getWidth());
          return e3 < 0 && 2 * Math.abs(e3) > r2;
        }, Bn.prototype.addCollection = function(t2) {
          for (var e3 = 0; e3 < t2.getNumGeometries(); e3++) {
            var n2 = t2.getGeometryN(e3);
            this.add(n2);
          }
        }, Bn.prototype.interfaces_ = function() {
          return [];
        }, Bn.prototype.getClass = function() {
          return Bn;
        };
        var Vn = function() {
        };
        Vn.prototype.locate = function(t2) {
        }, Vn.prototype.interfaces_ = function() {
          return [];
        }, Vn.prototype.getClass = function() {
          return Vn;
        };
        var Un = function() {
          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
          var t2 = arguments[0];
          this._parent = t2, this._atStart = true, this._index = 0, this._max = t2.getNumGeometries();
        };
        Un.prototype.next = function() {
          if (this._atStart)
            return this._atStart = false, Un.isAtomic(this._parent) && this._index++, this._parent;
          if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext())
              return this._subcollectionIterator.next();
            this._subcollectionIterator = null;
          }
          if (this._index >= this._max)
            throw new i();
          var t2 = this._parent.getGeometryN(this._index++);
          return t2 instanceof zt ? (this._subcollectionIterator = new Un(t2), this._subcollectionIterator.next()) : t2;
        }, Un.prototype.remove = function() {
          throw new Error(this.getClass().getName());
        }, Un.prototype.hasNext = function() {
          if (this._atStart)
            return true;
          if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext())
              return true;
            this._subcollectionIterator = null;
          }
          return !(this._index >= this._max);
        }, Un.prototype.interfaces_ = function() {
          return [Et];
        }, Un.prototype.getClass = function() {
          return Un;
        }, Un.isAtomic = function(t2) {
          return !(t2 instanceof zt);
        };
        var zn = function() {
          this._geom = null;
          var t2 = arguments[0];
          this._geom = t2;
        };
        zn.prototype.locate = function(t2) {
          return zn.locate(t2, this._geom);
        }, zn.prototype.interfaces_ = function() {
          return [Vn];
        }, zn.prototype.getClass = function() {
          return zn;
        }, zn.isPointInRing = function(t2, e3) {
          return !!e3.getEnvelopeInternal().intersects(t2) && at.isPointInRing(t2, e3.getCoordinates());
        }, zn.containsPointInPolygon = function(t2, e3) {
          if (e3.isEmpty())
            return false;
          var n2 = e3.getExteriorRing();
          if (!zn.isPointInRing(t2, n2))
            return false;
          for (var i2 = 0; i2 < e3.getNumInteriorRing(); i2++) {
            var r2 = e3.getInteriorRingN(i2);
            if (zn.isPointInRing(t2, r2))
              return false;
          }
          return true;
        }, zn.containsPoint = function(t2, e3) {
          if (e3 instanceof $t)
            return zn.containsPointInPolygon(t2, e3);
          if (e3 instanceof zt)
            for (var n2 = new Un(e3); n2.hasNext(); ) {
              var i2 = n2.next();
              if (i2 !== e3 && zn.containsPoint(t2, i2))
                return true;
            }
          return false;
        }, zn.locate = function(t2, e3) {
          return e3.isEmpty() ? w.EXTERIOR : zn.containsPoint(t2, e3) ? w.INTERIOR : w.EXTERIOR;
        };
        var Xn = function() {
          this._edgeMap = new p(), this._edgeList = null, this._ptInAreaLocation = [w.NONE, w.NONE];
        };
        Xn.prototype.getNextCW = function(t2) {
          this.getEdges();
          var e3 = this._edgeList.indexOf(t2), n2 = e3 - 1;
          return 0 === e3 && (n2 = this._edgeList.size() - 1), this._edgeList.get(n2);
        }, Xn.prototype.propagateSideLabels = function(t2) {
          for (var e3 = w.NONE, n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().getLabel();
            i2.isArea(t2) && i2.getLocation(t2, Se.LEFT) !== w.NONE && (e3 = i2.getLocation(t2, Se.LEFT));
          }
          if (e3 === w.NONE)
            return null;
          for (var r2 = e3, o2 = this.iterator(); o2.hasNext(); ) {
            var s2 = o2.next(), a3 = s2.getLabel();
            if (a3.getLocation(t2, Se.ON) === w.NONE && a3.setLocation(t2, Se.ON, r2), a3.isArea(t2)) {
              var u2 = a3.getLocation(t2, Se.LEFT), l2 = a3.getLocation(t2, Se.RIGHT);
              if (l2 !== w.NONE) {
                if (l2 !== r2)
                  throw new we("side location conflict", s2.getCoordinate());
                u2 === w.NONE && et.shouldNeverReachHere("found single null side (at " + s2.getCoordinate() + ")"), r2 = u2;
              } else
                et.isTrue(a3.getLocation(t2, Se.LEFT) === w.NONE, "found single null side"), a3.setLocation(t2, Se.RIGHT, r2), a3.setLocation(t2, Se.LEFT, r2);
            }
          }
        }, Xn.prototype.getCoordinate = function() {
          var t2 = this.iterator();
          if (!t2.hasNext())
            return null;
          return t2.next().getCoordinate();
        }, Xn.prototype.print = function(t2) {
          Y.out.println("EdgeEndStar:   " + this.getCoordinate());
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, Xn.prototype.isAreaLabelsConsistent = function(t2) {
          return this.computeEdgeEndLabels(t2.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
        }, Xn.prototype.checkAreaLabelsConsistent = function(t2) {
          var e3 = this.getEdges();
          if (e3.size() <= 0)
            return true;
          var n2 = e3.size() - 1, i2 = e3.get(n2).getLabel().getLocation(t2, Se.LEFT);
          et.isTrue(i2 !== w.NONE, "Found unlabelled area edge");
          for (var r2 = i2, o2 = this.iterator(); o2.hasNext(); ) {
            var s2 = o2.next().getLabel();
            et.isTrue(s2.isArea(t2), "Found non-area edge");
            var a3 = s2.getLocation(t2, Se.LEFT), u2 = s2.getLocation(t2, Se.RIGHT);
            if (a3 === u2)
              return false;
            if (u2 !== r2)
              return false;
            r2 = a3;
          }
          return true;
        }, Xn.prototype.findIndex = function(t2) {
          this.iterator();
          for (var e3 = 0; e3 < this._edgeList.size(); e3++) {
            if (this._edgeList.get(e3) === t2)
              return e3;
          }
          return -1;
        }, Xn.prototype.iterator = function() {
          return this.getEdges().iterator();
        }, Xn.prototype.getEdges = function() {
          return null === this._edgeList && (this._edgeList = new Nt(this._edgeMap.values())), this._edgeList;
        }, Xn.prototype.getLocation = function(t2, e3, n2) {
          return this._ptInAreaLocation[t2] === w.NONE && (this._ptInAreaLocation[t2] = zn.locate(e3, n2[t2].getGeometry())), this._ptInAreaLocation[t2];
        }, Xn.prototype.toString = function() {
          var t2 = new D();
          t2.append("EdgeEndStar:   " + this.getCoordinate()), t2.append("\n");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            t2.append(n2), t2.append("\n");
          }
          return t2.toString();
        }, Xn.prototype.computeEdgeEndLabels = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().computeLabel(t2);
          }
        }, Xn.prototype.computeLabelling = function(t2) {
          this.computeEdgeEndLabels(t2[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
          for (var e3 = [false, false], n2 = this.iterator(); n2.hasNext(); )
            for (var i2 = n2.next().getLabel(), r2 = 0; r2 < 2; r2++)
              i2.isLine(r2) && i2.getLocation(r2) === w.BOUNDARY && (e3[r2] = true);
          for (var o2 = this.iterator(); o2.hasNext(); )
            for (var s2 = o2.next(), a3 = s2.getLabel(), u2 = 0; u2 < 2; u2++)
              if (a3.isAnyNull(u2)) {
                var l2 = w.NONE;
                if (e3[u2])
                  l2 = w.EXTERIOR;
                else {
                  var c2 = s2.getCoordinate();
                  l2 = this.getLocation(u2, c2, t2);
                }
                a3.setAllLocationsIfNull(u2, l2);
              }
        }, Xn.prototype.getDegree = function() {
          return this._edgeMap.size();
        }, Xn.prototype.insertEdgeEnd = function(t2, e3) {
          this._edgeMap.put(t2, e3), this._edgeList = null;
        }, Xn.prototype.interfaces_ = function() {
          return [];
        }, Xn.prototype.getClass = function() {
          return Xn;
        };
        var Yn = function(t2) {
          function e3() {
            t2.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.linkResultDirectedEdges = function() {
            this.getResultAreaEdges();
            for (var t3 = null, e4 = null, n2 = this._SCANNING_FOR_INCOMING, i2 = 0; i2 < this._resultAreaEdgeList.size(); i2++) {
              var r2 = this._resultAreaEdgeList.get(i2), o2 = r2.getSym();
              if (r2.getLabel().isArea())
                switch (null === t3 && r2.isInResult() && (t3 = r2), n2) {
                  case this._SCANNING_FOR_INCOMING:
                    if (!o2.isInResult())
                      continue;
                    e4 = o2, n2 = this._LINKING_TO_OUTGOING;
                    break;
                  case this._LINKING_TO_OUTGOING:
                    if (!r2.isInResult())
                      continue;
                    e4.setNext(r2), n2 = this._SCANNING_FOR_INCOMING;
                }
            }
            if (n2 === this._LINKING_TO_OUTGOING) {
              if (null === t3)
                throw new we("no outgoing dirEdge found", this.getCoordinate());
              et.isTrue(t3.isInResult(), "unable to link last incoming dirEdge"), e4.setNext(t3);
            }
          }, e3.prototype.insert = function(t3) {
            var e4 = t3;
            this.insertEdgeEnd(e4, e4);
          }, e3.prototype.getRightmostEdge = function() {
            var t3 = this.getEdges(), e4 = t3.size();
            if (e4 < 1)
              return null;
            var n2 = t3.get(0);
            if (1 === e4)
              return n2;
            var i2 = t3.get(e4 - 1), r2 = n2.getQuadrant(), o2 = i2.getQuadrant();
            return Be.isNorthern(r2) && Be.isNorthern(o2) ? n2 : Be.isNorthern(r2) || Be.isNorthern(o2) ? 0 !== n2.getDy() ? n2 : 0 !== i2.getDy() ? i2 : (et.shouldNeverReachHere("found two horizontal edges incident on node"), null) : i2;
          }, e3.prototype.print = function(t3) {
            Y.out.println("DirectedEdgeStar: " + this.getCoordinate());
            for (var e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              t3.print("out "), n2.print(t3), t3.println(), t3.print("in "), n2.getSym().print(t3), t3.println();
            }
          }, e3.prototype.getResultAreaEdges = function() {
            if (null !== this._resultAreaEdgeList)
              return this._resultAreaEdgeList;
            this._resultAreaEdgeList = new Nt();
            for (var t3 = this.iterator(); t3.hasNext(); ) {
              var e4 = t3.next();
              (e4.isInResult() || e4.getSym().isInResult()) && this._resultAreaEdgeList.add(e4);
            }
            return this._resultAreaEdgeList;
          }, e3.prototype.updateLabelling = function(t3) {
            for (var e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next().getLabel();
              n2.setAllLocationsIfNull(0, t3.getLocation(0)), n2.setAllLocationsIfNull(1, t3.getLocation(1));
            }
          }, e3.prototype.linkAllDirectedEdges = function() {
            this.getEdges();
            for (var t3 = null, e4 = null, n2 = this._edgeList.size() - 1; n2 >= 0; n2--) {
              var i2 = this._edgeList.get(n2), r2 = i2.getSym();
              null === e4 && (e4 = r2), null !== t3 && r2.setNext(t3), t3 = i2;
            }
            e4.setNext(t3);
          }, e3.prototype.computeDepths = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0], e4 = this.findIndex(t3), n2 = t3.getDepth(Se.LEFT), i2 = t3.getDepth(Se.RIGHT), r2 = this.computeDepths(e4 + 1, this._edgeList.size(), n2);
              if (this.computeDepths(0, e4, r2) !== i2)
                throw new we("depth mismatch at " + t3.getCoordinate());
            } else if (3 === arguments.length) {
              for (var o2 = arguments[0], s2 = arguments[1], a3 = arguments[2], u2 = o2; u2 < s2; u2++) {
                var l2 = this._edgeList.get(u2);
                l2.setEdgeDepths(Se.RIGHT, a3), a3 = l2.getDepth(Se.LEFT);
              }
              return a3;
            }
          }, e3.prototype.mergeSymLabels = function() {
            for (var t3 = this.iterator(); t3.hasNext(); ) {
              var e4 = t3.next();
              e4.getLabel().merge(e4.getSym().getLabel());
            }
          }, e3.prototype.linkMinimalDirectedEdges = function(t3) {
            for (var e4 = null, n2 = null, i2 = this._SCANNING_FOR_INCOMING, r2 = this._resultAreaEdgeList.size() - 1; r2 >= 0; r2--) {
              var o2 = this._resultAreaEdgeList.get(r2), s2 = o2.getSym();
              switch (null === e4 && o2.getEdgeRing() === t3 && (e4 = o2), i2) {
                case this._SCANNING_FOR_INCOMING:
                  if (s2.getEdgeRing() !== t3)
                    continue;
                  n2 = s2, i2 = this._LINKING_TO_OUTGOING;
                  break;
                case this._LINKING_TO_OUTGOING:
                  if (o2.getEdgeRing() !== t3)
                    continue;
                  n2.setNextMin(o2), i2 = this._SCANNING_FOR_INCOMING;
              }
            }
            i2 === this._LINKING_TO_OUTGOING && (et.isTrue(null !== e4, "found null for first outgoing dirEdge"), et.isTrue(e4.getEdgeRing() === t3, "unable to link last incoming dirEdge"), n2.setNextMin(e4));
          }, e3.prototype.getOutgoingDegree = function() {
            if (0 === arguments.length) {
              for (var t3 = 0, e4 = this.iterator(); e4.hasNext(); ) {
                e4.next().isInResult() && t3++;
              }
              return t3;
            }
            if (1 === arguments.length) {
              for (var n2 = arguments[0], i2 = 0, r2 = this.iterator(); r2.hasNext(); ) {
                r2.next().getEdgeRing() === n2 && i2++;
              }
              return i2;
            }
          }, e3.prototype.getLabel = function() {
            return this._label;
          }, e3.prototype.findCoveredLineEdges = function() {
            for (var t3 = w.NONE, e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next(), i2 = n2.getSym();
              if (!n2.isLineEdge()) {
                if (n2.isInResult()) {
                  t3 = w.INTERIOR;
                  break;
                }
                if (i2.isInResult()) {
                  t3 = w.EXTERIOR;
                  break;
                }
              }
            }
            if (t3 === w.NONE)
              return null;
            for (var r2 = t3, o2 = this.iterator(); o2.hasNext(); ) {
              var s2 = o2.next(), a3 = s2.getSym();
              s2.isLineEdge() ? s2.getEdge().setCovered(r2 === w.INTERIOR) : (s2.isInResult() && (r2 = w.EXTERIOR), a3.isInResult() && (r2 = w.INTERIOR));
            }
          }, e3.prototype.computeLabelling = function(e4) {
            t2.prototype.computeLabelling.call(this, e4), this._label = new Pe(w.NONE);
            for (var n2 = this.iterator(); n2.hasNext(); )
              for (var i2 = n2.next().getEdge().getLabel(), r2 = 0; r2 < 2; r2++) {
                var o2 = i2.getLocation(r2);
                o2 !== w.INTERIOR && o2 !== w.BOUNDARY || this._label.setLocation(r2, w.INTERIOR);
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Xn), kn = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.createNode = function(t3) {
            return new Ge(t3, new Yn());
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Xe), jn = function t2() {
          this._pts = null, this._orientation = null;
          var e3 = arguments[0];
          this._pts = e3, this._orientation = t2.orientation(e3);
        };
        jn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return jn.compareOriented(this._pts, this._orientation, e3._pts, e3._orientation);
        }, jn.prototype.interfaces_ = function() {
          return [E];
        }, jn.prototype.getClass = function() {
          return jn;
        }, jn.orientation = function(t2) {
          return 1 === Lt.increasingDirection(t2);
        }, jn.compareOriented = function(t2, e3, n2, i2) {
          for (var r2 = e3 ? 1 : -1, o2 = i2 ? 1 : -1, s2 = e3 ? t2.length : -1, a3 = i2 ? n2.length : -1, u2 = e3 ? 0 : t2.length - 1, l2 = i2 ? 0 : n2.length - 1; ; ) {
            var c2 = t2[u2].compareTo(n2[l2]);
            if (0 !== c2)
              return c2;
            var p2 = (u2 += r2) === s2, h2 = (l2 += o2) === a3;
            if (p2 && !h2)
              return -1;
            if (!p2 && h2)
              return 1;
            if (p2 && h2)
              return 0;
          }
        };
        var Hn = function() {
          this._edges = new Nt(), this._ocaMap = new p();
        };
        Hn.prototype.print = function(t2) {
          t2.print("MULTILINESTRING ( ");
          for (var e3 = 0; e3 < this._edges.size(); e3++) {
            var n2 = this._edges.get(e3);
            e3 > 0 && t2.print(","), t2.print("(");
            for (var i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++)
              r2 > 0 && t2.print(","), t2.print(i2[r2].x + " " + i2[r2].y);
            t2.println(")");
          }
          t2.print(")  ");
        }, Hn.prototype.addAll = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); )
            this.add(e3.next());
        }, Hn.prototype.findEdgeIndex = function(t2) {
          for (var e3 = 0; e3 < this._edges.size(); e3++)
            if (this._edges.get(e3).equals(t2))
              return e3;
          return -1;
        }, Hn.prototype.iterator = function() {
          return this._edges.iterator();
        }, Hn.prototype.getEdges = function() {
          return this._edges;
        }, Hn.prototype.get = function(t2) {
          return this._edges.get(t2);
        }, Hn.prototype.findEqualEdge = function(t2) {
          var e3 = new jn(t2.getCoordinates());
          return this._ocaMap.get(e3);
        }, Hn.prototype.add = function(t2) {
          this._edges.add(t2);
          var e3 = new jn(t2.getCoordinates());
          this._ocaMap.put(e3, t2);
        }, Hn.prototype.interfaces_ = function() {
          return [];
        }, Hn.prototype.getClass = function() {
          return Hn;
        };
        var Wn = function() {
        };
        Wn.prototype.processIntersections = function(t2, e3, n2, i2) {
        }, Wn.prototype.isDone = function() {
        }, Wn.prototype.interfaces_ = function() {
          return [];
        }, Wn.prototype.getClass = function() {
          return Wn;
        };
        var Kn = function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._hasInterior = false, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
          var t2 = arguments[0];
          this._li = t2;
        };
        Kn.prototype.isTrivialIntersection = function(t2, e3, n2, i2) {
          if (t2 === n2 && 1 === this._li.getIntersectionNum()) {
            if (Kn.isAdjacentSegments(e3, i2))
              return true;
            if (t2.isClosed()) {
              var r2 = t2.size() - 1;
              if (0 === e3 && i2 === r2 || 0 === i2 && e3 === r2)
                return true;
            }
          }
          return false;
        }, Kn.prototype.getProperIntersectionPoint = function() {
          return this._properIntersectionPoint;
        }, Kn.prototype.hasProperInteriorIntersection = function() {
          return this._hasProperInterior;
        }, Kn.prototype.getLineIntersector = function() {
          return this._li;
        }, Kn.prototype.hasProperIntersection = function() {
          return this._hasProper;
        }, Kn.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          this.numTests++;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a3 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a3), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = true), this.isTrivialIntersection(t2, e3, n2, i2) || (this._hasIntersection = true, t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = true, this._hasProperInterior = true)));
        }, Kn.prototype.hasIntersection = function() {
          return this._hasIntersection;
        }, Kn.prototype.isDone = function() {
          return false;
        }, Kn.prototype.hasInteriorIntersection = function() {
          return this._hasInterior;
        }, Kn.prototype.interfaces_ = function() {
          return [Wn];
        }, Kn.prototype.getClass = function() {
          return Kn;
        }, Kn.isAdjacentSegments = function(t2, e3) {
          return 1 === Math.abs(t2 - e3);
        };
        var Jn = function() {
          this.coord = null, this.segmentIndex = null, this.dist = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this.coord = new C(t2), this.segmentIndex = e3, this.dist = n2;
        };
        Jn.prototype.getSegmentIndex = function() {
          return this.segmentIndex;
        }, Jn.prototype.getCoordinate = function() {
          return this.coord;
        }, Jn.prototype.print = function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex), t2.println(" dist = " + this.dist);
        }, Jn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.compare(e3.segmentIndex, e3.dist);
        }, Jn.prototype.isEndPoint = function(t2) {
          return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t2;
        }, Jn.prototype.toString = function() {
          return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
        }, Jn.prototype.getDistance = function() {
          return this.dist;
        }, Jn.prototype.compare = function(t2, e3) {
          return this.segmentIndex < t2 ? -1 : this.segmentIndex > t2 ? 1 : this.dist < e3 ? -1 : this.dist > e3 ? 1 : 0;
        }, Jn.prototype.interfaces_ = function() {
          return [E];
        }, Jn.prototype.getClass = function() {
          return Jn;
        };
        var Qn = function() {
          this._nodeMap = new p(), this.edge = null;
          var t2 = arguments[0];
          this.edge = t2;
        };
        Qn.prototype.print = function(t2) {
          t2.println("Intersections:");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, Qn.prototype.iterator = function() {
          return this._nodeMap.values().iterator();
        }, Qn.prototype.addSplitEdges = function(t2) {
          this.addEndpoints();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        }, Qn.prototype.addEndpoints = function() {
          var t2 = this.edge.pts.length - 1;
          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t2], t2, 0);
        }, Qn.prototype.createSplitEdge = function(t2, e3) {
          var n2 = e3.segmentIndex - t2.segmentIndex + 2, i2 = this.edge.pts[e3.segmentIndex], r2 = e3.dist > 0 || !e3.coord.equals2D(i2);
          r2 || n2--;
          var o2 = new Array(n2).fill(null), s2 = 0;
          o2[s2++] = new C(t2.coord);
          for (var a3 = t2.segmentIndex + 1; a3 <= e3.segmentIndex; a3++)
            o2[s2++] = this.edge.pts[a3];
          return r2 && (o2[s2] = e3.coord), new ni(o2, new Pe(this.edge._label));
        }, Qn.prototype.add = function(t2, e3, n2) {
          var i2 = new Jn(t2, e3, n2), r2 = this._nodeMap.get(i2);
          return null !== r2 ? r2 : (this._nodeMap.put(i2, i2), i2);
        }, Qn.prototype.isIntersection = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            if (e3.next().coord.equals(t2))
              return true;
          }
          return false;
        }, Qn.prototype.interfaces_ = function() {
          return [];
        }, Qn.prototype.getClass = function() {
          return Qn;
        };
        var Zn = function() {
        };
        Zn.prototype.getChainStartIndices = function(t2) {
          var e3 = 0, n2 = new Nt();
          n2.add(new M(e3));
          do {
            var i2 = this.findChainEnd(t2, e3);
            n2.add(new M(i2)), e3 = i2;
          } while (e3 < t2.length - 1);
          return Zn.toIntArray(n2);
        }, Zn.prototype.findChainEnd = function(t2, e3) {
          for (var n2 = Be.quadrant(t2[e3], t2[e3 + 1]), i2 = e3 + 1; i2 < t2.length; ) {
            if (Be.quadrant(t2[i2 - 1], t2[i2]) !== n2)
              break;
            i2++;
          }
          return i2 - 1;
        }, Zn.prototype.interfaces_ = function() {
          return [];
        }, Zn.prototype.getClass = function() {
          return Zn;
        }, Zn.toIntArray = function(t2) {
          for (var e3 = new Array(t2.size()).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = t2.get(n2).intValue();
          return e3;
        };
        var $n = function() {
          this.e = null, this.pts = null, this.startIndex = null, this.env1 = new j(), this.env2 = new j();
          var t2 = arguments[0];
          this.e = t2, this.pts = t2.getCoordinates();
          var e3 = new Zn();
          this.startIndex = e3.getChainStartIndices(this.pts);
        };
        $n.prototype.getCoordinates = function() {
          return this.pts;
        }, $n.prototype.getMaxX = function(t2) {
          var e3 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e3 > n2 ? e3 : n2;
        }, $n.prototype.getMinX = function(t2) {
          var e3 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e3 < n2 ? e3 : n2;
        }, $n.prototype.computeIntersectsForChain = function() {
          if (4 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            this.computeIntersectsForChain(this.startIndex[t2], this.startIndex[t2 + 1], e3, e3.startIndex[n2], e3.startIndex[n2 + 1], i2);
          } else if (6 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a3 = arguments[3], u2 = arguments[4], l2 = arguments[5], c2 = this.pts[r2], p2 = this.pts[o2], h2 = s2.pts[a3], f2 = s2.pts[u2];
            if (o2 - r2 == 1 && u2 - a3 == 1)
              return l2.addIntersections(this.e, r2, s2.e, a3), null;
            if (this.env1.init(c2, p2), this.env2.init(h2, f2), !this.env1.intersects(this.env2))
              return null;
            var g2 = Math.trunc((r2 + o2) / 2), d2 = Math.trunc((a3 + u2) / 2);
            r2 < g2 && (a3 < d2 && this.computeIntersectsForChain(r2, g2, s2, a3, d2, l2), d2 < u2 && this.computeIntersectsForChain(r2, g2, s2, d2, u2, l2)), g2 < o2 && (a3 < d2 && this.computeIntersectsForChain(g2, o2, s2, a3, d2, l2), d2 < u2 && this.computeIntersectsForChain(g2, o2, s2, d2, u2, l2));
          }
        }, $n.prototype.getStartIndexes = function() {
          return this.startIndex;
        }, $n.prototype.computeIntersects = function(t2, e3) {
          for (var n2 = 0; n2 < this.startIndex.length - 1; n2++)
            for (var i2 = 0; i2 < t2.startIndex.length - 1; i2++)
              this.computeIntersectsForChain(n2, t2, i2, e3);
        }, $n.prototype.interfaces_ = function() {
          return [];
        }, $n.prototype.getClass = function() {
          return $n;
        };
        var ti = function t2() {
          this._depth = Array(2).fill().map(function() {
            return Array(3);
          });
          for (var e3 = 0; e3 < 2; e3++)
            for (var n2 = 0; n2 < 3; n2++)
              this._depth[e3][n2] = t2.NULL_VALUE;
        }, ei = { NULL_VALUE: { configurable: true } };
        ti.prototype.getDepth = function(t2, e3) {
          return this._depth[t2][e3];
        }, ti.prototype.setDepth = function(t2, e3, n2) {
          this._depth[t2][e3] = n2;
        }, ti.prototype.isNull = function() {
          if (0 === arguments.length) {
            for (var t2 = 0; t2 < 2; t2++)
              for (var e3 = 0; e3 < 3; e3++)
                if (this._depth[t2][e3] !== ti.NULL_VALUE)
                  return false;
            return true;
          }
          if (1 === arguments.length) {
            var n2 = arguments[0];
            return this._depth[n2][1] === ti.NULL_VALUE;
          }
          if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return this._depth[i2][r2] === ti.NULL_VALUE;
          }
        }, ti.prototype.normalize = function() {
          for (var t2 = 0; t2 < 2; t2++)
            if (!this.isNull(t2)) {
              var e3 = this._depth[t2][1];
              this._depth[t2][2] < e3 && (e3 = this._depth[t2][2]), e3 < 0 && (e3 = 0);
              for (var n2 = 1; n2 < 3; n2++) {
                var i2 = 0;
                this._depth[t2][n2] > e3 && (i2 = 1), this._depth[t2][n2] = i2;
              }
            }
        }, ti.prototype.getDelta = function(t2) {
          return this._depth[t2][Se.RIGHT] - this._depth[t2][Se.LEFT];
        }, ti.prototype.getLocation = function(t2, e3) {
          return this._depth[t2][e3] <= 0 ? w.EXTERIOR : w.INTERIOR;
        }, ti.prototype.toString = function() {
          return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
        }, ti.prototype.add = function() {
          if (1 === arguments.length)
            for (var t2 = arguments[0], e3 = 0; e3 < 2; e3++)
              for (var n2 = 1; n2 < 3; n2++) {
                var i2 = t2.getLocation(e3, n2);
                i2 !== w.EXTERIOR && i2 !== w.INTERIOR || (this.isNull(e3, n2) ? this._depth[e3][n2] = ti.depthAtLocation(i2) : this._depth[e3][n2] += ti.depthAtLocation(i2));
              }
          else if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1];
            arguments[2] === w.INTERIOR && this._depth[r2][o2]++;
          }
        }, ti.prototype.interfaces_ = function() {
          return [];
        }, ti.prototype.getClass = function() {
          return ti;
        }, ti.depthAtLocation = function(t2) {
          return t2 === w.EXTERIOR ? 0 : t2 === w.INTERIOR ? 1 : ti.NULL_VALUE;
        }, ei.NULL_VALUE.get = function() {
          return -1;
        }, Object.defineProperties(ti, ei);
        var ni = function(t2) {
          function e3() {
            if (t2.call(this), this.pts = null, this._env = null, this.eiList = new Qn(this), this._name = null, this._mce = null, this._isIsolated = true, this._depth = new ti(), this._depthDelta = 0, 1 === arguments.length) {
              var n2 = arguments[0];
              e3.call(this, n2, null);
            } else if (2 === arguments.length) {
              var i2 = arguments[0], r2 = arguments[1];
              this.pts = i2, this._label = r2;
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getDepth = function() {
            return this._depth;
          }, e3.prototype.getCollapsedEdge = function() {
            var t3 = new Array(2).fill(null);
            t3[0] = this.pts[0], t3[1] = this.pts[1];
            return new e3(t3, Pe.toLineLabel(this._label));
          }, e3.prototype.isIsolated = function() {
            return this._isIsolated;
          }, e3.prototype.getCoordinates = function() {
            return this.pts;
          }, e3.prototype.setIsolated = function(t3) {
            this._isIsolated = t3;
          }, e3.prototype.setName = function(t3) {
            this._name = t3;
          }, e3.prototype.equals = function(t3) {
            if (!(t3 instanceof e3))
              return false;
            var n2 = t3;
            if (this.pts.length !== n2.pts.length)
              return false;
            for (var i2 = true, r2 = true, o2 = this.pts.length, s2 = 0; s2 < this.pts.length; s2++)
              if (this.pts[s2].equals2D(n2.pts[s2]) || (i2 = false), this.pts[s2].equals2D(n2.pts[--o2]) || (r2 = false), !i2 && !r2)
                return false;
            return true;
          }, e3.prototype.getCoordinate = function() {
            if (0 === arguments.length)
              return this.pts.length > 0 ? this.pts[0] : null;
            if (1 === arguments.length) {
              var t3 = arguments[0];
              return this.pts[t3];
            }
          }, e3.prototype.print = function(t3) {
            t3.print("edge " + this._name + ": "), t3.print("LINESTRING (");
            for (var e4 = 0; e4 < this.pts.length; e4++)
              e4 > 0 && t3.print(","), t3.print(this.pts[e4].x + " " + this.pts[e4].y);
            t3.print(")  " + this._label + " " + this._depthDelta);
          }, e3.prototype.computeIM = function(t3) {
            e3.updateIM(this._label, t3);
          }, e3.prototype.isCollapsed = function() {
            return !!this._label.isArea() && (3 === this.pts.length && !!this.pts[0].equals(this.pts[2]));
          }, e3.prototype.isClosed = function() {
            return this.pts[0].equals(this.pts[this.pts.length - 1]);
          }, e3.prototype.getMaximumSegmentIndex = function() {
            return this.pts.length - 1;
          }, e3.prototype.getDepthDelta = function() {
            return this._depthDelta;
          }, e3.prototype.getNumPoints = function() {
            return this.pts.length;
          }, e3.prototype.printReverse = function(t3) {
            t3.print("edge " + this._name + ": ");
            for (var e4 = this.pts.length - 1; e4 >= 0; e4--)
              t3.print(this.pts[e4] + " ");
            t3.println("");
          }, e3.prototype.getMonotoneChainEdge = function() {
            return null === this._mce && (this._mce = new $n(this)), this._mce;
          }, e3.prototype.getEnvelope = function() {
            if (null === this._env) {
              this._env = new j();
              for (var t3 = 0; t3 < this.pts.length; t3++)
                this._env.expandToInclude(this.pts[t3]);
            }
            return this._env;
          }, e3.prototype.addIntersection = function(t3, e4, n2, i2) {
            var r2 = new C(t3.getIntersection(i2)), o2 = e4, s2 = t3.getEdgeDistance(n2, i2), a3 = o2 + 1;
            if (a3 < this.pts.length) {
              var u2 = this.pts[a3];
              r2.equals2D(u2) && (o2 = a3, s2 = 0);
            }
            this.eiList.add(r2, o2, s2);
          }, e3.prototype.toString = function() {
            var t3 = new D();
            t3.append("edge " + this._name + ": "), t3.append("LINESTRING (");
            for (var e4 = 0; e4 < this.pts.length; e4++)
              e4 > 0 && t3.append(","), t3.append(this.pts[e4].x + " " + this.pts[e4].y);
            return t3.append(")  " + this._label + " " + this._depthDelta), t3.toString();
          }, e3.prototype.isPointwiseEqual = function(t3) {
            if (this.pts.length !== t3.pts.length)
              return false;
            for (var e4 = 0; e4 < this.pts.length; e4++)
              if (!this.pts[e4].equals2D(t3.pts[e4]))
                return false;
            return true;
          }, e3.prototype.setDepthDelta = function(t3) {
            this._depthDelta = t3;
          }, e3.prototype.getEdgeIntersectionList = function() {
            return this.eiList;
          }, e3.prototype.addIntersections = function(t3, e4, n2) {
            for (var i2 = 0; i2 < t3.getIntersectionNum(); i2++)
              this.addIntersection(t3, e4, n2, i2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.updateIM = function() {
            if (2 !== arguments.length)
              return t2.prototype.updateIM.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1];
            n2.setAtLeastIfValid(e4.getLocation(0, Se.ON), e4.getLocation(1, Se.ON), 1), e4.isArea() && (n2.setAtLeastIfValid(e4.getLocation(0, Se.LEFT), e4.getLocation(1, Se.LEFT), 2), n2.setAtLeastIfValid(e4.getLocation(0, Se.RIGHT), e4.getLocation(1, Se.RIGHT), 2));
          }, e3;
        }(Fe), ii = function(t2) {
          this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Hn(), this._bufParams = t2 || null;
        };
        ii.prototype.setWorkingPrecisionModel = function(t2) {
          this._workingPrecisionModel = t2;
        }, ii.prototype.insertUniqueEdge = function(t2) {
          var e3 = this._edgeList.findEqualEdge(t2);
          if (null !== e3) {
            var n2 = e3.getLabel(), i2 = t2.getLabel();
            e3.isPointwiseEqual(t2) || (i2 = new Pe(t2.getLabel())).flip(), n2.merge(i2);
            var r2 = ii.depthDelta(i2), o2 = e3.getDepthDelta() + r2;
            e3.setDepthDelta(o2);
          } else
            this._edgeList.add(t2), t2.setDepthDelta(ii.depthDelta(t2.getLabel()));
        }, ii.prototype.buildSubgraphs = function(t2, e3) {
          for (var n2 = new Nt(), i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), o2 = r2.getRightmostCoordinate(), s2 = new An(n2).getDepth(o2);
            r2.computeDepth(s2), r2.findResultEdges(), n2.add(r2), e3.add(r2.getDirectedEdges(), r2.getNodes());
          }
        }, ii.prototype.createSubgraphs = function(t2) {
          for (var e3 = new Nt(), n2 = t2.getNodes().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (!i2.isVisited()) {
              var r2 = new Te();
              r2.create(i2), e3.add(r2);
            }
          }
          return $e.sort(e3, $e.reverseOrder()), e3;
        }, ii.prototype.createEmptyResultGeometry = function() {
          return this._geomFact.createPolygon();
        }, ii.prototype.getNoder = function(t2) {
          if (null !== this._workingNoder)
            return this._workingNoder;
          var e3 = new xn(), n2 = new rt();
          return n2.setPrecisionModel(t2), e3.setSegmentIntersector(new Kn(n2)), e3;
        }, ii.prototype.buffer = function(t2, e3) {
          var n2 = this._workingPrecisionModel;
          null === n2 && (n2 = t2.getPrecisionModel()), this._geomFact = t2.getFactory();
          var i2 = new Mn(n2, this._bufParams), r2 = new Bn(t2, e3, i2).getCurves();
          if (r2.size() <= 0)
            return this.createEmptyResultGeometry();
          this.computeNodedEdges(r2, n2), this._graph = new Ye(new kn()), this._graph.addEdges(this._edgeList.getEdges());
          var o2 = this.createSubgraphs(this._graph), s2 = new ke(this._geomFact);
          this.buildSubgraphs(o2, s2);
          var a3 = s2.getPolygons();
          if (a3.size() <= 0)
            return this.createEmptyResultGeometry();
          return this._geomFact.buildGeometry(a3);
        }, ii.prototype.computeNodedEdges = function(t2, e3) {
          var n2 = this.getNoder(e3);
          n2.computeNodes(t2);
          for (var i2 = n2.getNodedSubstrings().iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), o2 = r2.getCoordinates();
            if (2 !== o2.length || !o2[0].equals2D(o2[1])) {
              var s2 = r2.getData(), a3 = new ni(r2.getCoordinates(), new Pe(s2));
              this.insertUniqueEdge(a3);
            }
          }
        }, ii.prototype.setNoder = function(t2) {
          this._workingNoder = t2;
        }, ii.prototype.interfaces_ = function() {
          return [];
        }, ii.prototype.getClass = function() {
          return ii;
        }, ii.depthDelta = function(t2) {
          var e3 = t2.getLocation(0, Se.LEFT), n2 = t2.getLocation(0, Se.RIGHT);
          return e3 === w.INTERIOR && n2 === w.EXTERIOR ? 1 : e3 === w.EXTERIOR && n2 === w.INTERIOR ? -1 : 0;
        }, ii.convertSegStrings = function(t2) {
          for (var e3 = new _e(), n2 = new Nt(); t2.hasNext(); ) {
            var i2 = t2.next(), r2 = e3.createLineString(i2.getCoordinates());
            n2.add(r2);
          }
          return e3.buildGeometry(n2);
        };
        var ri = function() {
          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = false, 2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._noder = t2, this._scaleFactor = e3, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision();
          } else if (4 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = arguments[3];
            this._noder = n2, this._scaleFactor = i2, this._offsetX = r2, this._offsetY = o2, this._isScaled = !this.isIntegerPrecision();
          }
        };
        ri.prototype.rescale = function() {
          if (T(arguments[0], It))
            for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.rescale(e3.getCoordinates());
            }
          else if (arguments[0] instanceof Array) {
            for (var n2 = arguments[0], i2 = 0; i2 < n2.length; i2++)
              n2[i2].x = n2[i2].x / this._scaleFactor + this._offsetX, n2[i2].y = n2[i2].y / this._scaleFactor + this._offsetY;
            2 === n2.length && n2[0].equals2D(n2[1]) && Y.out.println(n2);
          }
        }, ri.prototype.scale = function() {
          if (T(arguments[0], It)) {
            for (var t2 = arguments[0], e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              e3.add(new gn(this.scale(i2.getCoordinates()), i2.getData()));
            }
            return e3;
          }
          if (arguments[0] instanceof Array) {
            for (var r2 = arguments[0], o2 = new Array(r2.length).fill(null), s2 = 0; s2 < r2.length; s2++)
              o2[s2] = new C(Math.round((r2[s2].x - this._offsetX) * this._scaleFactor), Math.round((r2[s2].y - this._offsetY) * this._scaleFactor), r2[s2].z);
            return Lt.removeRepeatedPoints(o2);
          }
        }, ri.prototype.isIntegerPrecision = function() {
          return 1 === this._scaleFactor;
        }, ri.prototype.getNodedSubstrings = function() {
          var t2 = this._noder.getNodedSubstrings();
          return this._isScaled && this.rescale(t2), t2;
        }, ri.prototype.computeNodes = function(t2) {
          var e3 = t2;
          this._isScaled && (e3 = this.scale(t2)), this._noder.computeNodes(e3);
        }, ri.prototype.interfaces_ = function() {
          return [In];
        }, ri.prototype.getClass = function() {
          return ri;
        };
        var oi = function() {
          this._li = new rt(), this._segStrings = null;
          var t2 = arguments[0];
          this._segStrings = t2;
        }, si = { fact: { configurable: true } };
        oi.prototype.checkEndPtVertexIntersections = function() {
          if (0 === arguments.length)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
              var e3 = t2.next().getCoordinates();
              this.checkEndPtVertexIntersections(e3[0], this._segStrings), this.checkEndPtVertexIntersections(e3[e3.length - 1], this._segStrings);
            }
          else if (2 === arguments.length) {
            for (var n2 = arguments[0], i2 = arguments[1].iterator(); i2.hasNext(); )
              for (var r2 = i2.next().getCoordinates(), o2 = 1; o2 < r2.length - 1; o2++)
                if (r2[o2].equals(n2))
                  throw new $("found endpt/interior pt intersection at index " + o2 + " :pt " + n2);
          }
        }, oi.prototype.checkInteriorIntersections = function() {
          if (0 === arguments.length)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); )
              for (var e3 = t2.next(), n2 = this._segStrings.iterator(); n2.hasNext(); ) {
                var i2 = n2.next();
                this.checkInteriorIntersections(e3, i2);
              }
          else if (2 === arguments.length)
            for (var r2 = arguments[0], o2 = arguments[1], s2 = r2.getCoordinates(), a3 = o2.getCoordinates(), u2 = 0; u2 < s2.length - 1; u2++)
              for (var l2 = 0; l2 < a3.length - 1; l2++)
                this.checkInteriorIntersections(r2, u2, o2, l2);
          else if (4 === arguments.length) {
            var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = arguments[3];
            if (c2 === h2 && p2 === f2)
              return null;
            var g2 = c2.getCoordinates()[p2], d2 = c2.getCoordinates()[p2 + 1], y4 = h2.getCoordinates()[f2], _2 = h2.getCoordinates()[f2 + 1];
            if (this._li.computeIntersection(g2, d2, y4, _2), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g2, d2) || this.hasInteriorIntersection(this._li, y4, _2)))
              throw new $("found non-noded intersection at " + g2 + "-" + d2 + " and " + y4 + "-" + _2);
          }
        }, oi.prototype.checkValid = function() {
          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
        }, oi.prototype.checkCollapses = function() {
          if (0 === arguments.length)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.checkCollapses(e3);
            }
          else if (1 === arguments.length)
            for (var n2 = arguments[0].getCoordinates(), i2 = 0; i2 < n2.length - 2; i2++)
              this.checkCollapse(n2[i2], n2[i2 + 1], n2[i2 + 2]);
        }, oi.prototype.hasInteriorIntersection = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++) {
            var r2 = t2.getIntersection(i2);
            if (!r2.equals(e3) && !r2.equals(n2))
              return true;
          }
          return false;
        }, oi.prototype.checkCollapse = function(t2, e3, n2) {
          if (t2.equals(n2))
            throw new $("found non-noded collapse at " + oi.fact.createLineString([t2, e3, n2]));
        }, oi.prototype.interfaces_ = function() {
          return [];
        }, oi.prototype.getClass = function() {
          return oi;
        }, si.fact.get = function() {
          return new _e();
        }, Object.defineProperties(oi, si);
        var ai = function() {
          this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          if (this._originalPt = t2, this._pt = t2, this._scaleFactor = e3, this._li = n2, e3 <= 0)
            throw new m("Scale factor must be non-zero");
          1 !== e3 && (this._pt = new C(this.scale(t2.x), this.scale(t2.y)), this._p0Scaled = new C(), this._p1Scaled = new C()), this.initCorners(this._pt);
        }, ui = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };
        ai.prototype.intersectsScaled = function(t2, e3) {
          var n2 = Math.min(t2.x, e3.x), i2 = Math.max(t2.x, e3.x), r2 = Math.min(t2.y, e3.y), o2 = Math.max(t2.y, e3.y), s2 = this._maxx < n2 || this._minx > i2 || this._maxy < r2 || this._miny > o2;
          if (s2)
            return false;
          var a3 = this.intersectsToleranceSquare(t2, e3);
          return et.isTrue(!(s2 && a3), "Found bad envelope test"), a3;
        }, ai.prototype.initCorners = function(t2) {
          this._minx = t2.x - 0.5, this._maxx = t2.x + 0.5, this._miny = t2.y - 0.5, this._maxy = t2.y + 0.5, this._corner[0] = new C(this._maxx, this._maxy), this._corner[1] = new C(this._minx, this._maxy), this._corner[2] = new C(this._minx, this._miny), this._corner[3] = new C(this._maxx, this._miny);
        }, ai.prototype.intersects = function(t2, e3) {
          return 1 === this._scaleFactor ? this.intersectsScaled(t2, e3) : (this.copyScaled(t2, this._p0Scaled), this.copyScaled(e3, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
        }, ai.prototype.scale = function(t2) {
          return Math.round(t2 * this._scaleFactor);
        }, ai.prototype.getCoordinate = function() {
          return this._originalPt;
        }, ai.prototype.copyScaled = function(t2, e3) {
          e3.x = this.scale(t2.x), e3.y = this.scale(t2.y);
        }, ai.prototype.getSafeEnvelope = function() {
          if (null === this._safeEnv) {
            var t2 = ai.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new j(this._originalPt.x - t2, this._originalPt.x + t2, this._originalPt.y - t2, this._originalPt.y + t2);
          }
          return this._safeEnv;
        }, ai.prototype.intersectsPixelClosure = function(t2, e3) {
          return this._li.computeIntersection(t2, e3, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
        }, ai.prototype.intersectsToleranceSquare = function(t2, e3) {
          var n2 = false, i2 = false;
          return this._li.computeIntersection(t2, e3, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t2, e3, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n2 = true), this._li.computeIntersection(t2, e3, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i2 = true), this._li.computeIntersection(t2, e3, this._corner[3], this._corner[0]), !!this._li.isProper() || (!(!n2 || !i2) || (!!t2.equals(this._pt) || !!e3.equals(this._pt))))));
        }, ai.prototype.addSnappedNode = function(t2, e3) {
          var n2 = t2.getCoordinate(e3), i2 = t2.getCoordinate(e3 + 1);
          return !!this.intersects(n2, i2) && (t2.addIntersection(this.getCoordinate(), e3), true);
        }, ai.prototype.interfaces_ = function() {
          return [];
        }, ai.prototype.getClass = function() {
          return ai;
        }, ui.SAFE_ENV_EXPANSION_FACTOR.get = function() {
          return 0.75;
        }, Object.defineProperties(ai, ui);
        var li = function() {
          this.tempEnv1 = new j(), this.selectedSegment = new dn();
        };
        li.prototype.select = function() {
          if (1 === arguments.length)
            ;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            t2.getLineSegment(e3, this.selectedSegment), this.select(this.selectedSegment);
          }
        }, li.prototype.interfaces_ = function() {
          return [];
        }, li.prototype.getClass = function() {
          return li;
        };
        var ci = function() {
          this._index = null;
          var t2 = arguments[0];
          this._index = t2;
        }, pi2 = { HotPixelSnapAction: { configurable: true } };
        ci.prototype.snap = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.snap(t2, null, -1);
          }
          if (3 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = e3.getSafeEnvelope(), o2 = new hi(e3, n2, i2);
            return this._index.query(r2, { interfaces_: function() {
              return [Ke];
            }, visitItem: function(t3) {
              t3.select(r2, o2);
            } }), o2.isNodeAdded();
          }
        }, ci.prototype.interfaces_ = function() {
          return [];
        }, ci.prototype.getClass = function() {
          return ci;
        }, pi2.HotPixelSnapAction.get = function() {
          return hi;
        }, Object.defineProperties(ci, pi2);
        var hi = function(t2) {
          function e3() {
            t2.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = false;
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._hotPixel = e4, this._parentEdge = n2, this._hotPixelVertexIndex = i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isNodeAdded = function() {
            return this._isNodeAdded;
          }, e3.prototype.select = function() {
            if (2 !== arguments.length)
              return t2.prototype.select.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = e4.getContext();
            if (null !== this._parentEdge && i2 === this._parentEdge && n2 === this._hotPixelVertexIndex)
              return null;
            this._isNodeAdded = this._hotPixel.addSnappedNode(i2, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(li), fi = function() {
          this._li = null, this._interiorIntersections = null;
          var t2 = arguments[0];
          this._li = t2, this._interiorIntersections = new Nt();
        };
        fi.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a3 = n2.getCoordinates()[i2 + 1];
          if (this._li.computeIntersection(r2, o2, s2, a3), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (var u2 = 0; u2 < this._li.getIntersectionNum(); u2++)
              this._interiorIntersections.add(this._li.getIntersection(u2));
            t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1);
          }
        }, fi.prototype.isDone = function() {
          return false;
        }, fi.prototype.getInteriorIntersections = function() {
          return this._interiorIntersections;
        }, fi.prototype.interfaces_ = function() {
          return [Wn];
        }, fi.prototype.getClass = function() {
          return fi;
        };
        var gi = function() {
          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
          var t2 = arguments[0];
          this._pm = t2, this._li = new rt(), this._li.setPrecisionModel(t2), this._scaleFactor = t2.getScale();
        };
        gi.prototype.checkCorrectness = function(t2) {
          var e3 = gn.getNodedSubstrings(t2), n2 = new oi(e3);
          try {
            n2.checkValid();
          } catch (t3) {
            if (!(t3 instanceof z2))
              throw t3;
            t3.printStackTrace();
          }
        }, gi.prototype.getNodedSubstrings = function() {
          return gn.getNodedSubstrings(this._nodedSegStrings);
        }, gi.prototype.snapRound = function(t2, e3) {
          var n2 = this.findInteriorIntersections(t2, e3);
          this.computeIntersectionSnaps(n2), this.computeVertexSnaps(t2);
        }, gi.prototype.findInteriorIntersections = function(t2, e3) {
          var n2 = new fi(e3);
          return this._noder.setSegmentIntersector(n2), this._noder.computeNodes(t2), n2.getInteriorIntersections();
        }, gi.prototype.computeVertexSnaps = function() {
          if (T(arguments[0], It))
            for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.computeVertexSnaps(e3);
            }
          else if (arguments[0] instanceof gn)
            for (var n2 = arguments[0], i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++) {
              var o2 = new ai(i2[r2], this._scaleFactor, this._li);
              this._pointSnapper.snap(o2, n2, r2) && n2.addIntersection(i2[r2], r2);
            }
        }, gi.prototype.computeNodes = function(t2) {
          this._nodedSegStrings = t2, this._noder = new xn(), this._pointSnapper = new ci(this._noder.getIndex()), this.snapRound(t2, this._li);
        }, gi.prototype.computeIntersectionSnaps = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = new ai(n2, this._scaleFactor, this._li);
            this._pointSnapper.snap(i2);
          }
        }, gi.prototype.interfaces_ = function() {
          return [In];
        }, gi.prototype.getClass = function() {
          return gi;
        };
        var di = function() {
          if (this._argGeom = null, this._distance = null, this._bufParams = new Cn(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this._argGeom = t2;
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this._argGeom = e3, this._bufParams = n2;
          }
        }, yi = { CAP_ROUND: { configurable: true }, CAP_BUTT: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, MAX_PRECISION_DIGITS: { configurable: true } };
        di.prototype.bufferFixedPrecision = function(t2) {
          var e3 = new ri(new gi(new fe(1)), t2.getScale()), n2 = new ii(this._bufParams);
          n2.setWorkingPrecisionModel(t2), n2.setNoder(e3), this._resultGeometry = n2.buffer(this._argGeom, this._distance);
        }, di.prototype.bufferReducedPrecision = function() {
          var t2 = this;
          if (0 === arguments.length) {
            for (var e3 = di.MAX_PRECISION_DIGITS; e3 >= 0; e3--) {
              try {
                t2.bufferReducedPrecision(e3);
              } catch (e4) {
                if (!(e4 instanceof we))
                  throw e4;
                t2._saveException = e4;
              }
              if (null !== t2._resultGeometry)
                return null;
            }
            throw this._saveException;
          }
          if (1 === arguments.length) {
            var n2 = arguments[0], i2 = di.precisionScaleFactor(this._argGeom, this._distance, n2), r2 = new fe(i2);
            this.bufferFixedPrecision(r2);
          }
        }, di.prototype.computeGeometry = function() {
          if (this.bufferOriginalPrecision(), null !== this._resultGeometry)
            return null;
          var t2 = this._argGeom.getFactory().getPrecisionModel();
          t2.getType() === fe.FIXED ? this.bufferFixedPrecision(t2) : this.bufferReducedPrecision();
        }, di.prototype.setQuadrantSegments = function(t2) {
          this._bufParams.setQuadrantSegments(t2);
        }, di.prototype.bufferOriginalPrecision = function() {
          try {
            var t2 = new ii(this._bufParams);
            this._resultGeometry = t2.buffer(this._argGeom, this._distance);
          } catch (t3) {
            if (!(t3 instanceof $))
              throw t3;
            this._saveException = t3;
          }
        }, di.prototype.getResultGeometry = function(t2) {
          return this._distance = t2, this.computeGeometry(), this._resultGeometry;
        }, di.prototype.setEndCapStyle = function(t2) {
          this._bufParams.setEndCapStyle(t2);
        }, di.prototype.interfaces_ = function() {
          return [];
        }, di.prototype.getClass = function() {
          return di;
        }, di.bufferOp = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            return new di(t2).getResultGeometry(e3);
          }
          if (3 === arguments.length) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof ct && "number" == typeof arguments[1]) {
              var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new di(n2);
              o2.setQuadrantSegments(r2);
              return o2.getResultGeometry(i2);
            }
            if (arguments[2] instanceof Cn && arguments[0] instanceof ct && "number" == typeof arguments[1]) {
              var s2 = arguments[0], a3 = arguments[1], u2 = arguments[2];
              return new di(s2, u2).getResultGeometry(a3);
            }
          } else if (4 === arguments.length) {
            var l2 = arguments[0], c2 = arguments[1], p2 = arguments[2], h2 = arguments[3], f2 = new di(l2);
            f2.setQuadrantSegments(p2), f2.setEndCapStyle(h2);
            return f2.getResultGeometry(c2);
          }
        }, di.precisionScaleFactor = function(t2, e3, n2) {
          var i2 = t2.getEnvelopeInternal(), r2 = R.max(Math.abs(i2.getMaxX()), Math.abs(i2.getMaxY()), Math.abs(i2.getMinX()), Math.abs(i2.getMinY())) + 2 * (e3 > 0 ? e3 : 0), o2 = n2 - Math.trunc(Math.log(r2) / Math.log(10) + 1);
          return Math.pow(10, o2);
        }, yi.CAP_ROUND.get = function() {
          return Cn.CAP_ROUND;
        }, yi.CAP_BUTT.get = function() {
          return Cn.CAP_FLAT;
        }, yi.CAP_FLAT.get = function() {
          return Cn.CAP_FLAT;
        }, yi.CAP_SQUARE.get = function() {
          return Cn.CAP_SQUARE;
        }, yi.MAX_PRECISION_DIGITS.get = function() {
          return 12;
        }, Object.defineProperties(di, yi);
        var _i = function() {
          this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = true;
        };
        _i.prototype.getCoordinates = function() {
          return this._pt;
        }, _i.prototype.getCoordinate = function(t2) {
          return this._pt[t2];
        }, _i.prototype.setMinimum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMinimum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 < this._distance && this.initialize(e3, n2, i2);
          }
        }, _i.prototype.initialize = function() {
          if (0 === arguments.length)
            this._isNull = true;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._pt[0].setCoordinate(t2), this._pt[1].setCoordinate(e3), this._distance = t2.distance(e3), this._isNull = false;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._pt[0].setCoordinate(n2), this._pt[1].setCoordinate(i2), this._distance = r2, this._isNull = false;
          }
        }, _i.prototype.getDistance = function() {
          return this._distance;
        }, _i.prototype.setMaximum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMaximum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 > this._distance && this.initialize(e3, n2, i2);
          }
        }, _i.prototype.interfaces_ = function() {
          return [];
        }, _i.prototype.getClass = function() {
          return _i;
        };
        var mi = function() {
        };
        mi.prototype.interfaces_ = function() {
          return [];
        }, mi.prototype.getClass = function() {
          return mi;
        }, mi.computeDistance = function() {
          if (arguments[2] instanceof _i && arguments[0] instanceof Kt && arguments[1] instanceof C)
            for (var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = t2.getCoordinates(), r2 = new dn(), o2 = 0; o2 < i2.length - 1; o2++) {
              r2.setCoordinates(i2[o2], i2[o2 + 1]);
              var s2 = r2.closestPoint(e3);
              n2.setMinimum(s2, e3);
            }
          else if (arguments[2] instanceof _i && arguments[0] instanceof $t && arguments[1] instanceof C) {
            var a3 = arguments[0], u2 = arguments[1], l2 = arguments[2];
            mi.computeDistance(a3.getExteriorRing(), u2, l2);
            for (var c2 = 0; c2 < a3.getNumInteriorRing(); c2++)
              mi.computeDistance(a3.getInteriorRingN(c2), u2, l2);
          } else if (arguments[2] instanceof _i && arguments[0] instanceof ct && arguments[1] instanceof C) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2];
            if (p2 instanceof Kt)
              mi.computeDistance(p2, h2, f2);
            else if (p2 instanceof $t)
              mi.computeDistance(p2, h2, f2);
            else if (p2 instanceof zt)
              for (var g2 = p2, d2 = 0; d2 < g2.getNumGeometries(); d2++) {
                var y4 = g2.getGeometryN(d2);
                mi.computeDistance(y4, h2, f2);
              }
            else
              f2.setMinimum(p2.getCoordinate(), h2);
          } else if (arguments[2] instanceof _i && arguments[0] instanceof dn && arguments[1] instanceof C) {
            var _2 = arguments[0], m2 = arguments[1], v2 = arguments[2], I3 = _2.closestPoint(m2);
            v2.setMinimum(I3, m2);
          }
        };
        var vi = function(t2) {
          this._maxPtDist = new _i(), this._inputGeom = t2 || null;
        }, Ii = { MaxPointDistanceFilter: { configurable: true }, MaxMidpointDistanceFilter: { configurable: true } };
        vi.prototype.computeMaxMidpointDistance = function(t2) {
          var e3 = new xi(this._inputGeom);
          t2.apply(e3), this._maxPtDist.setMaximum(e3.getMaxPointDistance());
        }, vi.prototype.computeMaxVertexDistance = function(t2) {
          var e3 = new Ei(this._inputGeom);
          t2.apply(e3), this._maxPtDist.setMaximum(e3.getMaxPointDistance());
        }, vi.prototype.findDistance = function(t2) {
          return this.computeMaxVertexDistance(t2), this.computeMaxMidpointDistance(t2), this._maxPtDist.getDistance();
        }, vi.prototype.getDistancePoints = function() {
          return this._maxPtDist;
        }, vi.prototype.interfaces_ = function() {
          return [];
        }, vi.prototype.getClass = function() {
          return vi;
        }, Ii.MaxPointDistanceFilter.get = function() {
          return Ei;
        }, Ii.MaxMidpointDistanceFilter.get = function() {
          return xi;
        }, Object.defineProperties(vi, Ii);
        var Ei = function(t2) {
          this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t2 || null;
        };
        Ei.prototype.filter = function(t2) {
          this._minPtDist.initialize(), mi.computeDistance(this._geom, t2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, Ei.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Ei.prototype.interfaces_ = function() {
          return [ft];
        }, Ei.prototype.getClass = function() {
          return Ei;
        };
        var xi = function(t2) {
          this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t2 || null;
        };
        xi.prototype.filter = function(t2, e3) {
          if (0 === e3)
            return null;
          var n2 = t2.getCoordinate(e3 - 1), i2 = t2.getCoordinate(e3), r2 = new C((n2.x + i2.x) / 2, (n2.y + i2.y) / 2);
          this._minPtDist.initialize(), mi.computeDistance(this._geom, r2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, xi.prototype.isDone = function() {
          return false;
        }, xi.prototype.isGeometryChanged = function() {
          return false;
        }, xi.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, xi.prototype.interfaces_ = function() {
          return [Ut];
        }, xi.prototype.getClass = function() {
          return xi;
        };
        var Ni = function(t2) {
          this._comps = t2 || null;
        };
        Ni.prototype.filter = function(t2) {
          t2 instanceof $t && this._comps.add(t2);
        }, Ni.prototype.interfaces_ = function() {
          return [Vt];
        }, Ni.prototype.getClass = function() {
          return Ni;
        }, Ni.getPolygons = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Ni.getPolygons(t2, new Nt());
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3 instanceof $t ? n2.add(e3) : e3 instanceof zt && e3.apply(new Ni(n2)), n2;
          }
        };
        var Ci = function() {
          if (this._lines = null, this._isForcedToLineString = false, 1 === arguments.length) {
            var t2 = arguments[0];
            this._lines = t2;
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this._lines = e3, this._isForcedToLineString = n2;
          }
        };
        Ci.prototype.filter = function(t2) {
          if (this._isForcedToLineString && t2 instanceof ee2) {
            var e3 = t2.getFactory().createLineString(t2.getCoordinateSequence());
            return this._lines.add(e3), null;
          }
          t2 instanceof Kt && this._lines.add(t2);
        }, Ci.prototype.setForceToLineString = function(t2) {
          this._isForcedToLineString = t2;
        }, Ci.prototype.interfaces_ = function() {
          return [lt];
        }, Ci.prototype.getClass = function() {
          return Ci;
        }, Ci.getGeometry = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return t2.getFactory().buildGeometry(Ci.getLines(t2));
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3.getFactory().buildGeometry(Ci.getLines(e3, n2));
          }
        }, Ci.getLines = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Ci.getLines(t2, false);
          }
          if (2 === arguments.length) {
            if (T(arguments[0], It) && T(arguments[1], It)) {
              for (var e3 = arguments[0], n2 = arguments[1], i2 = e3.iterator(); i2.hasNext(); ) {
                var r2 = i2.next();
                Ci.getLines(r2, n2);
              }
              return n2;
            }
            if (arguments[0] instanceof ct && "boolean" == typeof arguments[1]) {
              var o2 = arguments[0], s2 = arguments[1], a3 = new Nt();
              return o2.apply(new Ci(a3, s2)), a3;
            }
            if (arguments[0] instanceof ct && T(arguments[1], It)) {
              var u2 = arguments[0], l2 = arguments[1];
              return u2 instanceof Kt ? l2.add(u2) : u2.apply(new Ci(l2)), l2;
            }
          } else if (3 === arguments.length) {
            if ("boolean" == typeof arguments[2] && T(arguments[0], It) && T(arguments[1], It)) {
              for (var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = c2.iterator(); f2.hasNext(); ) {
                var g2 = f2.next();
                Ci.getLines(g2, p2, h2);
              }
              return p2;
            }
            if ("boolean" == typeof arguments[2] && arguments[0] instanceof ct && T(arguments[1], It)) {
              var d2 = arguments[0], y4 = arguments[1], _2 = arguments[2];
              return d2.apply(new Ci(y4, _2)), y4;
            }
          }
        };
        var Si = function() {
          if (this._boundaryRule = gt.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            if (null === t2)
              throw new m("Rule must be non-null");
            this._boundaryRule = t2;
          }
        };
        Si.prototype.locateInternal = function() {
          if (arguments[0] instanceof C && arguments[1] instanceof $t) {
            var t2 = arguments[0], e3 = arguments[1];
            if (e3.isEmpty())
              return w.EXTERIOR;
            var n2 = e3.getExteriorRing(), i2 = this.locateInPolygonRing(t2, n2);
            if (i2 === w.EXTERIOR)
              return w.EXTERIOR;
            if (i2 === w.BOUNDARY)
              return w.BOUNDARY;
            for (var r2 = 0; r2 < e3.getNumInteriorRing(); r2++) {
              var o2 = e3.getInteriorRingN(r2), s2 = this.locateInPolygonRing(t2, o2);
              if (s2 === w.INTERIOR)
                return w.EXTERIOR;
              if (s2 === w.BOUNDARY)
                return w.BOUNDARY;
            }
            return w.INTERIOR;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Kt) {
            var a3 = arguments[0], u2 = arguments[1];
            if (!u2.getEnvelopeInternal().intersects(a3))
              return w.EXTERIOR;
            var l2 = u2.getCoordinates();
            return u2.isClosed() || !a3.equals(l2[0]) && !a3.equals(l2[l2.length - 1]) ? at.isOnLine(a3, l2) ? w.INTERIOR : w.EXTERIOR : w.BOUNDARY;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Qt) {
            var c2 = arguments[0];
            return arguments[1].getCoordinate().equals2D(c2) ? w.INTERIOR : w.EXTERIOR;
          }
        }, Si.prototype.locateInPolygonRing = function(t2, e3) {
          return e3.getEnvelopeInternal().intersects(t2) ? at.locatePointInRing(t2, e3.getCoordinates()) : w.EXTERIOR;
        }, Si.prototype.intersects = function(t2, e3) {
          return this.locate(t2, e3) !== w.EXTERIOR;
        }, Si.prototype.updateLocationInfo = function(t2) {
          t2 === w.INTERIOR && (this._isIn = true), t2 === w.BOUNDARY && this._numBoundaries++;
        }, Si.prototype.computeLocation = function(t2, e3) {
          if (e3 instanceof Qt && this.updateLocationInfo(this.locateInternal(t2, e3)), e3 instanceof Kt)
            this.updateLocationInfo(this.locateInternal(t2, e3));
          else if (e3 instanceof $t)
            this.updateLocationInfo(this.locateInternal(t2, e3));
          else if (e3 instanceof Xt)
            for (var n2 = e3, i2 = 0; i2 < n2.getNumGeometries(); i2++) {
              var r2 = n2.getGeometryN(i2);
              this.updateLocationInfo(this.locateInternal(t2, r2));
            }
          else if (e3 instanceof ne)
            for (var o2 = e3, s2 = 0; s2 < o2.getNumGeometries(); s2++) {
              var a3 = o2.getGeometryN(s2);
              this.updateLocationInfo(this.locateInternal(t2, a3));
            }
          else if (e3 instanceof zt)
            for (var u2 = new Un(e3); u2.hasNext(); ) {
              var l2 = u2.next();
              l2 !== e3 && this.computeLocation(t2, l2);
            }
        }, Si.prototype.locate = function(t2, e3) {
          return e3.isEmpty() ? w.EXTERIOR : e3 instanceof Kt ? this.locateInternal(t2, e3) : e3 instanceof $t ? this.locateInternal(t2, e3) : (this._isIn = false, this._numBoundaries = 0, this.computeLocation(t2, e3), this._boundaryRule.isInBoundary(this._numBoundaries) ? w.BOUNDARY : this._numBoundaries > 0 || this._isIn ? w.INTERIOR : w.EXTERIOR);
        }, Si.prototype.interfaces_ = function() {
          return [];
        }, Si.prototype.getClass = function() {
          return Si;
        };
        var Li = function t2() {
          if (this._component = null, this._segIndex = null, this._pt = null, 2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            t2.call(this, e3, t2.INSIDE_AREA, n2);
          } else if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._component = i2, this._segIndex = r2, this._pt = o2;
          }
        }, bi = { INSIDE_AREA: { configurable: true } };
        Li.prototype.isInsideArea = function() {
          return this._segIndex === Li.INSIDE_AREA;
        }, Li.prototype.getCoordinate = function() {
          return this._pt;
        }, Li.prototype.getGeometryComponent = function() {
          return this._component;
        }, Li.prototype.getSegmentIndex = function() {
          return this._segIndex;
        }, Li.prototype.interfaces_ = function() {
          return [];
        }, Li.prototype.getClass = function() {
          return Li;
        }, bi.INSIDE_AREA.get = function() {
          return -1;
        }, Object.defineProperties(Li, bi);
        var wi = function(t2) {
          this._pts = t2 || null;
        };
        wi.prototype.filter = function(t2) {
          t2 instanceof Qt && this._pts.add(t2);
        }, wi.prototype.interfaces_ = function() {
          return [Vt];
        }, wi.prototype.getClass = function() {
          return wi;
        }, wi.getPoints = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return t2 instanceof Qt ? $e.singletonList(t2) : wi.getPoints(t2, new Nt());
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3 instanceof Qt ? n2.add(e3) : e3 instanceof zt && e3.apply(new wi(n2)), n2;
          }
        };
        var Oi = function() {
          this._locations = null;
          var t2 = arguments[0];
          this._locations = t2;
        };
        Oi.prototype.filter = function(t2) {
          (t2 instanceof Qt || t2 instanceof Kt || t2 instanceof $t) && this._locations.add(new Li(t2, 0, t2.getCoordinate()));
        }, Oi.prototype.interfaces_ = function() {
          return [Vt];
        }, Oi.prototype.getClass = function() {
          return Oi;
        }, Oi.getLocations = function(t2) {
          var e3 = new Nt();
          return t2.apply(new Oi(e3)), e3;
        };
        var Ti = function() {
          if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Si(), this._minDistanceLocation = null, this._minDistance = v.MAX_VALUE, 2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._geom = [t2, e3], this._terminateDistance = 0;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._geom = new Array(2).fill(null), this._geom[0] = n2, this._geom[1] = i2, this._terminateDistance = r2;
          }
        };
        Ti.prototype.computeContainmentDistance = function() {
          if (0 === arguments.length) {
            var t2 = new Array(2).fill(null);
            if (this.computeContainmentDistance(0, t2), this._minDistance <= this._terminateDistance)
              return null;
            this.computeContainmentDistance(1, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = 1 - e3, r2 = Ni.getPolygons(this._geom[e3]);
            if (r2.size() > 0) {
              var o2 = Oi.getLocations(this._geom[i2]);
              if (this.computeContainmentDistance(o2, r2, n2), this._minDistance <= this._terminateDistance)
                return this._minDistanceLocation[i2] = n2[0], this._minDistanceLocation[e3] = n2[1], null;
            }
          } else if (3 === arguments.length) {
            if (arguments[2] instanceof Array && T(arguments[0], xt) && T(arguments[1], xt)) {
              for (var s2 = arguments[0], a3 = arguments[1], u2 = arguments[2], l2 = 0; l2 < s2.size(); l2++)
                for (var c2 = s2.get(l2), p2 = 0; p2 < a3.size(); p2++)
                  if (this.computeContainmentDistance(c2, a3.get(p2), u2), this._minDistance <= this._terminateDistance)
                    return null;
            } else if (arguments[2] instanceof Array && arguments[0] instanceof Li && arguments[1] instanceof $t) {
              var h2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = h2.getCoordinate();
              if (w.EXTERIOR !== this._ptLocator.locate(d2, f2))
                return this._minDistance = 0, g2[0] = h2, g2[1] = new Li(f2, d2), null;
            }
          }
        }, Ti.prototype.computeMinDistanceLinesPoints = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2);
              if (this.computeMinDistance(r2, s2, n2), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.computeFacetDistance = function() {
          var t2 = new Array(2).fill(null), e3 = Ci.getLines(this._geom[0]), n2 = Ci.getLines(this._geom[1]), i2 = wi.getPoints(this._geom[0]), r2 = wi.getPoints(this._geom[1]);
          return this.computeMinDistanceLines(e3, n2, t2), this.updateMinDistance(t2, false), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(e3, r2, t2), this.updateMinDistance(t2, false), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(n2, i2, t2), this.updateMinDistance(t2, true), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistancePoints(i2, r2, t2), void this.updateMinDistance(t2, false))));
        }, Ti.prototype.nearestLocations = function() {
          return this.computeMinDistance(), this._minDistanceLocation;
        }, Ti.prototype.updateMinDistance = function(t2, e3) {
          if (null === t2[0])
            return null;
          e3 ? (this._minDistanceLocation[0] = t2[1], this._minDistanceLocation[1] = t2[0]) : (this._minDistanceLocation[0] = t2[0], this._minDistanceLocation[1] = t2[1]);
        }, Ti.prototype.nearestPoints = function() {
          this.computeMinDistance();
          return [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
        }, Ti.prototype.computeMinDistance = function() {
          if (0 === arguments.length) {
            if (null !== this._minDistanceLocation)
              return null;
            if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance)
              return null;
            this.computeFacetDistance();
          } else if (3 === arguments.length) {
            if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Qt) {
              var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
              if (t2.getEnvelopeInternal().distance(e3.getEnvelopeInternal()) > this._minDistance)
                return null;
              for (var i2 = t2.getCoordinates(), r2 = e3.getCoordinate(), o2 = 0; o2 < i2.length - 1; o2++) {
                var s2 = at.distancePointLine(r2, i2[o2], i2[o2 + 1]);
                if (s2 < this._minDistance) {
                  this._minDistance = s2;
                  var a3 = new dn(i2[o2], i2[o2 + 1]).closestPoint(r2);
                  n2[0] = new Li(t2, o2, a3), n2[1] = new Li(e3, 0, r2);
                }
                if (this._minDistance <= this._terminateDistance)
                  return null;
              }
            } else if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Kt) {
              var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2];
              if (u2.getEnvelopeInternal().distance(l2.getEnvelopeInternal()) > this._minDistance)
                return null;
              for (var p2 = u2.getCoordinates(), h2 = l2.getCoordinates(), f2 = 0; f2 < p2.length - 1; f2++)
                for (var g2 = 0; g2 < h2.length - 1; g2++) {
                  var d2 = at.distanceLineLine(p2[f2], p2[f2 + 1], h2[g2], h2[g2 + 1]);
                  if (d2 < this._minDistance) {
                    this._minDistance = d2;
                    var y4 = new dn(p2[f2], p2[f2 + 1]), _2 = new dn(h2[g2], h2[g2 + 1]), m2 = y4.closestPoints(_2);
                    c2[0] = new Li(u2, f2, m2[0]), c2[1] = new Li(l2, g2, m2[1]);
                  }
                  if (this._minDistance <= this._terminateDistance)
                    return null;
                }
            }
          }
        }, Ti.prototype.computeMinDistancePoints = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2), a3 = r2.getCoordinate().distance(s2.getCoordinate());
              if (a3 < this._minDistance && (this._minDistance = a3, n2[0] = new Li(r2, 0, r2.getCoordinate()), n2[1] = new Li(s2, 0, s2.getCoordinate())), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.distance = function() {
          if (null === this._geom[0] || null === this._geom[1])
            throw new m("null geometries are not supported");
          return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);
        }, Ti.prototype.computeMinDistanceLines = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2);
              if (this.computeMinDistance(r2, s2, n2), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.interfaces_ = function() {
          return [];
        }, Ti.prototype.getClass = function() {
          return Ti;
        }, Ti.distance = function(t2, e3) {
          return new Ti(t2, e3).distance();
        }, Ti.isWithinDistance = function(t2, e3, n2) {
          return new Ti(t2, e3, n2).distance() <= n2;
        }, Ti.nearestPoints = function(t2, e3) {
          return new Ti(t2, e3).nearestPoints();
        };
        var Ri = function() {
          this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = true;
        };
        Ri.prototype.getCoordinates = function() {
          return this._pt;
        }, Ri.prototype.getCoordinate = function(t2) {
          return this._pt[t2];
        }, Ri.prototype.setMinimum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMinimum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 < this._distance && this.initialize(e3, n2, i2);
          }
        }, Ri.prototype.initialize = function() {
          if (0 === arguments.length)
            this._isNull = true;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._pt[0].setCoordinate(t2), this._pt[1].setCoordinate(e3), this._distance = t2.distance(e3), this._isNull = false;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._pt[0].setCoordinate(n2), this._pt[1].setCoordinate(i2), this._distance = r2, this._isNull = false;
          }
        }, Ri.prototype.toString = function() {
          return Z2.toLineString(this._pt[0], this._pt[1]);
        }, Ri.prototype.getDistance = function() {
          return this._distance;
        }, Ri.prototype.setMaximum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMaximum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 > this._distance && this.initialize(e3, n2, i2);
          }
        }, Ri.prototype.interfaces_ = function() {
          return [];
        }, Ri.prototype.getClass = function() {
          return Ri;
        };
        var Pi = function() {
        };
        Pi.prototype.interfaces_ = function() {
          return [];
        }, Pi.prototype.getClass = function() {
          return Pi;
        }, Pi.computeDistance = function() {
          if (arguments[2] instanceof Ri && arguments[0] instanceof Kt && arguments[1] instanceof C)
            for (var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = new dn(), r2 = t2.getCoordinates(), o2 = 0; o2 < r2.length - 1; o2++) {
              i2.setCoordinates(r2[o2], r2[o2 + 1]);
              var s2 = i2.closestPoint(e3);
              n2.setMinimum(s2, e3);
            }
          else if (arguments[2] instanceof Ri && arguments[0] instanceof $t && arguments[1] instanceof C) {
            var a3 = arguments[0], u2 = arguments[1], l2 = arguments[2];
            Pi.computeDistance(a3.getExteriorRing(), u2, l2);
            for (var c2 = 0; c2 < a3.getNumInteriorRing(); c2++)
              Pi.computeDistance(a3.getInteriorRingN(c2), u2, l2);
          } else if (arguments[2] instanceof Ri && arguments[0] instanceof ct && arguments[1] instanceof C) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2];
            if (p2 instanceof Kt)
              Pi.computeDistance(p2, h2, f2);
            else if (p2 instanceof $t)
              Pi.computeDistance(p2, h2, f2);
            else if (p2 instanceof zt)
              for (var g2 = p2, d2 = 0; d2 < g2.getNumGeometries(); d2++) {
                var y4 = g2.getGeometryN(d2);
                Pi.computeDistance(y4, h2, f2);
              }
            else
              f2.setMinimum(p2.getCoordinate(), h2);
          } else if (arguments[2] instanceof Ri && arguments[0] instanceof dn && arguments[1] instanceof C) {
            var _2 = arguments[0], m2 = arguments[1], v2 = arguments[2], I3 = _2.closestPoint(m2);
            v2.setMinimum(I3, m2);
          }
        };
        var Di = function() {
          this._g0 = null, this._g1 = null, this._ptDist = new Ri(), this._densifyFrac = 0;
          var t2 = arguments[0], e3 = arguments[1];
          this._g0 = t2, this._g1 = e3;
        }, Mi = { MaxPointDistanceFilter: { configurable: true }, MaxDensifiedByFractionDistanceFilter: { configurable: true } };
        Di.prototype.getCoordinates = function() {
          return this._ptDist.getCoordinates();
        }, Di.prototype.setDensifyFraction = function(t2) {
          if (t2 > 1 || t2 <= 0)
            throw new m("Fraction is not in range (0.0 - 1.0]");
          this._densifyFrac = t2;
        }, Di.prototype.compute = function(t2, e3) {
          this.computeOrientedDistance(t2, e3, this._ptDist), this.computeOrientedDistance(e3, t2, this._ptDist);
        }, Di.prototype.distance = function() {
          return this.compute(this._g0, this._g1), this._ptDist.getDistance();
        }, Di.prototype.computeOrientedDistance = function(t2, e3, n2) {
          var i2 = new Ai(e3);
          if (t2.apply(i2), n2.setMaximum(i2.getMaxPointDistance()), this._densifyFrac > 0) {
            var r2 = new Fi(e3, this._densifyFrac);
            t2.apply(r2), n2.setMaximum(r2.getMaxPointDistance());
          }
        }, Di.prototype.orientedDistance = function() {
          return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();
        }, Di.prototype.interfaces_ = function() {
          return [];
        }, Di.prototype.getClass = function() {
          return Di;
        }, Di.distance = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            return new Di(t2, e3).distance();
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new Di(n2, i2);
            return o2.setDensifyFraction(r2), o2.distance();
          }
        }, Mi.MaxPointDistanceFilter.get = function() {
          return Ai;
        }, Mi.MaxDensifiedByFractionDistanceFilter.get = function() {
          return Fi;
        }, Object.defineProperties(Di, Mi);
        var Ai = function() {
          this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._euclideanDist = new Pi(), this._geom = null;
          var t2 = arguments[0];
          this._geom = t2;
        };
        Ai.prototype.filter = function(t2) {
          this._minPtDist.initialize(), Pi.computeDistance(this._geom, t2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, Ai.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Ai.prototype.interfaces_ = function() {
          return [ft];
        }, Ai.prototype.getClass = function() {
          return Ai;
        };
        var Fi = function() {
          this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._geom = null, this._numSubSegs = 0;
          var t2 = arguments[0], e3 = arguments[1];
          this._geom = t2, this._numSubSegs = Math.trunc(Math.round(1 / e3));
        };
        Fi.prototype.filter = function(t2, e3) {
          if (0 === e3)
            return null;
          for (var n2 = t2.getCoordinate(e3 - 1), i2 = t2.getCoordinate(e3), r2 = (i2.x - n2.x) / this._numSubSegs, o2 = (i2.y - n2.y) / this._numSubSegs, s2 = 0; s2 < this._numSubSegs; s2++) {
            var a3 = n2.x + s2 * r2, u2 = n2.y + s2 * o2, l2 = new C(a3, u2);
            this._minPtDist.initialize(), Pi.computeDistance(this._geom, l2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
          }
        }, Fi.prototype.isDone = function() {
          return false;
        }, Fi.prototype.isGeometryChanged = function() {
          return false;
        }, Fi.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Fi.prototype.interfaces_ = function() {
          return [Ut];
        }, Fi.prototype.getClass = function() {
          return Fi;
        };
        var Gi = function(t2, e3, n2) {
          this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = true, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t2 || null, this._bufDistance = e3 || null, this._result = n2 || null;
        }, qi = { VERBOSE: { configurable: true }, MAX_DISTANCE_DIFF_FRAC: { configurable: true } };
        Gi.prototype.checkMaximumDistance = function(t2, e3, n2) {
          var i2 = new Di(e3, t2);
          if (i2.setDensifyFraction(0.25), this._maxDistanceFound = i2.orientedDistance(), this._maxDistanceFound > n2) {
            this._isValid = false;
            var r2 = i2.getCoordinates();
            this._errorLocation = r2[1], this._errorIndicator = t2.getFactory().createLineString(r2), this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + Z2.toLineString(r2[0], r2[1]) + ")";
          }
        }, Gi.prototype.isValid = function() {
          var t2 = Math.abs(this._bufDistance), e3 = Gi.MAX_DISTANCE_DIFF_FRAC * t2;
          return this._minValidDistance = t2 - e3, this._maxValidDistance = t2 + e3, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Gi.VERBOSE && Y.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid);
        }, Gi.prototype.checkNegativeValid = function() {
          if (!(this._input instanceof $t || this._input instanceof ne || this._input instanceof zt))
            return null;
          var t2 = this.getPolygonLines(this._input);
          if (this.checkMinimumDistance(t2, this._result, this._minValidDistance), !this._isValid)
            return null;
          this.checkMaximumDistance(t2, this._result, this._maxValidDistance);
        }, Gi.prototype.getErrorIndicator = function() {
          return this._errorIndicator;
        }, Gi.prototype.checkMinimumDistance = function(t2, e3, n2) {
          var i2 = new Ti(t2, e3, n2);
          if (this._minDistanceFound = i2.distance(), this._minDistanceFound < n2) {
            this._isValid = false;
            var r2 = i2.nearestPoints();
            this._errorLocation = i2.nearestPoints()[1], this._errorIndicator = t2.getFactory().createLineString(r2), this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + Z2.toLineString(r2[0], r2[1]) + " )";
          }
        }, Gi.prototype.checkPositiveValid = function() {
          var t2 = this._result.getBoundary();
          if (this.checkMinimumDistance(this._input, t2, this._minValidDistance), !this._isValid)
            return null;
          this.checkMaximumDistance(this._input, t2, this._maxValidDistance);
        }, Gi.prototype.getErrorLocation = function() {
          return this._errorLocation;
        }, Gi.prototype.getPolygonLines = function(t2) {
          for (var e3 = new Nt(), n2 = new Ci(e3), i2 = Ni.getPolygons(t2).iterator(); i2.hasNext(); ) {
            i2.next().apply(n2);
          }
          return t2.getFactory().buildGeometry(e3);
        }, Gi.prototype.getErrorMessage = function() {
          return this._errMsg;
        }, Gi.prototype.interfaces_ = function() {
          return [];
        }, Gi.prototype.getClass = function() {
          return Gi;
        }, qi.VERBOSE.get = function() {
          return false;
        }, qi.MAX_DISTANCE_DIFF_FRAC.get = function() {
          return 0.012;
        }, Object.defineProperties(Gi, qi);
        var Bi = function(t2, e3, n2) {
          this._isValid = true, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t2 || null, this._distance = e3 || null, this._result = n2 || null;
        }, Vi = { VERBOSE: { configurable: true }, MAX_ENV_DIFF_FRAC: { configurable: true } };
        Bi.prototype.isValid = function() {
          return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid;
        }, Bi.prototype.checkEnvelope = function() {
          if (this._distance < 0)
            return null;
          var t2 = this._distance * Bi.MAX_ENV_DIFF_FRAC;
          0 === t2 && (t2 = 1e-3);
          var e3 = new j(this._input.getEnvelopeInternal());
          e3.expandBy(this._distance);
          var n2 = new j(this._result.getEnvelopeInternal());
          n2.expandBy(t2), n2.contains(e3) || (this._isValid = false, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(n2)), this.report("Envelope");
        }, Bi.prototype.checkDistance = function() {
          var t2 = new Gi(this._input, this._distance, this._result);
          t2.isValid() || (this._isValid = false, this._errorMsg = t2.getErrorMessage(), this._errorLocation = t2.getErrorLocation(), this._errorIndicator = t2.getErrorIndicator()), this.report("Distance");
        }, Bi.prototype.checkArea = function() {
          var t2 = this._input.getArea(), e3 = this._result.getArea();
          this._distance > 0 && t2 > e3 && (this._isValid = false, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result), this._distance < 0 && t2 < e3 && (this._isValid = false, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result), this.report("Area");
        }, Bi.prototype.checkPolygonal = function() {
          this._result instanceof $t || this._result instanceof ne || (this._isValid = false), this._errorMsg = "Result is not polygonal", this._errorIndicator = this._result, this.report("Polygonal");
        }, Bi.prototype.getErrorIndicator = function() {
          return this._errorIndicator;
        }, Bi.prototype.getErrorLocation = function() {
          return this._errorLocation;
        }, Bi.prototype.checkExpectedEmpty = function() {
          return this._input.getDimension() >= 2 ? null : this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = false, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), void this.report("ExpectedEmpty"));
        }, Bi.prototype.report = function(t2) {
          if (!Bi.VERBOSE)
            return null;
          Y.out.println("Check " + t2 + ": " + (this._isValid ? "passed" : "FAILED"));
        }, Bi.prototype.getErrorMessage = function() {
          return this._errorMsg;
        }, Bi.prototype.interfaces_ = function() {
          return [];
        }, Bi.prototype.getClass = function() {
          return Bi;
        }, Bi.isValidMsg = function(t2, e3, n2) {
          var i2 = new Bi(t2, e3, n2);
          return i2.isValid() ? null : i2.getErrorMessage();
        }, Bi.isValid = function(t2, e3, n2) {
          return !!new Bi(t2, e3, n2).isValid();
        }, Vi.VERBOSE.get = function() {
          return false;
        }, Vi.MAX_ENV_DIFF_FRAC.get = function() {
          return 0.012;
        }, Object.defineProperties(Bi, Vi);
        var Ui = function() {
          this._pts = null, this._data = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._pts = t2, this._data = e3;
        };
        Ui.prototype.getCoordinates = function() {
          return this._pts;
        }, Ui.prototype.size = function() {
          return this._pts.length;
        }, Ui.prototype.getCoordinate = function(t2) {
          return this._pts[t2];
        }, Ui.prototype.isClosed = function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        }, Ui.prototype.getSegmentOctant = function(t2) {
          return t2 === this._pts.length - 1 ? -1 : pn.octant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
        }, Ui.prototype.setData = function(t2) {
          this._data = t2;
        }, Ui.prototype.getData = function() {
          return this._data;
        }, Ui.prototype.toString = function() {
          return Z2.toLineString(new ue(this._pts));
        }, Ui.prototype.interfaces_ = function() {
          return [hn];
        }, Ui.prototype.getClass = function() {
          return Ui;
        };
        var zi = function() {
          this._findAllIntersections = false, this._isCheckEndSegmentsOnly = false, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new Nt(), this._intersectionCount = 0, this._keepIntersections = true;
          var t2 = arguments[0];
          this._li = t2, this._interiorIntersection = null;
        };
        zi.prototype.getInteriorIntersection = function() {
          return this._interiorIntersection;
        }, zi.prototype.setCheckEndSegmentsOnly = function(t2) {
          this._isCheckEndSegmentsOnly = t2;
        }, zi.prototype.getIntersectionSegments = function() {
          return this._intSegments;
        }, zi.prototype.count = function() {
          return this._intersectionCount;
        }, zi.prototype.getIntersections = function() {
          return this._intersections;
        }, zi.prototype.setFindAllIntersections = function(t2) {
          this._findAllIntersections = t2;
        }, zi.prototype.setKeepIntersections = function(t2) {
          this._keepIntersections = t2;
        }, zi.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (!this._findAllIntersections && this.hasIntersection())
            return null;
          if (t2 === n2 && e3 === i2)
            return null;
          if (this._isCheckEndSegmentsOnly) {
            if (!(this.isEndSegment(t2, e3) || this.isEndSegment(n2, i2)))
              return null;
          }
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a3 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a3), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = r2, this._intSegments[1] = o2, this._intSegments[2] = s2, this._intSegments[3] = a3, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);
        }, zi.prototype.isEndSegment = function(t2, e3) {
          return 0 === e3 || e3 >= t2.size() - 2;
        }, zi.prototype.hasIntersection = function() {
          return null !== this._interiorIntersection;
        }, zi.prototype.isDone = function() {
          return !this._findAllIntersections && null !== this._interiorIntersection;
        }, zi.prototype.interfaces_ = function() {
          return [Wn];
        }, zi.prototype.getClass = function() {
          return zi;
        }, zi.createAllIntersectionsFinder = function(t2) {
          var e3 = new zi(t2);
          return e3.setFindAllIntersections(true), e3;
        }, zi.createAnyIntersectionFinder = function(t2) {
          return new zi(t2);
        }, zi.createIntersectionCounter = function(t2) {
          var e3 = new zi(t2);
          return e3.setFindAllIntersections(true), e3.setKeepIntersections(false), e3;
        };
        var Xi = function() {
          this._li = new rt(), this._segStrings = null, this._findAllIntersections = false, this._segInt = null, this._isValid = true;
          var t2 = arguments[0];
          this._segStrings = t2;
        };
        Xi.prototype.execute = function() {
          if (null !== this._segInt)
            return null;
          this.checkInteriorIntersections();
        }, Xi.prototype.getIntersections = function() {
          return this._segInt.getIntersections();
        }, Xi.prototype.isValid = function() {
          return this.execute(), this._isValid;
        }, Xi.prototype.setFindAllIntersections = function(t2) {
          this._findAllIntersections = t2;
        }, Xi.prototype.checkInteriorIntersections = function() {
          this._isValid = true, this._segInt = new zi(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
          var t2 = new xn();
          if (t2.setSegmentIntersector(this._segInt), t2.computeNodes(this._segStrings), this._segInt.hasIntersection())
            return this._isValid = false, null;
        }, Xi.prototype.checkValid = function() {
          if (this.execute(), !this._isValid)
            throw new we(this.getErrorMessage(), this._segInt.getInteriorIntersection());
        }, Xi.prototype.getErrorMessage = function() {
          if (this._isValid)
            return "no intersections found";
          var t2 = this._segInt.getIntersectionSegments();
          return "found non-noded intersection between " + Z2.toLineString(t2[0], t2[1]) + " and " + Z2.toLineString(t2[2], t2[3]);
        }, Xi.prototype.interfaces_ = function() {
          return [];
        }, Xi.prototype.getClass = function() {
          return Xi;
        }, Xi.computeIntersections = function(t2) {
          var e3 = new Xi(t2);
          return e3.setFindAllIntersections(true), e3.isValid(), e3.getIntersections();
        };
        var Yi = function t2() {
          this._nv = null;
          var e3 = arguments[0];
          this._nv = new Xi(t2.toSegmentStrings(e3));
        };
        Yi.prototype.checkValid = function() {
          this._nv.checkValid();
        }, Yi.prototype.interfaces_ = function() {
          return [];
        }, Yi.prototype.getClass = function() {
          return Yi;
        }, Yi.toSegmentStrings = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            e3.add(new Ui(i2.getCoordinates(), i2));
          }
          return e3;
        }, Yi.checkValid = function(t2) {
          new Yi(t2).checkValid();
        };
        var ki = function(t2) {
          this._mapOp = t2;
        };
        ki.prototype.map = function(t2) {
          for (var e3 = new Nt(), n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = this._mapOp.map(t2.getGeometryN(n2));
            i2.isEmpty() || e3.add(i2);
          }
          return t2.getFactory().createGeometryCollection(_e.toGeometryArray(e3));
        }, ki.prototype.interfaces_ = function() {
          return [];
        }, ki.prototype.getClass = function() {
          return ki;
        }, ki.map = function(t2, e3) {
          return new ki(e3).map(t2);
        };
        var ji = function() {
          this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new Nt(), this._resultLineList = new Nt();
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._op = t2, this._geometryFactory = e3, this._ptLocator = n2;
        };
        ji.prototype.collectLines = function(t2) {
          for (var e3 = this._op.getGraph().getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this.collectLineEdge(n2, t2, this._lineEdgesList), this.collectBoundaryTouchEdge(n2, t2, this._lineEdgesList);
          }
        }, ji.prototype.labelIsolatedLine = function(t2, e3) {
          var n2 = this._ptLocator.locate(t2.getCoordinate(), this._op.getArgGeometry(e3));
          t2.getLabel().setLocation(e3, n2);
        }, ji.prototype.build = function(t2) {
          return this.findCoveredLineEdges(), this.collectLines(t2), this.buildLines(t2), this._resultLineList;
        }, ji.prototype.collectLineEdge = function(t2, e3, n2) {
          var i2 = t2.getLabel(), r2 = t2.getEdge();
          t2.isLineEdge() && (t2.isVisited() || !Lr.isResultOfOp(i2, e3) || r2.isCovered() || (n2.add(r2), t2.setVisitedEdge(true)));
        }, ji.prototype.findCoveredLineEdges = function() {
          for (var t2 = this._op.getGraph().getNodes().iterator(); t2.hasNext(); ) {
            t2.next().getEdges().findCoveredLineEdges();
          }
          for (var e3 = this._op.getGraph().getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = n2.getEdge();
            if (n2.isLineEdge() && !i2.isCoveredSet()) {
              var r2 = this._op.isCoveredByA(n2.getCoordinate());
              i2.setCovered(r2);
            }
          }
        }, ji.prototype.labelIsolatedLines = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = n2.getLabel();
            n2.isIsolated() && (i2.isNull(0) ? this.labelIsolatedLine(n2, 0) : this.labelIsolatedLine(n2, 1));
          }
        }, ji.prototype.buildLines = function(t2) {
          for (var e3 = this._lineEdgesList.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = this._geometryFactory.createLineString(n2.getCoordinates());
            this._resultLineList.add(i2), n2.setInResult(true);
          }
        }, ji.prototype.collectBoundaryTouchEdge = function(t2, e3, n2) {
          var i2 = t2.getLabel();
          return t2.isLineEdge() ? null : t2.isVisited() ? null : t2.isInteriorAreaEdge() ? null : t2.getEdge().isInResult() ? null : (et.isTrue(!(t2.isInResult() || t2.getSym().isInResult()) || !t2.getEdge().isInResult()), void (Lr.isResultOfOp(i2, e3) && e3 === Lr.INTERSECTION && (n2.add(t2.getEdge()), t2.setVisitedEdge(true))));
        }, ji.prototype.interfaces_ = function() {
          return [];
        }, ji.prototype.getClass = function() {
          return ji;
        };
        var Hi = function() {
          this._op = null, this._geometryFactory = null, this._resultPointList = new Nt();
          var t2 = arguments[0], e3 = arguments[1];
          this._op = t2, this._geometryFactory = e3;
        };
        Hi.prototype.filterCoveredNodeToPoint = function(t2) {
          var e3 = t2.getCoordinate();
          if (!this._op.isCoveredByLA(e3)) {
            var n2 = this._geometryFactory.createPoint(e3);
            this._resultPointList.add(n2);
          }
        }, Hi.prototype.extractNonCoveredResultNodes = function(t2) {
          for (var e3 = this._op.getGraph().getNodes().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            if (!n2.isInResult() && (!n2.isIncidentEdgeInResult() && (0 === n2.getEdges().getDegree() || t2 === Lr.INTERSECTION))) {
              var i2 = n2.getLabel();
              Lr.isResultOfOp(i2, t2) && this.filterCoveredNodeToPoint(n2);
            }
          }
        }, Hi.prototype.build = function(t2) {
          return this.extractNonCoveredResultNodes(t2), this._resultPointList;
        }, Hi.prototype.interfaces_ = function() {
          return [];
        }, Hi.prototype.getClass = function() {
          return Hi;
        };
        var Wi = function() {
          this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = true, this._preserveGeometryCollectionType = true, this._preserveCollections = false, this._preserveType = false;
        };
        Wi.prototype.transformPoint = function(t2, e3) {
          return this._factory.createPoint(this.transformCoordinates(t2.getCoordinateSequence(), t2));
        }, Wi.prototype.transformPolygon = function(t2, e3) {
          var n2 = true, i2 = this.transformLinearRing(t2.getExteriorRing(), t2);
          null !== i2 && i2 instanceof ee2 && !i2.isEmpty() || (n2 = false);
          for (var r2 = new Nt(), o2 = 0; o2 < t2.getNumInteriorRing(); o2++) {
            var s2 = this.transformLinearRing(t2.getInteriorRingN(o2), t2);
            null === s2 || s2.isEmpty() || (s2 instanceof ee2 || (n2 = false), r2.add(s2));
          }
          if (n2)
            return this._factory.createPolygon(i2, r2.toArray([]));
          var a3 = new Nt();
          return null !== i2 && a3.add(i2), a3.addAll(r2), this._factory.buildGeometry(a3);
        }, Wi.prototype.createCoordinateSequence = function(t2) {
          return this._factory.getCoordinateSequenceFactory().create(t2);
        }, Wi.prototype.getInputGeometry = function() {
          return this._inputGeom;
        }, Wi.prototype.transformMultiLineString = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformLineString(t2.getGeometryN(i2), t2);
            null !== r2 && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.transformCoordinates = function(t2, e3) {
          return this.copy(t2);
        }, Wi.prototype.transformLineString = function(t2, e3) {
          return this._factory.createLineString(this.transformCoordinates(t2.getCoordinateSequence(), t2));
        }, Wi.prototype.transformMultiPoint = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformPoint(t2.getGeometryN(i2), t2);
            null !== r2 && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.transformMultiPolygon = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformPolygon(t2.getGeometryN(i2), t2);
            null !== r2 && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.copy = function(t2) {
          return t2.copy();
        }, Wi.prototype.transformGeometryCollection = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transform(t2.getGeometryN(i2));
            null !== r2 && (this._pruneEmptyGeometry && r2.isEmpty() || n2.add(r2));
          }
          return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(_e.toGeometryArray(n2)) : this._factory.buildGeometry(n2);
        }, Wi.prototype.transform = function(t2) {
          if (this._inputGeom = t2, this._factory = t2.getFactory(), t2 instanceof Qt)
            return this.transformPoint(t2, null);
          if (t2 instanceof te)
            return this.transformMultiPoint(t2, null);
          if (t2 instanceof ee2)
            return this.transformLinearRing(t2, null);
          if (t2 instanceof Kt)
            return this.transformLineString(t2, null);
          if (t2 instanceof Xt)
            return this.transformMultiLineString(t2, null);
          if (t2 instanceof $t)
            return this.transformPolygon(t2, null);
          if (t2 instanceof ne)
            return this.transformMultiPolygon(t2, null);
          if (t2 instanceof zt)
            return this.transformGeometryCollection(t2, null);
          throw new m("Unknown Geometry subtype: " + t2.getClass().getName());
        }, Wi.prototype.transformLinearRing = function(t2, e3) {
          var n2 = this.transformCoordinates(t2.getCoordinateSequence(), t2);
          if (null === n2)
            return this._factory.createLinearRing(null);
          var i2 = n2.size();
          return i2 > 0 && i2 < 4 && !this._preserveType ? this._factory.createLineString(n2) : this._factory.createLinearRing(n2);
        }, Wi.prototype.interfaces_ = function() {
          return [];
        }, Wi.prototype.getClass = function() {
          return Wi;
        };
        var Ki = function t2() {
          if (this._snapTolerance = 0, this._srcPts = null, this._seg = new dn(), this._allowSnappingToSourceVertices = false, this._isClosed = false, arguments[0] instanceof Kt && "number" == typeof arguments[1]) {
            var e3 = arguments[0], n2 = arguments[1];
            t2.call(this, e3.getCoordinates(), n2);
          } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
            var i2 = arguments[0], r2 = arguments[1];
            this._srcPts = i2, this._isClosed = t2.isClosed(i2), this._snapTolerance = r2;
          }
        };
        Ki.prototype.snapVertices = function(t2, e3) {
          for (var n2 = this._isClosed ? t2.size() - 1 : t2.size(), i2 = 0; i2 < n2; i2++) {
            var r2 = t2.get(i2), o2 = this.findSnapForVertex(r2, e3);
            null !== o2 && (t2.set(i2, new C(o2)), 0 === i2 && this._isClosed && t2.set(t2.size() - 1, new C(o2)));
          }
        }, Ki.prototype.findSnapForVertex = function(t2, e3) {
          for (var n2 = 0; n2 < e3.length; n2++) {
            if (t2.equals2D(e3[n2]))
              return null;
            if (t2.distance(e3[n2]) < this._snapTolerance)
              return e3[n2];
          }
          return null;
        }, Ki.prototype.snapTo = function(t2) {
          var e3 = new St(this._srcPts);
          this.snapVertices(e3, t2), this.snapSegments(e3, t2);
          return e3.toCoordinateArray();
        }, Ki.prototype.snapSegments = function(t2, e3) {
          if (0 === e3.length)
            return null;
          var n2 = e3.length;
          e3[0].equals2D(e3[e3.length - 1]) && (n2 = e3.length - 1);
          for (var i2 = 0; i2 < n2; i2++) {
            var r2 = e3[i2], o2 = this.findSegmentIndexToSnap(r2, t2);
            o2 >= 0 && t2.add(o2 + 1, new C(r2), false);
          }
        }, Ki.prototype.findSegmentIndexToSnap = function(t2, e3) {
          for (var n2 = v.MAX_VALUE, i2 = -1, r2 = 0; r2 < e3.size() - 1; r2++) {
            if (this._seg.p0 = e3.get(r2), this._seg.p1 = e3.get(r2 + 1), this._seg.p0.equals2D(t2) || this._seg.p1.equals2D(t2)) {
              if (this._allowSnappingToSourceVertices)
                continue;
              return -1;
            }
            var o2 = this._seg.distance(t2);
            o2 < this._snapTolerance && o2 < n2 && (n2 = o2, i2 = r2);
          }
          return i2;
        }, Ki.prototype.setAllowSnappingToSourceVertices = function(t2) {
          this._allowSnappingToSourceVertices = t2;
        }, Ki.prototype.interfaces_ = function() {
          return [];
        }, Ki.prototype.getClass = function() {
          return Ki;
        }, Ki.isClosed = function(t2) {
          return !(t2.length <= 1) && t2[0].equals2D(t2[t2.length - 1]);
        };
        var Ji = function(t2) {
          this._srcGeom = t2 || null;
        }, Qi = { SNAP_PRECISION_FACTOR: { configurable: true } };
        Ji.prototype.snapTo = function(t2, e3) {
          var n2 = this.extractTargetCoordinates(t2);
          return new Zi(e3, n2).transform(this._srcGeom);
        }, Ji.prototype.snapToSelf = function(t2, e3) {
          var n2 = this.extractTargetCoordinates(this._srcGeom), i2 = new Zi(t2, n2, true).transform(this._srcGeom), r2 = i2;
          return e3 && T(r2, Zt) && (r2 = i2.buffer(0)), r2;
        }, Ji.prototype.computeSnapTolerance = function(t2) {
          return this.computeMinimumSegmentLength(t2) / 10;
        }, Ji.prototype.extractTargetCoordinates = function(t2) {
          for (var e3 = new f(), n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; i2++)
            e3.add(n2[i2]);
          return e3.toArray(new Array(0).fill(null));
        }, Ji.prototype.computeMinimumSegmentLength = function(t2) {
          for (var e3 = v.MAX_VALUE, n2 = 0; n2 < t2.length - 1; n2++) {
            var i2 = t2[n2].distance(t2[n2 + 1]);
            i2 < e3 && (e3 = i2);
          }
          return e3;
        }, Ji.prototype.interfaces_ = function() {
          return [];
        }, Ji.prototype.getClass = function() {
          return Ji;
        }, Ji.snap = function(t2, e3, n2) {
          var i2 = new Array(2).fill(null), r2 = new Ji(t2);
          i2[0] = r2.snapTo(e3, n2);
          var o2 = new Ji(e3);
          return i2[1] = o2.snapTo(i2[0], n2), i2;
        }, Ji.computeOverlaySnapTolerance = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = Ji.computeSizeBasedSnapTolerance(t2), n2 = t2.getPrecisionModel();
            if (n2.getType() === fe.FIXED) {
              var i2 = 1 / n2.getScale() * 2 / 1.415;
              i2 > e3 && (e3 = i2);
            }
            return e3;
          }
          if (2 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1];
            return Math.min(Ji.computeOverlaySnapTolerance(r2), Ji.computeOverlaySnapTolerance(o2));
          }
        }, Ji.computeSizeBasedSnapTolerance = function(t2) {
          var e3 = t2.getEnvelopeInternal();
          return Math.min(e3.getHeight(), e3.getWidth()) * Ji.SNAP_PRECISION_FACTOR;
        }, Ji.snapToSelf = function(t2, e3, n2) {
          return new Ji(t2).snapToSelf(e3, n2);
        }, Qi.SNAP_PRECISION_FACTOR.get = function() {
          return 1e-9;
        }, Object.defineProperties(Ji, Qi);
        var Zi = function(t2) {
          function e3(e4, n2, i2) {
            t2.call(this), this._snapTolerance = e4 || null, this._snapPts = n2 || null, this._isSelfSnap = void 0 !== i2 && i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.snapLine = function(t3, e4) {
            var n2 = new Ki(t3, this._snapTolerance);
            return n2.setAllowSnappingToSourceVertices(this._isSelfSnap), n2.snapTo(e4);
          }, e3.prototype.transformCoordinates = function(t3, e4) {
            var n2 = t3.toCoordinateArray(), i2 = this.snapLine(n2, this._snapPts);
            return this._factory.getCoordinateSequenceFactory().create(i2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Wi), $i = function() {
          this._isFirst = true, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null;
        };
        $i.prototype.getCommon = function() {
          return v.longBitsToDouble(this._commonBits);
        }, $i.prototype.add = function(t2) {
          var e3 = v.doubleToLongBits(t2);
          if (this._isFirst)
            return this._commonBits = e3, this._commonSignExp = $i.signExpBits(this._commonBits), this._isFirst = false, null;
          if ($i.signExpBits(e3) !== this._commonSignExp)
            return this._commonBits = 0, null;
          this._commonMantissaBitsCount = $i.numCommonMostSigMantissaBits(this._commonBits, e3), this._commonBits = $i.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
        }, $i.prototype.toString = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = v.longBitsToDouble(t2), n2 = "0000000000000000000000000000000000000000000000000000000000000000" + v.toBinaryString(t2), i2 = n2.substring(n2.length - 64);
            return i2.substring(0, 1) + "  " + i2.substring(1, 12) + "(exp) " + i2.substring(12) + " [ " + e3 + " ]";
          }
        }, $i.prototype.interfaces_ = function() {
          return [];
        }, $i.prototype.getClass = function() {
          return $i;
        }, $i.getBit = function(t2, e3) {
          return 0 != (t2 & 1 << e3) ? 1 : 0;
        }, $i.signExpBits = function(t2) {
          return t2 >> 52;
        }, $i.zeroLowerBits = function(t2, e3) {
          return t2 & ~((1 << e3) - 1);
        }, $i.numCommonMostSigMantissaBits = function(t2, e3) {
          for (var n2 = 0, i2 = 52; i2 >= 0; i2--) {
            if ($i.getBit(t2, i2) !== $i.getBit(e3, i2))
              return n2;
            n2++;
          }
          return 52;
        };
        var tr = function() {
          this._commonCoord = null, this._ccFilter = new nr();
        }, er = { CommonCoordinateFilter: { configurable: true }, Translater: { configurable: true } };
        tr.prototype.addCommonBits = function(t2) {
          var e3 = new ir(this._commonCoord);
          t2.apply(e3), t2.geometryChanged();
        }, tr.prototype.removeCommonBits = function(t2) {
          if (0 === this._commonCoord.x && 0 === this._commonCoord.y)
            return t2;
          var e3 = new C(this._commonCoord);
          e3.x = -e3.x, e3.y = -e3.y;
          var n2 = new ir(e3);
          return t2.apply(n2), t2.geometryChanged(), t2;
        }, tr.prototype.getCommonCoordinate = function() {
          return this._commonCoord;
        }, tr.prototype.add = function(t2) {
          t2.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();
        }, tr.prototype.interfaces_ = function() {
          return [];
        }, tr.prototype.getClass = function() {
          return tr;
        }, er.CommonCoordinateFilter.get = function() {
          return nr;
        }, er.Translater.get = function() {
          return ir;
        }, Object.defineProperties(tr, er);
        var nr = function() {
          this._commonBitsX = new $i(), this._commonBitsY = new $i();
        };
        nr.prototype.filter = function(t2) {
          this._commonBitsX.add(t2.x), this._commonBitsY.add(t2.y);
        }, nr.prototype.getCommonCoordinate = function() {
          return new C(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
        }, nr.prototype.interfaces_ = function() {
          return [ft];
        }, nr.prototype.getClass = function() {
          return nr;
        };
        var ir = function() {
          this.trans = null;
          var t2 = arguments[0];
          this.trans = t2;
        };
        ir.prototype.filter = function(t2, e3) {
          var n2 = t2.getOrdinate(e3, 0) + this.trans.x, i2 = t2.getOrdinate(e3, 1) + this.trans.y;
          t2.setOrdinate(e3, 0, n2), t2.setOrdinate(e3, 1, i2);
        }, ir.prototype.isDone = function() {
          return false;
        }, ir.prototype.isGeometryChanged = function() {
          return true;
        }, ir.prototype.interfaces_ = function() {
          return [Ut];
        }, ir.prototype.getClass = function() {
          return ir;
        };
        var rr = function(t2, e3) {
          this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t2, this._geom[1] = e3, this.computeSnapTolerance();
        };
        rr.prototype.selfSnap = function(t2) {
          return new Ji(t2).snapTo(t2, this._snapTolerance);
        }, rr.prototype.removeCommonBits = function(t2) {
          this._cbr = new tr(), this._cbr.add(t2[0]), this._cbr.add(t2[1]);
          var e3 = new Array(2).fill(null);
          return e3[0] = this._cbr.removeCommonBits(t2[0].copy()), e3[1] = this._cbr.removeCommonBits(t2[1].copy()), e3;
        }, rr.prototype.prepareResult = function(t2) {
          return this._cbr.addCommonBits(t2), t2;
        }, rr.prototype.getResultGeometry = function(t2) {
          var e3 = this.snap(this._geom), n2 = Lr.overlayOp(e3[0], e3[1], t2);
          return this.prepareResult(n2);
        }, rr.prototype.checkValid = function(t2) {
          t2.isValid() || Y.out.println("Snapped geometry is invalid");
        }, rr.prototype.computeSnapTolerance = function() {
          this._snapTolerance = Ji.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
        }, rr.prototype.snap = function(t2) {
          var e3 = this.removeCommonBits(t2);
          return Ji.snap(e3[0], e3[1], this._snapTolerance);
        }, rr.prototype.interfaces_ = function() {
          return [];
        }, rr.prototype.getClass = function() {
          return rr;
        }, rr.overlayOp = function(t2, e3, n2) {
          return new rr(t2, e3).getResultGeometry(n2);
        }, rr.union = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.UNION);
        }, rr.intersection = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.INTERSECTION);
        }, rr.symDifference = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, rr.difference = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.DIFFERENCE);
        };
        var or = function(t2, e3) {
          this._geom = new Array(2).fill(null), this._geom[0] = t2, this._geom[1] = e3;
        };
        or.prototype.getResultGeometry = function(t2) {
          var e3 = null, n2 = false, i2 = null;
          try {
            e3 = Lr.overlayOp(this._geom[0], this._geom[1], t2);
            n2 = true;
          } catch (t3) {
            if (!(t3 instanceof $))
              throw t3;
            i2 = t3;
          }
          if (!n2)
            try {
              e3 = rr.overlayOp(this._geom[0], this._geom[1], t2);
            } catch (t3) {
              throw t3 instanceof $ ? i2 : t3;
            }
          return e3;
        }, or.prototype.interfaces_ = function() {
          return [];
        }, or.prototype.getClass = function() {
          return or;
        }, or.overlayOp = function(t2, e3, n2) {
          return new or(t2, e3).getResultGeometry(n2);
        }, or.union = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.UNION);
        }, or.intersection = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.INTERSECTION);
        }, or.symDifference = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, or.difference = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.DIFFERENCE);
        };
        var sr = function() {
          this.mce = null, this.chainIndex = null;
          var t2 = arguments[0], e3 = arguments[1];
          this.mce = t2, this.chainIndex = e3;
        };
        sr.prototype.computeIntersections = function(t2, e3) {
          this.mce.computeIntersectsForChain(this.chainIndex, t2.mce, t2.chainIndex, e3);
        }, sr.prototype.interfaces_ = function() {
          return [];
        }, sr.prototype.getClass = function() {
          return sr;
        };
        var ar = function t2() {
          if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this._eventType = t2.DELETE, this._xValue = e3, this._insertEvent = n2;
          } else if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._eventType = t2.INSERT, this._label = i2, this._xValue = r2, this._obj = o2;
          }
        }, ur = { INSERT: { configurable: true }, DELETE: { configurable: true } };
        ar.prototype.isDelete = function() {
          return this._eventType === ar.DELETE;
        }, ar.prototype.setDeleteEventIndex = function(t2) {
          this._deleteEventIndex = t2;
        }, ar.prototype.getObject = function() {
          return this._obj;
        }, ar.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._xValue < e3._xValue ? -1 : this._xValue > e3._xValue ? 1 : this._eventType < e3._eventType ? -1 : this._eventType > e3._eventType ? 1 : 0;
        }, ar.prototype.getInsertEvent = function() {
          return this._insertEvent;
        }, ar.prototype.isInsert = function() {
          return this._eventType === ar.INSERT;
        }, ar.prototype.isSameLabel = function(t2) {
          return null !== this._label && this._label === t2._label;
        }, ar.prototype.getDeleteEventIndex = function() {
          return this._deleteEventIndex;
        }, ar.prototype.interfaces_ = function() {
          return [E];
        }, ar.prototype.getClass = function() {
          return ar;
        }, ur.INSERT.get = function() {
          return 1;
        }, ur.DELETE.get = function() {
          return 2;
        }, Object.defineProperties(ar, ur);
        var lr = function() {
        };
        lr.prototype.interfaces_ = function() {
          return [];
        }, lr.prototype.getClass = function() {
          return lr;
        };
        var cr = function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = false, this._isDoneWhenProperInt = false;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._li = t2, this._includeProper = e3, this._recordIsolated = n2;
        };
        cr.prototype.isTrivialIntersection = function(t2, e3, n2, i2) {
          if (t2 === n2 && 1 === this._li.getIntersectionNum()) {
            if (cr.isAdjacentSegments(e3, i2))
              return true;
            if (t2.isClosed()) {
              var r2 = t2.getNumPoints() - 1;
              if (0 === e3 && i2 === r2 || 0 === i2 && e3 === r2)
                return true;
            }
          }
          return false;
        }, cr.prototype.getProperIntersectionPoint = function() {
          return this._properIntersectionPoint;
        }, cr.prototype.setIsDoneIfProperInt = function(t2) {
          this._isDoneWhenProperInt = t2;
        }, cr.prototype.hasProperInteriorIntersection = function() {
          return this._hasProperInterior;
        }, cr.prototype.isBoundaryPointInternal = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().getCoordinate();
            if (t2.isIntersection(i2))
              return true;
          }
          return false;
        }, cr.prototype.hasProperIntersection = function() {
          return this._hasProper;
        }, cr.prototype.hasIntersection = function() {
          return this._hasIntersection;
        }, cr.prototype.isDone = function() {
          return this._isDone;
        }, cr.prototype.isBoundaryPoint = function(t2, e3) {
          return null !== e3 && (!!this.isBoundaryPointInternal(t2, e3[0]) || !!this.isBoundaryPointInternal(t2, e3[1]));
        }, cr.prototype.setBoundaryNodes = function(t2, e3) {
          this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t2, this._bdyNodes[1] = e3;
        }, cr.prototype.addIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          this.numTests++;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a3 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a3), this._li.hasIntersection() && (this._recordIsolated && (t2.setIsolated(false), n2.setIsolated(false)), this._numIntersections++, this.isTrivialIntersection(t2, e3, n2, i2) || (this._hasIntersection = true, !this._includeProper && this._li.isProper() || (t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = true, this._isDoneWhenProperInt && (this._isDone = true), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = true))));
        }, cr.prototype.interfaces_ = function() {
          return [];
        }, cr.prototype.getClass = function() {
          return cr;
        }, cr.isAdjacentSegments = function(t2, e3) {
          return 1 === Math.abs(t2 - e3);
        };
        var pr = function(t2) {
          function e3() {
            t2.call(this), this.events = new Nt(), this.nOverlaps = null;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.prepareEvents = function() {
            $e.sort(this.events);
            for (var t3 = 0; t3 < this.events.size(); t3++) {
              var e4 = this.events.get(t3);
              e4.isDelete() && e4.getInsertEvent().setDeleteEventIndex(t3);
            }
          }, e3.prototype.computeIntersections = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0];
              this.nOverlaps = 0, this.prepareEvents();
              for (var e4 = 0; e4 < this.events.size(); e4++) {
                var n2 = this.events.get(e4);
                if (n2.isInsert() && this.processOverlaps(e4, n2.getDeleteEventIndex(), n2, t3), t3.isDone())
                  break;
              }
            } else if (3 === arguments.length) {
              if (arguments[2] instanceof cr && T(arguments[0], xt) && T(arguments[1], xt)) {
                var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
                this.addEdges(i2, i2), this.addEdges(r2, r2), this.computeIntersections(o2);
              } else if ("boolean" == typeof arguments[2] && T(arguments[0], xt) && arguments[1] instanceof cr) {
                var s2 = arguments[0], a3 = arguments[1];
                arguments[2] ? this.addEdges(s2, null) : this.addEdges(s2), this.computeIntersections(a3);
              }
            }
          }, e3.prototype.addEdge = function(t3, e4) {
            for (var n2 = t3.getMonotoneChainEdge(), i2 = n2.getStartIndexes(), r2 = 0; r2 < i2.length - 1; r2++) {
              var o2 = new sr(n2, r2), s2 = new ar(e4, n2.getMinX(r2), o2);
              this.events.add(s2), this.events.add(new ar(n2.getMaxX(r2), s2));
            }
          }, e3.prototype.processOverlaps = function(t3, e4, n2, i2) {
            for (var r2 = n2.getObject(), o2 = t3; o2 < e4; o2++) {
              var s2 = this.events.get(o2);
              if (s2.isInsert()) {
                var a3 = s2.getObject();
                n2.isSameLabel(s2) || (r2.computeIntersections(a3, i2), this.nOverlaps++);
              }
            }
          }, e3.prototype.addEdges = function() {
            if (1 === arguments.length)
              for (var t3 = arguments[0].iterator(); t3.hasNext(); ) {
                var e4 = t3.next();
                this.addEdge(e4, e4);
              }
            else if (2 === arguments.length)
              for (var n2 = arguments[0], i2 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
                var o2 = r2.next();
                this.addEdge(o2, i2);
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(lr), hr = function() {
          this._min = v.POSITIVE_INFINITY, this._max = v.NEGATIVE_INFINITY;
        }, fr = { NodeComparator: { configurable: true } };
        hr.prototype.getMin = function() {
          return this._min;
        }, hr.prototype.intersects = function(t2, e3) {
          return !(this._min > e3 || this._max < t2);
        }, hr.prototype.getMax = function() {
          return this._max;
        }, hr.prototype.toString = function() {
          return Z2.toLineString(new C(this._min, 0), new C(this._max, 0));
        }, hr.prototype.interfaces_ = function() {
          return [];
        }, hr.prototype.getClass = function() {
          return hr;
        }, fr.NodeComparator.get = function() {
          return gr;
        }, Object.defineProperties(hr, fr);
        var gr = function() {
        };
        gr.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3, r2 = (n2._min + n2._max) / 2, o2 = (i2._min + i2._max) / 2;
          return r2 < o2 ? -1 : r2 > o2 ? 1 : 0;
        }, gr.prototype.interfaces_ = function() {
          return [N];
        }, gr.prototype.getClass = function() {
          return gr;
        };
        var dr = function(t2) {
          function e3() {
            t2.call(this), this._item = null;
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._min = e4, this._max = n2, this._item = i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.query = function(t3, e4, n2) {
            if (!this.intersects(t3, e4))
              return null;
            n2.visitItem(this._item);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(hr), yr = function(t2) {
          function e3() {
            t2.call(this), this._node1 = null, this._node2 = null;
            var e4 = arguments[0], n2 = arguments[1];
            this._node1 = e4, this._node2 = n2, this.buildExtent(this._node1, this._node2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.buildExtent = function(t3, e4) {
            this._min = Math.min(t3._min, e4._min), this._max = Math.max(t3._max, e4._max);
          }, e3.prototype.query = function(t3, e4, n2) {
            if (!this.intersects(t3, e4))
              return null;
            null !== this._node1 && this._node1.query(t3, e4, n2), null !== this._node2 && this._node2.query(t3, e4, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(hr), _r = function() {
          this._leaves = new Nt(), this._root = null, this._level = 0;
        };
        _r.prototype.buildTree = function() {
          $e.sort(this._leaves, new hr.NodeComparator());
          for (var t2 = this._leaves, e3 = null, n2 = new Nt(); ; ) {
            if (this.buildLevel(t2, n2), 1 === n2.size())
              return n2.get(0);
            e3 = t2, t2 = n2, n2 = e3;
          }
        }, _r.prototype.insert = function(t2, e3, n2) {
          if (null !== this._root)
            throw new Error("Index cannot be added to once it has been queried");
          this._leaves.add(new dr(t2, e3, n2));
        }, _r.prototype.query = function(t2, e3, n2) {
          this.init(), this._root.query(t2, e3, n2);
        }, _r.prototype.buildRoot = function() {
          if (null !== this._root)
            return null;
          this._root = this.buildTree();
        }, _r.prototype.printNode = function(t2) {
          Y.out.println(Z2.toLineString(new C(t2._min, this._level), new C(t2._max, this._level)));
        }, _r.prototype.init = function() {
          if (null !== this._root)
            return null;
          this.buildRoot();
        }, _r.prototype.buildLevel = function(t2, e3) {
          this._level++, e3.clear();
          for (var n2 = 0; n2 < t2.size(); n2 += 2) {
            var i2 = t2.get(n2);
            if (null === (n2 + 1 < t2.size() ? t2.get(n2) : null))
              e3.add(i2);
            else {
              var r2 = new yr(t2.get(n2), t2.get(n2 + 1));
              e3.add(r2);
            }
          }
        }, _r.prototype.interfaces_ = function() {
          return [];
        }, _r.prototype.getClass = function() {
          return _r;
        };
        var mr = function() {
          this._items = new Nt();
        };
        mr.prototype.visitItem = function(t2) {
          this._items.add(t2);
        }, mr.prototype.getItems = function() {
          return this._items;
        }, mr.prototype.interfaces_ = function() {
          return [Ke];
        }, mr.prototype.getClass = function() {
          return mr;
        };
        var vr = function() {
          this._index = null;
          var t2 = arguments[0];
          if (!T(t2, Zt))
            throw new m("Argument must be Polygonal");
          this._index = new xr(t2);
        }, Ir = { SegmentVisitor: { configurable: true }, IntervalIndexedGeometry: { configurable: true } };
        vr.prototype.locate = function(t2) {
          var e3 = new st(t2), n2 = new Er(e3);
          return this._index.query(t2.y, t2.y, n2), e3.getLocation();
        }, vr.prototype.interfaces_ = function() {
          return [Vn];
        }, vr.prototype.getClass = function() {
          return vr;
        }, Ir.SegmentVisitor.get = function() {
          return Er;
        }, Ir.IntervalIndexedGeometry.get = function() {
          return xr;
        }, Object.defineProperties(vr, Ir);
        var Er = function() {
          this._counter = null;
          var t2 = arguments[0];
          this._counter = t2;
        };
        Er.prototype.visitItem = function(t2) {
          var e3 = t2;
          this._counter.countSegment(e3.getCoordinate(0), e3.getCoordinate(1));
        }, Er.prototype.interfaces_ = function() {
          return [Ke];
        }, Er.prototype.getClass = function() {
          return Er;
        };
        var xr = function() {
          this._index = new _r();
          var t2 = arguments[0];
          this.init(t2);
        };
        xr.prototype.init = function(t2) {
          for (var e3 = Ci.getLines(t2).iterator(); e3.hasNext(); ) {
            var n2 = e3.next().getCoordinates();
            this.addLine(n2);
          }
        }, xr.prototype.addLine = function(t2) {
          for (var e3 = 1; e3 < t2.length; e3++) {
            var n2 = new dn(t2[e3 - 1], t2[e3]), i2 = Math.min(n2.p0.y, n2.p1.y), r2 = Math.max(n2.p0.y, n2.p1.y);
            this._index.insert(i2, r2, n2);
          }
        }, xr.prototype.query = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = new mr();
            return this._index.query(t2, e3, n2), n2.getItems();
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._index.query(i2, r2, o2);
          }
        }, xr.prototype.interfaces_ = function() {
          return [];
        }, xr.prototype.getClass = function() {
          return xr;
        };
        var Nr = function(t2) {
          function e3() {
            if (t2.call(this), this._parentGeom = null, this._lineEdgeMap = new he(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = true, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = false, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Si(), 2 === arguments.length) {
              var e4 = arguments[0], n2 = arguments[1], i2 = gt.OGC_SFS_BOUNDARY_RULE;
              this._argIndex = e4, this._parentGeom = n2, this._boundaryNodeRule = i2, null !== n2 && this.add(n2);
            } else if (3 === arguments.length) {
              var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
              this._argIndex = r2, this._parentGeom = o2, this._boundaryNodeRule = s2, null !== o2 && this.add(o2);
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.insertBoundaryPoint = function(t3, n2) {
            var i2 = this._nodes.addNode(n2).getLabel(), r2 = 1;
            w.NONE;
            i2.getLocation(t3, Se.ON) === w.BOUNDARY && r2++;
            var o2 = e3.determineBoundary(this._boundaryNodeRule, r2);
            i2.setLocation(t3, o2);
          }, e3.prototype.computeSelfNodes = function() {
            if (2 === arguments.length) {
              var t3 = arguments[0], e4 = arguments[1];
              return this.computeSelfNodes(t3, e4, false);
            }
            if (3 === arguments.length) {
              var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new cr(n2, true, false);
              o2.setIsDoneIfProperInt(r2);
              var s2 = this.createEdgeSetIntersector(), a3 = this._parentGeom instanceof ee2 || this._parentGeom instanceof $t || this._parentGeom instanceof ne, u2 = i2 || !a3;
              return s2.computeIntersections(this._edges, o2, u2), this.addSelfIntersectionNodes(this._argIndex), o2;
            }
          }, e3.prototype.computeSplitEdges = function(t3) {
            for (var e4 = this._edges.iterator(); e4.hasNext(); ) {
              e4.next().eiList.addSplitEdges(t3);
            }
          }, e3.prototype.computeEdgeIntersections = function(t3, e4, n2) {
            var i2 = new cr(e4, n2, true);
            i2.setBoundaryNodes(this.getBoundaryNodes(), t3.getBoundaryNodes());
            return this.createEdgeSetIntersector().computeIntersections(this._edges, t3._edges, i2), i2;
          }, e3.prototype.getGeometry = function() {
            return this._parentGeom;
          }, e3.prototype.getBoundaryNodeRule = function() {
            return this._boundaryNodeRule;
          }, e3.prototype.hasTooFewPoints = function() {
            return this._hasTooFewPoints;
          }, e3.prototype.addPoint = function() {
            if (arguments[0] instanceof Qt) {
              var t3 = arguments[0].getCoordinate();
              this.insertPoint(this._argIndex, t3, w.INTERIOR);
            } else if (arguments[0] instanceof C) {
              var e4 = arguments[0];
              this.insertPoint(this._argIndex, e4, w.INTERIOR);
            }
          }, e3.prototype.addPolygon = function(t3) {
            this.addPolygonRing(t3.getExteriorRing(), w.EXTERIOR, w.INTERIOR);
            for (var e4 = 0; e4 < t3.getNumInteriorRing(); e4++) {
              var n2 = t3.getInteriorRingN(e4);
              this.addPolygonRing(n2, w.INTERIOR, w.EXTERIOR);
            }
          }, e3.prototype.addEdge = function(t3) {
            this.insertEdge(t3);
            var e4 = t3.getCoordinates();
            this.insertPoint(this._argIndex, e4[0], w.BOUNDARY), this.insertPoint(this._argIndex, e4[e4.length - 1], w.BOUNDARY);
          }, e3.prototype.addLineString = function(t3) {
            var e4 = Lt.removeRepeatedPoints(t3.getCoordinates());
            if (e4.length < 2)
              return this._hasTooFewPoints = true, this._invalidPoint = e4[0], null;
            var n2 = new ni(e4, new Pe(this._argIndex, w.INTERIOR));
            this._lineEdgeMap.put(t3, n2), this.insertEdge(n2), et.isTrue(e4.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, e4[0]), this.insertBoundaryPoint(this._argIndex, e4[e4.length - 1]);
          }, e3.prototype.getInvalidPoint = function() {
            return this._invalidPoint;
          }, e3.prototype.getBoundaryPoints = function() {
            for (var t3 = this.getBoundaryNodes(), e4 = new Array(t3.size()).fill(null), n2 = 0, i2 = t3.iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              e4[n2++] = r2.getCoordinate().copy();
            }
            return e4;
          }, e3.prototype.getBoundaryNodes = function() {
            return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;
          }, e3.prototype.addSelfIntersectionNode = function(t3, e4, n2) {
            if (this.isBoundaryNode(t3, e4))
              return null;
            n2 === w.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t3, e4) : this.insertPoint(t3, e4, n2);
          }, e3.prototype.addPolygonRing = function(t3, e4, n2) {
            if (t3.isEmpty())
              return null;
            var i2 = Lt.removeRepeatedPoints(t3.getCoordinates());
            if (i2.length < 4)
              return this._hasTooFewPoints = true, this._invalidPoint = i2[0], null;
            var r2 = e4, o2 = n2;
            at.isCCW(i2) && (r2 = n2, o2 = e4);
            var s2 = new ni(i2, new Pe(this._argIndex, w.BOUNDARY, r2, o2));
            this._lineEdgeMap.put(t3, s2), this.insertEdge(s2), this.insertPoint(this._argIndex, i2[0], w.BOUNDARY);
          }, e3.prototype.insertPoint = function(t3, e4, n2) {
            var i2 = this._nodes.addNode(e4), r2 = i2.getLabel();
            null === r2 ? i2._label = new Pe(t3, n2) : r2.setLocation(t3, n2);
          }, e3.prototype.createEdgeSetIntersector = function() {
            return new pr();
          }, e3.prototype.addSelfIntersectionNodes = function(t3) {
            for (var e4 = this._edges.iterator(); e4.hasNext(); )
              for (var n2 = e4.next(), i2 = n2.getLabel().getLocation(t3), r2 = n2.eiList.iterator(); r2.hasNext(); ) {
                var o2 = r2.next();
                this.addSelfIntersectionNode(t3, o2.coord, i2);
              }
          }, e3.prototype.add = function() {
            if (1 !== arguments.length)
              return t2.prototype.add.apply(this, arguments);
            var e4 = arguments[0];
            if (e4.isEmpty())
              return null;
            if (e4 instanceof ne && (this._useBoundaryDeterminationRule = false), e4 instanceof $t)
              this.addPolygon(e4);
            else if (e4 instanceof Kt)
              this.addLineString(e4);
            else if (e4 instanceof Qt)
              this.addPoint(e4);
            else if (e4 instanceof te)
              this.addCollection(e4);
            else if (e4 instanceof Xt)
              this.addCollection(e4);
            else if (e4 instanceof ne)
              this.addCollection(e4);
            else {
              if (!(e4 instanceof zt))
                throw new Error(e4.getClass().getName());
              this.addCollection(e4);
            }
          }, e3.prototype.addCollection = function(t3) {
            for (var e4 = 0; e4 < t3.getNumGeometries(); e4++) {
              var n2 = t3.getGeometryN(e4);
              this.add(n2);
            }
          }, e3.prototype.locate = function(t3) {
            return T(this._parentGeom, Zt) && this._parentGeom.getNumGeometries() > 50 ? (null === this._areaPtLocator && (this._areaPtLocator = new vr(this._parentGeom)), this._areaPtLocator.locate(t3)) : this._ptLocator.locate(t3, this._parentGeom);
          }, e3.prototype.findEdge = function() {
            if (1 === arguments.length) {
              var e4 = arguments[0];
              return this._lineEdgeMap.get(e4);
            }
            return t2.prototype.findEdge.apply(this, arguments);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.determineBoundary = function(t3, e4) {
            return t3.isInBoundary(e4) ? w.BOUNDARY : w.INTERIOR;
          }, e3;
        }(Ye), Cr = function() {
          if (this._li = new rt(), this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this.setComputationPrecision(t2.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Nr(0, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = gt.OGC_SFS_BOUNDARY_RULE;
            e3.getPrecisionModel().compareTo(n2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e3.getPrecisionModel()) : this.setComputationPrecision(n2.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, e3, i2), this._arg[1] = new Nr(1, n2, i2);
          } else if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
            r2.getPrecisionModel().compareTo(o2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(r2.getPrecisionModel()) : this.setComputationPrecision(o2.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, r2, s2), this._arg[1] = new Nr(1, o2, s2);
          }
        };
        Cr.prototype.getArgGeometry = function(t2) {
          return this._arg[t2].getGeometry();
        }, Cr.prototype.setComputationPrecision = function(t2) {
          this._resultPrecisionModel = t2, this._li.setPrecisionModel(this._resultPrecisionModel);
        }, Cr.prototype.interfaces_ = function() {
          return [];
        }, Cr.prototype.getClass = function() {
          return Cr;
        };
        var Sr = function() {
        };
        Sr.prototype.interfaces_ = function() {
          return [];
        }, Sr.prototype.getClass = function() {
          return Sr;
        }, Sr.map = function() {
          if (arguments[0] instanceof ct && T(arguments[1], Sr.MapOp)) {
            for (var t2 = arguments[0], e3 = arguments[1], n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
              var r2 = e3.map(t2.getGeometryN(i2));
              null !== r2 && n2.add(r2);
            }
            return t2.getFactory().buildGeometry(n2);
          }
          if (T(arguments[0], It) && T(arguments[1], Sr.MapOp)) {
            for (var o2 = arguments[0], s2 = arguments[1], a3 = new Nt(), u2 = o2.iterator(); u2.hasNext(); ) {
              var l2 = u2.next(), c2 = s2.map(l2);
              null !== c2 && a3.add(c2);
            }
            return a3;
          }
        }, Sr.MapOp = function() {
        };
        var Lr = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2), this._ptLocator = new Si(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Hn(), this._resultPolyList = new Nt(), this._resultLineList = new Nt(), this._resultPointList = new Nt(), this._graph = new Ye(new kn()), this._geomFact = e4.getFactory();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.insertUniqueEdge = function(t3) {
            var e4 = this._edgeList.findEqualEdge(t3);
            if (null !== e4) {
              var n2 = e4.getLabel(), i2 = t3.getLabel();
              e4.isPointwiseEqual(t3) || (i2 = new Pe(t3.getLabel())).flip();
              var r2 = e4.getDepth();
              r2.isNull() && r2.add(n2), r2.add(i2), n2.merge(i2);
            } else
              this._edgeList.add(t3);
          }, e3.prototype.getGraph = function() {
            return this._graph;
          }, e3.prototype.cancelDuplicateResultEdges = function() {
            for (var t3 = this._graph.getEdgeEnds().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getSym();
              e4.isInResult() && n2.isInResult() && (e4.setInResult(false), n2.setInResult(false));
            }
          }, e3.prototype.isCoveredByLA = function(t3) {
            return !!this.isCovered(t3, this._resultLineList) || !!this.isCovered(t3, this._resultPolyList);
          }, e3.prototype.computeGeometry = function(t3, n2, i2, r2) {
            var o2 = new Nt();
            return o2.addAll(t3), o2.addAll(n2), o2.addAll(i2), o2.isEmpty() ? e3.createEmptyResult(r2, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(o2);
          }, e3.prototype.mergeSymLabels = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              t3.next().getEdges().mergeSymLabels();
            }
          }, e3.prototype.isCovered = function(t3, e4) {
            for (var n2 = e4.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              if (this._ptLocator.locate(t3, i2) !== w.EXTERIOR)
                return true;
            }
            return false;
          }, e3.prototype.replaceCollapsedEdges = function() {
            for (var t3 = new Nt(), e4 = this._edgeList.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              n2.isCollapsed() && (e4.remove(), t3.add(n2.getCollapsedEdge()));
            }
            this._edgeList.addAll(t3);
          }, e3.prototype.updateNodeLabelling = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getEdges().getLabel();
              e4.getLabel().merge(n2);
            }
          }, e3.prototype.getResultGeometry = function(t3) {
            return this.computeOverlay(t3), this._resultGeom;
          }, e3.prototype.insertUniqueEdges = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              this.insertUniqueEdge(n2);
            }
          }, e3.prototype.computeOverlay = function(t3) {
            this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, false), this._arg[1].computeSelfNodes(this._li, false), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
            var e4 = new Nt();
            this._arg[0].computeSplitEdges(e4), this._arg[1].computeSplitEdges(e4), this.insertUniqueEdges(e4), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Yi.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t3), this.cancelDuplicateResultEdges();
            var n2 = new ke(this._geomFact);
            n2.add(this._graph), this._resultPolyList = n2.getPolygons();
            var i2 = new ji(this, this._geomFact, this._ptLocator);
            this._resultLineList = i2.build(t3);
            var r2 = new Hi(this, this._geomFact, this._ptLocator);
            this._resultPointList = r2.build(t3), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t3);
          }, e3.prototype.labelIncompleteNode = function(t3, e4) {
            var n2 = this._ptLocator.locate(t3.getCoordinate(), this._arg[e4].getGeometry());
            t3.getLabel().setLocation(e4, n2);
          }, e3.prototype.copyPoints = function(t3) {
            for (var e4 = this._arg[t3].getNodeIterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              this._graph.addNode(n2.getCoordinate()).setLabel(t3, n2.getLabel().getLocation(t3));
            }
          }, e3.prototype.findResultAreaEdges = function(t3) {
            for (var n2 = this._graph.getEdgeEnds().iterator(); n2.hasNext(); ) {
              var i2 = n2.next(), r2 = i2.getLabel();
              r2.isArea() && !i2.isInteriorAreaEdge() && e3.isResultOfOp(r2.getLocation(0, Se.RIGHT), r2.getLocation(1, Se.RIGHT), t3) && i2.setInResult(true);
            }
          }, e3.prototype.computeLabelsFromDepths = function() {
            for (var t3 = this._edgeList.iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getLabel(), i2 = e4.getDepth();
              if (!i2.isNull()) {
                i2.normalize();
                for (var r2 = 0; r2 < 2; r2++)
                  n2.isNull(r2) || !n2.isArea() || i2.isNull(r2) || (0 === i2.getDelta(r2) ? n2.toLine(r2) : (et.isTrue(!i2.isNull(r2, Se.LEFT), "depth of LEFT side has not been initialized"), n2.setLocation(r2, Se.LEFT, i2.getLocation(r2, Se.LEFT)), et.isTrue(!i2.isNull(r2, Se.RIGHT), "depth of RIGHT side has not been initialized"), n2.setLocation(r2, Se.RIGHT, i2.getLocation(r2, Se.RIGHT))));
              }
            }
          }, e3.prototype.computeLabelling = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              t3.next().getEdges().computeLabelling(this._arg);
            }
            this.mergeSymLabels(), this.updateNodeLabelling();
          }, e3.prototype.labelIncompleteNodes = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getLabel();
              e4.isIsolated() && (n2.isNull(0) ? this.labelIncompleteNode(e4, 0) : this.labelIncompleteNode(e4, 1)), e4.getEdges().updateLabelling(n2);
            }
          }, e3.prototype.isCoveredByA = function(t3) {
            return !!this.isCovered(t3, this._resultPolyList);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Cr);
        Lr.overlayOp = function(t2, e3, n2) {
          return new Lr(t2, e3).getResultGeometry(n2);
        }, Lr.intersection = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty())
            return Lr.createEmptyResult(Lr.INTERSECTION, t2, e3, t2.getFactory());
          if (t2.isGeometryCollection()) {
            var n2 = e3;
            return ki.map(t2, { interfaces_: function() {
              return [Sr.MapOp];
            }, map: function(t3) {
              return t3.intersection(n2);
            } });
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.INTERSECTION);
        }, Lr.symDifference = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty()) {
            if (t2.isEmpty() && e3.isEmpty())
              return Lr.createEmptyResult(Lr.SYMDIFFERENCE, t2, e3, t2.getFactory());
            if (t2.isEmpty())
              return e3.copy();
            if (e3.isEmpty())
              return t2.copy();
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, Lr.resultDimension = function(t2, e3, n2) {
          var i2 = e3.getDimension(), r2 = n2.getDimension(), o2 = -1;
          switch (t2) {
            case Lr.INTERSECTION:
              o2 = Math.min(i2, r2);
              break;
            case Lr.UNION:
              o2 = Math.max(i2, r2);
              break;
            case Lr.DIFFERENCE:
              o2 = i2;
              break;
            case Lr.SYMDIFFERENCE:
              o2 = Math.max(i2, r2);
          }
          return o2;
        }, Lr.createEmptyResult = function(t2, e3, n2, i2) {
          var r2 = null;
          switch (Lr.resultDimension(t2, e3, n2)) {
            case -1:
              r2 = i2.createGeometryCollection(new Array(0).fill(null));
              break;
            case 0:
              r2 = i2.createPoint();
              break;
            case 1:
              r2 = i2.createLineString();
              break;
            case 2:
              r2 = i2.createPolygon();
          }
          return r2;
        }, Lr.difference = function(t2, e3) {
          return t2.isEmpty() ? Lr.createEmptyResult(Lr.DIFFERENCE, t2, e3, t2.getFactory()) : e3.isEmpty() ? t2.copy() : (t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.DIFFERENCE));
        }, Lr.isResultOfOp = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = t2.getLocation(0), i2 = t2.getLocation(1);
            return Lr.isResultOfOp(n2, i2, e3);
          }
          if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
            switch (r2 === w.BOUNDARY && (r2 = w.INTERIOR), o2 === w.BOUNDARY && (o2 = w.INTERIOR), s2) {
              case Lr.INTERSECTION:
                return r2 === w.INTERIOR && o2 === w.INTERIOR;
              case Lr.UNION:
                return r2 === w.INTERIOR || o2 === w.INTERIOR;
              case Lr.DIFFERENCE:
                return r2 === w.INTERIOR && o2 !== w.INTERIOR;
              case Lr.SYMDIFFERENCE:
                return r2 === w.INTERIOR && o2 !== w.INTERIOR || r2 !== w.INTERIOR && o2 === w.INTERIOR;
            }
            return false;
          }
        }, Lr.INTERSECTION = 1, Lr.UNION = 2, Lr.DIFFERENCE = 3, Lr.SYMDIFFERENCE = 4;
        var br = function() {
          this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Si(), this._seg = new dn();
          var t2 = arguments[0], e3 = arguments[1];
          this._g = t2, this._boundaryDistanceTolerance = e3, this._linework = this.extractLinework(t2);
        };
        br.prototype.isWithinToleranceOfBoundary = function(t2) {
          for (var e3 = 0; e3 < this._linework.getNumGeometries(); e3++)
            for (var n2 = this._linework.getGeometryN(e3).getCoordinateSequence(), i2 = 0; i2 < n2.size() - 1; i2++) {
              n2.getCoordinate(i2, this._seg.p0), n2.getCoordinate(i2 + 1, this._seg.p1);
              if (this._seg.distance(t2) <= this._boundaryDistanceTolerance)
                return true;
            }
          return false;
        }, br.prototype.getLocation = function(t2) {
          return this.isWithinToleranceOfBoundary(t2) ? w.BOUNDARY : this._ptLocator.locate(t2, this._g);
        }, br.prototype.extractLinework = function(t2) {
          var e3 = new wr();
          t2.apply(e3);
          var n2 = e3.getLinework(), i2 = _e.toLineStringArray(n2);
          return t2.getFactory().createMultiLineString(i2);
        }, br.prototype.interfaces_ = function() {
          return [];
        }, br.prototype.getClass = function() {
          return br;
        };
        var wr = function() {
          this._linework = null, this._linework = new Nt();
        };
        wr.prototype.getLinework = function() {
          return this._linework;
        }, wr.prototype.filter = function(t2) {
          if (t2 instanceof $t) {
            var e3 = t2;
            this._linework.add(e3.getExteriorRing());
            for (var n2 = 0; n2 < e3.getNumInteriorRing(); n2++)
              this._linework.add(e3.getInteriorRingN(n2));
          }
        }, wr.prototype.interfaces_ = function() {
          return [Vt];
        }, wr.prototype.getClass = function() {
          return wr;
        };
        var Or = function() {
          this._g = null, this._doLeft = true, this._doRight = true;
          var t2 = arguments[0];
          this._g = t2;
        };
        Or.prototype.extractPoints = function(t2, e3, n2) {
          for (var i2 = t2.getCoordinates(), r2 = 0; r2 < i2.length - 1; r2++)
            this.computeOffsetPoints(i2[r2], i2[r2 + 1], e3, n2);
        }, Or.prototype.setSidesToGenerate = function(t2, e3) {
          this._doLeft = t2, this._doRight = e3;
        }, Or.prototype.getPoints = function(t2) {
          for (var e3 = new Nt(), n2 = Ci.getLines(this._g).iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this.extractPoints(i2, t2, e3);
          }
          return e3;
        }, Or.prototype.computeOffsetPoints = function(t2, e3, n2, i2) {
          var r2 = e3.x - t2.x, o2 = e3.y - t2.y, s2 = Math.sqrt(r2 * r2 + o2 * o2), a3 = n2 * r2 / s2, u2 = n2 * o2 / s2, l2 = (e3.x + t2.x) / 2, c2 = (e3.y + t2.y) / 2;
          if (this._doLeft) {
            var p2 = new C(l2 - u2, c2 + a3);
            i2.add(p2);
          }
          if (this._doRight) {
            var h2 = new C(l2 + u2, c2 - a3);
            i2.add(h2);
          }
        }, Or.prototype.interfaces_ = function() {
          return [];
        }, Or.prototype.getClass = function() {
          return Or;
        };
        var Tr = function t2() {
          this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = t2.TOLERANCE, this._testCoords = new Nt();
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._boundaryDistanceTolerance = t2.computeBoundaryDistanceTolerance(e3, n2), this._geom = [e3, n2, i2], this._locFinder = [new br(this._geom[0], this._boundaryDistanceTolerance), new br(this._geom[1], this._boundaryDistanceTolerance), new br(this._geom[2], this._boundaryDistanceTolerance)];
        }, Rr = { TOLERANCE: { configurable: true } };
        Tr.prototype.reportResult = function(t2, e3, n2) {
          Y.out.println("Overlay result invalid - A:" + w.toLocationSymbol(e3[0]) + " B:" + w.toLocationSymbol(e3[1]) + " expected:" + (n2 ? "i" : "e") + " actual:" + w.toLocationSymbol(e3[2]));
        }, Tr.prototype.isValid = function(t2) {
          this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]);
          var e3 = this.checkValid(t2);
          return e3;
        }, Tr.prototype.checkValid = function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = 0; e3 < this._testCoords.size(); e3++) {
              var n2 = this._testCoords.get(e3);
              if (!this.checkValid(t2, n2))
                return this._invalidLocation = n2, false;
            }
            return true;
          }
          if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return this._location[0] = this._locFinder[0].getLocation(r2), this._location[1] = this._locFinder[1].getLocation(r2), this._location[2] = this._locFinder[2].getLocation(r2), !!Tr.hasLocation(this._location, w.BOUNDARY) || this.isValidResult(i2, this._location);
          }
        }, Tr.prototype.addTestPts = function(t2) {
          var e3 = new Or(t2);
          this._testCoords.addAll(e3.getPoints(5 * this._boundaryDistanceTolerance));
        }, Tr.prototype.isValidResult = function(t2, e3) {
          var n2 = Lr.isResultOfOp(e3[0], e3[1], t2), i2 = !(n2 ^ e3[2] === w.INTERIOR);
          return i2 || this.reportResult(t2, e3, n2), i2;
        }, Tr.prototype.getInvalidLocation = function() {
          return this._invalidLocation;
        }, Tr.prototype.interfaces_ = function() {
          return [];
        }, Tr.prototype.getClass = function() {
          return Tr;
        }, Tr.hasLocation = function(t2, e3) {
          for (var n2 = 0; n2 < 3; n2++)
            if (t2[n2] === e3)
              return true;
          return false;
        }, Tr.computeBoundaryDistanceTolerance = function(t2, e3) {
          return Math.min(Ji.computeSizeBasedSnapTolerance(t2), Ji.computeSizeBasedSnapTolerance(e3));
        }, Tr.isValid = function(t2, e3, n2, i2) {
          return new Tr(t2, e3, i2).isValid(n2);
        }, Rr.TOLERANCE.get = function() {
          return 1e-6;
        }, Object.defineProperties(Tr, Rr);
        var Pr = function t2(e3) {
          this._geomFactory = null, this._skipEmpty = false, this._inputGeoms = null, this._geomFactory = t2.extractFactory(e3), this._inputGeoms = e3;
        };
        Pr.prototype.extractElements = function(t2, e3) {
          if (null === t2)
            return null;
          for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = t2.getGeometryN(n2);
            this._skipEmpty && i2.isEmpty() || e3.add(i2);
          }
        }, Pr.prototype.combine = function() {
          for (var t2 = new Nt(), e3 = this._inputGeoms.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this.extractElements(n2, t2);
          }
          return 0 === t2.size() ? null !== this._geomFactory ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t2);
        }, Pr.prototype.interfaces_ = function() {
          return [];
        }, Pr.prototype.getClass = function() {
          return Pr;
        }, Pr.combine = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Pr(t2).combine();
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return new Pr(Pr.createList(e3, n2)).combine();
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            return new Pr(Pr.createList(i2, r2, o2)).combine();
          }
        }, Pr.extractFactory = function(t2) {
          return t2.isEmpty() ? null : t2.iterator().next().getFactory();
        }, Pr.createList = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = new Nt();
            return n2.add(t2), n2.add(e3), n2;
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = new Nt();
            return s2.add(i2), s2.add(r2), s2.add(o2), s2;
          }
        };
        var Dr = function() {
          this._inputPolys = null, this._geomFactory = null;
          var t2 = arguments[0];
          this._inputPolys = t2, null === this._inputPolys && (this._inputPolys = new Nt());
        }, Mr = { STRTREE_NODE_CAPACITY: { configurable: true } };
        Dr.prototype.reduceToGeometries = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next(), r2 = null;
            T(i2, xt) ? r2 = this.unionTree(i2) : i2 instanceof ct && (r2 = i2), e3.add(r2);
          }
          return e3;
        }, Dr.prototype.extractByEnvelope = function(t2, e3, n2) {
          for (var i2 = new Nt(), r2 = 0; r2 < e3.getNumGeometries(); r2++) {
            var o2 = e3.getGeometryN(r2);
            o2.getEnvelopeInternal().intersects(t2) ? i2.add(o2) : n2.add(o2);
          }
          return this._geomFactory.buildGeometry(i2);
        }, Dr.prototype.unionOptimized = function(t2, e3) {
          var n2 = t2.getEnvelopeInternal(), i2 = e3.getEnvelopeInternal();
          if (!n2.intersects(i2)) {
            return Pr.combine(t2, e3);
          }
          if (t2.getNumGeometries() <= 1 && e3.getNumGeometries() <= 1)
            return this.unionActual(t2, e3);
          var r2 = n2.intersection(i2);
          return this.unionUsingEnvelopeIntersection(t2, e3, r2);
        }, Dr.prototype.union = function() {
          if (null === this._inputPolys)
            throw new Error("union() method cannot be called twice");
          if (this._inputPolys.isEmpty())
            return null;
          this._geomFactory = this._inputPolys.iterator().next().getFactory();
          for (var t2 = new sn(Dr.STRTREE_NODE_CAPACITY), e3 = this._inputPolys.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            t2.insert(n2.getEnvelopeInternal(), n2);
          }
          this._inputPolys = null;
          var i2 = t2.itemsTree();
          return this.unionTree(i2);
        }, Dr.prototype.binaryUnion = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.binaryUnion(t2, 0, t2.size());
          }
          if (3 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            if (i2 - n2 <= 1) {
              var r2 = Dr.getGeometry(e3, n2);
              return this.unionSafe(r2, null);
            }
            if (i2 - n2 == 2)
              return this.unionSafe(Dr.getGeometry(e3, n2), Dr.getGeometry(e3, n2 + 1));
            var o2 = Math.trunc((i2 + n2) / 2), s2 = this.binaryUnion(e3, n2, o2), a3 = this.binaryUnion(e3, o2, i2);
            return this.unionSafe(s2, a3);
          }
        }, Dr.prototype.repeatedUnion = function(t2) {
          for (var e3 = null, n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            e3 = null === e3 ? i2.copy() : e3.union(i2);
          }
          return e3;
        }, Dr.prototype.unionSafe = function(t2, e3) {
          return null === t2 && null === e3 ? null : null === t2 ? e3.copy() : null === e3 ? t2.copy() : this.unionOptimized(t2, e3);
        }, Dr.prototype.unionActual = function(t2, e3) {
          return Dr.restrictToPolygons(t2.union(e3));
        }, Dr.prototype.unionTree = function(t2) {
          var e3 = this.reduceToGeometries(t2);
          return this.binaryUnion(e3);
        }, Dr.prototype.unionUsingEnvelopeIntersection = function(t2, e3, n2) {
          var i2 = new Nt(), r2 = this.extractByEnvelope(n2, t2, i2), o2 = this.extractByEnvelope(n2, e3, i2), s2 = this.unionActual(r2, o2);
          i2.add(s2);
          return Pr.combine(i2);
        }, Dr.prototype.bufferUnion = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return t2.get(0).getFactory().buildGeometry(t2).buffer(0);
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3.getFactory().createGeometryCollection([e3, n2]).buffer(0);
          }
        }, Dr.prototype.interfaces_ = function() {
          return [];
        }, Dr.prototype.getClass = function() {
          return Dr;
        }, Dr.restrictToPolygons = function(t2) {
          if (T(t2, Zt))
            return t2;
          var e3 = Ni.getPolygons(t2);
          return 1 === e3.size() ? e3.get(0) : t2.getFactory().createMultiPolygon(_e.toPolygonArray(e3));
        }, Dr.getGeometry = function(t2, e3) {
          return e3 >= t2.size() ? null : t2.get(e3);
        }, Dr.union = function(t2) {
          return new Dr(t2).union();
        }, Mr.STRTREE_NODE_CAPACITY.get = function() {
          return 4;
        }, Object.defineProperties(Dr, Mr);
        var Ar = function() {
        };
        Ar.prototype.interfaces_ = function() {
          return [];
        }, Ar.prototype.getClass = function() {
          return Ar;
        }, Ar.union = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty()) {
            if (t2.isEmpty() && e3.isEmpty())
              return Lr.createEmptyResult(Lr.UNION, t2, e3, t2.getFactory());
            if (t2.isEmpty())
              return e3.copy();
            if (e3.isEmpty())
              return t2.copy();
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.UNION);
        }, t.GeoJSONReader = Ne, t.GeoJSONWriter = Ce, t.OverlayOp = Lr, t.UnionOp = Ar, t.BufferOp = di, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // node_modules/grapheme-splitter/index.js
  var require_grapheme_splitter = __commonJS({
    "node_modules/grapheme-splitter/index.js"(exports5, module) {
      function GraphemeSplitter2() {
        var CR = 0, LF = 1, Control2 = 2, Extend = 3, Regional_Indicator = 4, SpacingMark = 5, L = 6, V2 = 7, T = 8, LV = 9, LVT = 10, Other = 11, Prepend = 12, E_Base = 13, E_Modifier = 14, ZWJ = 15, Glue_After_Zwj = 16, E_Base_GAZ = 17;
        var NotBreak = 0, BreakStart = 1, Break = 2, BreakLastRegional = 3, BreakPenultimateRegional = 4;
        function isSurrogate(str, pos) {
          return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
        }
        function codePointAt(str, idx) {
          if (idx === void 0) {
            idx = 0;
          }
          var code = str.charCodeAt(idx);
          if (55296 <= code && code <= 56319 && idx < str.length - 1) {
            var hi = code;
            var low = str.charCodeAt(idx + 1);
            if (56320 <= low && low <= 57343) {
              return (hi - 55296) * 1024 + (low - 56320) + 65536;
            }
            return hi;
          }
          if (56320 <= code && code <= 57343 && idx >= 1) {
            var hi = str.charCodeAt(idx - 1);
            var low = code;
            if (55296 <= hi && hi <= 56319) {
              return (hi - 55296) * 1024 + (low - 56320) + 65536;
            }
            return low;
          }
          return code;
        }
        function shouldBreak(start2, mid, end) {
          var all = [start2].concat(mid).concat([end]);
          var previous = all[all.length - 2];
          var next = end;
          var eModifierIndex = all.lastIndexOf(E_Modifier);
          if (eModifierIndex > 1 && all.slice(1, eModifierIndex).every(function(c) {
            return c == Extend;
          }) && [Extend, E_Base, E_Base_GAZ].indexOf(start2) == -1) {
            return Break;
          }
          var rIIndex = all.lastIndexOf(Regional_Indicator);
          if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
            return c == Regional_Indicator;
          }) && [Prepend, Regional_Indicator].indexOf(previous) == -1) {
            if (all.filter(function(c) {
              return c == Regional_Indicator;
            }).length % 2 == 1) {
              return BreakLastRegional;
            } else {
              return BreakPenultimateRegional;
            }
          }
          if (previous == CR && next == LF) {
            return NotBreak;
          } else if (previous == Control2 || previous == CR || previous == LF) {
            if (next == E_Modifier && mid.every(function(c) {
              return c == Extend;
            })) {
              return Break;
            } else {
              return BreakStart;
            }
          } else if (next == Control2 || next == CR || next == LF) {
            return BreakStart;
          } else if (previous == L && (next == L || next == V2 || next == LV || next == LVT)) {
            return NotBreak;
          } else if ((previous == LV || previous == V2) && (next == V2 || next == T)) {
            return NotBreak;
          } else if ((previous == LVT || previous == T) && next == T) {
            return NotBreak;
          } else if (next == Extend || next == ZWJ) {
            return NotBreak;
          } else if (next == SpacingMark) {
            return NotBreak;
          } else if (previous == Prepend) {
            return NotBreak;
          }
          var previousNonExtendIndex = all.indexOf(Extend) != -1 ? all.lastIndexOf(Extend) - 1 : all.length - 2;
          if ([E_Base, E_Base_GAZ].indexOf(all[previousNonExtendIndex]) != -1 && all.slice(previousNonExtendIndex + 1, -1).every(function(c) {
            return c == Extend;
          }) && next == E_Modifier) {
            return NotBreak;
          }
          if (previous == ZWJ && [Glue_After_Zwj, E_Base_GAZ].indexOf(next) != -1) {
            return NotBreak;
          }
          if (mid.indexOf(Regional_Indicator) != -1) {
            return Break;
          }
          if (previous == Regional_Indicator && next == Regional_Indicator) {
            return NotBreak;
          }
          return BreakStart;
        }
        this.nextBreak = function(string, index) {
          if (index === void 0) {
            index = 0;
          }
          if (index < 0) {
            return 0;
          }
          if (index >= string.length - 1) {
            return string.length;
          }
          var prev = getGraphemeBreakProperty(codePointAt(string, index));
          var mid = [];
          for (var i = index + 1; i < string.length; i++) {
            if (isSurrogate(string, i - 1)) {
              continue;
            }
            var next = getGraphemeBreakProperty(codePointAt(string, i));
            if (shouldBreak(prev, mid, next)) {
              return i;
            }
            mid.push(next);
          }
          return string.length;
        };
        this.splitGraphemes = function(str) {
          var res = [];
          var index = 0;
          var brk;
          while ((brk = this.nextBreak(str, index)) < str.length) {
            res.push(str.slice(index, brk));
            index = brk;
          }
          if (index < str.length) {
            res.push(str.slice(index));
          }
          return res;
        };
        this.iterateGraphemes = function(str) {
          var index = 0;
          var res = {
            next: function() {
              var value;
              var brk;
              if ((brk = this.nextBreak(str, index)) < str.length) {
                value = str.slice(index, brk);
                index = brk;
                return { value, done: false };
              }
              if (index < str.length) {
                value = str.slice(index);
                index = str.length;
                return { value, done: false };
              }
              return { value: void 0, done: true };
            }.bind(this)
          };
          if (typeof Symbol !== "undefined" && Symbol.iterator) {
            res[Symbol.iterator] = function() {
              return res;
            };
          }
          return res;
        };
        this.countGraphemes = function(str) {
          var count = 0;
          var index = 0;
          var brk;
          while ((brk = this.nextBreak(str, index)) < str.length) {
            index = brk;
            count++;
          }
          if (index < str.length) {
            count++;
          }
          return count;
        };
        function getGraphemeBreakProperty(code) {
          if (1536 <= code && code <= 1541 || 1757 == code || 1807 == code || 2274 == code || 3406 == code || 69821 == code || 70082 <= code && code <= 70083 || 72250 == code || 72326 <= code && code <= 72329 || 73030 == code) {
            return Prepend;
          }
          if (13 == code) {
            return CR;
          }
          if (10 == code) {
            return LF;
          }
          if (0 <= code && code <= 9 || 11 <= code && code <= 12 || 14 <= code && code <= 31 || 127 <= code && code <= 159 || 173 == code || 1564 == code || 6158 == code || 8203 == code || 8206 <= code && code <= 8207 || 8232 == code || 8233 == code || 8234 <= code && code <= 8238 || 8288 <= code && code <= 8292 || 8293 == code || 8294 <= code && code <= 8303 || 55296 <= code && code <= 57343 || 65279 == code || 65520 <= code && code <= 65528 || 65529 <= code && code <= 65531 || 113824 <= code && code <= 113827 || 119155 <= code && code <= 119162 || 917504 == code || 917505 == code || 917506 <= code && code <= 917535 || 917632 <= code && code <= 917759 || 918e3 <= code && code <= 921599) {
            return Control2;
          }
          if (768 <= code && code <= 879 || 1155 <= code && code <= 1159 || 1160 <= code && code <= 1161 || 1425 <= code && code <= 1469 || 1471 == code || 1473 <= code && code <= 1474 || 1476 <= code && code <= 1477 || 1479 == code || 1552 <= code && code <= 1562 || 1611 <= code && code <= 1631 || 1648 == code || 1750 <= code && code <= 1756 || 1759 <= code && code <= 1764 || 1767 <= code && code <= 1768 || 1770 <= code && code <= 1773 || 1809 == code || 1840 <= code && code <= 1866 || 1958 <= code && code <= 1968 || 2027 <= code && code <= 2035 || 2070 <= code && code <= 2073 || 2075 <= code && code <= 2083 || 2085 <= code && code <= 2087 || 2089 <= code && code <= 2093 || 2137 <= code && code <= 2139 || 2260 <= code && code <= 2273 || 2275 <= code && code <= 2306 || 2362 == code || 2364 == code || 2369 <= code && code <= 2376 || 2381 == code || 2385 <= code && code <= 2391 || 2402 <= code && code <= 2403 || 2433 == code || 2492 == code || 2494 == code || 2497 <= code && code <= 2500 || 2509 == code || 2519 == code || 2530 <= code && code <= 2531 || 2561 <= code && code <= 2562 || 2620 == code || 2625 <= code && code <= 2626 || 2631 <= code && code <= 2632 || 2635 <= code && code <= 2637 || 2641 == code || 2672 <= code && code <= 2673 || 2677 == code || 2689 <= code && code <= 2690 || 2748 == code || 2753 <= code && code <= 2757 || 2759 <= code && code <= 2760 || 2765 == code || 2786 <= code && code <= 2787 || 2810 <= code && code <= 2815 || 2817 == code || 2876 == code || 2878 == code || 2879 == code || 2881 <= code && code <= 2884 || 2893 == code || 2902 == code || 2903 == code || 2914 <= code && code <= 2915 || 2946 == code || 3006 == code || 3008 == code || 3021 == code || 3031 == code || 3072 == code || 3134 <= code && code <= 3136 || 3142 <= code && code <= 3144 || 3146 <= code && code <= 3149 || 3157 <= code && code <= 3158 || 3170 <= code && code <= 3171 || 3201 == code || 3260 == code || 3263 == code || 3266 == code || 3270 == code || 3276 <= code && code <= 3277 || 3285 <= code && code <= 3286 || 3298 <= code && code <= 3299 || 3328 <= code && code <= 3329 || 3387 <= code && code <= 3388 || 3390 == code || 3393 <= code && code <= 3396 || 3405 == code || 3415 == code || 3426 <= code && code <= 3427 || 3530 == code || 3535 == code || 3538 <= code && code <= 3540 || 3542 == code || 3551 == code || 3633 == code || 3636 <= code && code <= 3642 || 3655 <= code && code <= 3662 || 3761 == code || 3764 <= code && code <= 3769 || 3771 <= code && code <= 3772 || 3784 <= code && code <= 3789 || 3864 <= code && code <= 3865 || 3893 == code || 3895 == code || 3897 == code || 3953 <= code && code <= 3966 || 3968 <= code && code <= 3972 || 3974 <= code && code <= 3975 || 3981 <= code && code <= 3991 || 3993 <= code && code <= 4028 || 4038 == code || 4141 <= code && code <= 4144 || 4146 <= code && code <= 4151 || 4153 <= code && code <= 4154 || 4157 <= code && code <= 4158 || 4184 <= code && code <= 4185 || 4190 <= code && code <= 4192 || 4209 <= code && code <= 4212 || 4226 == code || 4229 <= code && code <= 4230 || 4237 == code || 4253 == code || 4957 <= code && code <= 4959 || 5906 <= code && code <= 5908 || 5938 <= code && code <= 5940 || 5970 <= code && code <= 5971 || 6002 <= code && code <= 6003 || 6068 <= code && code <= 6069 || 6071 <= code && code <= 6077 || 6086 == code || 6089 <= code && code <= 6099 || 6109 == code || 6155 <= code && code <= 6157 || 6277 <= code && code <= 6278 || 6313 == code || 6432 <= code && code <= 6434 || 6439 <= code && code <= 6440 || 6450 == code || 6457 <= code && code <= 6459 || 6679 <= code && code <= 6680 || 6683 == code || 6742 == code || 6744 <= code && code <= 6750 || 6752 == code || 6754 == code || 6757 <= code && code <= 6764 || 6771 <= code && code <= 6780 || 6783 == code || 6832 <= code && code <= 6845 || 6846 == code || 6912 <= code && code <= 6915 || 6964 == code || 6966 <= code && code <= 6970 || 6972 == code || 6978 == code || 7019 <= code && code <= 7027 || 7040 <= code && code <= 7041 || 7074 <= code && code <= 7077 || 7080 <= code && code <= 7081 || 7083 <= code && code <= 7085 || 7142 == code || 7144 <= code && code <= 7145 || 7149 == code || 7151 <= code && code <= 7153 || 7212 <= code && code <= 7219 || 7222 <= code && code <= 7223 || 7376 <= code && code <= 7378 || 7380 <= code && code <= 7392 || 7394 <= code && code <= 7400 || 7405 == code || 7412 == code || 7416 <= code && code <= 7417 || 7616 <= code && code <= 7673 || 7675 <= code && code <= 7679 || 8204 == code || 8400 <= code && code <= 8412 || 8413 <= code && code <= 8416 || 8417 == code || 8418 <= code && code <= 8420 || 8421 <= code && code <= 8432 || 11503 <= code && code <= 11505 || 11647 == code || 11744 <= code && code <= 11775 || 12330 <= code && code <= 12333 || 12334 <= code && code <= 12335 || 12441 <= code && code <= 12442 || 42607 == code || 42608 <= code && code <= 42610 || 42612 <= code && code <= 42621 || 42654 <= code && code <= 42655 || 42736 <= code && code <= 42737 || 43010 == code || 43014 == code || 43019 == code || 43045 <= code && code <= 43046 || 43204 <= code && code <= 43205 || 43232 <= code && code <= 43249 || 43302 <= code && code <= 43309 || 43335 <= code && code <= 43345 || 43392 <= code && code <= 43394 || 43443 == code || 43446 <= code && code <= 43449 || 43452 == code || 43493 == code || 43561 <= code && code <= 43566 || 43569 <= code && code <= 43570 || 43573 <= code && code <= 43574 || 43587 == code || 43596 == code || 43644 == code || 43696 == code || 43698 <= code && code <= 43700 || 43703 <= code && code <= 43704 || 43710 <= code && code <= 43711 || 43713 == code || 43756 <= code && code <= 43757 || 43766 == code || 44005 == code || 44008 == code || 44013 == code || 64286 == code || 65024 <= code && code <= 65039 || 65056 <= code && code <= 65071 || 65438 <= code && code <= 65439 || 66045 == code || 66272 == code || 66422 <= code && code <= 66426 || 68097 <= code && code <= 68099 || 68101 <= code && code <= 68102 || 68108 <= code && code <= 68111 || 68152 <= code && code <= 68154 || 68159 == code || 68325 <= code && code <= 68326 || 69633 == code || 69688 <= code && code <= 69702 || 69759 <= code && code <= 69761 || 69811 <= code && code <= 69814 || 69817 <= code && code <= 69818 || 69888 <= code && code <= 69890 || 69927 <= code && code <= 69931 || 69933 <= code && code <= 69940 || 70003 == code || 70016 <= code && code <= 70017 || 70070 <= code && code <= 70078 || 70090 <= code && code <= 70092 || 70191 <= code && code <= 70193 || 70196 == code || 70198 <= code && code <= 70199 || 70206 == code || 70367 == code || 70371 <= code && code <= 70378 || 70400 <= code && code <= 70401 || 70460 == code || 70462 == code || 70464 == code || 70487 == code || 70502 <= code && code <= 70508 || 70512 <= code && code <= 70516 || 70712 <= code && code <= 70719 || 70722 <= code && code <= 70724 || 70726 == code || 70832 == code || 70835 <= code && code <= 70840 || 70842 == code || 70845 == code || 70847 <= code && code <= 70848 || 70850 <= code && code <= 70851 || 71087 == code || 71090 <= code && code <= 71093 || 71100 <= code && code <= 71101 || 71103 <= code && code <= 71104 || 71132 <= code && code <= 71133 || 71219 <= code && code <= 71226 || 71229 == code || 71231 <= code && code <= 71232 || 71339 == code || 71341 == code || 71344 <= code && code <= 71349 || 71351 == code || 71453 <= code && code <= 71455 || 71458 <= code && code <= 71461 || 71463 <= code && code <= 71467 || 72193 <= code && code <= 72198 || 72201 <= code && code <= 72202 || 72243 <= code && code <= 72248 || 72251 <= code && code <= 72254 || 72263 == code || 72273 <= code && code <= 72278 || 72281 <= code && code <= 72283 || 72330 <= code && code <= 72342 || 72344 <= code && code <= 72345 || 72752 <= code && code <= 72758 || 72760 <= code && code <= 72765 || 72767 == code || 72850 <= code && code <= 72871 || 72874 <= code && code <= 72880 || 72882 <= code && code <= 72883 || 72885 <= code && code <= 72886 || 73009 <= code && code <= 73014 || 73018 == code || 73020 <= code && code <= 73021 || 73023 <= code && code <= 73029 || 73031 == code || 92912 <= code && code <= 92916 || 92976 <= code && code <= 92982 || 94095 <= code && code <= 94098 || 113821 <= code && code <= 113822 || 119141 == code || 119143 <= code && code <= 119145 || 119150 <= code && code <= 119154 || 119163 <= code && code <= 119170 || 119173 <= code && code <= 119179 || 119210 <= code && code <= 119213 || 119362 <= code && code <= 119364 || 121344 <= code && code <= 121398 || 121403 <= code && code <= 121452 || 121461 == code || 121476 == code || 121499 <= code && code <= 121503 || 121505 <= code && code <= 121519 || 122880 <= code && code <= 122886 || 122888 <= code && code <= 122904 || 122907 <= code && code <= 122913 || 122915 <= code && code <= 122916 || 122918 <= code && code <= 122922 || 125136 <= code && code <= 125142 || 125252 <= code && code <= 125258 || 917536 <= code && code <= 917631 || 917760 <= code && code <= 917999) {
            return Extend;
          }
          if (127462 <= code && code <= 127487) {
            return Regional_Indicator;
          }
          if (2307 == code || 2363 == code || 2366 <= code && code <= 2368 || 2377 <= code && code <= 2380 || 2382 <= code && code <= 2383 || 2434 <= code && code <= 2435 || 2495 <= code && code <= 2496 || 2503 <= code && code <= 2504 || 2507 <= code && code <= 2508 || 2563 == code || 2622 <= code && code <= 2624 || 2691 == code || 2750 <= code && code <= 2752 || 2761 == code || 2763 <= code && code <= 2764 || 2818 <= code && code <= 2819 || 2880 == code || 2887 <= code && code <= 2888 || 2891 <= code && code <= 2892 || 3007 == code || 3009 <= code && code <= 3010 || 3014 <= code && code <= 3016 || 3018 <= code && code <= 3020 || 3073 <= code && code <= 3075 || 3137 <= code && code <= 3140 || 3202 <= code && code <= 3203 || 3262 == code || 3264 <= code && code <= 3265 || 3267 <= code && code <= 3268 || 3271 <= code && code <= 3272 || 3274 <= code && code <= 3275 || 3330 <= code && code <= 3331 || 3391 <= code && code <= 3392 || 3398 <= code && code <= 3400 || 3402 <= code && code <= 3404 || 3458 <= code && code <= 3459 || 3536 <= code && code <= 3537 || 3544 <= code && code <= 3550 || 3570 <= code && code <= 3571 || 3635 == code || 3763 == code || 3902 <= code && code <= 3903 || 3967 == code || 4145 == code || 4155 <= code && code <= 4156 || 4182 <= code && code <= 4183 || 4228 == code || 6070 == code || 6078 <= code && code <= 6085 || 6087 <= code && code <= 6088 || 6435 <= code && code <= 6438 || 6441 <= code && code <= 6443 || 6448 <= code && code <= 6449 || 6451 <= code && code <= 6456 || 6681 <= code && code <= 6682 || 6741 == code || 6743 == code || 6765 <= code && code <= 6770 || 6916 == code || 6965 == code || 6971 == code || 6973 <= code && code <= 6977 || 6979 <= code && code <= 6980 || 7042 == code || 7073 == code || 7078 <= code && code <= 7079 || 7082 == code || 7143 == code || 7146 <= code && code <= 7148 || 7150 == code || 7154 <= code && code <= 7155 || 7204 <= code && code <= 7211 || 7220 <= code && code <= 7221 || 7393 == code || 7410 <= code && code <= 7411 || 7415 == code || 43043 <= code && code <= 43044 || 43047 == code || 43136 <= code && code <= 43137 || 43188 <= code && code <= 43203 || 43346 <= code && code <= 43347 || 43395 == code || 43444 <= code && code <= 43445 || 43450 <= code && code <= 43451 || 43453 <= code && code <= 43456 || 43567 <= code && code <= 43568 || 43571 <= code && code <= 43572 || 43597 == code || 43755 == code || 43758 <= code && code <= 43759 || 43765 == code || 44003 <= code && code <= 44004 || 44006 <= code && code <= 44007 || 44009 <= code && code <= 44010 || 44012 == code || 69632 == code || 69634 == code || 69762 == code || 69808 <= code && code <= 69810 || 69815 <= code && code <= 69816 || 69932 == code || 70018 == code || 70067 <= code && code <= 70069 || 70079 <= code && code <= 70080 || 70188 <= code && code <= 70190 || 70194 <= code && code <= 70195 || 70197 == code || 70368 <= code && code <= 70370 || 70402 <= code && code <= 70403 || 70463 == code || 70465 <= code && code <= 70468 || 70471 <= code && code <= 70472 || 70475 <= code && code <= 70477 || 70498 <= code && code <= 70499 || 70709 <= code && code <= 70711 || 70720 <= code && code <= 70721 || 70725 == code || 70833 <= code && code <= 70834 || 70841 == code || 70843 <= code && code <= 70844 || 70846 == code || 70849 == code || 71088 <= code && code <= 71089 || 71096 <= code && code <= 71099 || 71102 == code || 71216 <= code && code <= 71218 || 71227 <= code && code <= 71228 || 71230 == code || 71340 == code || 71342 <= code && code <= 71343 || 71350 == code || 71456 <= code && code <= 71457 || 71462 == code || 72199 <= code && code <= 72200 || 72249 == code || 72279 <= code && code <= 72280 || 72343 == code || 72751 == code || 72766 == code || 72873 == code || 72881 == code || 72884 == code || 94033 <= code && code <= 94078 || 119142 == code || 119149 == code) {
            return SpacingMark;
          }
          if (4352 <= code && code <= 4447 || 43360 <= code && code <= 43388) {
            return L;
          }
          if (4448 <= code && code <= 4519 || 55216 <= code && code <= 55238) {
            return V2;
          }
          if (4520 <= code && code <= 4607 || 55243 <= code && code <= 55291) {
            return T;
          }
          if (44032 == code || 44060 == code || 44088 == code || 44116 == code || 44144 == code || 44172 == code || 44200 == code || 44228 == code || 44256 == code || 44284 == code || 44312 == code || 44340 == code || 44368 == code || 44396 == code || 44424 == code || 44452 == code || 44480 == code || 44508 == code || 44536 == code || 44564 == code || 44592 == code || 44620 == code || 44648 == code || 44676 == code || 44704 == code || 44732 == code || 44760 == code || 44788 == code || 44816 == code || 44844 == code || 44872 == code || 44900 == code || 44928 == code || 44956 == code || 44984 == code || 45012 == code || 45040 == code || 45068 == code || 45096 == code || 45124 == code || 45152 == code || 45180 == code || 45208 == code || 45236 == code || 45264 == code || 45292 == code || 45320 == code || 45348 == code || 45376 == code || 45404 == code || 45432 == code || 45460 == code || 45488 == code || 45516 == code || 45544 == code || 45572 == code || 45600 == code || 45628 == code || 45656 == code || 45684 == code || 45712 == code || 45740 == code || 45768 == code || 45796 == code || 45824 == code || 45852 == code || 45880 == code || 45908 == code || 45936 == code || 45964 == code || 45992 == code || 46020 == code || 46048 == code || 46076 == code || 46104 == code || 46132 == code || 46160 == code || 46188 == code || 46216 == code || 46244 == code || 46272 == code || 46300 == code || 46328 == code || 46356 == code || 46384 == code || 46412 == code || 46440 == code || 46468 == code || 46496 == code || 46524 == code || 46552 == code || 46580 == code || 46608 == code || 46636 == code || 46664 == code || 46692 == code || 46720 == code || 46748 == code || 46776 == code || 46804 == code || 46832 == code || 46860 == code || 46888 == code || 46916 == code || 46944 == code || 46972 == code || 47e3 == code || 47028 == code || 47056 == code || 47084 == code || 47112 == code || 47140 == code || 47168 == code || 47196 == code || 47224 == code || 47252 == code || 47280 == code || 47308 == code || 47336 == code || 47364 == code || 47392 == code || 47420 == code || 47448 == code || 47476 == code || 47504 == code || 47532 == code || 47560 == code || 47588 == code || 47616 == code || 47644 == code || 47672 == code || 47700 == code || 47728 == code || 47756 == code || 47784 == code || 47812 == code || 47840 == code || 47868 == code || 47896 == code || 47924 == code || 47952 == code || 47980 == code || 48008 == code || 48036 == code || 48064 == code || 48092 == code || 48120 == code || 48148 == code || 48176 == code || 48204 == code || 48232 == code || 48260 == code || 48288 == code || 48316 == code || 48344 == code || 48372 == code || 48400 == code || 48428 == code || 48456 == code || 48484 == code || 48512 == code || 48540 == code || 48568 == code || 48596 == code || 48624 == code || 48652 == code || 48680 == code || 48708 == code || 48736 == code || 48764 == code || 48792 == code || 48820 == code || 48848 == code || 48876 == code || 48904 == code || 48932 == code || 48960 == code || 48988 == code || 49016 == code || 49044 == code || 49072 == code || 49100 == code || 49128 == code || 49156 == code || 49184 == code || 49212 == code || 49240 == code || 49268 == code || 49296 == code || 49324 == code || 49352 == code || 49380 == code || 49408 == code || 49436 == code || 49464 == code || 49492 == code || 49520 == code || 49548 == code || 49576 == code || 49604 == code || 49632 == code || 49660 == code || 49688 == code || 49716 == code || 49744 == code || 49772 == code || 49800 == code || 49828 == code || 49856 == code || 49884 == code || 49912 == code || 49940 == code || 49968 == code || 49996 == code || 50024 == code || 50052 == code || 50080 == code || 50108 == code || 50136 == code || 50164 == code || 50192 == code || 50220 == code || 50248 == code || 50276 == code || 50304 == code || 50332 == code || 50360 == code || 50388 == code || 50416 == code || 50444 == code || 50472 == code || 50500 == code || 50528 == code || 50556 == code || 50584 == code || 50612 == code || 50640 == code || 50668 == code || 50696 == code || 50724 == code || 50752 == code || 50780 == code || 50808 == code || 50836 == code || 50864 == code || 50892 == code || 50920 == code || 50948 == code || 50976 == code || 51004 == code || 51032 == code || 51060 == code || 51088 == code || 51116 == code || 51144 == code || 51172 == code || 51200 == code || 51228 == code || 51256 == code || 51284 == code || 51312 == code || 51340 == code || 51368 == code || 51396 == code || 51424 == code || 51452 == code || 51480 == code || 51508 == code || 51536 == code || 51564 == code || 51592 == code || 51620 == code || 51648 == code || 51676 == code || 51704 == code || 51732 == code || 51760 == code || 51788 == code || 51816 == code || 51844 == code || 51872 == code || 51900 == code || 51928 == code || 51956 == code || 51984 == code || 52012 == code || 52040 == code || 52068 == code || 52096 == code || 52124 == code || 52152 == code || 52180 == code || 52208 == code || 52236 == code || 52264 == code || 52292 == code || 52320 == code || 52348 == code || 52376 == code || 52404 == code || 52432 == code || 52460 == code || 52488 == code || 52516 == code || 52544 == code || 52572 == code || 52600 == code || 52628 == code || 52656 == code || 52684 == code || 52712 == code || 52740 == code || 52768 == code || 52796 == code || 52824 == code || 52852 == code || 52880 == code || 52908 == code || 52936 == code || 52964 == code || 52992 == code || 53020 == code || 53048 == code || 53076 == code || 53104 == code || 53132 == code || 53160 == code || 53188 == code || 53216 == code || 53244 == code || 53272 == code || 53300 == code || 53328 == code || 53356 == code || 53384 == code || 53412 == code || 53440 == code || 53468 == code || 53496 == code || 53524 == code || 53552 == code || 53580 == code || 53608 == code || 53636 == code || 53664 == code || 53692 == code || 53720 == code || 53748 == code || 53776 == code || 53804 == code || 53832 == code || 53860 == code || 53888 == code || 53916 == code || 53944 == code || 53972 == code || 54e3 == code || 54028 == code || 54056 == code || 54084 == code || 54112 == code || 54140 == code || 54168 == code || 54196 == code || 54224 == code || 54252 == code || 54280 == code || 54308 == code || 54336 == code || 54364 == code || 54392 == code || 54420 == code || 54448 == code || 54476 == code || 54504 == code || 54532 == code || 54560 == code || 54588 == code || 54616 == code || 54644 == code || 54672 == code || 54700 == code || 54728 == code || 54756 == code || 54784 == code || 54812 == code || 54840 == code || 54868 == code || 54896 == code || 54924 == code || 54952 == code || 54980 == code || 55008 == code || 55036 == code || 55064 == code || 55092 == code || 55120 == code || 55148 == code || 55176 == code) {
            return LV;
          }
          if (44033 <= code && code <= 44059 || 44061 <= code && code <= 44087 || 44089 <= code && code <= 44115 || 44117 <= code && code <= 44143 || 44145 <= code && code <= 44171 || 44173 <= code && code <= 44199 || 44201 <= code && code <= 44227 || 44229 <= code && code <= 44255 || 44257 <= code && code <= 44283 || 44285 <= code && code <= 44311 || 44313 <= code && code <= 44339 || 44341 <= code && code <= 44367 || 44369 <= code && code <= 44395 || 44397 <= code && code <= 44423 || 44425 <= code && code <= 44451 || 44453 <= code && code <= 44479 || 44481 <= code && code <= 44507 || 44509 <= code && code <= 44535 || 44537 <= code && code <= 44563 || 44565 <= code && code <= 44591 || 44593 <= code && code <= 44619 || 44621 <= code && code <= 44647 || 44649 <= code && code <= 44675 || 44677 <= code && code <= 44703 || 44705 <= code && code <= 44731 || 44733 <= code && code <= 44759 || 44761 <= code && code <= 44787 || 44789 <= code && code <= 44815 || 44817 <= code && code <= 44843 || 44845 <= code && code <= 44871 || 44873 <= code && code <= 44899 || 44901 <= code && code <= 44927 || 44929 <= code && code <= 44955 || 44957 <= code && code <= 44983 || 44985 <= code && code <= 45011 || 45013 <= code && code <= 45039 || 45041 <= code && code <= 45067 || 45069 <= code && code <= 45095 || 45097 <= code && code <= 45123 || 45125 <= code && code <= 45151 || 45153 <= code && code <= 45179 || 45181 <= code && code <= 45207 || 45209 <= code && code <= 45235 || 45237 <= code && code <= 45263 || 45265 <= code && code <= 45291 || 45293 <= code && code <= 45319 || 45321 <= code && code <= 45347 || 45349 <= code && code <= 45375 || 45377 <= code && code <= 45403 || 45405 <= code && code <= 45431 || 45433 <= code && code <= 45459 || 45461 <= code && code <= 45487 || 45489 <= code && code <= 45515 || 45517 <= code && code <= 45543 || 45545 <= code && code <= 45571 || 45573 <= code && code <= 45599 || 45601 <= code && code <= 45627 || 45629 <= code && code <= 45655 || 45657 <= code && code <= 45683 || 45685 <= code && code <= 45711 || 45713 <= code && code <= 45739 || 45741 <= code && code <= 45767 || 45769 <= code && code <= 45795 || 45797 <= code && code <= 45823 || 45825 <= code && code <= 45851 || 45853 <= code && code <= 45879 || 45881 <= code && code <= 45907 || 45909 <= code && code <= 45935 || 45937 <= code && code <= 45963 || 45965 <= code && code <= 45991 || 45993 <= code && code <= 46019 || 46021 <= code && code <= 46047 || 46049 <= code && code <= 46075 || 46077 <= code && code <= 46103 || 46105 <= code && code <= 46131 || 46133 <= code && code <= 46159 || 46161 <= code && code <= 46187 || 46189 <= code && code <= 46215 || 46217 <= code && code <= 46243 || 46245 <= code && code <= 46271 || 46273 <= code && code <= 46299 || 46301 <= code && code <= 46327 || 46329 <= code && code <= 46355 || 46357 <= code && code <= 46383 || 46385 <= code && code <= 46411 || 46413 <= code && code <= 46439 || 46441 <= code && code <= 46467 || 46469 <= code && code <= 46495 || 46497 <= code && code <= 46523 || 46525 <= code && code <= 46551 || 46553 <= code && code <= 46579 || 46581 <= code && code <= 46607 || 46609 <= code && code <= 46635 || 46637 <= code && code <= 46663 || 46665 <= code && code <= 46691 || 46693 <= code && code <= 46719 || 46721 <= code && code <= 46747 || 46749 <= code && code <= 46775 || 46777 <= code && code <= 46803 || 46805 <= code && code <= 46831 || 46833 <= code && code <= 46859 || 46861 <= code && code <= 46887 || 46889 <= code && code <= 46915 || 46917 <= code && code <= 46943 || 46945 <= code && code <= 46971 || 46973 <= code && code <= 46999 || 47001 <= code && code <= 47027 || 47029 <= code && code <= 47055 || 47057 <= code && code <= 47083 || 47085 <= code && code <= 47111 || 47113 <= code && code <= 47139 || 47141 <= code && code <= 47167 || 47169 <= code && code <= 47195 || 47197 <= code && code <= 47223 || 47225 <= code && code <= 47251 || 47253 <= code && code <= 47279 || 47281 <= code && code <= 47307 || 47309 <= code && code <= 47335 || 47337 <= code && code <= 47363 || 47365 <= code && code <= 47391 || 47393 <= code && code <= 47419 || 47421 <= code && code <= 47447 || 47449 <= code && code <= 47475 || 47477 <= code && code <= 47503 || 47505 <= code && code <= 47531 || 47533 <= code && code <= 47559 || 47561 <= code && code <= 47587 || 47589 <= code && code <= 47615 || 47617 <= code && code <= 47643 || 47645 <= code && code <= 47671 || 47673 <= code && code <= 47699 || 47701 <= code && code <= 47727 || 47729 <= code && code <= 47755 || 47757 <= code && code <= 47783 || 47785 <= code && code <= 47811 || 47813 <= code && code <= 47839 || 47841 <= code && code <= 47867 || 47869 <= code && code <= 47895 || 47897 <= code && code <= 47923 || 47925 <= code && code <= 47951 || 47953 <= code && code <= 47979 || 47981 <= code && code <= 48007 || 48009 <= code && code <= 48035 || 48037 <= code && code <= 48063 || 48065 <= code && code <= 48091 || 48093 <= code && code <= 48119 || 48121 <= code && code <= 48147 || 48149 <= code && code <= 48175 || 48177 <= code && code <= 48203 || 48205 <= code && code <= 48231 || 48233 <= code && code <= 48259 || 48261 <= code && code <= 48287 || 48289 <= code && code <= 48315 || 48317 <= code && code <= 48343 || 48345 <= code && code <= 48371 || 48373 <= code && code <= 48399 || 48401 <= code && code <= 48427 || 48429 <= code && code <= 48455 || 48457 <= code && code <= 48483 || 48485 <= code && code <= 48511 || 48513 <= code && code <= 48539 || 48541 <= code && code <= 48567 || 48569 <= code && code <= 48595 || 48597 <= code && code <= 48623 || 48625 <= code && code <= 48651 || 48653 <= code && code <= 48679 || 48681 <= code && code <= 48707 || 48709 <= code && code <= 48735 || 48737 <= code && code <= 48763 || 48765 <= code && code <= 48791 || 48793 <= code && code <= 48819 || 48821 <= code && code <= 48847 || 48849 <= code && code <= 48875 || 48877 <= code && code <= 48903 || 48905 <= code && code <= 48931 || 48933 <= code && code <= 48959 || 48961 <= code && code <= 48987 || 48989 <= code && code <= 49015 || 49017 <= code && code <= 49043 || 49045 <= code && code <= 49071 || 49073 <= code && code <= 49099 || 49101 <= code && code <= 49127 || 49129 <= code && code <= 49155 || 49157 <= code && code <= 49183 || 49185 <= code && code <= 49211 || 49213 <= code && code <= 49239 || 49241 <= code && code <= 49267 || 49269 <= code && code <= 49295 || 49297 <= code && code <= 49323 || 49325 <= code && code <= 49351 || 49353 <= code && code <= 49379 || 49381 <= code && code <= 49407 || 49409 <= code && code <= 49435 || 49437 <= code && code <= 49463 || 49465 <= code && code <= 49491 || 49493 <= code && code <= 49519 || 49521 <= code && code <= 49547 || 49549 <= code && code <= 49575 || 49577 <= code && code <= 49603 || 49605 <= code && code <= 49631 || 49633 <= code && code <= 49659 || 49661 <= code && code <= 49687 || 49689 <= code && code <= 49715 || 49717 <= code && code <= 49743 || 49745 <= code && code <= 49771 || 49773 <= code && code <= 49799 || 49801 <= code && code <= 49827 || 49829 <= code && code <= 49855 || 49857 <= code && code <= 49883 || 49885 <= code && code <= 49911 || 49913 <= code && code <= 49939 || 49941 <= code && code <= 49967 || 49969 <= code && code <= 49995 || 49997 <= code && code <= 50023 || 50025 <= code && code <= 50051 || 50053 <= code && code <= 50079 || 50081 <= code && code <= 50107 || 50109 <= code && code <= 50135 || 50137 <= code && code <= 50163 || 50165 <= code && code <= 50191 || 50193 <= code && code <= 50219 || 50221 <= code && code <= 50247 || 50249 <= code && code <= 50275 || 50277 <= code && code <= 50303 || 50305 <= code && code <= 50331 || 50333 <= code && code <= 50359 || 50361 <= code && code <= 50387 || 50389 <= code && code <= 50415 || 50417 <= code && code <= 50443 || 50445 <= code && code <= 50471 || 50473 <= code && code <= 50499 || 50501 <= code && code <= 50527 || 50529 <= code && code <= 50555 || 50557 <= code && code <= 50583 || 50585 <= code && code <= 50611 || 50613 <= code && code <= 50639 || 50641 <= code && code <= 50667 || 50669 <= code && code <= 50695 || 50697 <= code && code <= 50723 || 50725 <= code && code <= 50751 || 50753 <= code && code <= 50779 || 50781 <= code && code <= 50807 || 50809 <= code && code <= 50835 || 50837 <= code && code <= 50863 || 50865 <= code && code <= 50891 || 50893 <= code && code <= 50919 || 50921 <= code && code <= 50947 || 50949 <= code && code <= 50975 || 50977 <= code && code <= 51003 || 51005 <= code && code <= 51031 || 51033 <= code && code <= 51059 || 51061 <= code && code <= 51087 || 51089 <= code && code <= 51115 || 51117 <= code && code <= 51143 || 51145 <= code && code <= 51171 || 51173 <= code && code <= 51199 || 51201 <= code && code <= 51227 || 51229 <= code && code <= 51255 || 51257 <= code && code <= 51283 || 51285 <= code && code <= 51311 || 51313 <= code && code <= 51339 || 51341 <= code && code <= 51367 || 51369 <= code && code <= 51395 || 51397 <= code && code <= 51423 || 51425 <= code && code <= 51451 || 51453 <= code && code <= 51479 || 51481 <= code && code <= 51507 || 51509 <= code && code <= 51535 || 51537 <= code && code <= 51563 || 51565 <= code && code <= 51591 || 51593 <= code && code <= 51619 || 51621 <= code && code <= 51647 || 51649 <= code && code <= 51675 || 51677 <= code && code <= 51703 || 51705 <= code && code <= 51731 || 51733 <= code && code <= 51759 || 51761 <= code && code <= 51787 || 51789 <= code && code <= 51815 || 51817 <= code && code <= 51843 || 51845 <= code && code <= 51871 || 51873 <= code && code <= 51899 || 51901 <= code && code <= 51927 || 51929 <= code && code <= 51955 || 51957 <= code && code <= 51983 || 51985 <= code && code <= 52011 || 52013 <= code && code <= 52039 || 52041 <= code && code <= 52067 || 52069 <= code && code <= 52095 || 52097 <= code && code <= 52123 || 52125 <= code && code <= 52151 || 52153 <= code && code <= 52179 || 52181 <= code && code <= 52207 || 52209 <= code && code <= 52235 || 52237 <= code && code <= 52263 || 52265 <= code && code <= 52291 || 52293 <= code && code <= 52319 || 52321 <= code && code <= 52347 || 52349 <= code && code <= 52375 || 52377 <= code && code <= 52403 || 52405 <= code && code <= 52431 || 52433 <= code && code <= 52459 || 52461 <= code && code <= 52487 || 52489 <= code && code <= 52515 || 52517 <= code && code <= 52543 || 52545 <= code && code <= 52571 || 52573 <= code && code <= 52599 || 52601 <= code && code <= 52627 || 52629 <= code && code <= 52655 || 52657 <= code && code <= 52683 || 52685 <= code && code <= 52711 || 52713 <= code && code <= 52739 || 52741 <= code && code <= 52767 || 52769 <= code && code <= 52795 || 52797 <= code && code <= 52823 || 52825 <= code && code <= 52851 || 52853 <= code && code <= 52879 || 52881 <= code && code <= 52907 || 52909 <= code && code <= 52935 || 52937 <= code && code <= 52963 || 52965 <= code && code <= 52991 || 52993 <= code && code <= 53019 || 53021 <= code && code <= 53047 || 53049 <= code && code <= 53075 || 53077 <= code && code <= 53103 || 53105 <= code && code <= 53131 || 53133 <= code && code <= 53159 || 53161 <= code && code <= 53187 || 53189 <= code && code <= 53215 || 53217 <= code && code <= 53243 || 53245 <= code && code <= 53271 || 53273 <= code && code <= 53299 || 53301 <= code && code <= 53327 || 53329 <= code && code <= 53355 || 53357 <= code && code <= 53383 || 53385 <= code && code <= 53411 || 53413 <= code && code <= 53439 || 53441 <= code && code <= 53467 || 53469 <= code && code <= 53495 || 53497 <= code && code <= 53523 || 53525 <= code && code <= 53551 || 53553 <= code && code <= 53579 || 53581 <= code && code <= 53607 || 53609 <= code && code <= 53635 || 53637 <= code && code <= 53663 || 53665 <= code && code <= 53691 || 53693 <= code && code <= 53719 || 53721 <= code && code <= 53747 || 53749 <= code && code <= 53775 || 53777 <= code && code <= 53803 || 53805 <= code && code <= 53831 || 53833 <= code && code <= 53859 || 53861 <= code && code <= 53887 || 53889 <= code && code <= 53915 || 53917 <= code && code <= 53943 || 53945 <= code && code <= 53971 || 53973 <= code && code <= 53999 || 54001 <= code && code <= 54027 || 54029 <= code && code <= 54055 || 54057 <= code && code <= 54083 || 54085 <= code && code <= 54111 || 54113 <= code && code <= 54139 || 54141 <= code && code <= 54167 || 54169 <= code && code <= 54195 || 54197 <= code && code <= 54223 || 54225 <= code && code <= 54251 || 54253 <= code && code <= 54279 || 54281 <= code && code <= 54307 || 54309 <= code && code <= 54335 || 54337 <= code && code <= 54363 || 54365 <= code && code <= 54391 || 54393 <= code && code <= 54419 || 54421 <= code && code <= 54447 || 54449 <= code && code <= 54475 || 54477 <= code && code <= 54503 || 54505 <= code && code <= 54531 || 54533 <= code && code <= 54559 || 54561 <= code && code <= 54587 || 54589 <= code && code <= 54615 || 54617 <= code && code <= 54643 || 54645 <= code && code <= 54671 || 54673 <= code && code <= 54699 || 54701 <= code && code <= 54727 || 54729 <= code && code <= 54755 || 54757 <= code && code <= 54783 || 54785 <= code && code <= 54811 || 54813 <= code && code <= 54839 || 54841 <= code && code <= 54867 || 54869 <= code && code <= 54895 || 54897 <= code && code <= 54923 || 54925 <= code && code <= 54951 || 54953 <= code && code <= 54979 || 54981 <= code && code <= 55007 || 55009 <= code && code <= 55035 || 55037 <= code && code <= 55063 || 55065 <= code && code <= 55091 || 55093 <= code && code <= 55119 || 55121 <= code && code <= 55147 || 55149 <= code && code <= 55175 || 55177 <= code && code <= 55203) {
            return LVT;
          }
          if (9757 == code || 9977 == code || 9994 <= code && code <= 9997 || 127877 == code || 127938 <= code && code <= 127940 || 127943 == code || 127946 <= code && code <= 127948 || 128066 <= code && code <= 128067 || 128070 <= code && code <= 128080 || 128110 == code || 128112 <= code && code <= 128120 || 128124 == code || 128129 <= code && code <= 128131 || 128133 <= code && code <= 128135 || 128170 == code || 128372 <= code && code <= 128373 || 128378 == code || 128400 == code || 128405 <= code && code <= 128406 || 128581 <= code && code <= 128583 || 128587 <= code && code <= 128591 || 128675 == code || 128692 <= code && code <= 128694 || 128704 == code || 128716 == code || 129304 <= code && code <= 129308 || 129310 <= code && code <= 129311 || 129318 == code || 129328 <= code && code <= 129337 || 129341 <= code && code <= 129342 || 129489 <= code && code <= 129501) {
            return E_Base;
          }
          if (127995 <= code && code <= 127999) {
            return E_Modifier;
          }
          if (8205 == code) {
            return ZWJ;
          }
          if (9792 == code || 9794 == code || 9877 <= code && code <= 9878 || 9992 == code || 10084 == code || 127752 == code || 127806 == code || 127859 == code || 127891 == code || 127908 == code || 127912 == code || 127979 == code || 127981 == code || 128139 == code || 128187 <= code && code <= 128188 || 128295 == code || 128300 == code || 128488 == code || 128640 == code || 128658 == code) {
            return Glue_After_Zwj;
          }
          if (128102 <= code && code <= 128105) {
            return E_Base_GAZ;
          }
          return Other;
        }
        return this;
      }
      if (typeof module != "undefined" && module.exports) {
        module.exports = GraphemeSplitter2;
      }
    }
  });

  // ../node_modules/md5-node/index.js
  var require_md5_node = __commonJS({
    "../node_modules/md5-node/index.js"(exports5, module) {
      function safe_add(x3, y3) {
        var lsw = (x3 & 65535) + (y3 & 65535), msw = (x3 >> 16) + (y3 >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 65535;
      }
      function bit_rol(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
      }
      function md5_cmn(q, a2, b, x3, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a2, q), safe_add(x3, t)), s), b);
      }
      function md5_ff(a2, b, c, d, x3, s, t) {
        return md5_cmn(b & c | ~b & d, a2, b, x3, s, t);
      }
      function md5_gg(a2, b, c, d, x3, s, t) {
        return md5_cmn(b & d | c & ~d, a2, b, x3, s, t);
      }
      function md5_hh(a2, b, c, d, x3, s, t) {
        return md5_cmn(b ^ c ^ d, a2, b, x3, s, t);
      }
      function md5_ii(a2, b, c, d, x3, s, t) {
        return md5_cmn(c ^ (b | ~d), a2, b, x3, s, t);
      }
      function binl_md5(x3, len) {
        x3[len >> 5] |= 128 << len % 32;
        x3[(len + 64 >>> 9 << 4) + 14] = len;
        var i, olda, oldb, oldc, oldd, a2 = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
        for (i = 0; i < x3.length; i += 16) {
          olda = a2;
          oldb = b;
          oldc = c;
          oldd = d;
          a2 = md5_ff(a2, b, c, d, x3[i], 7, -680876936);
          d = md5_ff(d, a2, b, c, x3[i + 1], 12, -389564586);
          c = md5_ff(c, d, a2, b, x3[i + 2], 17, 606105819);
          b = md5_ff(b, c, d, a2, x3[i + 3], 22, -1044525330);
          a2 = md5_ff(a2, b, c, d, x3[i + 4], 7, -176418897);
          d = md5_ff(d, a2, b, c, x3[i + 5], 12, 1200080426);
          c = md5_ff(c, d, a2, b, x3[i + 6], 17, -1473231341);
          b = md5_ff(b, c, d, a2, x3[i + 7], 22, -45705983);
          a2 = md5_ff(a2, b, c, d, x3[i + 8], 7, 1770035416);
          d = md5_ff(d, a2, b, c, x3[i + 9], 12, -1958414417);
          c = md5_ff(c, d, a2, b, x3[i + 10], 17, -42063);
          b = md5_ff(b, c, d, a2, x3[i + 11], 22, -1990404162);
          a2 = md5_ff(a2, b, c, d, x3[i + 12], 7, 1804603682);
          d = md5_ff(d, a2, b, c, x3[i + 13], 12, -40341101);
          c = md5_ff(c, d, a2, b, x3[i + 14], 17, -1502002290);
          b = md5_ff(b, c, d, a2, x3[i + 15], 22, 1236535329);
          a2 = md5_gg(a2, b, c, d, x3[i + 1], 5, -165796510);
          d = md5_gg(d, a2, b, c, x3[i + 6], 9, -1069501632);
          c = md5_gg(c, d, a2, b, x3[i + 11], 14, 643717713);
          b = md5_gg(b, c, d, a2, x3[i], 20, -373897302);
          a2 = md5_gg(a2, b, c, d, x3[i + 5], 5, -701558691);
          d = md5_gg(d, a2, b, c, x3[i + 10], 9, 38016083);
          c = md5_gg(c, d, a2, b, x3[i + 15], 14, -660478335);
          b = md5_gg(b, c, d, a2, x3[i + 4], 20, -405537848);
          a2 = md5_gg(a2, b, c, d, x3[i + 9], 5, 568446438);
          d = md5_gg(d, a2, b, c, x3[i + 14], 9, -1019803690);
          c = md5_gg(c, d, a2, b, x3[i + 3], 14, -187363961);
          b = md5_gg(b, c, d, a2, x3[i + 8], 20, 1163531501);
          a2 = md5_gg(a2, b, c, d, x3[i + 13], 5, -1444681467);
          d = md5_gg(d, a2, b, c, x3[i + 2], 9, -51403784);
          c = md5_gg(c, d, a2, b, x3[i + 7], 14, 1735328473);
          b = md5_gg(b, c, d, a2, x3[i + 12], 20, -1926607734);
          a2 = md5_hh(a2, b, c, d, x3[i + 5], 4, -378558);
          d = md5_hh(d, a2, b, c, x3[i + 8], 11, -2022574463);
          c = md5_hh(c, d, a2, b, x3[i + 11], 16, 1839030562);
          b = md5_hh(b, c, d, a2, x3[i + 14], 23, -35309556);
          a2 = md5_hh(a2, b, c, d, x3[i + 1], 4, -1530992060);
          d = md5_hh(d, a2, b, c, x3[i + 4], 11, 1272893353);
          c = md5_hh(c, d, a2, b, x3[i + 7], 16, -155497632);
          b = md5_hh(b, c, d, a2, x3[i + 10], 23, -1094730640);
          a2 = md5_hh(a2, b, c, d, x3[i + 13], 4, 681279174);
          d = md5_hh(d, a2, b, c, x3[i], 11, -358537222);
          c = md5_hh(c, d, a2, b, x3[i + 3], 16, -722521979);
          b = md5_hh(b, c, d, a2, x3[i + 6], 23, 76029189);
          a2 = md5_hh(a2, b, c, d, x3[i + 9], 4, -640364487);
          d = md5_hh(d, a2, b, c, x3[i + 12], 11, -421815835);
          c = md5_hh(c, d, a2, b, x3[i + 15], 16, 530742520);
          b = md5_hh(b, c, d, a2, x3[i + 2], 23, -995338651);
          a2 = md5_ii(a2, b, c, d, x3[i], 6, -198630844);
          d = md5_ii(d, a2, b, c, x3[i + 7], 10, 1126891415);
          c = md5_ii(c, d, a2, b, x3[i + 14], 15, -1416354905);
          b = md5_ii(b, c, d, a2, x3[i + 5], 21, -57434055);
          a2 = md5_ii(a2, b, c, d, x3[i + 12], 6, 1700485571);
          d = md5_ii(d, a2, b, c, x3[i + 3], 10, -1894986606);
          c = md5_ii(c, d, a2, b, x3[i + 10], 15, -1051523);
          b = md5_ii(b, c, d, a2, x3[i + 1], 21, -2054922799);
          a2 = md5_ii(a2, b, c, d, x3[i + 8], 6, 1873313359);
          d = md5_ii(d, a2, b, c, x3[i + 15], 10, -30611744);
          c = md5_ii(c, d, a2, b, x3[i + 6], 15, -1560198380);
          b = md5_ii(b, c, d, a2, x3[i + 13], 21, 1309151649);
          a2 = md5_ii(a2, b, c, d, x3[i + 4], 6, -145523070);
          d = md5_ii(d, a2, b, c, x3[i + 11], 10, -1120210379);
          c = md5_ii(c, d, a2, b, x3[i + 2], 15, 718787259);
          b = md5_ii(b, c, d, a2, x3[i + 9], 21, -343485551);
          a2 = safe_add(a2, olda);
          b = safe_add(b, oldb);
          c = safe_add(c, oldc);
          d = safe_add(d, oldd);
        }
        return [a2, b, c, d];
      }
      function binl2rstr(input) {
        var i, output = "";
        for (i = 0; i < input.length * 32; i += 8) {
          output += String.fromCharCode(input[i >> 5] >>> i % 32 & 255);
        }
        return output;
      }
      function rstr2binl(input) {
        var i, output = [];
        output[(input.length >> 2) - 1] = void 0;
        for (i = 0; i < output.length; i += 1) {
          output[i] = 0;
        }
        for (i = 0; i < input.length * 8; i += 8) {
          output[i >> 5] |= (input.charCodeAt(i / 8) & 255) << i % 32;
        }
        return output;
      }
      function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
      }
      function rstr_hmac_md5(key2, data) {
        var i, bkey = rstr2binl(key2), ipad = [], opad = [], hash;
        ipad[15] = opad[15] = void 0;
        if (bkey.length > 16) {
          bkey = binl_md5(bkey, key2.length * 8);
        }
        for (i = 0; i < 16; i += 1) {
          ipad[i] = bkey[i] ^ 909522486;
          opad[i] = bkey[i] ^ 1549556828;
        }
        hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
      }
      function rstr2hex(input) {
        var hex_tab = "0123456789abcdef", output = "", x3, i;
        for (i = 0; i < input.length; i += 1) {
          x3 = input.charCodeAt(i);
          output += hex_tab.charAt(x3 >>> 4 & 15) + hex_tab.charAt(x3 & 15);
        }
        return output;
      }
      function str2rstr_utf8(input) {
        return unescape(encodeURIComponent(input));
      }
      function raw_md5(s) {
        return rstr_md5(str2rstr_utf8(s));
      }
      function hex_md5(s) {
        return rstr2hex(raw_md5(s));
      }
      function raw_hmac_md5(k, d) {
        return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));
      }
      function hex_hmac_md5(k, d) {
        return rstr2hex(raw_hmac_md5(k, d));
      }
      function md53(string, key2, raw) {
        if (!key2) {
          if (!raw) {
            return hex_md5(string);
          }
          return raw_md5(string);
        }
        if (!raw) {
          return hex_hmac_md5(key2, string);
        }
        return raw_hmac_md5(key2, string);
      }
      module.exports = md53;
    }
  });

  // ../node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "../node_modules/ieee754/index.js"(exports5) {
      exports5.read = function(buffer4, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer4[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer4[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer4[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports5.write = function(buffer4, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer4[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer4[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer4[offset + i - d] |= s * 128;
      };
    }
  });

  // ../node_modules/pbf/index.js
  var require_pbf = __commonJS({
    "../node_modules/pbf/index.js"(exports5, module) {
      "use strict";
      module.exports = Pbf;
      var ieee754 = require_ieee754();
      function Pbf(buf) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
        this.pos = 0;
        this.type = 0;
        this.length = this.buf.length;
      }
      Pbf.Varint = 0;
      Pbf.Fixed64 = 1;
      Pbf.Bytes = 2;
      Pbf.Fixed32 = 5;
      var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
      var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
      var TEXT_DECODER_MIN_LENGTH = 12;
      var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
      Pbf.prototype = {
        destroy: function() {
          this.buf = null;
        },
        readFields: function(readField, result, end) {
          end = end || this.length;
          while (this.pos < end) {
            var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
            this.type = val & 7;
            readField(tag, result, this);
            if (this.pos === startPos)
              this.skip(val);
          }
          return result;
        },
        readMessage: function(readField, result) {
          return this.readFields(readField, result, this.readVarint() + this.pos);
        },
        readFixed32: function() {
          var val = readUInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        },
        readSFixed32: function() {
          var val = readInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        },
        readFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        },
        readSFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        },
        readFloat: function() {
          var val = ieee754.read(this.buf, this.pos, true, 23, 4);
          this.pos += 4;
          return val;
        },
        readDouble: function() {
          var val = ieee754.read(this.buf, this.pos, true, 52, 8);
          this.pos += 8;
          return val;
        },
        readVarint: function(isSigned) {
          var buf = this.buf, val, b;
          b = buf[this.pos++];
          val = b & 127;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 7;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 14;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 21;
          if (b < 128)
            return val;
          b = buf[this.pos];
          val |= (b & 15) << 28;
          return readVarintRemainder(val, isSigned, this);
        },
        readVarint64: function() {
          return this.readVarint(true);
        },
        readSVarint: function() {
          var num = this.readVarint();
          return num % 2 === 1 ? (num + 1) / -2 : num / 2;
        },
        readBoolean: function() {
          return Boolean(this.readVarint());
        },
        readString: function() {
          var end = this.readVarint() + this.pos;
          var pos = this.pos;
          this.pos = end;
          if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            return readUtf8TextDecoder(this.buf, pos, end);
          }
          return readUtf8(this.buf, pos, end);
        },
        readBytes: function() {
          var end = this.readVarint() + this.pos, buffer4 = this.buf.subarray(this.pos, end);
          this.pos = end;
          return buffer4;
        },
        readPackedVarint: function(arr2, isSigned) {
          if (this.type !== Pbf.Bytes)
            return arr2.push(this.readVarint(isSigned));
          var end = readPackedEnd(this);
          arr2 = arr2 || [];
          while (this.pos < end)
            arr2.push(this.readVarint(isSigned));
          return arr2;
        },
        readPackedSVarint: function(arr2) {
          if (this.type !== Pbf.Bytes)
            return arr2.push(this.readSVarint());
          var end = readPackedEnd(this);
          arr2 = arr2 || [];
          while (this.pos < end)
            arr2.push(this.readSVarint());
          return arr2;
        },
        readPackedBoolean: function(arr2) {
          if (this.type !== Pbf.Bytes)
            return arr2.push(this.readBoolean());
          var end = readPackedEnd(this);
          arr2 = arr2 || [];
          while (this.pos < end)
            arr2.push(this.readBoolean());
          return arr2;
        },
        readPackedFloat: function(arr2) {
          if (this.type !== Pbf.Bytes)
            return arr2.push(this.readFloat());
          var end = readPackedEnd(this);
          arr2 = arr2 || [];
          while (this.pos < end)
            arr2.push(this.readFloat());
          return arr2;
        },
        readPackedDouble: function(arr2) {
          if (this.type !== Pbf.Bytes)
            return arr2.push(this.readDouble());
          var end = readPackedEnd(this);
          arr2 = arr2 || [];
          while (this.pos < end)
            arr2.push(this.readDouble());
          return arr2;
        },
        readPackedFixed32: function(arr2) {
          if (this.type !== Pbf.Bytes)
            return arr2.push(this.readFixed32());
          var end = readPackedEnd(this);
          arr2 = arr2 || [];
          while (this.pos < end)
            arr2.push(this.readFixed32());
          return arr2;
        },
        readPackedSFixed32: function(arr2) {
          if (this.type !== Pbf.Bytes)
            return arr2.push(this.readSFixed32());
          var end = readPackedEnd(this);
          arr2 = arr2 || [];
          while (this.pos < end)
            arr2.push(this.readSFixed32());
          return arr2;
        },
        readPackedFixed64: function(arr2) {
          if (this.type !== Pbf.Bytes)
            return arr2.push(this.readFixed64());
          var end = readPackedEnd(this);
          arr2 = arr2 || [];
          while (this.pos < end)
            arr2.push(this.readFixed64());
          return arr2;
        },
        readPackedSFixed64: function(arr2) {
          if (this.type !== Pbf.Bytes)
            return arr2.push(this.readSFixed64());
          var end = readPackedEnd(this);
          arr2 = arr2 || [];
          while (this.pos < end)
            arr2.push(this.readSFixed64());
          return arr2;
        },
        skip: function(val) {
          var type = val & 7;
          if (type === Pbf.Varint)
            while (this.buf[this.pos++] > 127) {
            }
          else if (type === Pbf.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (type === Pbf.Fixed32)
            this.pos += 4;
          else if (type === Pbf.Fixed64)
            this.pos += 8;
          else
            throw new Error("Unimplemented type: " + type);
        },
        writeTag: function(tag, type) {
          this.writeVarint(tag << 3 | type);
        },
        realloc: function(min) {
          var length2 = this.length || 16;
          while (length2 < this.pos + min)
            length2 *= 2;
          if (length2 !== this.length) {
            var buf = new Uint8Array(length2);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length2;
          }
        },
        finish: function() {
          this.length = this.pos;
          this.pos = 0;
          return this.buf.subarray(0, this.length);
        },
        writeFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        },
        writeSFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        },
        writeFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeSFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeVarint: function(val) {
          val = +val || 0;
          if (val > 268435455 || val < 0) {
            writeBigVarint(val, this);
            return;
          }
          this.realloc(4);
          this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = val >>> 7 & 127;
        },
        writeSVarint: function(val) {
          this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
        },
        writeBoolean: function(val) {
          this.writeVarint(Boolean(val));
        },
        writeString: function(str) {
          str = String(str);
          this.realloc(str.length * 4);
          this.pos++;
          var startPos = this.pos;
          this.pos = writeUtf8(this.buf, str, this.pos);
          var len = this.pos - startPos;
          if (len >= 128)
            makeRoomForExtraLength(startPos, len, this);
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
        },
        writeFloat: function(val) {
          this.realloc(4);
          ieee754.write(this.buf, val, this.pos, true, 23, 4);
          this.pos += 4;
        },
        writeDouble: function(val) {
          this.realloc(8);
          ieee754.write(this.buf, val, this.pos, true, 52, 8);
          this.pos += 8;
        },
        writeBytes: function(buffer4) {
          var len = buffer4.length;
          this.writeVarint(len);
          this.realloc(len);
          for (var i = 0; i < len; i++)
            this.buf[this.pos++] = buffer4[i];
        },
        writeRawMessage: function(fn, obj) {
          this.pos++;
          var startPos = this.pos;
          fn(obj, this);
          var len = this.pos - startPos;
          if (len >= 128)
            makeRoomForExtraLength(startPos, len, this);
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
        },
        writeMessage: function(tag, fn, obj) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeRawMessage(fn, obj);
        },
        writePackedVarint: function(tag, arr2) {
          if (arr2.length)
            this.writeMessage(tag, writePackedVarint, arr2);
        },
        writePackedSVarint: function(tag, arr2) {
          if (arr2.length)
            this.writeMessage(tag, writePackedSVarint, arr2);
        },
        writePackedBoolean: function(tag, arr2) {
          if (arr2.length)
            this.writeMessage(tag, writePackedBoolean, arr2);
        },
        writePackedFloat: function(tag, arr2) {
          if (arr2.length)
            this.writeMessage(tag, writePackedFloat, arr2);
        },
        writePackedDouble: function(tag, arr2) {
          if (arr2.length)
            this.writeMessage(tag, writePackedDouble, arr2);
        },
        writePackedFixed32: function(tag, arr2) {
          if (arr2.length)
            this.writeMessage(tag, writePackedFixed32, arr2);
        },
        writePackedSFixed32: function(tag, arr2) {
          if (arr2.length)
            this.writeMessage(tag, writePackedSFixed32, arr2);
        },
        writePackedFixed64: function(tag, arr2) {
          if (arr2.length)
            this.writeMessage(tag, writePackedFixed64, arr2);
        },
        writePackedSFixed64: function(tag, arr2) {
          if (arr2.length)
            this.writeMessage(tag, writePackedSFixed64, arr2);
        },
        writeBytesField: function(tag, buffer4) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeBytes(buffer4);
        },
        writeFixed32Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFixed32(val);
        },
        writeSFixed32Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeSFixed32(val);
        },
        writeFixed64Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeFixed64(val);
        },
        writeSFixed64Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeSFixed64(val);
        },
        writeVarintField: function(tag, val) {
          this.writeTag(tag, Pbf.Varint);
          this.writeVarint(val);
        },
        writeSVarintField: function(tag, val) {
          this.writeTag(tag, Pbf.Varint);
          this.writeSVarint(val);
        },
        writeStringField: function(tag, str) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeString(str);
        },
        writeFloatField: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFloat(val);
        },
        writeDoubleField: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeDouble(val);
        },
        writeBooleanField: function(tag, val) {
          this.writeVarintField(tag, Boolean(val));
        }
      };
      function readVarintRemainder(l, s, p) {
        var buf = p.buf, h, b;
        b = buf[p.pos++];
        h = (b & 112) >> 4;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 3;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 10;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 17;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 24;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 1) << 31;
        if (b < 128)
          return toNum(l, h, s);
        throw new Error("Expected varint not more than 10 bytes");
      }
      function readPackedEnd(pbf) {
        return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
      }
      function toNum(low, high, isSigned) {
        if (isSigned) {
          return high * 4294967296 + (low >>> 0);
        }
        return (high >>> 0) * 4294967296 + (low >>> 0);
      }
      function writeBigVarint(val, pbf) {
        var low, high;
        if (val >= 0) {
          low = val % 4294967296 | 0;
          high = val / 4294967296 | 0;
        } else {
          low = ~(-val % 4294967296);
          high = ~(-val / 4294967296);
          if (low ^ 4294967295) {
            low = low + 1 | 0;
          } else {
            low = 0;
            high = high + 1 | 0;
          }
        }
        if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
          throw new Error("Given varint doesn't fit into 10 bytes");
        }
        pbf.realloc(10);
        writeBigVarintLow(low, high, pbf);
        writeBigVarintHigh(high, pbf);
      }
      function writeBigVarintLow(low, high, pbf) {
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos] = low & 127;
      }
      function writeBigVarintHigh(high, pbf) {
        var lsb = (high & 7) << 4;
        pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127;
      }
      function makeRoomForExtraLength(startPos, len, pbf) {
        var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
        pbf.realloc(extraLen);
        for (var i = pbf.pos - 1; i >= startPos; i--)
          pbf.buf[i + extraLen] = pbf.buf[i];
      }
      function writePackedVarint(arr2, pbf) {
        for (var i = 0; i < arr2.length; i++)
          pbf.writeVarint(arr2[i]);
      }
      function writePackedSVarint(arr2, pbf) {
        for (var i = 0; i < arr2.length; i++)
          pbf.writeSVarint(arr2[i]);
      }
      function writePackedFloat(arr2, pbf) {
        for (var i = 0; i < arr2.length; i++)
          pbf.writeFloat(arr2[i]);
      }
      function writePackedDouble(arr2, pbf) {
        for (var i = 0; i < arr2.length; i++)
          pbf.writeDouble(arr2[i]);
      }
      function writePackedBoolean(arr2, pbf) {
        for (var i = 0; i < arr2.length; i++)
          pbf.writeBoolean(arr2[i]);
      }
      function writePackedFixed32(arr2, pbf) {
        for (var i = 0; i < arr2.length; i++)
          pbf.writeFixed32(arr2[i]);
      }
      function writePackedSFixed32(arr2, pbf) {
        for (var i = 0; i < arr2.length; i++)
          pbf.writeSFixed32(arr2[i]);
      }
      function writePackedFixed64(arr2, pbf) {
        for (var i = 0; i < arr2.length; i++)
          pbf.writeFixed64(arr2[i]);
      }
      function writePackedSFixed64(arr2, pbf) {
        for (var i = 0; i < arr2.length; i++)
          pbf.writeSFixed64(arr2[i]);
      }
      function readUInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
      }
      function writeInt32(buf, val, pos) {
        buf[pos] = val;
        buf[pos + 1] = val >>> 8;
        buf[pos + 2] = val >>> 16;
        buf[pos + 3] = val >>> 24;
      }
      function readInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
      }
      function readUtf8(buf, pos, end) {
        var str = "";
        var i = pos;
        while (i < end) {
          var b0 = buf[i];
          var c = null;
          var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
          if (i + bytesPerSequence > end)
            break;
          var b1, b2, b3;
          if (bytesPerSequence === 1) {
            if (b0 < 128) {
              c = b0;
            }
          } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 192) === 128) {
              c = (b0 & 31) << 6 | b1 & 63;
              if (c <= 127) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 192) === 128 && (b2 & 192) === 128) {
              c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
              if (c <= 2047 || c >= 55296 && c <= 57343) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
              c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
              if (c <= 65535 || c >= 1114112) {
                c = null;
              }
            }
          }
          if (c === null) {
            c = 65533;
            bytesPerSequence = 1;
          } else if (c > 65535) {
            c -= 65536;
            str += String.fromCharCode(c >>> 10 & 1023 | 55296);
            c = 56320 | c & 1023;
          }
          str += String.fromCharCode(c);
          i += bytesPerSequence;
        }
        return str;
      }
      function readUtf8TextDecoder(buf, pos, end) {
        return utf8TextDecoder.decode(buf.subarray(pos, end));
      }
      function writeUtf8(buf, str, pos) {
        for (var i = 0, c, lead; i < str.length; i++) {
          c = str.charCodeAt(i);
          if (c > 55295 && c < 57344) {
            if (lead) {
              if (c < 56320) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
                lead = c;
                continue;
              } else {
                c = lead - 55296 << 10 | c - 56320 | 65536;
                lead = null;
              }
            } else {
              if (c > 56319 || i + 1 === str.length) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
              } else {
                lead = c;
              }
              continue;
            }
          } else if (lead) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = null;
          }
          if (c < 128) {
            buf[pos++] = c;
          } else {
            if (c < 2048) {
              buf[pos++] = c >> 6 | 192;
            } else {
              if (c < 65536) {
                buf[pos++] = c >> 12 | 224;
              } else {
                buf[pos++] = c >> 18 | 240;
                buf[pos++] = c >> 12 & 63 | 128;
              }
              buf[pos++] = c >> 6 & 63 | 128;
            }
            buf[pos++] = c & 63 | 128;
          }
        }
        return pos;
      }
    }
  });

  // Source/Custom.js
  var Custom_exports = {};
  __export(Custom_exports, {
    AspectAnalysis: () => AspectAnalysis_default,
    AvoidTile: () => AvoidTile_default,
    AvoidUtil: () => AvoidUtil_default,
    BeziterLine: () => BeziterLine_default,
    BillboardCollection: () => BillboardCollection_default,
    BoxSet: () => BoxSet_default,
    Browser: () => Browser_default,
    Buffer: () => Buffer4,
    CRS: () => CRS_default,
    Cache: () => Cache_default,
    CesiumTerrainProvider: () => CesiumTerrainProvider_default,
    CodeTool: () => CodeTool_default,
    Control: () => Control_default,
    DataSource: () => DataSource_default,
    Drag: () => Drag_default,
    DragModel: () => DragModel_default,
    DrawFboHillShade: () => DrawFboHillShade_default,
    DrawFboVector: () => DrawFboVector_default,
    DrawFill: () => DrawFill_default,
    DrawHillshade: () => DrawHillshade_default,
    DrawLine: () => DrawLine_default,
    DrawTilesFboVector: () => DrawTilesFboVector_default,
    DrawVector: () => DrawVector_default,
    DynamicGlowMaterialProperty: () => DynamicGlowMaterialProperty_default,
    ElevationAnalysis: () => ElevationAnalysis_default,
    ElevationImageryProvider: () => ElevationImageryProvider_default,
    ElevationTool: () => ElevationTool_default,
    EnvelopeDataSource: () => EnvelopeDataSource_default,
    EnvelopeModelTileServiceImageryProvider: () => EnvelopeModelTileServiceImageryProvider_default,
    EnvelopeWmtsDataSource: () => EnvelopeWmtsDataSource_default,
    EnvelopeWmtsImageryProvider: () => EnvelopeWmtsImageryProvider_default,
    Filter: () => Filter_default,
    FilterLayer: () => FilterLayer_default,
    FlowWaterMaterialProperty: () => FlowWaterMaterialProperty_default,
    GAnnoAvoid: () => GAnnoAvoid_default,
    GCutLine: () => GCutLine_default,
    GDistance: () => GDistance_default,
    GGridIndex: () => GGridIndex_default,
    GLabelBox: () => GLabelBox_default,
    GXYZUtil: () => GXYZUtil_default,
    Geojson: () => Geojson_default,
    GisTools: () => GisTools_default,
    GlyphSource: () => GlyphSource_default,
    GridFilter: () => GridFilter_default,
    GridFilterLabel: () => GridFilterLabel_default,
    HillShaderTile: () => HillShaderTile_default,
    HillShaderTileServiceImageryProvider: () => HillShaderTileServiceImageryProvider_default,
    HouseDataSource: () => HouseDataSource_default,
    HouseTileServiceImageryProvider: () => HouseTileServiceImageryProvider_default,
    ImageTileProvider: () => ImageTileProvider_default,
    IndexDBTool: () => IndexDBTool_default,
    LabelCollectionExt: () => LabelCollectionExt_default,
    LabelDrawer: () => LabelDrawer_default,
    LabelTile: () => LabelTile_default,
    LabelTileServiceImageryProvider: () => LabelTileServiceImageryProvider_default,
    LatLngArray: () => LatLngArray_default,
    LatLngPoint: () => LatLngPoint_default,
    LayerContentModel: () => LayerContentModel_default,
    Light: () => Light_default,
    LightTool: () => LightTool_default,
    LineAtlas: () => LineAtlas_default,
    LineGlow: () => LineGlow_default,
    LocalDataSource: () => LocalDataSource_default,
    MapPosition: () => MapPosition_default,
    MapboxTexture: () => MapboxTexture_default,
    Measure: () => Measure_default,
    ModelCollectionShaderFactory: () => ModelCollectionShaderFactory_default,
    ModelDataSource: () => ModelDataSource_default,
    ModelShaderFactory: () => ModelShaderFactory_default,
    ModelTileServiceImageryProvider: () => ModelTileServiceImageryProvider_default,
    Overlay: () => Overlay_default,
    ParseLabelData: () => ParseLabelData_default,
    PhasedArrayRadar: () => PhasedArrayRadar_default,
    PhasedArrayRadarFS: () => PhasedArrayRadarFS_default,
    PhasedArrayRadarPrimitive: () => PhasedArrayRadarPrimitive_default,
    PhasedArrayRadarScanPlaneFS: () => PhasedArrayRadarScanPlaneFS_default,
    PhasedArrayRadarVS: () => PhasedArrayRadarVS_default,
    Pit: () => Pit_default,
    PointLight: () => PointLight_default,
    PointTrans: () => PointTrans_default,
    PointUtil: () => PointUtil_default,
    Poly: () => Poly_default,
    PolygonDiffuseGlow: () => PolygonDiffuseGlow_default,
    ProgramFactory: () => ProgramFactory_default,
    Quadtree3DTilesProvider: () => Quadtree3DTilesProvider_default,
    QueryToJs: () => QueryToJs_default,
    RGBAImage: () => RGBAImage_default,
    RGBWorldTerrainProvider: () => RGBWorldTerrainProvider_default,
    Radar3dTileLight: () => Radar3dTileLight_default,
    RadarLight: () => RadarLight_default,
    RasterBoundsArray: () => RasterBoundsArray_default,
    ReflectWater: () => ReflectWater_default,
    ReflexWaterMaterialProperty: () => ReflexWaterMaterialProperty_default,
    RidingLanternGlow: () => RidingLanternGlow_default,
    RidingLanternGlowPrimitive: () => RidingLanternGlowPrimitive_default,
    RippleWaterMaterialProperty: () => RippleWaterMaterialProperty_default,
    SectionAnalysis: () => SectionAnalysis_default,
    Shader: () => Shader_default,
    Shaders: () => Shaders_default,
    SightLineAnalysis: () => SightLineAnalysis_default,
    SlopeAnalysis: () => SlopeAnalysis_default,
    TargetBloom: () => TargetBloom_default,
    TerrainClip: () => TerrainClip_default,
    TerrainEditBase: () => TerrainEditBase_default,
    TextureQueue: () => TextureQueue_default,
    TilesetClip: () => TilesetClip_default,
    TilesetEditBase: () => TilesetEditBase_default,
    TilesetFlat: () => TilesetFlat_default,
    ToolTip: () => ToolTip_default,
    TowerGlow: () => TowerGlow_default,
    URLDataSource: () => URLDataSource_default,
    UpDownScanLight: () => UpDownScanLight_default,
    Util: () => Util_default,
    VERSION: () => VERSION,
    VarintReader: () => VarintReader_default,
    VectorDrawer: () => VectorDrawer_default,
    VectorTile: () => VectorTile_default,
    VectorTileServiceImageryProvider: () => VectorTileServiceImageryProvider_default,
    Version: () => Version_default,
    VertexArrayObject: () => VertexArrayObject_default,
    Video: () => Video_default,
    VideoTranslucentMaterialProperty: () => VideoTranslucentMaterialProperty_default,
    ViewShedAnalysis: () => ViewShedAnalysis_default,
    VortexWaterMaterialProperty: () => VortexWaterMaterialProperty_default,
    Wave3dTileLight: () => Wave3dTileLight_default,
    WaveLight: () => WaveLight_default,
    WebMapTileServiceImageryProvider: () => WebMapTileServiceImageryProvider_default,
    Wkt: () => Wkt_default,
    _prelude_fragment: () => prelude_fragment_default,
    _prelude_vertex: () => prelude_vertex_default,
    circle_fragment: () => circle_fragment_default,
    circle_vertex: () => circle_vertex_default,
    createWorldTerrain: () => createWorldTerrain_default,
    es6_promise: () => es6_promise_default,
    fill_fragment: () => fill_fragment_default,
    fill_outline_fragment: () => fill_outline_fragment_default,
    fill_outline_pattern_fragment: () => fill_outline_pattern_fragment_default,
    fill_outline_pattern_vertex: () => fill_outline_pattern_vertex_default,
    fill_outline_vertex: () => fill_outline_vertex_default,
    fill_pattern_fragment: () => fill_pattern_fragment_default,
    fill_pattern_vertex: () => fill_pattern_vertex_default,
    fill_vertex: () => fill_vertex_default,
    gl_matrix: () => gl_matrix_default,
    glyphs: () => glyphs_default,
    hillshadeFragment: () => hillshadeFragment_default,
    hillshadePrepareFragment: () => hillshadePrepareFragment_default,
    hillshadePrepareVertex: () => hillshadePrepareVertex_default,
    hillshadeVertex: () => hillshadeVertex_default,
    hillshade_fragment: () => hillshade_fragment_default,
    hillshade_prepare_fragment: () => hillshade_prepare_fragment_default,
    hillshade_prepare_vertex: () => hillshade_prepare_vertex_default,
    hillshade_vertex: () => hillshade_vertex_default,
    ieee754: () => ieee754_default,
    isArray: () => isArray_default,
    is_char_in_unicode_block: () => is_char_in_unicode_block_default,
    jx: () => jx_default,
    line_fragment: () => line_fragment_default,
    line_gradient_fragment: () => line_gradient_fragment_default,
    line_gradient_vertex: () => line_gradient_vertex_default,
    line_pattern_fragment: () => line_pattern_fragment_default,
    line_pattern_vertex: () => line_pattern_vertex_default,
    line_sdf_fragment: () => line_sdf_fragment_default,
    line_sdf_vertex: () => line_sdf_vertex_default,
    line_vertex: () => line_vertex_default,
    script_detection: () => script_detection_default,
    snappyJs: () => snappyJs_default,
    uuid: () => uuid_default,
    verticalize_punctuation: () => verticalize_punctuation_default
  });

  // Source/custom/terrain/TerrainEditBase.js
  var TerrainEditVS = `attribute vec3 position;
void main()
{
    vec4 pos = vec4(position.xyz,1.0);
    gl_Position = czm_projection*pos;
}`;
  var TerrainEditFS = `#ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
#else
    precision mediump float;
#endif
void main()
{
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}`;
  var TerrainEditBase = class {
    constructor(viewer3, options = {}) {
      this.options = options;
      this.floodVar = Cesium.defaultValue(options.floodVar, [0, 0, 0, 500]);
      this._map = viewer3;
      this._maxCanvasSize = Cesium.defaultValue(options.maxCanvasSize, 4096);
      this._areaList = [];
      this._cache_id = 0;
    }
    get terrainEditCtl() {
      return this._map.scene.globe._surface.tileProvider._floodAnalysis || {};
    }
    get list() {
      return this._areaList;
    }
    get showElseArea() {
      return this.terrainEditCtl.showElseArea;
    }
    set showElseArea(val) {
      this.terrainEditCtl.showElseArea = val;
    }
    get positions() {
      if (this.length > 0) {
        return this._areaList[0].positions;
      } else {
        return null;
      }
    }
    set positions(val) {
      this.clear();
      this.addPolygon(val);
    }
    get length() {
      if (this._areaList) {
        return this._areaList.length;
      } else {
        return 0;
      }
    }
    clear() {
      this._map.scene.globe.material = null;
      this._map.scene.globe._surface.tileProvider.resetFloodAnalysis();
      this._map.scene.globe._surface.tileProvider.resetExcavateAnalysis();
      this._areaList = [];
      if (this.tailorTex) {
        this.tailorTex.destroy();
      }
    }
    getPolygonById(id) {
      for (let i = 0; i < this._areaList.length; i++) {
        let item = this._areaList[i];
        if (item.id == id) {
          return item;
        }
      }
      return null;
    }
    hidePolygon(id) {
      let areaObj = this.getPolygonById(id);
      if (areaObj) {
        areaObj.show = false;
        if (areaObj.pitPrimitive) {
          areaObj.pitPrimitive.show = false;
        }
        this.drawPolygon();
      }
    }
    showPolygon(id) {
      let areaObj = this.getPolygonById(id);
      if (areaObj) {
        areaObj.show = true;
        if (areaObj.pitPrimitive) {
          areaObj.pitPrimitive.show = true;
        }
        this.drawPolygon();
      }
    }
    removePolygon(item) {
      if (!item) {
        return;
      }
      this.removeArrayItem(this._areaList, item);
      this.drawPolygon();
    }
    addPolygon(positions, options) {
      if (!positions || positions.length == 0) {
        return;
      }
      let areaObj = {
        show: true,
        id: ++this._cache_id,
        positions_original: this.clonePositions(positions),
        positions
      };
      this._areaList.push(areaObj);
      this.computedCenter();
      this._prepareFlood();
      this.prepareCamera();
      this.prepareFBO();
      this.drawPolygon();
      this.beginTailor();
      return areaObj;
    }
    clonePositions(positions) {
      let newPositions = [];
      for (let i = 0; i < positions.length; i++) {
        let c3 = positions[i];
        newPositions.push(c3.clone());
      }
      return newPositions;
    }
    computedCenter() {
      let total = new Cesium.Cartesian3();
      this._areaList.forEach((areaObj) => {
        let arr2 = areaObj.positions;
        if (!arr2) {
          return;
        }
        let boundingSphere = Cesium.BoundingSphere.fromPoints(arr2);
        Cesium.Cartesian3.add(total, boundingSphere.center, total);
      });
      this.totalCenter = Cesium.Cartesian3.multiplyByScalar(total, 1 / this._areaList.length, new Cesium.Cartesian3());
    }
    _prepareFlood() {
      const context = this._map.scene.context;
      this.trans = Cesium.Transforms.eastNorthUpToFixedFrame(this.totalCenter);
      this.inverTrans = Cesium.Matrix4.inverse(this.trans, new Cesium.Matrix4());
      let minX = 99999999;
      let minY = 99999999;
      let maxX = -99999999;
      let maxY = -99999999;
      this._areaList.forEach((areaObj) => {
        let arr2 = areaObj.positions;
        let polygon2 = new Cesium.PolygonGeometry({
          polygonHierarchy: new Cesium.PolygonHierarchy(arr2)
        });
        polygon2 = Cesium.PolygonGeometry.createGeometry(polygon2);
        let indexs = polygon2.indices;
        let positionVal = polygon2.attributes.position.values;
        let lenV = positionVal.length;
        let localPos = [];
        let localVertex = [];
        for (let i = 0; i < lenV; i += 3) {
          let currx = positionVal[i];
          let curry = positionVal[i + 1];
          let currz = positionVal[i + 2];
          let currCar = new Cesium.Cartesian3(currx, curry, currz);
          let localp = Cesium.Matrix4.multiplyByPoint(this.inverTrans, currCar, new Cesium.Cartesian3());
          localp.z = 0;
          localPos.push(localp);
          localVertex.push(localp.x);
          localVertex.push(localp.y);
          localVertex.push(localp.z);
          if (minX >= localp.x) {
            minX = localp.x;
          }
          if (minY >= localp.y) {
            minY = localp.y;
          }
          if (maxX <= localp.x) {
            maxX = localp.x;
          }
          if (maxY <= localp.y) {
            maxY = localp.y;
          }
        }
        areaObj.localPos = localPos;
        let lps = new Float64Array(localVertex);
        let bs = Cesium.BoundingSphere.fromVertices(lps);
        let localGeo = new Cesium.Geometry({
          attributes: {
            position: new Cesium.GeometryAttribute({
              componentDatatype: Cesium.ComponentDatatype.DOUBLE,
              componentsPerAttribute: 3,
              values: lps
            })
          },
          indices: indexs,
          primitiveType: Cesium.PrimitiveType.TRIANGLES,
          boundingSphere: bs
        });
        let sp = Cesium.ShaderProgram.fromCache({
          context,
          vertexShaderSource: TerrainEditVS,
          fragmentShaderSource: TerrainEditFS,
          attributeLocations: {
            position: 0
          }
        });
        let vao = Cesium.VertexArray.fromGeometry({
          context,
          geometry: localGeo,
          attributeLocations: sp._attributeLocations,
          bufferUsage: Cesium.BufferUsage.STATIC_DRAW,
          interleave: true
        });
        let rs = new Cesium.RenderState();
        rs.depthRange.near = -1e6;
        rs.depthRange.far = 1e6;
        areaObj.drawAreaCommand = new Cesium.DrawCommand({
          boundingVolume: bs,
          primitiveType: Cesium.PrimitiveType.TRIANGLES,
          vertexArray: vao,
          shaderProgram: sp,
          renderState: rs,
          pass: Cesium.Pass.TRANSLUCENT
        });
      });
      this.ratio = (maxY - minY) / (maxX - minX);
      this.totalRect = [minX, minY, maxX, maxY];
    }
    prepareCamera() {
      let maxDis = 12e4;
      this.ortCamera = {
        viewMatrix: Cesium.Matrix4.IDENTITY,
        inverseViewMatrix: Cesium.Matrix4.IDENTITY,
        frustum: new Cesium.OrthographicOffCenterFrustum(),
        positionCartographic: {
          height: 0,
          latitude: 0,
          longitude: 0
        },
        positionWC: new Cesium.Cartesian3(0, 0, maxDis / 2),
        directionWC: new Cesium.Cartesian3(0, 0, -1),
        upWC: new Cesium.Cartesian3(0, 1, 0),
        rightWC: new Cesium.Cartesian3(1, 0, 0),
        viewProjectionMatrix: Cesium.Matrix4.IDENTITY
      };
      this.ortCamera.frustum.left = this.totalRect[0];
      this.ortCamera.frustum.top = this.totalRect[3];
      this.ortCamera.frustum.right = this.totalRect[2];
      this.ortCamera.frustum.bottom = this.totalRect[1];
      this.ortCamera.frustum.near = 0.1;
      this.ortCamera.frustum.far = -maxDis;
      this.floodRect = new Cesium.Cartesian4(
        this.totalRect[0],
        this.totalRect[1],
        this.totalRect[2] - this.totalRect[0],
        this.totalRect[3] - this.totalRect[1]
      );
    }
    prepareFBO() {
      let width;
      let height;
      if (this.ratio > 1) {
        width = this._maxCanvasSize / this.ratio;
        height = this._maxCanvasSize;
      } else {
        width = this._maxCanvasSize;
        height = width * this.ratio;
      }
      let context = this._map.scene.context;
      let tailorTex = new Cesium.Texture({
        context,
        width,
        height,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.HALF_FLOAT,
        flipY: false
      });
      this.tailorTex = tailorTex;
      this.yanmoFbo = new Cesium.Framebuffer({
        context,
        colorTextures: [tailorTex],
        destroyAttachments: false
      });
      this._fboClearCommand = new Cesium.ClearCommand({
        color: new Cesium.Color(0, 0, 0, 0),
        framebuffer: this.yanmoFbo
      });
    }
    drawPolygon() {
      let context = this._map.scene.context;
      let width;
      let height;
      if (this.ratio > 1) {
        width = this._maxCanvasSize / this.ratio;
        height = this._maxCanvasSize;
      } else {
        width = this._maxCanvasSize;
        height = width * this.ratio;
      }
      let passState = new Cesium.PassState(context);
      passState.viewport = new Cesium.BoundingRectangle(0, 0, width, height);
      let us = context.uniformState;
      us.updateCamera(this.ortCamera);
      this._fboClearCommand.execute(context);
      this._areaList.forEach((areaObj) => {
        const command = areaObj.drawAreaCommand;
        if (command && areaObj.show) {
          us.updatePass(command.pass);
          command.framebuffer = this.yanmoFbo;
          command.execute(context, passState);
        }
      });
    }
    beginTailor() {
      this.terrainEditCtl.inverFloodCenterMat = this.inverTrans;
      this.terrainEditCtl.floodArea = this.yanmoFbo;
      this.terrainEditCtl.enableFlood = true;
      this.terrainEditCtl.floodRect = this.floodRect;
      this.terrainEditCtl.globe = false;
    }
    _setFloodVar() {
      this.floodVar = [this.minHeight, this.minHeight, this.maxHeight, this.maxHeight - this.minHeight];
    }
    removeArrayItem(arr2, val) {
      let index = arr2.indexOf(val);
      if (index > -1) {
        arr2.splice(index, 1);
        return true;
      }
      return false;
    }
  };
  var TerrainEditBase_default = TerrainEditBase;

  // ../node_modules/@turf/helpers/dist/es/index.js
  var earthRadius = 63710088e-1;
  var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: earthRadius / 111325,
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1e3,
    kilometres: earthRadius / 1e3,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1e3,
    millimetres: earthRadius * 1e3,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
  };
  var unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1e3,
    kilometres: 1 / 1e3,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1e3,
    millimetres: 1e3,
    nauticalmiles: 1 / 1852,
    radians: 1 / earthRadius,
    yards: 1.0936133
  };
  function feature2(geom, properties, options) {
    if (options === void 0) {
      options = {};
    }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
      feat.id = options.id;
    }
    if (options.bbox) {
      feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
  }
  function point(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    if (!coordinates) {
      throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
      throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
      throw new Error("coordinates must contain numbers");
    }
    var geom = {
      type: "Point",
      coordinates
    };
    return feature2(geom, properties, options);
  }
  function polygon(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
      var ring = coordinates_1[_i];
      if (ring.length < 4) {
        throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
      }
      for (var j = 0; j < ring[ring.length - 1].length; j++) {
        if (ring[ring.length - 1][j] !== ring[0][j]) {
          throw new Error("First and last Position are not equivalent.");
        }
      }
    }
    var geom = {
      type: "Polygon",
      coordinates
    };
    return feature2(geom, properties, options);
  }
  function lineString(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
      type: "LineString",
      coordinates
    };
    return feature2(geom, properties, options);
  }
  function featureCollection(features, options) {
    if (options === void 0) {
      options = {};
    }
    var fc = { type: "FeatureCollection" };
    if (options.id) {
      fc.id = options.id;
    }
    if (options.bbox) {
      fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
  }
  function multiPoint(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    var geom = {
      type: "MultiPoint",
      coordinates
    };
    return feature2(geom, properties, options);
  }
  function radiansToLength(radians2, units) {
    if (units === void 0) {
      units = "kilometers";
    }
    var factor = factors[units];
    if (!factor) {
      throw new Error(units + " units is invalid");
    }
    return radians2 * factor;
  }
  function lengthToRadians(distance, units) {
    if (units === void 0) {
      units = "kilometers";
    }
    var factor = factors[units];
    if (!factor) {
      throw new Error(units + " units is invalid");
    }
    return distance / factor;
  }
  function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
  }

  // ../node_modules/@turf/meta/dist/es/index.js
  function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null)
      return;
    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
        var multiFeatureIndex = 0;
        var geometryIndex = 0;
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
        if (geometry === null)
          continue;
        coords = geometry.coordinates;
        var geomType = geometry.type;
        wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
        switch (geomType) {
          case null:
            break;
          case "Point":
            if (callback(
              coords,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            multiFeatureIndex++;
            break;
          case "LineString":
          case "MultiPoint":
            for (j = 0; j < coords.length; j++) {
              if (callback(
                coords[j],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
              if (geomType === "MultiPoint")
                multiFeatureIndex++;
            }
            if (geomType === "LineString")
              multiFeatureIndex++;
            break;
          case "Polygon":
          case "MultiLineString":
            for (j = 0; j < coords.length; j++) {
              for (k = 0; k < coords[j].length - wrapShrink; k++) {
                if (callback(
                  coords[j][k],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              if (geomType === "MultiLineString")
                multiFeatureIndex++;
              if (geomType === "Polygon")
                geometryIndex++;
            }
            if (geomType === "Polygon")
              multiFeatureIndex++;
            break;
          case "MultiPolygon":
            for (j = 0; j < coords.length; j++) {
              geometryIndex = 0;
              for (k = 0; k < coords[j].length; k++) {
                for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                  if (callback(
                    coords[j][k][l],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                }
                geometryIndex++;
              }
              multiFeatureIndex++;
            }
            break;
          case "GeometryCollection":
            for (j = 0; j < geometry.geometries.length; j++)
              if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
                return false;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
    }
  }
  function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(
      geojson,
      function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === void 0)
          previousValue = currentCoord;
        else
          previousValue = callback(
            previousValue,
            currentCoord,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          );
      },
      excludeWrapCoord
    );
    return previousValue;
  }
  function featureEach(geojson, callback) {
    if (geojson.type === "Feature") {
      callback(geojson, 0);
    } else if (geojson.type === "FeatureCollection") {
      for (var i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i], i) === false)
          break;
      }
    }
  }
  function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (i = 0; i < stop; i++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
      featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
      featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
      featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (g = 0; g < stopG; g++) {
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
        if (geometry === null) {
          if (callback(
            null,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          continue;
        }
        switch (geometry.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (callback(
              geometry,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
            break;
          }
          case "GeometryCollection": {
            for (j = 0; j < geometry.geometries.length; j++) {
              if (callback(
                geometry.geometries[j],
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false)
                return false;
            }
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      featureIndex++;
    }
  }
  function flattenEach(geojson, callback) {
    geomEach(geojson, function(geometry, featureIndex, properties, bbox2, id) {
      var type = geometry === null ? null : geometry.type;
      switch (type) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          if (callback(
            feature2(geometry, properties, { bbox: bbox2, id }),
            featureIndex,
            0
          ) === false)
            return false;
          return;
      }
      var geomType;
      switch (type) {
        case "MultiPoint":
          geomType = "Point";
          break;
        case "MultiLineString":
          geomType = "LineString";
          break;
        case "MultiPolygon":
          geomType = "Polygon";
          break;
      }
      for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
        var coordinate = geometry.coordinates[multiFeatureIndex];
        var geom = {
          type: geomType,
          coordinates: coordinate
        };
        if (callback(feature2(geom, properties), featureIndex, multiFeatureIndex) === false)
          return false;
      }
    });
  }

  // ../node_modules/@turf/bbox/dist/es/index.js
  function bbox(geojson) {
    var result = [Infinity, Infinity, -Infinity, -Infinity];
    coordEach(geojson, function(coord) {
      if (result[0] > coord[0]) {
        result[0] = coord[0];
      }
      if (result[1] > coord[1]) {
        result[1] = coord[1];
      }
      if (result[2] < coord[0]) {
        result[2] = coord[0];
      }
      if (result[3] < coord[1]) {
        result[3] = coord[1];
      }
    });
    return result;
  }
  bbox["default"] = bbox;
  var es_default = bbox;

  // ../node_modules/@turf/invariant/dist/es/index.js
  function getCoord(coord) {
    if (!coord) {
      throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
      if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
        return coord.geometry.coordinates;
      }
      if (coord.type === "Point") {
        return coord.coordinates;
      }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
      return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
  }
  function featureOf(feature3, type, name2) {
    if (!feature3) {
      throw new Error("No feature passed");
    }
    if (!name2) {
      throw new Error(".featureOf() requires a name");
    }
    if (!feature3 || feature3.type !== "Feature" || !feature3.geometry) {
      throw new Error("Invalid input to " + name2 + ", Feature with geometry required");
    }
    if (!feature3.geometry || feature3.geometry.type !== type) {
      throw new Error("Invalid input to " + name2 + ": must be a " + type + ", given " + feature3.geometry.type);
    }
  }
  function getGeom(geojson) {
    if (geojson.type === "Feature") {
      return geojson.geometry;
    }
    return geojson;
  }

  // ../node_modules/@turf/isolines/dist/es/index.js
  var import_object_assign = __toESM(require_object_assign(), 1);
  /**
   * @license GNU Affero General Public License.
   * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
   * v. 1.2.0
   * https://github.com/RaumZeit/MarchingSquares.js
   *
   * MarchingSquaresJS is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Affero General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MarchingSquaresJS is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU Affero General Public License for more details.
   *
   * As additional permission under GNU Affero General Public License version 3
   * section 7, third-party projects (personal or commercial) may distribute,
   * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
   * requirement that said third-party project for that reason alone becomes
   * subject to any requirement of the GNU Affero General Public License version 3.
   * Any modifications to MarchingSquaresJS, however, must be shared with the public
   * and made available.
   *
   * In summary this:
   * - allows you to use MarchingSquaresJS at no cost
   * - allows you to use MarchingSquaresJS for both personal and commercial purposes
   * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
   *   license as long as this license notice is included
   * - enables you to keep the source code of your program that uses MarchingSquaresJS
   *   undisclosed
   * - forces you to share any modifications you have made to MarchingSquaresJS,
   *   e.g. bug-fixes
   *
   * You should have received a copy of the GNU Affero General Public License
   * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
   */

  // ../node_modules/@turf/convex/dist/es/index.js
  var import_concaveman = __toESM(require_concaveman(), 1);
  function convex(geojson, options) {
    if (options === void 0) {
      options = {};
    }
    options.concavity = options.concavity || Infinity;
    var points = [];
    coordEach(geojson, function(coord) {
      points.push([coord[0], coord[1]]);
    });
    if (!points.length) {
      return null;
    }
    var convexHull = (0, import_concaveman.default)(points, options.concavity);
    if (convexHull.length > 3) {
      return polygon([convexHull]);
    }
    return null;
  }

  // ../node_modules/@turf/boolean-point-in-polygon/dist/es/index.js
  function booleanPointInPolygon(point2, polygon2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!point2) {
      throw new Error("point is required");
    }
    if (!polygon2) {
      throw new Error("polygon is required");
    }
    var pt = getCoord(point2);
    var geom = getGeom(polygon2);
    var type = geom.type;
    var bbox2 = polygon2.bbox;
    var polys = geom.coordinates;
    if (bbox2 && inBBox(pt, bbox2) === false) {
      return false;
    }
    if (type === "Polygon") {
      polys = [polys];
    }
    var insidePoly = false;
    for (var i = 0; i < polys.length && !insidePoly; i++) {
      if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
        var inHole = false;
        var k = 1;
        while (k < polys[i].length && !inHole) {
          if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
            inHole = true;
          }
          k++;
        }
        if (!inHole) {
          insidePoly = true;
        }
      }
    }
    return insidePoly;
  }
  function inRing(pt, ring, ignoreBoundary) {
    var isInside = false;
    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
      ring = ring.slice(0, ring.length - 1);
    }
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      var xi = ring[i][0];
      var yi = ring[i][1];
      var xj = ring[j][0];
      var yj = ring[j][1];
      var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
      if (onBoundary) {
        return !ignoreBoundary;
      }
      var intersect2 = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
      if (intersect2) {
        isInside = !isInside;
      }
    }
    return isInside;
  }
  function inBBox(pt, bbox2) {
    return bbox2[0] <= pt[0] && bbox2[1] <= pt[1] && bbox2[2] >= pt[0] && bbox2[3] >= pt[1];
  }

  // ../node_modules/@turf/tin/dist/es/index.js
  var Triangle = function() {
    function Triangle2(a2, b, c) {
      this.a = a2;
      this.b = b;
      this.c = c;
      var A2 = b.x - a2.x;
      var B2 = b.y - a2.y;
      var C = c.x - a2.x;
      var D = c.y - a2.y;
      var E = A2 * (a2.x + b.x) + B2 * (a2.y + b.y);
      var F = C * (a2.x + c.x) + D * (a2.y + c.y);
      var G = 2 * (A2 * (c.y - b.y) - B2 * (c.x - b.x));
      var dx;
      var dy;
      this.x = (D * E - B2 * F) / G;
      this.y = (A2 * F - C * E) / G;
      dx = this.x - a2.x;
      dy = this.y - a2.y;
      this.r = dx * dx + dy * dy;
    }
    return Triangle2;
  }();

  // ../node_modules/topojson-server/src/hash/point-hash.js
  var buffer = new ArrayBuffer(16);
  var floats = new Float64Array(buffer);
  var uints = new Uint32Array(buffer);

  // ../node_modules/@turf/collect/dist/es/index.js
  var import_rbush = __toESM(require_rbush(), 1);

  // ../node_modules/@turf/bezier-spline/dist/es/lib/spline.js
  var Spline = function() {
    function Spline2(options) {
      this.points = options.points || [];
      this.duration = options.duration || 1e4;
      this.sharpness = options.sharpness || 0.85;
      this.centers = [];
      this.controls = [];
      this.stepLength = options.stepLength || 60;
      this.length = this.points.length;
      this.delay = 0;
      for (var i = 0; i < this.length; i++) {
        this.points[i].z = this.points[i].z || 0;
      }
      for (var i = 0; i < this.length - 1; i++) {
        var p1 = this.points[i];
        var p2 = this.points[i + 1];
        this.centers.push({
          x: (p1.x + p2.x) / 2,
          y: (p1.y + p2.y) / 2,
          z: (p1.z + p2.z) / 2
        });
      }
      this.controls.push([this.points[0], this.points[0]]);
      for (var i = 0; i < this.centers.length - 1; i++) {
        var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
        var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
        var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
        this.controls.push([
          {
            x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
            y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
            z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)
          },
          {
            x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
            y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
            z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)
          }
        ]);
      }
      this.controls.push([
        this.points[this.length - 1],
        this.points[this.length - 1]
      ]);
      this.steps = this.cacheSteps(this.stepLength);
      return this;
    }
    Spline2.prototype.cacheSteps = function(mindist) {
      var steps = [];
      var laststep = this.pos(0);
      steps.push(0);
      for (var t = 0; t < this.duration; t += 10) {
        var step = this.pos(t);
        var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
        if (dist > mindist) {
          steps.push(t);
          laststep = step;
        }
      }
      return steps;
    };
    Spline2.prototype.vector = function(t) {
      var p1 = this.pos(t + 10);
      var p2 = this.pos(t - 10);
      return {
        angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
        speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
      };
    };
    Spline2.prototype.pos = function(time) {
      var t = time - this.delay;
      if (t < 0) {
        t = 0;
      }
      if (t > this.duration) {
        t = this.duration - 1;
      }
      var t2 = t / this.duration;
      if (t2 >= 1) {
        return this.points[this.length - 1];
      }
      var n = Math.floor((this.points.length - 1) * t2);
      var t1 = (this.length - 1) * t2 - n;
      return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
    };
    return Spline2;
  }();
  var spline_default = Spline;
  function bezier(t, p1, c1, c2, p2) {
    var b = B(t);
    var pos = {
      x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
      y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
      z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
    };
    return pos;
  }
  function B(t) {
    var t2 = t * t;
    var t3 = t2 * t;
    return [
      t3,
      3 * t2 * (1 - t),
      3 * t * (1 - t) * (1 - t),
      (1 - t) * (1 - t) * (1 - t)
    ];
  }

  // ../node_modules/@turf/bezier-spline/dist/es/index.js
  function bezier2(line, options) {
    if (options === void 0) {
      options = {};
    }
    var resolution = options.resolution || 1e4;
    var sharpness = options.sharpness || 0.85;
    var coords = [];
    var points = getGeom(line).coordinates.map(function(pt) {
      return { x: pt[0], y: pt[1] };
    });
    var spline = new spline_default({
      duration: resolution,
      points,
      sharpness
    });
    var pushCoord = function(time) {
      var pos = spline.pos(time);
      if (Math.floor(time / 100) % 2 === 0) {
        coords.push([pos.x, pos.y]);
      }
    };
    for (var i = 0; i < spline.duration; i += 10) {
      pushCoord(i);
    }
    pushCoord(spline.duration);
    return lineString(coords, options.properties);
  }
  var es_default5 = bezier2;

  // ../node_modules/@turf/bbox-polygon/dist/es/index.js
  function bboxPolygon(bbox2, options) {
    if (options === void 0) {
      options = {};
    }
    var west = Number(bbox2[0]);
    var south = Number(bbox2[1]);
    var east = Number(bbox2[2]);
    var north = Number(bbox2[3]);
    if (bbox2.length === 6) {
      throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
    }
    var lowLeft = [west, south];
    var topLeft = [west, north];
    var topRight = [east, north];
    var lowRight = [east, south];
    return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox2, id: options.id });
  }

  // ../node_modules/@turf/envelope/dist/es/index.js
  function envelope(geojson) {
    return bboxPolygon(es_default(geojson));
  }
  var es_default6 = envelope;

  // ../node_modules/@turf/center/dist/es/index.js
  function center(geojson, options) {
    if (options === void 0) {
      options = {};
    }
    var ext = es_default(geojson);
    var x3 = (ext[0] + ext[2]) / 2;
    var y3 = (ext[1] + ext[3]) / 2;
    return point([x3, y3], options.properties, options);
  }
  var es_default7 = center;

  // ../node_modules/@turf/tesselate/dist/es/index.js
  var import_earcut = __toESM(require_earcut(), 1);

  // ../node_modules/@turf/line-intersect/dist/es/index.js
  var import_geojson_rbush = __toESM(require_geojson_rbush(), 1);

  // ../node_modules/@turf/nearest-point-to-line/dist/es/index.js
  var import_object_assign2 = __toESM(require_object_assign(), 1);

  // ../node_modules/@turf/unkink-polygon/dist/es/index.js
  var import_rbush2 = __toESM(require_rbush2(), 1);

  // ../node_modules/@turf/great-circle/dist/es/index.js
  var D2R = Math.PI / 180;
  var R2D = 180 / Math.PI;
  var Coord = function(lon, lat) {
    this.lon = lon;
    this.lat = lat;
    this.x = D2R * lon;
    this.y = D2R * lat;
  };
  Coord.prototype.view = function() {
    return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
  };
  Coord.prototype.antipode = function() {
    var anti_lat = -1 * this.lat;
    var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
    return new Coord(anti_lon, anti_lat);
  };
  var LineString = function() {
    this.coords = [];
    this.length = 0;
  };
  LineString.prototype.move_to = function(coord) {
    this.length++;
    this.coords.push(coord);
  };
  var Arc = function(properties) {
    this.properties = properties || {};
    this.geometries = [];
  };
  Arc.prototype.json = function() {
    if (this.geometries.length <= 0) {
      return {
        geometry: { type: "LineString", coordinates: null },
        type: "Feature",
        properties: this.properties
      };
    } else if (this.geometries.length === 1) {
      return {
        geometry: { type: "LineString", coordinates: this.geometries[0].coords },
        type: "Feature",
        properties: this.properties
      };
    } else {
      var multiline = [];
      for (var i = 0; i < this.geometries.length; i++) {
        multiline.push(this.geometries[i].coords);
      }
      return {
        geometry: { type: "MultiLineString", coordinates: multiline },
        type: "Feature",
        properties: this.properties
      };
    }
  };
  Arc.prototype.wkt = function() {
    var wkt_string = "";
    var wkt = "LINESTRING(";
    var collect = function(c) {
      wkt += c[0] + " " + c[1] + ",";
    };
    for (var i = 0; i < this.geometries.length; i++) {
      if (this.geometries[i].coords.length === 0) {
        return "LINESTRING(empty)";
      } else {
        var coords = this.geometries[i].coords;
        coords.forEach(collect);
        wkt_string += wkt.substring(0, wkt.length - 1) + ")";
      }
    }
    return wkt_string;
  };
  var GreatCircle = function(start2, end, properties) {
    if (!start2 || start2.x === void 0 || start2.y === void 0) {
      throw new Error(
        "GreatCircle constructor expects two args: start and end objects with x and y properties"
      );
    }
    if (!end || end.x === void 0 || end.y === void 0) {
      throw new Error(
        "GreatCircle constructor expects two args: start and end objects with x and y properties"
      );
    }
    this.start = new Coord(start2.x, start2.y);
    this.end = new Coord(end.x, end.y);
    this.properties = properties || {};
    var w = this.start.x - this.end.x;
    var h = this.start.y - this.end.y;
    var z2 = Math.pow(Math.sin(h / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2), 2);
    this.g = 2 * Math.asin(Math.sqrt(z2));
    if (this.g === Math.PI) {
      throw new Error(
        "it appears " + start2.view() + " and " + end.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"
      );
    } else if (isNaN(this.g)) {
      throw new Error(
        "could not calculate great circle between " + start2 + " and " + end
      );
    }
  };
  GreatCircle.prototype.interpolate = function(f) {
    var A2 = Math.sin((1 - f) * this.g) / Math.sin(this.g);
    var B2 = Math.sin(f * this.g) / Math.sin(this.g);
    var x3 = A2 * Math.cos(this.start.y) * Math.cos(this.start.x) + B2 * Math.cos(this.end.y) * Math.cos(this.end.x);
    var y3 = A2 * Math.cos(this.start.y) * Math.sin(this.start.x) + B2 * Math.cos(this.end.y) * Math.sin(this.end.x);
    var z2 = A2 * Math.sin(this.start.y) + B2 * Math.sin(this.end.y);
    var lat = R2D * Math.atan2(z2, Math.sqrt(Math.pow(x3, 2) + Math.pow(y3, 2)));
    var lon = R2D * Math.atan2(y3, x3);
    return [lon, lat];
  };
  GreatCircle.prototype.Arc = function(npoints, options) {
    var first_pass = [];
    if (!npoints || npoints <= 2) {
      first_pass.push([this.start.lon, this.start.lat]);
      first_pass.push([this.end.lon, this.end.lat]);
    } else {
      var delta = 1 / (npoints - 1);
      for (var i = 0; i < npoints; ++i) {
        var step = delta * i;
        var pair2 = this.interpolate(step);
        first_pass.push(pair2);
      }
    }
    var bHasBigDiff = false;
    var dfMaxSmallDiffLong = 0;
    var dfDateLineOffset = options && options.offset ? options.offset : 10;
    var dfLeftBorderX = 180 - dfDateLineOffset;
    var dfRightBorderX = -180 + dfDateLineOffset;
    var dfDiffSpace = 360 - dfDateLineOffset;
    for (var j = 1; j < first_pass.length; ++j) {
      var dfPrevX = first_pass[j - 1][0];
      var dfX = first_pass[j][0];
      var dfDiffLong = Math.abs(dfX - dfPrevX);
      if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {
        bHasBigDiff = true;
      } else if (dfDiffLong > dfMaxSmallDiffLong) {
        dfMaxSmallDiffLong = dfDiffLong;
      }
    }
    var poMulti = [];
    if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
      var poNewLS = [];
      poMulti.push(poNewLS);
      for (var k = 0; k < first_pass.length; ++k) {
        var dfX0 = parseFloat(first_pass[k][0]);
        if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
          var dfX1 = parseFloat(first_pass[k - 1][0]);
          var dfY1 = parseFloat(first_pass[k - 1][1]);
          var dfX2 = parseFloat(first_pass[k][0]);
          var dfY2 = parseFloat(first_pass[k][1]);
          if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {
            poNewLS.push([-180, first_pass[k][1]]);
            k++;
            poNewLS.push([first_pass[k][0], first_pass[k][1]]);
            continue;
          } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {
            poNewLS.push([180, first_pass[k][1]]);
            k++;
            poNewLS.push([first_pass[k][0], first_pass[k][1]]);
            continue;
          }
          if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
            var tmpX = dfX1;
            dfX1 = dfX2;
            dfX2 = tmpX;
            var tmpY = dfY1;
            dfY1 = dfY2;
            dfY2 = tmpY;
          }
          if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
            dfX2 += 360;
          }
          if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
            var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
            var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
            poNewLS.push([
              first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
              dfY
            ]);
            poNewLS = [];
            poNewLS.push([
              first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
              dfY
            ]);
            poMulti.push(poNewLS);
          } else {
            poNewLS = [];
            poMulti.push(poNewLS);
          }
          poNewLS.push([dfX0, first_pass[k][1]]);
        } else {
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
        }
      }
    } else {
      var poNewLS0 = [];
      poMulti.push(poNewLS0);
      for (var l = 0; l < first_pass.length; ++l) {
        poNewLS0.push([first_pass[l][0], first_pass[l][1]]);
      }
    }
    var arc = new Arc(this.properties);
    for (var m = 0; m < poMulti.length; ++m) {
      var line = new LineString();
      arc.geometries.push(line);
      var points = poMulti[m];
      for (var j0 = 0; j0 < points.length; ++j0) {
        line.move_to(points[j0]);
      }
    }
    return arc;
  };

  // ../node_modules/@turf/line-split/dist/es/index.js
  var import_geojson_rbush2 = __toESM(require_geojson_rbush(), 1);

  // ../node_modules/@turf/line-overlap/dist/es/index.js
  var import_geojson_rbush3 = __toESM(require_geojson_rbush(), 1);
  var import_deep_equal = __toESM(require_deep_equal(), 1);

  // ../node_modules/@turf/isobands/dist/es/index.js
  var import_object_assign3 = __toESM(require_object_assign(), 1);
  /*!
   * @license GNU Affero General Public License.
   * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
   * v. 1.2.0
   * https://github.com/RaumZeit/MarchingSquares.js
   *
   * MarchingSquaresJS is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Affero General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MarchingSquaresJS is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU Affero General Public License for more details.
   *
   * As additional permission under GNU Affero General Public License version 3
   * section 7, third-party projects (personal or commercial) may distribute,
   * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
   * requirement that said third-party project for that reason alone becomes
   * subject to any requirement of the GNU Affero General Public License version 3.
   * Any modifications to MarchingSquaresJS, however, must be shared with the public
   * and made available.
   *
   * In summary this:
   * - allows you to use MarchingSquaresJS at no cost
   * - allows you to use MarchingSquaresJS for both personal and commercial purposes
   * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
   *   license as long as this license notice is included
   * - enables you to keep the source code of your program that uses MarchingSquaresJS
   *   undisclosed
   * - forces you to share any modifications you have made to MarchingSquaresJS,
   *   e.g. bug-fixes
   *
   * You should have received a copy of the GNU Affero General Public License
   * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
   */
  var isoBandNextXTL = [];
  var isoBandNextYTL = [];
  var isoBandNextOTL = [];
  var isoBandNextXTR = [];
  var isoBandNextYTR = [];
  var isoBandNextOTR = [];
  var isoBandNextXRT = [];
  var isoBandNextYRT = [];
  var isoBandNextORT = [];
  var isoBandNextXRB = [];
  var isoBandNextYRB = [];
  var isoBandNextORB = [];
  var isoBandNextXBL = [];
  var isoBandNextYBL = [];
  var isoBandNextOBL = [];
  var isoBandNextXBR = [];
  var isoBandNextYBR = [];
  var isoBandNextOBR = [];
  var isoBandNextXLT = [];
  var isoBandNextYLT = [];
  var isoBandNextOLT = [];
  var isoBandNextXLB = [];
  var isoBandNextYLB = [];
  var isoBandNextOLB = [];
  isoBandNextXRT[85] = isoBandNextXRB[85] = -1;
  isoBandNextYRT[85] = isoBandNextYRB[85] = 0;
  isoBandNextORT[85] = isoBandNextORB[85] = 1;
  isoBandNextXLT[85] = isoBandNextXLB[85] = 1;
  isoBandNextYLT[85] = isoBandNextYLB[85] = 0;
  isoBandNextOLT[85] = isoBandNextOLB[85] = 1;
  isoBandNextXTL[85] = isoBandNextXTR[85] = 0;
  isoBandNextYTL[85] = isoBandNextYTR[85] = -1;
  isoBandNextOTL[85] = isoBandNextOBL[85] = 0;
  isoBandNextXBR[85] = isoBandNextXBL[85] = 0;
  isoBandNextYBR[85] = isoBandNextYBL[85] = 1;
  isoBandNextOTR[85] = isoBandNextOBR[85] = 1;
  isoBandNextXLB[1] = isoBandNextXLB[169] = 0;
  isoBandNextYLB[1] = isoBandNextYLB[169] = -1;
  isoBandNextOLB[1] = isoBandNextOLB[169] = 0;
  isoBandNextXBL[1] = isoBandNextXBL[169] = -1;
  isoBandNextYBL[1] = isoBandNextYBL[169] = 0;
  isoBandNextOBL[1] = isoBandNextOBL[169] = 0;
  isoBandNextXRB[4] = isoBandNextXRB[166] = 0;
  isoBandNextYRB[4] = isoBandNextYRB[166] = -1;
  isoBandNextORB[4] = isoBandNextORB[166] = 1;
  isoBandNextXBR[4] = isoBandNextXBR[166] = 1;
  isoBandNextYBR[4] = isoBandNextYBR[166] = 0;
  isoBandNextOBR[4] = isoBandNextOBR[166] = 0;
  isoBandNextXRT[16] = isoBandNextXRT[154] = 0;
  isoBandNextYRT[16] = isoBandNextYRT[154] = 1;
  isoBandNextORT[16] = isoBandNextORT[154] = 1;
  isoBandNextXTR[16] = isoBandNextXTR[154] = 1;
  isoBandNextYTR[16] = isoBandNextYTR[154] = 0;
  isoBandNextOTR[16] = isoBandNextOTR[154] = 1;
  isoBandNextXLT[64] = isoBandNextXLT[106] = 0;
  isoBandNextYLT[64] = isoBandNextYLT[106] = 1;
  isoBandNextOLT[64] = isoBandNextOLT[106] = 0;
  isoBandNextXTL[64] = isoBandNextXTL[106] = -1;
  isoBandNextYTL[64] = isoBandNextYTL[106] = 0;
  isoBandNextOTL[64] = isoBandNextOTL[106] = 1;
  isoBandNextXLT[2] = isoBandNextXLT[168] = 0;
  isoBandNextYLT[2] = isoBandNextYLT[168] = -1;
  isoBandNextOLT[2] = isoBandNextOLT[168] = 1;
  isoBandNextXLB[2] = isoBandNextXLB[168] = 0;
  isoBandNextYLB[2] = isoBandNextYLB[168] = -1;
  isoBandNextOLB[2] = isoBandNextOLB[168] = 0;
  isoBandNextXBL[2] = isoBandNextXBL[168] = -1;
  isoBandNextYBL[2] = isoBandNextYBL[168] = 0;
  isoBandNextOBL[2] = isoBandNextOBL[168] = 0;
  isoBandNextXBR[2] = isoBandNextXBR[168] = -1;
  isoBandNextYBR[2] = isoBandNextYBR[168] = 0;
  isoBandNextOBR[2] = isoBandNextOBR[168] = 1;
  isoBandNextXRT[8] = isoBandNextXRT[162] = 0;
  isoBandNextYRT[8] = isoBandNextYRT[162] = -1;
  isoBandNextORT[8] = isoBandNextORT[162] = 0;
  isoBandNextXRB[8] = isoBandNextXRB[162] = 0;
  isoBandNextYRB[8] = isoBandNextYRB[162] = -1;
  isoBandNextORB[8] = isoBandNextORB[162] = 1;
  isoBandNextXBL[8] = isoBandNextXBL[162] = 1;
  isoBandNextYBL[8] = isoBandNextYBL[162] = 0;
  isoBandNextOBL[8] = isoBandNextOBL[162] = 1;
  isoBandNextXBR[8] = isoBandNextXBR[162] = 1;
  isoBandNextYBR[8] = isoBandNextYBR[162] = 0;
  isoBandNextOBR[8] = isoBandNextOBR[162] = 0;
  isoBandNextXRT[32] = isoBandNextXRT[138] = 0;
  isoBandNextYRT[32] = isoBandNextYRT[138] = 1;
  isoBandNextORT[32] = isoBandNextORT[138] = 1;
  isoBandNextXRB[32] = isoBandNextXRB[138] = 0;
  isoBandNextYRB[32] = isoBandNextYRB[138] = 1;
  isoBandNextORB[32] = isoBandNextORB[138] = 0;
  isoBandNextXTL[32] = isoBandNextXTL[138] = 1;
  isoBandNextYTL[32] = isoBandNextYTL[138] = 0;
  isoBandNextOTL[32] = isoBandNextOTL[138] = 0;
  isoBandNextXTR[32] = isoBandNextXTR[138] = 1;
  isoBandNextYTR[32] = isoBandNextYTR[138] = 0;
  isoBandNextOTR[32] = isoBandNextOTR[138] = 1;
  isoBandNextXLB[128] = isoBandNextXLB[42] = 0;
  isoBandNextYLB[128] = isoBandNextYLB[42] = 1;
  isoBandNextOLB[128] = isoBandNextOLB[42] = 1;
  isoBandNextXLT[128] = isoBandNextXLT[42] = 0;
  isoBandNextYLT[128] = isoBandNextYLT[42] = 1;
  isoBandNextOLT[128] = isoBandNextOLT[42] = 0;
  isoBandNextXTL[128] = isoBandNextXTL[42] = -1;
  isoBandNextYTL[128] = isoBandNextYTL[42] = 0;
  isoBandNextOTL[128] = isoBandNextOTL[42] = 1;
  isoBandNextXTR[128] = isoBandNextXTR[42] = -1;
  isoBandNextYTR[128] = isoBandNextYTR[42] = 0;
  isoBandNextOTR[128] = isoBandNextOTR[42] = 0;
  isoBandNextXRB[5] = isoBandNextXRB[165] = -1;
  isoBandNextYRB[5] = isoBandNextYRB[165] = 0;
  isoBandNextORB[5] = isoBandNextORB[165] = 0;
  isoBandNextXLB[5] = isoBandNextXLB[165] = 1;
  isoBandNextYLB[5] = isoBandNextYLB[165] = 0;
  isoBandNextOLB[5] = isoBandNextOLB[165] = 0;
  isoBandNextXBR[20] = isoBandNextXBR[150] = 0;
  isoBandNextYBR[20] = isoBandNextYBR[150] = 1;
  isoBandNextOBR[20] = isoBandNextOBR[150] = 1;
  isoBandNextXTR[20] = isoBandNextXTR[150] = 0;
  isoBandNextYTR[20] = isoBandNextYTR[150] = -1;
  isoBandNextOTR[20] = isoBandNextOTR[150] = 1;
  isoBandNextXRT[80] = isoBandNextXRT[90] = -1;
  isoBandNextYRT[80] = isoBandNextYRT[90] = 0;
  isoBandNextORT[80] = isoBandNextORT[90] = 1;
  isoBandNextXLT[80] = isoBandNextXLT[90] = 1;
  isoBandNextYLT[80] = isoBandNextYLT[90] = 0;
  isoBandNextOLT[80] = isoBandNextOLT[90] = 1;
  isoBandNextXBL[65] = isoBandNextXBL[105] = 0;
  isoBandNextYBL[65] = isoBandNextYBL[105] = 1;
  isoBandNextOBL[65] = isoBandNextOBL[105] = 0;
  isoBandNextXTL[65] = isoBandNextXTL[105] = 0;
  isoBandNextYTL[65] = isoBandNextYTL[105] = -1;
  isoBandNextOTL[65] = isoBandNextOTL[105] = 0;
  isoBandNextXRT[160] = isoBandNextXRT[10] = -1;
  isoBandNextYRT[160] = isoBandNextYRT[10] = 0;
  isoBandNextORT[160] = isoBandNextORT[10] = 1;
  isoBandNextXRB[160] = isoBandNextXRB[10] = -1;
  isoBandNextYRB[160] = isoBandNextYRB[10] = 0;
  isoBandNextORB[160] = isoBandNextORB[10] = 0;
  isoBandNextXLB[160] = isoBandNextXLB[10] = 1;
  isoBandNextYLB[160] = isoBandNextYLB[10] = 0;
  isoBandNextOLB[160] = isoBandNextOLB[10] = 0;
  isoBandNextXLT[160] = isoBandNextXLT[10] = 1;
  isoBandNextYLT[160] = isoBandNextYLT[10] = 0;
  isoBandNextOLT[160] = isoBandNextOLT[10] = 1;
  isoBandNextXBR[130] = isoBandNextXBR[40] = 0;
  isoBandNextYBR[130] = isoBandNextYBR[40] = 1;
  isoBandNextOBR[130] = isoBandNextOBR[40] = 1;
  isoBandNextXBL[130] = isoBandNextXBL[40] = 0;
  isoBandNextYBL[130] = isoBandNextYBL[40] = 1;
  isoBandNextOBL[130] = isoBandNextOBL[40] = 0;
  isoBandNextXTL[130] = isoBandNextXTL[40] = 0;
  isoBandNextYTL[130] = isoBandNextYTL[40] = -1;
  isoBandNextOTL[130] = isoBandNextOTL[40] = 0;
  isoBandNextXTR[130] = isoBandNextXTR[40] = 0;
  isoBandNextYTR[130] = isoBandNextYTR[40] = -1;
  isoBandNextOTR[130] = isoBandNextOTR[40] = 1;
  isoBandNextXRB[37] = isoBandNextXRB[133] = 0;
  isoBandNextYRB[37] = isoBandNextYRB[133] = 1;
  isoBandNextORB[37] = isoBandNextORB[133] = 1;
  isoBandNextXLB[37] = isoBandNextXLB[133] = 0;
  isoBandNextYLB[37] = isoBandNextYLB[133] = 1;
  isoBandNextOLB[37] = isoBandNextOLB[133] = 0;
  isoBandNextXTL[37] = isoBandNextXTL[133] = -1;
  isoBandNextYTL[37] = isoBandNextYTL[133] = 0;
  isoBandNextOTL[37] = isoBandNextOTL[133] = 0;
  isoBandNextXTR[37] = isoBandNextXTR[133] = 1;
  isoBandNextYTR[37] = isoBandNextYTR[133] = 0;
  isoBandNextOTR[37] = isoBandNextOTR[133] = 0;
  isoBandNextXBR[148] = isoBandNextXBR[22] = -1;
  isoBandNextYBR[148] = isoBandNextYBR[22] = 0;
  isoBandNextOBR[148] = isoBandNextOBR[22] = 0;
  isoBandNextXLB[148] = isoBandNextXLB[22] = 0;
  isoBandNextYLB[148] = isoBandNextYLB[22] = -1;
  isoBandNextOLB[148] = isoBandNextOLB[22] = 1;
  isoBandNextXLT[148] = isoBandNextXLT[22] = 0;
  isoBandNextYLT[148] = isoBandNextYLT[22] = 1;
  isoBandNextOLT[148] = isoBandNextOLT[22] = 1;
  isoBandNextXTR[148] = isoBandNextXTR[22] = -1;
  isoBandNextYTR[148] = isoBandNextYTR[22] = 0;
  isoBandNextOTR[148] = isoBandNextOTR[22] = 1;
  isoBandNextXRT[82] = isoBandNextXRT[88] = 0;
  isoBandNextYRT[82] = isoBandNextYRT[88] = -1;
  isoBandNextORT[82] = isoBandNextORT[88] = 1;
  isoBandNextXBR[82] = isoBandNextXBR[88] = 1;
  isoBandNextYBR[82] = isoBandNextYBR[88] = 0;
  isoBandNextOBR[82] = isoBandNextOBR[88] = 1;
  isoBandNextXBL[82] = isoBandNextXBL[88] = -1;
  isoBandNextYBL[82] = isoBandNextYBL[88] = 0;
  isoBandNextOBL[82] = isoBandNextOBL[88] = 1;
  isoBandNextXLT[82] = isoBandNextXLT[88] = 0;
  isoBandNextYLT[82] = isoBandNextYLT[88] = -1;
  isoBandNextOLT[82] = isoBandNextOLT[88] = 0;
  isoBandNextXRT[73] = isoBandNextXRT[97] = 0;
  isoBandNextYRT[73] = isoBandNextYRT[97] = 1;
  isoBandNextORT[73] = isoBandNextORT[97] = 0;
  isoBandNextXRB[73] = isoBandNextXRB[97] = 0;
  isoBandNextYRB[73] = isoBandNextYRB[97] = -1;
  isoBandNextORB[73] = isoBandNextORB[97] = 0;
  isoBandNextXBL[73] = isoBandNextXBL[97] = 1;
  isoBandNextYBL[73] = isoBandNextYBL[97] = 0;
  isoBandNextOBL[73] = isoBandNextOBL[97] = 0;
  isoBandNextXTL[73] = isoBandNextXTL[97] = 1;
  isoBandNextYTL[73] = isoBandNextYTL[97] = 0;
  isoBandNextOTL[73] = isoBandNextOTL[97] = 1;
  isoBandNextXRT[145] = isoBandNextXRT[25] = 0;
  isoBandNextYRT[145] = isoBandNextYRT[25] = -1;
  isoBandNextORT[145] = isoBandNextORT[25] = 0;
  isoBandNextXBL[145] = isoBandNextXBL[25] = 1;
  isoBandNextYBL[145] = isoBandNextYBL[25] = 0;
  isoBandNextOBL[145] = isoBandNextOBL[25] = 1;
  isoBandNextXLB[145] = isoBandNextXLB[25] = 0;
  isoBandNextYLB[145] = isoBandNextYLB[25] = 1;
  isoBandNextOLB[145] = isoBandNextOLB[25] = 1;
  isoBandNextXTR[145] = isoBandNextXTR[25] = -1;
  isoBandNextYTR[145] = isoBandNextYTR[25] = 0;
  isoBandNextOTR[145] = isoBandNextOTR[25] = 0;
  isoBandNextXRB[70] = isoBandNextXRB[100] = 0;
  isoBandNextYRB[70] = isoBandNextYRB[100] = 1;
  isoBandNextORB[70] = isoBandNextORB[100] = 0;
  isoBandNextXBR[70] = isoBandNextXBR[100] = -1;
  isoBandNextYBR[70] = isoBandNextYBR[100] = 0;
  isoBandNextOBR[70] = isoBandNextOBR[100] = 1;
  isoBandNextXLT[70] = isoBandNextXLT[100] = 0;
  isoBandNextYLT[70] = isoBandNextYLT[100] = -1;
  isoBandNextOLT[70] = isoBandNextOLT[100] = 1;
  isoBandNextXTL[70] = isoBandNextXTL[100] = 1;
  isoBandNextYTL[70] = isoBandNextYTL[100] = 0;
  isoBandNextOTL[70] = isoBandNextOTL[100] = 0;
  isoBandNextXRB[101] = isoBandNextXRB[69] = 0;
  isoBandNextYRB[101] = isoBandNextYRB[69] = 1;
  isoBandNextORB[101] = isoBandNextORB[69] = 0;
  isoBandNextXTL[101] = isoBandNextXTL[69] = 1;
  isoBandNextYTL[101] = isoBandNextYTL[69] = 0;
  isoBandNextOTL[101] = isoBandNextOTL[69] = 0;
  isoBandNextXLB[149] = isoBandNextXLB[21] = 0;
  isoBandNextYLB[149] = isoBandNextYLB[21] = 1;
  isoBandNextOLB[149] = isoBandNextOLB[21] = 1;
  isoBandNextXTR[149] = isoBandNextXTR[21] = -1;
  isoBandNextYTR[149] = isoBandNextYTR[21] = 0;
  isoBandNextOTR[149] = isoBandNextOTR[21] = 0;
  isoBandNextXBR[86] = isoBandNextXBR[84] = -1;
  isoBandNextYBR[86] = isoBandNextYBR[84] = 0;
  isoBandNextOBR[86] = isoBandNextOBR[84] = 1;
  isoBandNextXLT[86] = isoBandNextXLT[84] = 0;
  isoBandNextYLT[86] = isoBandNextYLT[84] = -1;
  isoBandNextOLT[86] = isoBandNextOLT[84] = 1;
  isoBandNextXRT[89] = isoBandNextXRT[81] = 0;
  isoBandNextYRT[89] = isoBandNextYRT[81] = -1;
  isoBandNextORT[89] = isoBandNextORT[81] = 0;
  isoBandNextXBL[89] = isoBandNextXBL[81] = 1;
  isoBandNextYBL[89] = isoBandNextYBL[81] = 0;
  isoBandNextOBL[89] = isoBandNextOBL[81] = 1;
  isoBandNextXRT[96] = isoBandNextXRT[74] = 0;
  isoBandNextYRT[96] = isoBandNextYRT[74] = 1;
  isoBandNextORT[96] = isoBandNextORT[74] = 0;
  isoBandNextXRB[96] = isoBandNextXRB[74] = -1;
  isoBandNextYRB[96] = isoBandNextYRB[74] = 0;
  isoBandNextORB[96] = isoBandNextORB[74] = 1;
  isoBandNextXLT[96] = isoBandNextXLT[74] = 1;
  isoBandNextYLT[96] = isoBandNextYLT[74] = 0;
  isoBandNextOLT[96] = isoBandNextOLT[74] = 0;
  isoBandNextXTL[96] = isoBandNextXTL[74] = 1;
  isoBandNextYTL[96] = isoBandNextYTL[74] = 0;
  isoBandNextOTL[96] = isoBandNextOTL[74] = 1;
  isoBandNextXRT[24] = isoBandNextXRT[146] = 0;
  isoBandNextYRT[24] = isoBandNextYRT[146] = -1;
  isoBandNextORT[24] = isoBandNextORT[146] = 1;
  isoBandNextXBR[24] = isoBandNextXBR[146] = 1;
  isoBandNextYBR[24] = isoBandNextYBR[146] = 0;
  isoBandNextOBR[24] = isoBandNextOBR[146] = 1;
  isoBandNextXBL[24] = isoBandNextXBL[146] = 0;
  isoBandNextYBL[24] = isoBandNextYBL[146] = 1;
  isoBandNextOBL[24] = isoBandNextOBL[146] = 1;
  isoBandNextXTR[24] = isoBandNextXTR[146] = 0;
  isoBandNextYTR[24] = isoBandNextYTR[146] = -1;
  isoBandNextOTR[24] = isoBandNextOTR[146] = 0;
  isoBandNextXRB[6] = isoBandNextXRB[164] = -1;
  isoBandNextYRB[6] = isoBandNextYRB[164] = 0;
  isoBandNextORB[6] = isoBandNextORB[164] = 1;
  isoBandNextXBR[6] = isoBandNextXBR[164] = -1;
  isoBandNextYBR[6] = isoBandNextYBR[164] = 0;
  isoBandNextOBR[6] = isoBandNextOBR[164] = 0;
  isoBandNextXLB[6] = isoBandNextXLB[164] = 0;
  isoBandNextYLB[6] = isoBandNextYLB[164] = -1;
  isoBandNextOLB[6] = isoBandNextOLB[164] = 1;
  isoBandNextXLT[6] = isoBandNextXLT[164] = 1;
  isoBandNextYLT[6] = isoBandNextYLT[164] = 0;
  isoBandNextOLT[6] = isoBandNextOLT[164] = 0;
  isoBandNextXBL[129] = isoBandNextXBL[41] = 0;
  isoBandNextYBL[129] = isoBandNextYBL[41] = 1;
  isoBandNextOBL[129] = isoBandNextOBL[41] = 1;
  isoBandNextXLB[129] = isoBandNextXLB[41] = 0;
  isoBandNextYLB[129] = isoBandNextYLB[41] = 1;
  isoBandNextOLB[129] = isoBandNextOLB[41] = 0;
  isoBandNextXTL[129] = isoBandNextXTL[41] = -1;
  isoBandNextYTL[129] = isoBandNextYTL[41] = 0;
  isoBandNextOTL[129] = isoBandNextOTL[41] = 0;
  isoBandNextXTR[129] = isoBandNextXTR[41] = 0;
  isoBandNextYTR[129] = isoBandNextYTR[41] = -1;
  isoBandNextOTR[129] = isoBandNextOTR[41] = 0;
  isoBandNextXBR[66] = isoBandNextXBR[104] = 0;
  isoBandNextYBR[66] = isoBandNextYBR[104] = 1;
  isoBandNextOBR[66] = isoBandNextOBR[104] = 0;
  isoBandNextXBL[66] = isoBandNextXBL[104] = -1;
  isoBandNextYBL[66] = isoBandNextYBL[104] = 0;
  isoBandNextOBL[66] = isoBandNextOBL[104] = 1;
  isoBandNextXLT[66] = isoBandNextXLT[104] = 0;
  isoBandNextYLT[66] = isoBandNextYLT[104] = -1;
  isoBandNextOLT[66] = isoBandNextOLT[104] = 0;
  isoBandNextXTL[66] = isoBandNextXTL[104] = 0;
  isoBandNextYTL[66] = isoBandNextYTL[104] = -1;
  isoBandNextOTL[66] = isoBandNextOTL[104] = 1;
  isoBandNextXRT[144] = isoBandNextXRT[26] = -1;
  isoBandNextYRT[144] = isoBandNextYRT[26] = 0;
  isoBandNextORT[144] = isoBandNextORT[26] = 0;
  isoBandNextXLB[144] = isoBandNextXLB[26] = 1;
  isoBandNextYLB[144] = isoBandNextYLB[26] = 0;
  isoBandNextOLB[144] = isoBandNextOLB[26] = 1;
  isoBandNextXLT[144] = isoBandNextXLT[26] = 0;
  isoBandNextYLT[144] = isoBandNextYLT[26] = 1;
  isoBandNextOLT[144] = isoBandNextOLT[26] = 1;
  isoBandNextXTR[144] = isoBandNextXTR[26] = -1;
  isoBandNextYTR[144] = isoBandNextYTR[26] = 0;
  isoBandNextOTR[144] = isoBandNextOTR[26] = 1;
  isoBandNextXRB[36] = isoBandNextXRB[134] = 0;
  isoBandNextYRB[36] = isoBandNextYRB[134] = 1;
  isoBandNextORB[36] = isoBandNextORB[134] = 1;
  isoBandNextXBR[36] = isoBandNextXBR[134] = 0;
  isoBandNextYBR[36] = isoBandNextYBR[134] = 1;
  isoBandNextOBR[36] = isoBandNextOBR[134] = 0;
  isoBandNextXTL[36] = isoBandNextXTL[134] = 0;
  isoBandNextYTL[36] = isoBandNextYTL[134] = -1;
  isoBandNextOTL[36] = isoBandNextOTL[134] = 1;
  isoBandNextXTR[36] = isoBandNextXTR[134] = 1;
  isoBandNextYTR[36] = isoBandNextYTR[134] = 0;
  isoBandNextOTR[36] = isoBandNextOTR[134] = 0;
  isoBandNextXRT[9] = isoBandNextXRT[161] = -1;
  isoBandNextYRT[9] = isoBandNextYRT[161] = 0;
  isoBandNextORT[9] = isoBandNextORT[161] = 0;
  isoBandNextXRB[9] = isoBandNextXRB[161] = 0;
  isoBandNextYRB[9] = isoBandNextYRB[161] = -1;
  isoBandNextORB[9] = isoBandNextORB[161] = 0;
  isoBandNextXBL[9] = isoBandNextXBL[161] = 1;
  isoBandNextYBL[9] = isoBandNextYBL[161] = 0;
  isoBandNextOBL[9] = isoBandNextOBL[161] = 0;
  isoBandNextXLB[9] = isoBandNextXLB[161] = 1;
  isoBandNextYLB[9] = isoBandNextYLB[161] = 0;
  isoBandNextOLB[9] = isoBandNextOLB[161] = 1;
  isoBandNextXRT[136] = 0;
  isoBandNextYRT[136] = 1;
  isoBandNextORT[136] = 1;
  isoBandNextXRB[136] = 0;
  isoBandNextYRB[136] = 1;
  isoBandNextORB[136] = 0;
  isoBandNextXBR[136] = -1;
  isoBandNextYBR[136] = 0;
  isoBandNextOBR[136] = 1;
  isoBandNextXBL[136] = -1;
  isoBandNextYBL[136] = 0;
  isoBandNextOBL[136] = 0;
  isoBandNextXLB[136] = 0;
  isoBandNextYLB[136] = -1;
  isoBandNextOLB[136] = 0;
  isoBandNextXLT[136] = 0;
  isoBandNextYLT[136] = -1;
  isoBandNextOLT[136] = 1;
  isoBandNextXTL[136] = 1;
  isoBandNextYTL[136] = 0;
  isoBandNextOTL[136] = 0;
  isoBandNextXTR[136] = 1;
  isoBandNextYTR[136] = 0;
  isoBandNextOTR[136] = 1;
  isoBandNextXRT[34] = 0;
  isoBandNextYRT[34] = -1;
  isoBandNextORT[34] = 0;
  isoBandNextXRB[34] = 0;
  isoBandNextYRB[34] = -1;
  isoBandNextORB[34] = 1;
  isoBandNextXBR[34] = 1;
  isoBandNextYBR[34] = 0;
  isoBandNextOBR[34] = 0;
  isoBandNextXBL[34] = 1;
  isoBandNextYBL[34] = 0;
  isoBandNextOBL[34] = 1;
  isoBandNextXLB[34] = 0;
  isoBandNextYLB[34] = 1;
  isoBandNextOLB[34] = 1;
  isoBandNextXLT[34] = 0;
  isoBandNextYLT[34] = 1;
  isoBandNextOLT[34] = 0;
  isoBandNextXTL[34] = -1;
  isoBandNextYTL[34] = 0;
  isoBandNextOTL[34] = 1;
  isoBandNextXTR[34] = -1;
  isoBandNextYTR[34] = 0;
  isoBandNextOTR[34] = 0;
  isoBandNextXRT[35] = 0;
  isoBandNextYRT[35] = 1;
  isoBandNextORT[35] = 1;
  isoBandNextXRB[35] = 0;
  isoBandNextYRB[35] = -1;
  isoBandNextORB[35] = 1;
  isoBandNextXBR[35] = 1;
  isoBandNextYBR[35] = 0;
  isoBandNextOBR[35] = 0;
  isoBandNextXBL[35] = -1;
  isoBandNextYBL[35] = 0;
  isoBandNextOBL[35] = 0;
  isoBandNextXLB[35] = 0;
  isoBandNextYLB[35] = -1;
  isoBandNextOLB[35] = 0;
  isoBandNextXLT[35] = 0;
  isoBandNextYLT[35] = 1;
  isoBandNextOLT[35] = 0;
  isoBandNextXTL[35] = -1;
  isoBandNextYTL[35] = 0;
  isoBandNextOTL[35] = 1;
  isoBandNextXTR[35] = 1;
  isoBandNextYTR[35] = 0;
  isoBandNextOTR[35] = 1;
  isoBandNextXRT[153] = 0;
  isoBandNextYRT[153] = 1;
  isoBandNextORT[153] = 1;
  isoBandNextXBL[153] = -1;
  isoBandNextYBL[153] = 0;
  isoBandNextOBL[153] = 0;
  isoBandNextXLB[153] = 0;
  isoBandNextYLB[153] = -1;
  isoBandNextOLB[153] = 0;
  isoBandNextXTR[153] = 1;
  isoBandNextYTR[153] = 0;
  isoBandNextOTR[153] = 1;
  isoBandNextXRB[102] = 0;
  isoBandNextYRB[102] = -1;
  isoBandNextORB[102] = 1;
  isoBandNextXBR[102] = 1;
  isoBandNextYBR[102] = 0;
  isoBandNextOBR[102] = 0;
  isoBandNextXLT[102] = 0;
  isoBandNextYLT[102] = 1;
  isoBandNextOLT[102] = 0;
  isoBandNextXTL[102] = -1;
  isoBandNextYTL[102] = 0;
  isoBandNextOTL[102] = 1;
  isoBandNextXRT[155] = 0;
  isoBandNextYRT[155] = -1;
  isoBandNextORT[155] = 0;
  isoBandNextXBL[155] = 1;
  isoBandNextYBL[155] = 0;
  isoBandNextOBL[155] = 1;
  isoBandNextXLB[155] = 0;
  isoBandNextYLB[155] = 1;
  isoBandNextOLB[155] = 1;
  isoBandNextXTR[155] = -1;
  isoBandNextYTR[155] = 0;
  isoBandNextOTR[155] = 0;
  isoBandNextXRB[103] = 0;
  isoBandNextYRB[103] = 1;
  isoBandNextORB[103] = 0;
  isoBandNextXBR[103] = -1;
  isoBandNextYBR[103] = 0;
  isoBandNextOBR[103] = 1;
  isoBandNextXLT[103] = 0;
  isoBandNextYLT[103] = -1;
  isoBandNextOLT[103] = 1;
  isoBandNextXTL[103] = 1;
  isoBandNextYTL[103] = 0;
  isoBandNextOTL[103] = 0;
  isoBandNextXRT[152] = 0;
  isoBandNextYRT[152] = 1;
  isoBandNextORT[152] = 1;
  isoBandNextXBR[152] = -1;
  isoBandNextYBR[152] = 0;
  isoBandNextOBR[152] = 1;
  isoBandNextXBL[152] = -1;
  isoBandNextYBL[152] = 0;
  isoBandNextOBL[152] = 0;
  isoBandNextXLB[152] = 0;
  isoBandNextYLB[152] = -1;
  isoBandNextOLB[152] = 0;
  isoBandNextXLT[152] = 0;
  isoBandNextYLT[152] = -1;
  isoBandNextOLT[152] = 1;
  isoBandNextXTR[152] = 1;
  isoBandNextYTR[152] = 0;
  isoBandNextOTR[152] = 1;
  isoBandNextXRT[156] = 0;
  isoBandNextYRT[156] = -1;
  isoBandNextORT[156] = 1;
  isoBandNextXBR[156] = 1;
  isoBandNextYBR[156] = 0;
  isoBandNextOBR[156] = 1;
  isoBandNextXBL[156] = -1;
  isoBandNextYBL[156] = 0;
  isoBandNextOBL[156] = 0;
  isoBandNextXLB[156] = 0;
  isoBandNextYLB[156] = -1;
  isoBandNextOLB[156] = 0;
  isoBandNextXLT[156] = 0;
  isoBandNextYLT[156] = 1;
  isoBandNextOLT[156] = 1;
  isoBandNextXTR[156] = -1;
  isoBandNextYTR[156] = 0;
  isoBandNextOTR[156] = 1;
  isoBandNextXRT[137] = 0;
  isoBandNextYRT[137] = 1;
  isoBandNextORT[137] = 1;
  isoBandNextXRB[137] = 0;
  isoBandNextYRB[137] = 1;
  isoBandNextORB[137] = 0;
  isoBandNextXBL[137] = -1;
  isoBandNextYBL[137] = 0;
  isoBandNextOBL[137] = 0;
  isoBandNextXLB[137] = 0;
  isoBandNextYLB[137] = -1;
  isoBandNextOLB[137] = 0;
  isoBandNextXTL[137] = 1;
  isoBandNextYTL[137] = 0;
  isoBandNextOTL[137] = 0;
  isoBandNextXTR[137] = 1;
  isoBandNextYTR[137] = 0;
  isoBandNextOTR[137] = 1;
  isoBandNextXRT[139] = 0;
  isoBandNextYRT[139] = 1;
  isoBandNextORT[139] = 1;
  isoBandNextXRB[139] = 0;
  isoBandNextYRB[139] = -1;
  isoBandNextORB[139] = 0;
  isoBandNextXBL[139] = 1;
  isoBandNextYBL[139] = 0;
  isoBandNextOBL[139] = 0;
  isoBandNextXLB[139] = 0;
  isoBandNextYLB[139] = 1;
  isoBandNextOLB[139] = 0;
  isoBandNextXTL[139] = -1;
  isoBandNextYTL[139] = 0;
  isoBandNextOTL[139] = 0;
  isoBandNextXTR[139] = 1;
  isoBandNextYTR[139] = 0;
  isoBandNextOTR[139] = 1;
  isoBandNextXRT[98] = 0;
  isoBandNextYRT[98] = -1;
  isoBandNextORT[98] = 0;
  isoBandNextXRB[98] = 0;
  isoBandNextYRB[98] = -1;
  isoBandNextORB[98] = 1;
  isoBandNextXBR[98] = 1;
  isoBandNextYBR[98] = 0;
  isoBandNextOBR[98] = 0;
  isoBandNextXBL[98] = 1;
  isoBandNextYBL[98] = 0;
  isoBandNextOBL[98] = 1;
  isoBandNextXLT[98] = 0;
  isoBandNextYLT[98] = 1;
  isoBandNextOLT[98] = 0;
  isoBandNextXTL[98] = -1;
  isoBandNextYTL[98] = 0;
  isoBandNextOTL[98] = 1;
  isoBandNextXRT[99] = 0;
  isoBandNextYRT[99] = 1;
  isoBandNextORT[99] = 0;
  isoBandNextXRB[99] = 0;
  isoBandNextYRB[99] = -1;
  isoBandNextORB[99] = 1;
  isoBandNextXBR[99] = 1;
  isoBandNextYBR[99] = 0;
  isoBandNextOBR[99] = 0;
  isoBandNextXBL[99] = -1;
  isoBandNextYBL[99] = 0;
  isoBandNextOBL[99] = 1;
  isoBandNextXLT[99] = 0;
  isoBandNextYLT[99] = -1;
  isoBandNextOLT[99] = 0;
  isoBandNextXTL[99] = 1;
  isoBandNextYTL[99] = 0;
  isoBandNextOTL[99] = 1;
  isoBandNextXRB[38] = 0;
  isoBandNextYRB[38] = -1;
  isoBandNextORB[38] = 1;
  isoBandNextXBR[38] = 1;
  isoBandNextYBR[38] = 0;
  isoBandNextOBR[38] = 0;
  isoBandNextXLB[38] = 0;
  isoBandNextYLB[38] = 1;
  isoBandNextOLB[38] = 1;
  isoBandNextXLT[38] = 0;
  isoBandNextYLT[38] = 1;
  isoBandNextOLT[38] = 0;
  isoBandNextXTL[38] = -1;
  isoBandNextYTL[38] = 0;
  isoBandNextOTL[38] = 1;
  isoBandNextXTR[38] = -1;
  isoBandNextYTR[38] = 0;
  isoBandNextOTR[38] = 0;
  isoBandNextXRB[39] = 0;
  isoBandNextYRB[39] = 1;
  isoBandNextORB[39] = 1;
  isoBandNextXBR[39] = -1;
  isoBandNextYBR[39] = 0;
  isoBandNextOBR[39] = 0;
  isoBandNextXLB[39] = 0;
  isoBandNextYLB[39] = -1;
  isoBandNextOLB[39] = 1;
  isoBandNextXLT[39] = 0;
  isoBandNextYLT[39] = 1;
  isoBandNextOLT[39] = 0;
  isoBandNextXTL[39] = -1;
  isoBandNextYTL[39] = 0;
  isoBandNextOTL[39] = 1;
  isoBandNextXTR[39] = 1;
  isoBandNextYTR[39] = 0;
  isoBandNextOTR[39] = 0;
  var p00 = function(cell) {
    return [
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p01 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0]
    ];
  };
  var p02 = function(cell) {
    return [
      [cell.topright, 1],
      [1, 1],
      [1, cell.righttop]
    ];
  };
  var p03 = function(cell) {
    return [
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p04 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p05 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [1, cell.righttop],
      [1, cell.rightbottom]
    ];
  };
  var p06 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p07 = function(cell) {
    return [
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p08 = function(cell) {
    return [
      [0, 0],
      [0, cell.leftbottom],
      [1, cell.rightbottom],
      [1, 0]
    ];
  };
  var p09 = function(cell) {
    return [
      [1, 0],
      [cell.bottomright, 0],
      [cell.topright, 1],
      [1, 1]
    ];
  };
  var p10 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [0, cell.lefttop],
      [0, 1]
    ];
  };
  var p11 = function(cell) {
    return [
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p12 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p13 = function(cell) {
    return [
      [cell.topleft, 1],
      [cell.topright, 1],
      [cell.bottomright, 0],
      [cell.bottomleft, 0]
    ];
  };
  var p14 = function() {
    return [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0]
    ];
  };
  var p15 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p16 = function(cell) {
    return [
      [cell.topright, 1],
      [1, 1],
      [1, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p17 = function(cell) {
    return [
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [1, 1]
    ];
  };
  var p18 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1]
    ];
  };
  var p19 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p20 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [cell.topright, 1]
    ];
  };
  var p21 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p22 = function(cell) {
    return [
      [cell.topright, 1],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1]
    ];
  };
  var p23 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p24 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p25 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p26 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p27 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p28 = function(cell) {
    return [
      [1, 1],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p29 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1]
    ];
  };
  var p30 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p31 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topright, 1]
    ];
  };
  var p32 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p33 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p34 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topright, 1]
    ];
  };
  var p35 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p36 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p37 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p38 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p39 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var isoBandEdgeRT = [];
  var isoBandEdgeRB = [];
  var isoBandEdgeBR = [];
  var isoBandEdgeBL = [];
  var isoBandEdgeLB = [];
  var isoBandEdgeLT = [];
  var isoBandEdgeTL = [];
  var isoBandEdgeTR = [];
  isoBandEdgeBL[1] = isoBandEdgeLB[1] = 18;
  isoBandEdgeBL[169] = isoBandEdgeLB[169] = 18;
  isoBandEdgeBR[4] = isoBandEdgeRB[4] = 12;
  isoBandEdgeBR[166] = isoBandEdgeRB[166] = 12;
  isoBandEdgeRT[16] = isoBandEdgeTR[16] = 4;
  isoBandEdgeRT[154] = isoBandEdgeTR[154] = 4;
  isoBandEdgeLT[64] = isoBandEdgeTL[64] = 22;
  isoBandEdgeLT[106] = isoBandEdgeTL[106] = 22;
  isoBandEdgeBR[2] = isoBandEdgeLT[2] = 17;
  isoBandEdgeBL[2] = isoBandEdgeLB[2] = 18;
  isoBandEdgeBR[168] = isoBandEdgeLT[168] = 17;
  isoBandEdgeBL[168] = isoBandEdgeLB[168] = 18;
  isoBandEdgeRT[8] = isoBandEdgeBL[8] = 9;
  isoBandEdgeRB[8] = isoBandEdgeBR[8] = 12;
  isoBandEdgeRT[162] = isoBandEdgeBL[162] = 9;
  isoBandEdgeRB[162] = isoBandEdgeBR[162] = 12;
  isoBandEdgeRT[32] = isoBandEdgeTR[32] = 4;
  isoBandEdgeRB[32] = isoBandEdgeTL[32] = 1;
  isoBandEdgeRT[138] = isoBandEdgeTR[138] = 4;
  isoBandEdgeRB[138] = isoBandEdgeTL[138] = 1;
  isoBandEdgeLB[128] = isoBandEdgeTR[128] = 21;
  isoBandEdgeLT[128] = isoBandEdgeTL[128] = 22;
  isoBandEdgeLB[42] = isoBandEdgeTR[42] = 21;
  isoBandEdgeLT[42] = isoBandEdgeTL[42] = 22;
  isoBandEdgeRB[5] = isoBandEdgeLB[5] = 14;
  isoBandEdgeRB[165] = isoBandEdgeLB[165] = 14;
  isoBandEdgeBR[20] = isoBandEdgeTR[20] = 6;
  isoBandEdgeBR[150] = isoBandEdgeTR[150] = 6;
  isoBandEdgeRT[80] = isoBandEdgeLT[80] = 11;
  isoBandEdgeRT[90] = isoBandEdgeLT[90] = 11;
  isoBandEdgeBL[65] = isoBandEdgeTL[65] = 3;
  isoBandEdgeBL[105] = isoBandEdgeTL[105] = 3;
  isoBandEdgeRT[160] = isoBandEdgeLT[160] = 11;
  isoBandEdgeRB[160] = isoBandEdgeLB[160] = 14;
  isoBandEdgeRT[10] = isoBandEdgeLT[10] = 11;
  isoBandEdgeRB[10] = isoBandEdgeLB[10] = 14;
  isoBandEdgeBR[130] = isoBandEdgeTR[130] = 6;
  isoBandEdgeBL[130] = isoBandEdgeTL[130] = 3;
  isoBandEdgeBR[40] = isoBandEdgeTR[40] = 6;
  isoBandEdgeBL[40] = isoBandEdgeTL[40] = 3;
  isoBandEdgeRB[101] = isoBandEdgeTL[101] = 1;
  isoBandEdgeRB[69] = isoBandEdgeTL[69] = 1;
  isoBandEdgeLB[149] = isoBandEdgeTR[149] = 21;
  isoBandEdgeLB[21] = isoBandEdgeTR[21] = 21;
  isoBandEdgeBR[86] = isoBandEdgeLT[86] = 17;
  isoBandEdgeBR[84] = isoBandEdgeLT[84] = 17;
  isoBandEdgeRT[89] = isoBandEdgeBL[89] = 9;
  isoBandEdgeRT[81] = isoBandEdgeBL[81] = 9;
  isoBandEdgeRT[96] = isoBandEdgeTL[96] = 0;
  isoBandEdgeRB[96] = isoBandEdgeLT[96] = 15;
  isoBandEdgeRT[74] = isoBandEdgeTL[74] = 0;
  isoBandEdgeRB[74] = isoBandEdgeLT[74] = 15;
  isoBandEdgeRT[24] = isoBandEdgeBR[24] = 8;
  isoBandEdgeBL[24] = isoBandEdgeTR[24] = 7;
  isoBandEdgeRT[146] = isoBandEdgeBR[146] = 8;
  isoBandEdgeBL[146] = isoBandEdgeTR[146] = 7;
  isoBandEdgeRB[6] = isoBandEdgeLT[6] = 15;
  isoBandEdgeBR[6] = isoBandEdgeLB[6] = 16;
  isoBandEdgeRB[164] = isoBandEdgeLT[164] = 15;
  isoBandEdgeBR[164] = isoBandEdgeLB[164] = 16;
  isoBandEdgeBL[129] = isoBandEdgeTR[129] = 7;
  isoBandEdgeLB[129] = isoBandEdgeTL[129] = 20;
  isoBandEdgeBL[41] = isoBandEdgeTR[41] = 7;
  isoBandEdgeLB[41] = isoBandEdgeTL[41] = 20;
  isoBandEdgeBR[66] = isoBandEdgeTL[66] = 2;
  isoBandEdgeBL[66] = isoBandEdgeLT[66] = 19;
  isoBandEdgeBR[104] = isoBandEdgeTL[104] = 2;
  isoBandEdgeBL[104] = isoBandEdgeLT[104] = 19;
  isoBandEdgeRT[144] = isoBandEdgeLB[144] = 10;
  isoBandEdgeLT[144] = isoBandEdgeTR[144] = 23;
  isoBandEdgeRT[26] = isoBandEdgeLB[26] = 10;
  isoBandEdgeLT[26] = isoBandEdgeTR[26] = 23;
  isoBandEdgeRB[36] = isoBandEdgeTR[36] = 5;
  isoBandEdgeBR[36] = isoBandEdgeTL[36] = 2;
  isoBandEdgeRB[134] = isoBandEdgeTR[134] = 5;
  isoBandEdgeBR[134] = isoBandEdgeTL[134] = 2;
  isoBandEdgeRT[9] = isoBandEdgeLB[9] = 10;
  isoBandEdgeRB[9] = isoBandEdgeBL[9] = 13;
  isoBandEdgeRT[161] = isoBandEdgeLB[161] = 10;
  isoBandEdgeRB[161] = isoBandEdgeBL[161] = 13;
  isoBandEdgeRB[37] = isoBandEdgeTR[37] = 5;
  isoBandEdgeLB[37] = isoBandEdgeTL[37] = 20;
  isoBandEdgeRB[133] = isoBandEdgeTR[133] = 5;
  isoBandEdgeLB[133] = isoBandEdgeTL[133] = 20;
  isoBandEdgeBR[148] = isoBandEdgeLB[148] = 16;
  isoBandEdgeLT[148] = isoBandEdgeTR[148] = 23;
  isoBandEdgeBR[22] = isoBandEdgeLB[22] = 16;
  isoBandEdgeLT[22] = isoBandEdgeTR[22] = 23;
  isoBandEdgeRT[82] = isoBandEdgeBR[82] = 8;
  isoBandEdgeBL[82] = isoBandEdgeLT[82] = 19;
  isoBandEdgeRT[88] = isoBandEdgeBR[88] = 8;
  isoBandEdgeBL[88] = isoBandEdgeLT[88] = 19;
  isoBandEdgeRT[73] = isoBandEdgeTL[73] = 0;
  isoBandEdgeRB[73] = isoBandEdgeBL[73] = 13;
  isoBandEdgeRT[97] = isoBandEdgeTL[97] = 0;
  isoBandEdgeRB[97] = isoBandEdgeBL[97] = 13;
  isoBandEdgeRT[145] = isoBandEdgeBL[145] = 9;
  isoBandEdgeLB[145] = isoBandEdgeTR[145] = 21;
  isoBandEdgeRT[25] = isoBandEdgeBL[25] = 9;
  isoBandEdgeLB[25] = isoBandEdgeTR[25] = 21;
  isoBandEdgeRB[70] = isoBandEdgeTL[70] = 1;
  isoBandEdgeBR[70] = isoBandEdgeLT[70] = 17;
  isoBandEdgeRB[100] = isoBandEdgeTL[100] = 1;
  isoBandEdgeBR[100] = isoBandEdgeLT[100] = 17;
  isoBandEdgeRT[34] = isoBandEdgeBL[34] = 9;
  isoBandEdgeRB[34] = isoBandEdgeBR[34] = 12;
  isoBandEdgeLB[34] = isoBandEdgeTR[34] = 21;
  isoBandEdgeLT[34] = isoBandEdgeTL[34] = 22;
  isoBandEdgeRT[136] = isoBandEdgeTR[136] = 4;
  isoBandEdgeRB[136] = isoBandEdgeTL[136] = 1;
  isoBandEdgeBR[136] = isoBandEdgeLT[136] = 17;
  isoBandEdgeBL[136] = isoBandEdgeLB[136] = 18;
  isoBandEdgeRT[35] = isoBandEdgeTR[35] = 4;
  isoBandEdgeRB[35] = isoBandEdgeBR[35] = 12;
  isoBandEdgeBL[35] = isoBandEdgeLB[35] = 18;
  isoBandEdgeLT[35] = isoBandEdgeTL[35] = 22;
  isoBandEdgeRT[153] = isoBandEdgeTR[153] = 4;
  isoBandEdgeBL[153] = isoBandEdgeLB[153] = 18;
  isoBandEdgeRB[102] = isoBandEdgeBR[102] = 12;
  isoBandEdgeLT[102] = isoBandEdgeTL[102] = 22;
  isoBandEdgeRT[155] = isoBandEdgeBL[155] = 9;
  isoBandEdgeLB[155] = isoBandEdgeTR[155] = 23;
  isoBandEdgeRB[103] = isoBandEdgeTL[103] = 1;
  isoBandEdgeBR[103] = isoBandEdgeLT[103] = 17;
  isoBandEdgeRT[152] = isoBandEdgeTR[152] = 4;
  isoBandEdgeBR[152] = isoBandEdgeLT[152] = 17;
  isoBandEdgeBL[152] = isoBandEdgeLB[152] = 18;
  isoBandEdgeRT[156] = isoBandEdgeBR[156] = 8;
  isoBandEdgeBL[156] = isoBandEdgeLB[156] = 18;
  isoBandEdgeLT[156] = isoBandEdgeTR[156] = 23;
  isoBandEdgeRT[137] = isoBandEdgeTR[137] = 4;
  isoBandEdgeRB[137] = isoBandEdgeTL[137] = 1;
  isoBandEdgeBL[137] = isoBandEdgeLB[137] = 18;
  isoBandEdgeRT[139] = isoBandEdgeTR[139] = 4;
  isoBandEdgeRB[139] = isoBandEdgeBL[139] = 13;
  isoBandEdgeLB[139] = isoBandEdgeTL[139] = 20;
  isoBandEdgeRT[98] = isoBandEdgeBL[98] = 9;
  isoBandEdgeRB[98] = isoBandEdgeBR[98] = 12;
  isoBandEdgeLT[98] = isoBandEdgeTL[98] = 22;
  isoBandEdgeRT[99] = isoBandEdgeTL[99] = 0;
  isoBandEdgeRB[99] = isoBandEdgeBR[99] = 12;
  isoBandEdgeBL[99] = isoBandEdgeLT[99] = 19;
  isoBandEdgeRB[38] = isoBandEdgeBR[38] = 12;
  isoBandEdgeLB[38] = isoBandEdgeTR[38] = 21;
  isoBandEdgeLT[38] = isoBandEdgeTL[38] = 22;
  isoBandEdgeRB[39] = isoBandEdgeTR[39] = 5;
  isoBandEdgeBR[39] = isoBandEdgeLB[39] = 16;
  isoBandEdgeLT[39] = isoBandEdgeTL[39] = 22;
  var polygon_table = [];
  polygon_table[1] = polygon_table[169] = p00;
  polygon_table[4] = polygon_table[166] = p01;
  polygon_table[16] = polygon_table[154] = p02;
  polygon_table[64] = polygon_table[106] = p03;
  polygon_table[168] = polygon_table[2] = p04;
  polygon_table[162] = polygon_table[8] = p05;
  polygon_table[138] = polygon_table[32] = p06;
  polygon_table[42] = polygon_table[128] = p07;
  polygon_table[5] = polygon_table[165] = p08;
  polygon_table[20] = polygon_table[150] = p09;
  polygon_table[80] = polygon_table[90] = p10;
  polygon_table[65] = polygon_table[105] = p11;
  polygon_table[160] = polygon_table[10] = p12;
  polygon_table[130] = polygon_table[40] = p13;
  polygon_table[85] = p14;
  polygon_table[101] = polygon_table[69] = p15;
  polygon_table[149] = polygon_table[21] = p16;
  polygon_table[86] = polygon_table[84] = p17;
  polygon_table[89] = polygon_table[81] = p18;
  polygon_table[96] = polygon_table[74] = p19;
  polygon_table[24] = polygon_table[146] = p20;
  polygon_table[6] = polygon_table[164] = p21;
  polygon_table[129] = polygon_table[41] = p22;
  polygon_table[66] = polygon_table[104] = p23;
  polygon_table[144] = polygon_table[26] = p24;
  polygon_table[36] = polygon_table[134] = p25;
  polygon_table[9] = polygon_table[161] = p26;
  polygon_table[37] = polygon_table[133] = p27;
  polygon_table[148] = polygon_table[22] = p28;
  polygon_table[82] = polygon_table[88] = p29;
  polygon_table[73] = polygon_table[97] = p30;
  polygon_table[145] = polygon_table[25] = p31;
  polygon_table[70] = polygon_table[100] = p32;
  polygon_table[34] = function(c) {
    return [p07(c), p05(c)];
  };
  polygon_table[35] = p33;
  polygon_table[136] = function(c) {
    return [p06(c), p04(c)];
  };
  polygon_table[153] = function(c) {
    return [p02(c), p00(c)];
  };
  polygon_table[102] = function(c) {
    return [p01(c), p03(c)];
  };
  polygon_table[155] = p34;
  polygon_table[103] = p35;
  polygon_table[152] = function(c) {
    return [p02(c), p04(c)];
  };
  polygon_table[156] = p36;
  polygon_table[137] = function(c) {
    return [p06(c), p00(c)];
  };
  polygon_table[139] = p37;
  polygon_table[98] = function(c) {
    return [p05(c), p03(c)];
  };
  polygon_table[99] = p38;
  polygon_table[38] = function(c) {
    return [p01(c), p07(c)];
  };
  polygon_table[39] = p39;

  // ../node_modules/@turf/polygonize/dist/es/lib/util.js
  function mathSign(x3) {
    return (x3 > 0) - (x3 < 0) || +x3;
  }
  function orientationIndex(p1, p2, q) {
    var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
    return mathSign(dx1 * dy2 - dx2 * dy1);
  }
  function envelopeIsEqual(env1, env2) {
    var envX1 = env1.geometry.coordinates[0].map(function(c) {
      return c[0];
    }), envY1 = env1.geometry.coordinates[0].map(function(c) {
      return c[1];
    }), envX2 = env2.geometry.coordinates[0].map(function(c) {
      return c[0];
    }), envY2 = env2.geometry.coordinates[0].map(function(c) {
      return c[1];
    });
    return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);
  }
  function envelopeContains(self2, env) {
    return env.geometry.coordinates[0].every(function(c) {
      return booleanPointInPolygon(point(c), self2);
    });
  }
  function coordinatesEqual(coord1, coord2) {
    return coord1[0] === coord2[0] && coord1[1] === coord2[1];
  }

  // ../node_modules/@turf/polygonize/dist/es/lib/Node.js
  var Node = function() {
    function Node2(coordinates) {
      this.id = Node2.buildId(coordinates);
      this.coordinates = coordinates;
      this.innerEdges = [];
      this.outerEdges = [];
      this.outerEdgesSorted = false;
    }
    Node2.buildId = function(coordinates) {
      return coordinates.join(",");
    };
    Node2.prototype.removeInnerEdge = function(edge) {
      this.innerEdges = this.innerEdges.filter(function(e) {
        return e.from.id !== edge.from.id;
      });
    };
    Node2.prototype.removeOuterEdge = function(edge) {
      this.outerEdges = this.outerEdges.filter(function(e) {
        return e.to.id !== edge.to.id;
      });
    };
    Node2.prototype.addOuterEdge = function(edge) {
      this.outerEdges.push(edge);
      this.outerEdgesSorted = false;
    };
    Node2.prototype.sortOuterEdges = function() {
      var _this = this;
      if (!this.outerEdgesSorted) {
        this.outerEdges.sort(function(a2, b) {
          var aNode = a2.to, bNode = b.to;
          if (aNode.coordinates[0] - _this.coordinates[0] >= 0 && bNode.coordinates[0] - _this.coordinates[0] < 0)
            return 1;
          if (aNode.coordinates[0] - _this.coordinates[0] < 0 && bNode.coordinates[0] - _this.coordinates[0] >= 0)
            return -1;
          if (aNode.coordinates[0] - _this.coordinates[0] === 0 && bNode.coordinates[0] - _this.coordinates[0] === 0) {
            if (aNode.coordinates[1] - _this.coordinates[1] >= 0 || bNode.coordinates[1] - _this.coordinates[1] >= 0)
              return aNode.coordinates[1] - bNode.coordinates[1];
            return bNode.coordinates[1] - aNode.coordinates[1];
          }
          var det = orientationIndex(_this.coordinates, aNode.coordinates, bNode.coordinates);
          if (det < 0)
            return 1;
          if (det > 0)
            return -1;
          var d1 = Math.pow(aNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - _this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - _this.coordinates[1], 2);
          return d1 - d2;
        });
        this.outerEdgesSorted = true;
      }
    };
    Node2.prototype.getOuterEdges = function() {
      this.sortOuterEdges();
      return this.outerEdges;
    };
    Node2.prototype.getOuterEdge = function(i) {
      this.sortOuterEdges();
      return this.outerEdges[i];
    };
    Node2.prototype.addInnerEdge = function(edge) {
      this.innerEdges.push(edge);
    };
    return Node2;
  }();
  var Node_default = Node;

  // ../node_modules/@turf/polygonize/dist/es/lib/Edge.js
  var Edge = function() {
    function Edge2(from2, to) {
      this.from = from2;
      this.to = to;
      this.next = void 0;
      this.label = void 0;
      this.symetric = void 0;
      this.ring = void 0;
      this.from.addOuterEdge(this);
      this.to.addInnerEdge(this);
    }
    Edge2.prototype.getSymetric = function() {
      if (!this.symetric) {
        this.symetric = new Edge2(this.to, this.from);
        this.symetric.symetric = this;
      }
      return this.symetric;
    };
    Edge2.prototype.deleteEdge = function() {
      this.from.removeOuterEdge(this);
      this.to.removeInnerEdge(this);
    };
    Edge2.prototype.isEqual = function(edge) {
      return this.from.id === edge.from.id && this.to.id === edge.to.id;
    };
    Edge2.prototype.toString = function() {
      return "Edge { " + this.from.id + " -> " + this.to.id + " }";
    };
    Edge2.prototype.toLineString = function() {
      return lineString([this.from.coordinates, this.to.coordinates]);
    };
    Edge2.prototype.compareTo = function(edge) {
      return orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);
    };
    return Edge2;
  }();
  var Edge_default = Edge;

  // ../node_modules/@turf/polygonize/dist/es/lib/EdgeRing.js
  var EdgeRing = function() {
    function EdgeRing2() {
      this.edges = [];
      this.polygon = void 0;
      this.envelope = void 0;
    }
    EdgeRing2.prototype.push = function(edge) {
      this.edges.push(edge);
      this.polygon = this.envelope = void 0;
    };
    EdgeRing2.prototype.get = function(i) {
      return this.edges[i];
    };
    Object.defineProperty(EdgeRing2.prototype, "length", {
      get: function() {
        return this.edges.length;
      },
      enumerable: true,
      configurable: true
    });
    EdgeRing2.prototype.forEach = function(f) {
      this.edges.forEach(f);
    };
    EdgeRing2.prototype.map = function(f) {
      return this.edges.map(f);
    };
    EdgeRing2.prototype.some = function(f) {
      return this.edges.some(f);
    };
    EdgeRing2.prototype.isValid = function() {
      return true;
    };
    EdgeRing2.prototype.isHole = function() {
      var _this = this;
      var hiIndex = this.edges.reduce(function(high, edge, i) {
        if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1])
          high = i;
        return high;
      }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);
      if (disc === 0)
        return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];
      return disc > 0;
    };
    EdgeRing2.prototype.toMultiPoint = function() {
      return multiPoint(this.edges.map(function(edge) {
        return edge.from.coordinates;
      }));
    };
    EdgeRing2.prototype.toPolygon = function() {
      if (this.polygon)
        return this.polygon;
      var coordinates = this.edges.map(function(edge) {
        return edge.from.coordinates;
      });
      coordinates.push(this.edges[0].from.coordinates);
      return this.polygon = polygon([coordinates]);
    };
    EdgeRing2.prototype.getEnvelope = function() {
      if (this.envelope)
        return this.envelope;
      return this.envelope = es_default6(this.toPolygon());
    };
    EdgeRing2.findEdgeRingContaining = function(testEdgeRing, shellList) {
      var testEnvelope = testEdgeRing.getEnvelope();
      var minEnvelope, minShell;
      shellList.forEach(function(shell) {
        var tryEnvelope = shell.getEnvelope();
        if (minShell)
          minEnvelope = minShell.getEnvelope();
        if (envelopeIsEqual(tryEnvelope, testEnvelope))
          return;
        if (envelopeContains(tryEnvelope, testEnvelope)) {
          var testEdgeRingCoordinates = testEdgeRing.map(function(edge) {
            return edge.from.coordinates;
          });
          var testPoint = void 0;
          var _loop_1 = function(pt2) {
            if (!shell.some(function(edge) {
              return coordinatesEqual(pt2, edge.from.coordinates);
            })) {
              testPoint = pt2;
            }
          };
          for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {
            var pt = testEdgeRingCoordinates_1[_i];
            _loop_1(pt);
          }
          if (testPoint && shell.inside(point(testPoint))) {
            if (!minShell || envelopeContains(minEnvelope, tryEnvelope))
              minShell = shell;
          }
        }
      });
      return minShell;
    };
    EdgeRing2.prototype.inside = function(pt) {
      return booleanPointInPolygon(pt, this.toPolygon());
    };
    return EdgeRing2;
  }();
  var EdgeRing_default = EdgeRing;

  // ../node_modules/@turf/polygonize/dist/es/lib/Graph.js
  function validateGeoJson(geoJson) {
    if (!geoJson)
      throw new Error("No geojson passed");
    if (geoJson.type !== "FeatureCollection" && geoJson.type !== "GeometryCollection" && geoJson.type !== "MultiLineString" && geoJson.type !== "LineString" && geoJson.type !== "Feature")
      throw new Error("Invalid input type '" + geoJson.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature");
  }
  var Graph = function() {
    function Graph3() {
      this.edges = [];
      this.nodes = {};
    }
    Graph3.fromGeoJson = function(geoJson) {
      validateGeoJson(geoJson);
      var graph = new Graph3();
      flattenEach(geoJson, function(feature3) {
        featureOf(feature3, "LineString", "Graph::fromGeoJson");
        coordReduce(feature3, function(prev, cur) {
          if (prev) {
            var start2 = graph.getNode(prev), end = graph.getNode(cur);
            graph.addEdge(start2, end);
          }
          return cur;
        });
      });
      return graph;
    };
    Graph3.prototype.getNode = function(coordinates) {
      var id = Node_default.buildId(coordinates);
      var node = this.nodes[id];
      if (!node)
        node = this.nodes[id] = new Node_default(coordinates);
      return node;
    };
    Graph3.prototype.addEdge = function(from2, to) {
      var edge = new Edge_default(from2, to), symetricEdge = edge.getSymetric();
      this.edges.push(edge);
      this.edges.push(symetricEdge);
    };
    Graph3.prototype.deleteDangles = function() {
      var _this = this;
      Object.keys(this.nodes).map(function(id) {
        return _this.nodes[id];
      }).forEach(function(node) {
        return _this._removeIfDangle(node);
      });
    };
    Graph3.prototype._removeIfDangle = function(node) {
      var _this = this;
      if (node.innerEdges.length <= 1) {
        var outerNodes = node.getOuterEdges().map(function(e) {
          return e.to;
        });
        this.removeNode(node);
        outerNodes.forEach(function(n) {
          return _this._removeIfDangle(n);
        });
      }
    };
    Graph3.prototype.deleteCutEdges = function() {
      var _this = this;
      this._computeNextCWEdges();
      this._findLabeledEdgeRings();
      this.edges.forEach(function(edge) {
        if (edge.label === edge.symetric.label) {
          _this.removeEdge(edge.symetric);
          _this.removeEdge(edge);
        }
      });
    };
    Graph3.prototype._computeNextCWEdges = function(node) {
      var _this = this;
      if (typeof node === "undefined") {
        Object.keys(this.nodes).forEach(function(id) {
          return _this._computeNextCWEdges(_this.nodes[id]);
        });
      } else {
        node.getOuterEdges().forEach(function(edge, i) {
          node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;
        });
      }
    };
    Graph3.prototype._computeNextCCWEdges = function(node, label) {
      var edges2 = node.getOuterEdges();
      var firstOutDE, prevInDE;
      for (var i = edges2.length - 1; i >= 0; --i) {
        var de = edges2[i], sym = de.symetric, outDE = void 0, inDE = void 0;
        if (de.label === label)
          outDE = de;
        if (sym.label === label)
          inDE = sym;
        if (!outDE || !inDE)
          continue;
        if (inDE)
          prevInDE = inDE;
        if (outDE) {
          if (prevInDE) {
            prevInDE.next = outDE;
            prevInDE = void 0;
          }
          if (!firstOutDE)
            firstOutDE = outDE;
        }
      }
      if (prevInDE)
        prevInDE.next = firstOutDE;
    };
    Graph3.prototype._findLabeledEdgeRings = function() {
      var edgeRingStarts = [];
      var label = 0;
      this.edges.forEach(function(edge) {
        if (edge.label >= 0)
          return;
        edgeRingStarts.push(edge);
        var e = edge;
        do {
          e.label = label;
          e = e.next;
        } while (!edge.isEqual(e));
        label++;
      });
      return edgeRingStarts;
    };
    Graph3.prototype.getEdgeRings = function() {
      var _this = this;
      this._computeNextCWEdges();
      this.edges.forEach(function(edge) {
        edge.label = void 0;
      });
      this._findLabeledEdgeRings().forEach(function(edge) {
        _this._findIntersectionNodes(edge).forEach(function(node) {
          _this._computeNextCCWEdges(node, edge.label);
        });
      });
      var edgeRingList = [];
      this.edges.forEach(function(edge) {
        if (edge.ring)
          return;
        edgeRingList.push(_this._findEdgeRing(edge));
      });
      return edgeRingList;
    };
    Graph3.prototype._findIntersectionNodes = function(startEdge) {
      var intersectionNodes = [];
      var edge = startEdge;
      var _loop_1 = function() {
        var degree = 0;
        edge.from.getOuterEdges().forEach(function(e) {
          if (e.label === startEdge.label)
            ++degree;
        });
        if (degree > 1)
          intersectionNodes.push(edge.from);
        edge = edge.next;
      };
      do {
        _loop_1();
      } while (!startEdge.isEqual(edge));
      return intersectionNodes;
    };
    Graph3.prototype._findEdgeRing = function(startEdge) {
      var edge = startEdge;
      var edgeRing = new EdgeRing_default();
      do {
        edgeRing.push(edge);
        edge.ring = edgeRing;
        edge = edge.next;
      } while (!startEdge.isEqual(edge));
      return edgeRing;
    };
    Graph3.prototype.removeNode = function(node) {
      var _this = this;
      node.getOuterEdges().forEach(function(edge) {
        return _this.removeEdge(edge);
      });
      node.innerEdges.forEach(function(edge) {
        return _this.removeEdge(edge);
      });
      delete this.nodes[node.id];
    };
    Graph3.prototype.removeEdge = function(edge) {
      this.edges = this.edges.filter(function(e) {
        return !e.isEqual(edge);
      });
      edge.deleteEdge();
    };
    return Graph3;
  }();

  // ../node_modules/@turf/boolean-overlap/dist/es/index.js
  var import_geojson_equality = __toESM(require_geojson_equality(), 1);

  // ../node_modules/@turf/boolean-equal/dist/es/index.js
  var import_geojson_equality2 = __toESM(require_geojson_equality(), 1);

  // ../node_modules/@turf/clusters-dbscan/dist/es/index.js
  var import_density_clustering = __toESM(require_lib(), 1);

  // ../node_modules/@turf/clusters-kmeans/dist/es/index.js
  var import_skmeans = __toESM(require_main(), 1);

  // ../node_modules/@turf/shortest-path/dist/es/index.js
  function pathTo(node) {
    var curr = node, path = [];
    while (curr.parent) {
      path.unshift(curr);
      curr = curr.parent;
    }
    return path;
  }
  function getHeap() {
    return new BinaryHeap(function(node) {
      return node.f;
    });
  }
  var astar = {
    search: function(graph, start2, end, options) {
      graph.cleanDirty();
      options = options || {};
      var heuristic = options.heuristic || astar.heuristics.manhattan, closest = options.closest || false;
      var openHeap = getHeap(), closestNode = start2;
      start2.h = heuristic(start2, end);
      openHeap.push(start2);
      while (openHeap.size() > 0) {
        var currentNode = openHeap.pop();
        if (currentNode === end) {
          return pathTo(currentNode);
        }
        currentNode.closed = true;
        var neighbors = graph.neighbors(currentNode);
        for (var i = 0, il = neighbors.length; i < il; ++i) {
          var neighbor = neighbors[i];
          if (neighbor.closed || neighbor.isWall()) {
            continue;
          }
          var gScore = currentNode.g + neighbor.getCost(currentNode), beenVisited = neighbor.visited;
          if (!beenVisited || gScore < neighbor.g) {
            neighbor.visited = true;
            neighbor.parent = currentNode;
            neighbor.h = neighbor.h || heuristic(neighbor, end);
            neighbor.g = gScore;
            neighbor.f = neighbor.g + neighbor.h;
            graph.markDirty(neighbor);
            if (closest) {
              if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
                closestNode = neighbor;
              }
            }
            if (!beenVisited) {
              openHeap.push(neighbor);
            } else {
              openHeap.rescoreElement(neighbor);
            }
          }
        }
      }
      if (closest) {
        return pathTo(closestNode);
      }
      return [];
    },
    heuristics: {
      manhattan: function(pos0, pos1) {
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return d1 + d2;
      },
      diagonal: function(pos0, pos1) {
        var D = 1;
        var D2 = Math.sqrt(2);
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
      }
    },
    cleanNode: function(node) {
      node.f = 0;
      node.g = 0;
      node.h = 0;
      node.visited = false;
      node.closed = false;
      node.parent = null;
    }
  };
  function Graph2(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];
    for (var x3 = 0; x3 < gridIn.length; x3++) {
      this.grid[x3] = [];
      for (var y3 = 0, row = gridIn[x3]; y3 < row.length; y3++) {
        var node = new GridNode(x3, y3, row[y3]);
        this.grid[x3][y3] = node;
        this.nodes.push(node);
      }
    }
    this.init();
  }
  Graph2.prototype.init = function() {
    this.dirtyNodes = [];
    for (var i = 0; i < this.nodes.length; i++) {
      astar.cleanNode(this.nodes[i]);
    }
  };
  Graph2.prototype.cleanDirty = function() {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
      astar.cleanNode(this.dirtyNodes[i]);
    }
    this.dirtyNodes = [];
  };
  Graph2.prototype.markDirty = function(node) {
    this.dirtyNodes.push(node);
  };
  Graph2.prototype.neighbors = function(node) {
    var ret = [], x3 = node.x, y3 = node.y, grid = this.grid;
    if (grid[x3 - 1] && grid[x3 - 1][y3]) {
      ret.push(grid[x3 - 1][y3]);
    }
    if (grid[x3 + 1] && grid[x3 + 1][y3]) {
      ret.push(grid[x3 + 1][y3]);
    }
    if (grid[x3] && grid[x3][y3 - 1]) {
      ret.push(grid[x3][y3 - 1]);
    }
    if (grid[x3] && grid[x3][y3 + 1]) {
      ret.push(grid[x3][y3 + 1]);
    }
    if (this.diagonal) {
      if (grid[x3 - 1] && grid[x3 - 1][y3 - 1]) {
        ret.push(grid[x3 - 1][y3 - 1]);
      }
      if (grid[x3 + 1] && grid[x3 + 1][y3 - 1]) {
        ret.push(grid[x3 + 1][y3 - 1]);
      }
      if (grid[x3 - 1] && grid[x3 - 1][y3 + 1]) {
        ret.push(grid[x3 - 1][y3 + 1]);
      }
      if (grid[x3 + 1] && grid[x3 + 1][y3 + 1]) {
        ret.push(grid[x3 + 1][y3 + 1]);
      }
    }
    return ret;
  };
  Graph2.prototype.toString = function() {
    var graphString = [], nodes = this.grid, rowDebug, row, y3, l;
    for (var x3 = 0, len = nodes.length; x3 < len; x3++) {
      rowDebug = [];
      row = nodes[x3];
      for (y3 = 0, l = row.length; y3 < l; y3++) {
        rowDebug.push(row[y3].weight);
      }
      graphString.push(rowDebug.join(" "));
    }
    return graphString.join("\n");
  };
  function GridNode(x3, y3, weight) {
    this.x = x3;
    this.y = y3;
    this.weight = weight;
  }
  GridNode.prototype.toString = function() {
    return "[" + this.x + " " + this.y + "]";
  };
  GridNode.prototype.getCost = function(fromNeighbor) {
    if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
      return this.weight * 1.41421;
    }
    return this.weight;
  };
  GridNode.prototype.isWall = function() {
    return this.weight === 0;
  };
  function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
  }
  BinaryHeap.prototype = {
    push: function(element) {
      this.content.push(element);
      this.sinkDown(this.content.length - 1);
    },
    pop: function() {
      var result = this.content[0];
      var end = this.content.pop();
      if (this.content.length > 0) {
        this.content[0] = end;
        this.bubbleUp(0);
      }
      return result;
    },
    remove: function(node) {
      var i = this.content.indexOf(node);
      var end = this.content.pop();
      if (i !== this.content.length - 1) {
        this.content[i] = end;
        if (this.scoreFunction(end) < this.scoreFunction(node)) {
          this.sinkDown(i);
        } else {
          this.bubbleUp(i);
        }
      }
    },
    size: function() {
      return this.content.length;
    },
    rescoreElement: function(node) {
      this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function(n) {
      var element = this.content[n];
      while (n > 0) {
        var parentN = (n + 1 >> 1) - 1, parent = this.content[parentN];
        if (this.scoreFunction(element) < this.scoreFunction(parent)) {
          this.content[parentN] = element;
          this.content[n] = parent;
          n = parentN;
        } else {
          break;
        }
      }
    },
    bubbleUp: function(n) {
      var length2 = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
      while (true) {
        var child2N = n + 1 << 1, child1N = child2N - 1;
        var swap2 = null, child1Score;
        if (child1N < length2) {
          var child1 = this.content[child1N];
          child1Score = this.scoreFunction(child1);
          if (child1Score < elemScore) {
            swap2 = child1N;
          }
        }
        if (child2N < length2) {
          var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
          if (child2Score < (swap2 === null ? elemScore : child1Score)) {
            swap2 = child2N;
          }
        }
        if (swap2 !== null) {
          this.content[n] = this.content[swap2];
          this.content[swap2] = element;
          n = swap2;
        } else {
          break;
        }
      }
    }
  };

  // ../node_modules/d3-voronoi/src/RedBlackTree.js
  function RedBlackTree() {
    this._ = null;
  }
  function RedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  RedBlackTree.prototype = {
    constructor: RedBlackTree,
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N)
          after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L)
            after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = RedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              RedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            RedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              RedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            RedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N)
        node.N.P = node.P;
      if (node.P)
        node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left)
        next = right;
      else if (!right)
        next = left;
      else
        next = RedBlackFirst(right);
      if (parent) {
        if (parent.L === node)
          parent.L = next;
        else
          parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node)
        node.U = parent;
      if (red)
        return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._)
          break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            RedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              RedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            RedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            RedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              RedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            RedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node)
        node.C = false;
    }
  };
  function RedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p)
        parent.L = q;
      else
        parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R)
      p.R.U = p;
    q.L = p;
  }
  function RedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p)
        parent.L = q;
      else
        parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L)
      p.L.U = p;
    q.R = p;
  }
  function RedBlackFirst(node) {
    while (node.L)
      node = node.L;
    return node;
  }
  var RedBlackTree_default = RedBlackTree;

  // ../node_modules/d3-voronoi/src/Edge.js
  function createEdge(left, right, v0, v1) {
    var edge = [null, null], index = edges.push(edge) - 1;
    edge.left = left;
    edge.right = right;
    if (v0)
      setEdgeEnd(edge, left, right, v0);
    if (v1)
      setEdgeEnd(edge, right, left, v1);
    cells[left.index].halfedges.push(index);
    cells[right.index].halfedges.push(index);
    return edge;
  }
  function createBorderEdge(left, v0, v1) {
    var edge = [v0, v1];
    edge.left = left;
    return edge;
  }
  function setEdgeEnd(edge, left, right, vertex) {
    if (!edge[0] && !edge[1]) {
      edge[0] = vertex;
      edge.left = left;
      edge.right = right;
    } else if (edge.left === right) {
      edge[1] = vertex;
    } else {
      edge[0] = vertex;
    }
  }
  function clipEdge(edge, x02, y02, x12, y12) {
    var a2 = edge[0], b = edge[1], ax = a2[0], ay = a2[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
    r = x02 - ax;
    if (!dx && r > 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    } else if (dx > 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    }
    r = x12 - ax;
    if (!dx && r < 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    } else if (dx > 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    }
    r = y02 - ay;
    if (!dy && r > 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    } else if (dy > 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    }
    r = y12 - ay;
    if (!dy && r < 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    } else if (dy > 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    }
    if (!(t0 > 0) && !(t1 < 1))
      return true;
    if (t0 > 0)
      edge[0] = [ax + t0 * dx, ay + t0 * dy];
    if (t1 < 1)
      edge[1] = [ax + t1 * dx, ay + t1 * dy];
    return true;
  }
  function connectEdge(edge, x02, y02, x12, y12) {
    var v1 = edge[1];
    if (v1)
      return true;
    var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x02 || fx >= x12)
        return;
      if (lx > rx) {
        if (!v0)
          v0 = [fx, y02];
        else if (v0[1] >= y12)
          return;
        v1 = [fx, y12];
      } else {
        if (!v0)
          v0 = [fx, y12];
        else if (v0[1] < y02)
          return;
        v1 = [fx, y02];
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!v0)
            v0 = [(y02 - fb) / fm, y02];
          else if (v0[1] >= y12)
            return;
          v1 = [(y12 - fb) / fm, y12];
        } else {
          if (!v0)
            v0 = [(y12 - fb) / fm, y12];
          else if (v0[1] < y02)
            return;
          v1 = [(y02 - fb) / fm, y02];
        }
      } else {
        if (ly < ry) {
          if (!v0)
            v0 = [x02, fm * x02 + fb];
          else if (v0[0] >= x12)
            return;
          v1 = [x12, fm * x12 + fb];
        } else {
          if (!v0)
            v0 = [x12, fm * x12 + fb];
          else if (v0[0] < x02)
            return;
          v1 = [x02, fm * x02 + fb];
        }
      }
    }
    edge[0] = v0;
    edge[1] = v1;
    return true;
  }
  function clipEdges(x02, y02, x12, y12) {
    var i = edges.length, edge;
    while (i--) {
      if (!connectEdge(edge = edges[i], x02, y02, x12, y12) || !clipEdge(edge, x02, y02, x12, y12) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
        delete edges[i];
      }
    }
  }

  // ../node_modules/d3-voronoi/src/Cell.js
  function createCell(site) {
    return cells[site.index] = {
      site,
      halfedges: []
    };
  }
  function cellHalfedgeAngle(cell, edge) {
    var site = cell.site, va = edge.left, vb = edge.right;
    if (site === vb)
      vb = va, va = site;
    if (vb)
      return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
    if (site === va)
      va = edge[1], vb = edge[0];
    else
      va = edge[0], vb = edge[1];
    return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
  }
  function cellHalfedgeStart(cell, edge) {
    return edge[+(edge.left !== cell.site)];
  }
  function cellHalfedgeEnd(cell, edge) {
    return edge[+(edge.left === cell.site)];
  }
  function sortCellHalfedges() {
    for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
      if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
        var index = new Array(m), array2 = new Array(m);
        for (j = 0; j < m; ++j)
          index[j] = j, array2[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
        index.sort(function(i2, j2) {
          return array2[j2] - array2[i2];
        });
        for (j = 0; j < m; ++j)
          array2[j] = halfedges[index[j]];
        for (j = 0; j < m; ++j)
          halfedges[j] = array2[j];
      }
    }
  }
  function clipCells(x02, y02, x12, y12) {
    var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start2, startX, startY, end, endX, endY, cover = true;
    for (iCell = 0; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        halfedges = cell.halfedges;
        iHalfedge = halfedges.length;
        while (iHalfedge--) {
          if (!edges[halfedges[iHalfedge]]) {
            halfedges.splice(iHalfedge, 1);
          }
        }
        iHalfedge = 0, nHalfedges = halfedges.length;
        while (iHalfedge < nHalfedges) {
          end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
          start2 = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start2[0], startY = start2[1];
          if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
            halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(
              site,
              end,
              Math.abs(endX - x02) < epsilon && y12 - endY > epsilon ? [x02, Math.abs(startX - x02) < epsilon ? startY : y12] : Math.abs(endY - y12) < epsilon && x12 - endX > epsilon ? [Math.abs(startY - y12) < epsilon ? startX : x12, y12] : Math.abs(endX - x12) < epsilon && endY - y02 > epsilon ? [x12, Math.abs(startX - x12) < epsilon ? startY : y02] : Math.abs(endY - y02) < epsilon && endX - x02 > epsilon ? [Math.abs(startY - y02) < epsilon ? startX : x02, y02] : null
            )) - 1);
            ++nHalfedges;
          }
        }
        if (nHalfedges)
          cover = false;
      }
    }
    if (cover) {
      var dx, dy, d2, dc = Infinity;
      for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
        if (cell = cells[iCell]) {
          site = cell.site;
          dx = site[0] - x02;
          dy = site[1] - y02;
          d2 = dx * dx + dy * dy;
          if (d2 < dc)
            dc = d2, cover = cell;
        }
      }
      if (cover) {
        var v00 = [x02, y02], v01 = [x02, y12], v11 = [x12, y12], v10 = [x12, y02];
        cover.halfedges.push(
          edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
          edges.push(createBorderEdge(site, v01, v11)) - 1,
          edges.push(createBorderEdge(site, v11, v10)) - 1,
          edges.push(createBorderEdge(site, v10, v00)) - 1
        );
      }
    }
    for (iCell = 0; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        if (!cell.halfedges.length) {
          delete cells[iCell];
        }
      }
    }
  }

  // ../node_modules/d3-voronoi/src/Circle.js
  var circlePool = [];
  var firstCircle;
  function Circle() {
    RedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function attachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc)
      return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite)
      return;
    var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -epsilon2)
      return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x3 = (cy * ha - ay * hc) / d, y3 = (ax * hc - cx * ha) / d;
    var circle2 = circlePool.pop() || new Circle();
    circle2.arc = arc;
    circle2.site = cSite;
    circle2.x = x3 + bx;
    circle2.y = (circle2.cy = y3 + by) + Math.sqrt(x3 * x3 + y3 * y3);
    arc.circle = circle2;
    var before = null, node = circles._;
    while (node) {
      if (circle2.y < node.y || circle2.y === node.y && circle2.x <= node.x) {
        if (node.L)
          node = node.L;
        else {
          before = node.P;
          break;
        }
      } else {
        if (node.R)
          node = node.R;
        else {
          before = node;
          break;
        }
      }
    }
    circles.insert(before, circle2);
    if (!before)
      firstCircle = circle2;
  }
  function detachCircle(arc) {
    var circle2 = arc.circle;
    if (circle2) {
      if (!circle2.P)
        firstCircle = circle2.N;
      circles.remove(circle2);
      circlePool.push(circle2);
      RedBlackNode(circle2);
      arc.circle = null;
    }
  }

  // ../node_modules/d3-voronoi/src/Beach.js
  var beachPool = [];
  function Beach() {
    RedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function createBeach(site) {
    var beach = beachPool.pop() || new Beach();
    beach.site = site;
    return beach;
  }
  function detachBeach(beach) {
    detachCircle(beach);
    beaches.remove(beach);
    beachPool.push(beach);
    RedBlackNode(beach);
  }
  function removeBeach(beach) {
    var circle2 = beach.circle, x3 = circle2.x, y3 = circle2.cy, vertex = [x3, y3], previous = beach.P, next = beach.N, disappearing = [beach];
    detachBeach(beach);
    var lArc = previous;
    while (lArc.circle && Math.abs(x3 - lArc.circle.x) < epsilon && Math.abs(y3 - lArc.circle.cy) < epsilon) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      detachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    detachCircle(lArc);
    var rArc = next;
    while (rArc.circle && Math.abs(x3 - rArc.circle.x) < epsilon && Math.abs(y3 - rArc.circle.cy) < epsilon) {
      next = rArc.N;
      disappearing.push(rArc);
      detachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    detachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
    attachCircle(lArc);
    attachCircle(rArc);
  }
  function addBeach(site) {
    var x3 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
    while (node) {
      dxl = leftBreakPoint(node, directrix) - x3;
      if (dxl > epsilon)
        node = node.L;
      else {
        dxr = x3 - rightBreakPoint(node, directrix);
        if (dxr > epsilon) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -epsilon) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -epsilon) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    createCell(site);
    var newArc = createBeach(site);
    beaches.insert(lArc, newArc);
    if (!lArc && !rArc)
      return;
    if (lArc === rArc) {
      detachCircle(lArc);
      rArc = createBeach(lArc.site);
      beaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
      attachCircle(lArc);
      attachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = createEdge(lArc.site, newArc.site);
      return;
    }
    detachCircle(lArc);
    detachCircle(rArc);
    var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
    setEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = createEdge(lSite, site, null, vertex);
    rArc.edge = createEdge(site, rSite, null, vertex);
    attachCircle(lArc);
    attachCircle(rArc);
  }
  function leftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
    if (!pby2)
      return rfocx;
    var lArc = arc.P;
    if (!lArc)
      return -Infinity;
    site = lArc.site;
    var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
    if (!plby2)
      return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2)
      return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function rightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc)
      return leftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site[1] === directrix ? site[0] : Infinity;
  }

  // ../node_modules/d3-voronoi/src/Diagram.js
  var epsilon = 1e-6;
  var epsilon2 = 1e-12;
  var beaches;
  var cells;
  var circles;
  var edges;
  function triangleArea(a2, b, c) {
    return (a2[0] - c[0]) * (b[1] - a2[1]) - (a2[0] - b[0]) * (c[1] - a2[1]);
  }
  function lexicographic(a2, b) {
    return b[1] - a2[1] || b[0] - a2[0];
  }
  function Diagram(sites, extent) {
    var site = sites.sort(lexicographic).pop(), x3, y3, circle2;
    edges = [];
    cells = new Array(sites.length);
    beaches = new RedBlackTree_default();
    circles = new RedBlackTree_default();
    while (true) {
      circle2 = firstCircle;
      if (site && (!circle2 || site[1] < circle2.y || site[1] === circle2.y && site[0] < circle2.x)) {
        if (site[0] !== x3 || site[1] !== y3) {
          addBeach(site);
          x3 = site[0], y3 = site[1];
        }
        site = sites.pop();
      } else if (circle2) {
        removeBeach(circle2.arc);
      } else {
        break;
      }
    }
    sortCellHalfedges();
    if (extent) {
      var x02 = +extent[0][0], y02 = +extent[0][1], x12 = +extent[1][0], y12 = +extent[1][1];
      clipEdges(x02, y02, x12, y12);
      clipCells(x02, y02, x12, y12);
    }
    this.edges = edges;
    this.cells = cells;
    beaches = circles = edges = cells = null;
  }
  Diagram.prototype = {
    constructor: Diagram,
    polygons: function() {
      var edges2 = this.edges;
      return this.cells.map(function(cell) {
        var polygon2 = cell.halfedges.map(function(i) {
          return cellHalfedgeStart(cell, edges2[i]);
        });
        polygon2.data = cell.site.data;
        return polygon2;
      });
    },
    triangles: function() {
      var triangles = [], edges2 = this.edges;
      this.cells.forEach(function(cell, i) {
        if (!(m = (halfedges = cell.halfedges).length))
          return;
        var site = cell.site, halfedges, j = -1, m, s0, e1 = edges2[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
        while (++j < m) {
          s0 = s1;
          e1 = edges2[halfedges[j]];
          s1 = e1.left === site ? e1.right : e1.left;
          if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
            triangles.push([site.data, s0.data, s1.data]);
          }
        }
      });
      return triangles;
    },
    links: function() {
      return this.edges.filter(function(edge) {
        return edge.right;
      }).map(function(edge) {
        return {
          source: edge.left.data,
          target: edge.right.data
        };
      });
    },
    find: function(x3, y3, radius) {
      var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
      while (!(cell = that.cells[i1]))
        if (++i1 >= n)
          return null;
      var dx = x3 - cell.site[0], dy = y3 - cell.site[1], d2 = dx * dx + dy * dy;
      do {
        cell = that.cells[i0 = i1], i1 = null;
        cell.halfedges.forEach(function(e) {
          var edge = that.edges[e], v = edge.left;
          if ((v === cell.site || !v) && !(v = edge.right))
            return;
          var vx = x3 - v[0], vy = y3 - v[1], v2 = vx * vx + vy * vy;
          if (v2 < d2)
            d2 = v2, i1 = v.index;
        });
      } while (i1 !== null);
      that._found = i0;
      return radius == null || d2 <= radius * radius ? cell.site : null;
    }
  };

  // ../node_modules/@turf/difference/dist/es/index.js
  var import_polygon_clipping = __toESM(require_polygon_clipping_umd(), 1);

  // ../node_modules/@turf/buffer/dist/es/index.js
  var import_turf_jsts = __toESM(require_jsts_min(), 1);

  // ../node_modules/d3-geo/src/adder.js
  function adder_default() {
    return new Adder();
  }
  function Adder() {
    this.reset();
  }
  Adder.prototype = {
    constructor: Adder,
    reset: function() {
      this.s = this.t = 0;
    },
    add: function(y3) {
      add(temp, y3, this.t);
      add(this, temp.s, this.s);
      if (this.s)
        this.t += temp.t;
      else
        this.s = temp.t;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var temp = new Adder();
  function add(adder, a2, b) {
    var x3 = adder.s = a2 + b, bv = x3 - a2, av = x3 - bv;
    adder.t = a2 - av + (b - bv);
  }

  // ../node_modules/d3-geo/src/math.js
  var epsilon3 = 1e-6;
  var pi = Math.PI;
  var halfPi = pi / 2;
  var quarterPi = pi / 4;
  var tau = pi * 2;
  var degrees = 180 / pi;
  var radians = pi / 180;
  var abs = Math.abs;
  var atan = Math.atan;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var exp = Math.exp;
  var log = Math.log;
  var sin = Math.sin;
  var sqrt = Math.sqrt;
  var tan = Math.tan;
  function acos(x3) {
    return x3 > 1 ? 0 : x3 < -1 ? pi : Math.acos(x3);
  }
  function asin(x3) {
    return x3 > 1 ? halfPi : x3 < -1 ? -halfPi : Math.asin(x3);
  }

  // ../node_modules/d3-geo/src/noop.js
  function noop() {
  }

  // ../node_modules/d3-geo/src/stream.js
  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }
  var streamObjectType = {
    Feature: function(object2, stream) {
      streamGeometry(object2.geometry, stream);
    },
    FeatureCollection: function(object2, stream) {
      var features = object2.features, i = -1, n = features.length;
      while (++i < n)
        streamGeometry(features[i].geometry, stream);
    }
  };
  var streamGeometryType = {
    Sphere: function(object2, stream) {
      stream.sphere();
    },
    Point: function(object2, stream) {
      object2 = object2.coordinates;
      stream.point(object2[0], object2[1], object2[2]);
    },
    MultiPoint: function(object2, stream) {
      var coordinates = object2.coordinates, i = -1, n = coordinates.length;
      while (++i < n)
        object2 = coordinates[i], stream.point(object2[0], object2[1], object2[2]);
    },
    LineString: function(object2, stream) {
      streamLine(object2.coordinates, stream, 0);
    },
    MultiLineString: function(object2, stream) {
      var coordinates = object2.coordinates, i = -1, n = coordinates.length;
      while (++i < n)
        streamLine(coordinates[i], stream, 0);
    },
    Polygon: function(object2, stream) {
      streamPolygon(object2.coordinates, stream);
    },
    MultiPolygon: function(object2, stream) {
      var coordinates = object2.coordinates, i = -1, n = coordinates.length;
      while (++i < n)
        streamPolygon(coordinates[i], stream);
    },
    GeometryCollection: function(object2, stream) {
      var geometries = object2.geometries, i = -1, n = geometries.length;
      while (++i < n)
        streamGeometry(geometries[i], stream);
    }
  };
  function streamLine(coordinates, stream, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    stream.lineStart();
    while (++i < n)
      coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }
  function streamPolygon(coordinates, stream) {
    var i = -1, n = coordinates.length;
    stream.polygonStart();
    while (++i < n)
      streamLine(coordinates[i], stream, 1);
    stream.polygonEnd();
  }
  function stream_default(object2, stream) {
    if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
      streamObjectType[object2.type](object2, stream);
    } else {
      streamGeometry(object2, stream);
    }
  }

  // ../node_modules/d3-geo/src/area.js
  var areaRingSum = adder_default();
  var areaSum = adder_default();

  // ../node_modules/d3-geo/src/cartesian.js
  function spherical(cartesian2) {
    return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
  }
  function cartesian(spherical2) {
    var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
    return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
  }
  function cartesianDot(a2, b) {
    return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
  }
  function cartesianCross(a2, b) {
    return [a2[1] * b[2] - a2[2] * b[1], a2[2] * b[0] - a2[0] * b[2], a2[0] * b[1] - a2[1] * b[0]];
  }
  function cartesianAddInPlace(a2, b) {
    a2[0] += b[0], a2[1] += b[1], a2[2] += b[2];
  }
  function cartesianScale(vector, k) {
    return [vector[0] * k, vector[1] * k, vector[2] * k];
  }
  function cartesianNormalizeInPlace(d) {
    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l, d[1] /= l, d[2] /= l;
  }

  // ../node_modules/d3-geo/src/bounds.js
  var deltaSum = adder_default();

  // ../node_modules/d3-geo/src/compose.js
  function compose_default(a2, b) {
    function compose(x3, y3) {
      return x3 = a2(x3, y3), b(x3[0], x3[1]);
    }
    if (a2.invert && b.invert)
      compose.invert = function(x3, y3) {
        return x3 = b.invert(x3, y3), x3 && a2.invert(x3[0], x3[1]);
      };
    return compose;
  }

  // ../node_modules/d3-geo/src/rotation.js
  function rotationIdentity(lambda, phi) {
    return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  }
  rotationIdentity.invert = rotationIdentity;
  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
    return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
  }
  function forwardRotationLambda(deltaLambda) {
    return function(lambda, phi) {
      return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
    };
  }
  function rotationLambda(deltaLambda) {
    var rotation = forwardRotationLambda(deltaLambda);
    rotation.invert = forwardRotationLambda(-deltaLambda);
    return rotation;
  }
  function rotationPhiGamma(deltaPhi, deltaGamma) {
    var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
    function rotation(lambda, phi) {
      var cosPhi = cos(phi), x3 = cos(lambda) * cosPhi, y3 = sin(lambda) * cosPhi, z2 = sin(phi), k = z2 * cosDeltaPhi + x3 * sinDeltaPhi;
      return [
        atan2(y3 * cosDeltaGamma - k * sinDeltaGamma, x3 * cosDeltaPhi - z2 * sinDeltaPhi),
        asin(k * cosDeltaGamma + y3 * sinDeltaGamma)
      ];
    }
    rotation.invert = function(lambda, phi) {
      var cosPhi = cos(phi), x3 = cos(lambda) * cosPhi, y3 = sin(lambda) * cosPhi, z2 = sin(phi), k = z2 * cosDeltaGamma - y3 * sinDeltaGamma;
      return [
        atan2(y3 * cosDeltaGamma + z2 * sinDeltaGamma, x3 * cosDeltaPhi + k * sinDeltaPhi),
        asin(k * cosDeltaPhi - x3 * sinDeltaPhi)
      ];
    };
    return rotation;
  }

  // ../node_modules/d3-geo/src/circle.js
  function circleStream(stream, radius, delta, direction, t0, t1) {
    if (!delta)
      return;
    var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;
    if (t0 == null) {
      t0 = radius + direction * tau;
      t1 = radius - step / 2;
    } else {
      t0 = circleRadius(cosRadius, t0);
      t1 = circleRadius(cosRadius, t1);
      if (direction > 0 ? t0 < t1 : t0 > t1)
        t0 += direction * tau;
    }
    for (var point2, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
      point2 = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
      stream.point(point2[0], point2[1]);
    }
  }
  function circleRadius(cosRadius, point2) {
    point2 = cartesian(point2), point2[0] -= cosRadius;
    cartesianNormalizeInPlace(point2);
    var radius = acos(-point2[1]);
    return ((-point2[2] < 0 ? -radius : radius) + tau - epsilon3) % tau;
  }

  // ../node_modules/d3-geo/src/clip/buffer.js
  function buffer_default() {
    var lines = [], line;
    return {
      point: function(x3, y3) {
        line.push([x3, y3]);
      },
      lineStart: function() {
        lines.push(line = []);
      },
      lineEnd: noop,
      rejoin: function() {
        if (lines.length > 1)
          lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line = null;
        return result;
      }
    };
  }

  // ../node_modules/d3-geo/src/clip/line.js
  function line_default(a2, b, x02, y02, x12, y12) {
    var ax = a2[0], ay = a2[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
    r = x02 - ax;
    if (!dx && r > 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    } else if (dx > 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    }
    r = x12 - ax;
    if (!dx && r < 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    } else if (dx > 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    }
    r = y02 - ay;
    if (!dy && r > 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    } else if (dy > 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    }
    r = y12 - ay;
    if (!dy && r < 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    } else if (dy > 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    }
    if (t0 > 0)
      a2[0] = ax + t0 * dx, a2[1] = ay + t0 * dy;
    if (t1 < 1)
      b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
    return true;
  }

  // ../node_modules/d3-geo/src/pointEqual.js
  function pointEqual_default(a2, b) {
    return abs(a2[0] - b[0]) < epsilon3 && abs(a2[1] - b[1]) < epsilon3;
  }

  // ../node_modules/d3-geo/src/clip/polygon.js
  function Intersection(point2, points, other, entry) {
    this.x = point2;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function polygon_default(segments, compareIntersection2, startInside, interpolate, stream) {
    var subject = [], clip = [], i, n;
    segments.forEach(function(segment) {
      if ((n2 = segment.length - 1) <= 0)
        return;
      var n2, p0 = segment[0], p1 = segment[n2], x3;
      if (pointEqual_default(p0, p1)) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      subject.push(x3 = new Intersection(p0, segment, null, true));
      clip.push(x3.o = new Intersection(p0, null, x3, false));
      subject.push(x3 = new Intersection(p1, segment, null, false));
      clip.push(x3.o = new Intersection(p1, null, x3, true));
    });
    if (!subject.length)
      return;
    clip.sort(compareIntersection2);
    link(subject);
    link(clip);
    for (i = 0, n = clip.length; i < n; ++i) {
      clip[i].e = startInside = !startInside;
    }
    var start2 = subject[0], points, point2;
    while (1) {
      var current = start2, isSubject = true;
      while (current.v)
        if ((current = current.n) === start2)
          return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n = points.length; i < n; ++i)
              stream.point((point2 = points[i])[0], point2[1]);
          } else {
            interpolate(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i)
              stream.point((point2 = points[i])[0], point2[1]);
          } else {
            interpolate(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }
  function link(array2) {
    if (!(n = array2.length))
      return;
    var n, i = 0, a2 = array2[0], b;
    while (++i < n) {
      a2.n = b = array2[i];
      b.p = a2;
      a2 = b;
    }
    a2.n = b = array2[0];
    b.p = a2;
  }

  // ../node_modules/d3-array/src/ascending.js
  function ascending_default(a2, b) {
    return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
  }

  // ../node_modules/d3-array/src/bisector.js
  function bisector_default(compare3) {
    if (compare3.length === 1)
      compare3 = ascendingComparator(compare3);
    return {
      left: function(a2, x3, lo, hi) {
        if (lo == null)
          lo = 0;
        if (hi == null)
          hi = a2.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare3(a2[mid], x3) < 0)
            lo = mid + 1;
          else
            hi = mid;
        }
        return lo;
      },
      right: function(a2, x3, lo, hi) {
        if (lo == null)
          lo = 0;
        if (hi == null)
          hi = a2.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare3(a2[mid], x3) > 0)
            hi = mid;
          else
            lo = mid + 1;
        }
        return lo;
      }
    };
  }
  function ascendingComparator(f) {
    return function(d, x3) {
      return ascending_default(f(d), x3);
    };
  }

  // ../node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector_default(ascending_default);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;

  // ../node_modules/d3-array/src/array.js
  var array = Array.prototype;
  var slice = array.slice;
  var map = array.map;

  // ../node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);

  // ../node_modules/d3-array/src/merge.js
  function merge_default2(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array2;
    while (++i < n)
      j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array2 = arrays[n];
      m = array2.length;
      while (--m >= 0) {
        merged[--j] = array2[m];
      }
    }
    return merged;
  }

  // ../node_modules/d3-geo/src/clip/extent.js
  var clipMax = 1e9;
  var clipMin = -clipMax;
  function clipExtent(x02, y02, x12, y12) {
    function visible(x3, y3) {
      return x02 <= x3 && x3 <= x12 && y02 <= y3 && y3 <= y12;
    }
    function interpolate(from2, to, direction, stream) {
      var a2 = 0, a1 = 0;
      if (from2 == null || (a2 = corner(from2, direction)) !== (a1 = corner(to, direction)) || comparePoint(from2, to) < 0 ^ direction > 0) {
        do
          stream.point(a2 === 0 || a2 === 3 ? x02 : x12, a2 > 1 ? y12 : y02);
        while ((a2 = (a2 + direction + 4) % 4) !== a1);
      } else {
        stream.point(to[0], to[1]);
      }
    }
    function corner(p, direction) {
      return abs(p[0] - x02) < epsilon3 ? direction > 0 ? 0 : 3 : abs(p[0] - x12) < epsilon3 ? direction > 0 ? 2 : 1 : abs(p[1] - y02) < epsilon3 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compareIntersection2(a2, b) {
      return comparePoint(a2.x, b.x);
    }
    function comparePoint(a2, b) {
      var ca = corner(a2, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a2[1] : ca === 1 ? a2[0] - b[0] : ca === 2 ? a2[1] - b[1] : b[0] - a2[0];
    }
    return function(stream) {
      var activeStream = stream, bufferStream = buffer_default(), segments, polygon2, ring, x__, y__, v__, x_, y_, v_, first, clean;
      var clipStream = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart,
        polygonEnd
      };
      function point2(x3, y3) {
        if (visible(x3, y3))
          activeStream.point(x3, y3);
      }
      function polygonInside() {
        var winding = 0;
        for (var i = 0, n = polygon2.length; i < n; ++i) {
          for (var ring2 = polygon2[i], j = 1, m = ring2.length, point3 = ring2[0], a0, a1, b0 = point3[0], b1 = point3[1]; j < m; ++j) {
            a0 = b0, a1 = b1, point3 = ring2[j], b0 = point3[0], b1 = point3[1];
            if (a1 <= y12) {
              if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x02 - a0))
                ++winding;
            } else {
              if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x02 - a0))
                --winding;
            }
          }
        }
        return winding;
      }
      function polygonStart() {
        activeStream = bufferStream, segments = [], polygon2 = [], clean = true;
      }
      function polygonEnd() {
        var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge_default2(segments)).length;
        if (cleanInside || visible2) {
          stream.polygonStart();
          if (cleanInside) {
            stream.lineStart();
            interpolate(null, null, 1, stream);
            stream.lineEnd();
          }
          if (visible2) {
            polygon_default(segments, compareIntersection2, startInside, interpolate, stream);
          }
          stream.polygonEnd();
        }
        activeStream = stream, segments = polygon2 = ring = null;
      }
      function lineStart() {
        clipStream.point = linePoint;
        if (polygon2)
          polygon2.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_)
            bufferStream.rejoin();
          segments.push(bufferStream.result());
        }
        clipStream.point = point2;
        if (v_)
          activeStream.lineEnd();
      }
      function linePoint(x3, y3) {
        var v = visible(x3, y3);
        if (polygon2)
          ring.push([x3, y3]);
        if (first) {
          x__ = x3, y__ = y3, v__ = v;
          first = false;
          if (v) {
            activeStream.lineStart();
            activeStream.point(x3, y3);
          }
        } else {
          if (v && v_)
            activeStream.point(x3, y3);
          else {
            var a2 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x3 = Math.max(clipMin, Math.min(clipMax, x3)), y3 = Math.max(clipMin, Math.min(clipMax, y3))];
            if (line_default(a2, b, x02, y02, x12, y12)) {
              if (!v_) {
                activeStream.lineStart();
                activeStream.point(a2[0], a2[1]);
              }
              activeStream.point(b[0], b[1]);
              if (!v)
                activeStream.lineEnd();
              clean = false;
            } else if (v) {
              activeStream.lineStart();
              activeStream.point(x3, y3);
              clean = false;
            }
          }
        }
        x_ = x3, y_ = y3, v_ = v;
      }
      return clipStream;
    };
  }

  // ../node_modules/d3-geo/src/polygonContains.js
  var sum = adder_default();
  function polygonContains_default(polygon2, point2) {
    var lambda = point2[0], phi = point2[1], normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;
    sum.reset();
    for (var i = 0, n = polygon2.length; i < n; ++i) {
      if (!(m = (ring = polygon2[i]).length))
        continue;
      var ring, m, point0 = ring[m - 1], lambda0 = point0[0], phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);
      for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
        var point1 = ring[j], lambda1 = point1[0], phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;
        sum.add(atan2(k * sign2 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
        angle += antimeridian ? delta + sign2 * tau : delta;
        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }
    return (angle < -epsilon3 || angle < epsilon3 && sum < -epsilon3) ^ winding & 1;
  }

  // ../node_modules/d3-geo/src/length.js
  var lengthSum = adder_default();

  // ../node_modules/d3-geo/src/identity.js
  function identity_default3(x3) {
    return x3;
  }

  // ../node_modules/d3-geo/src/path/area.js
  var areaSum2 = adder_default();
  var areaRingSum2 = adder_default();

  // ../node_modules/d3-geo/src/path/bounds.js
  var x0 = Infinity;
  var y0 = x0;
  var x1 = -x0;
  var y1 = x1;
  var boundsStream = {
    point: boundsPoint,
    lineStart: noop,
    lineEnd: noop,
    polygonStart: noop,
    polygonEnd: noop,
    result: function() {
      var bounds = [[x0, y0], [x1, y1]];
      x1 = y1 = -(y0 = x0 = Infinity);
      return bounds;
    }
  };
  function boundsPoint(x3, y3) {
    if (x3 < x0)
      x0 = x3;
    if (x3 > x1)
      x1 = x3;
    if (y3 < y0)
      y0 = y3;
    if (y3 > y1)
      y1 = y3;
  }
  var bounds_default2 = boundsStream;

  // ../node_modules/d3-geo/src/path/context.js
  function PathContext(context) {
    this._context = context;
  }
  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_) {
      return this._radius = _, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._context.closePath();
      this._point = NaN;
    },
    point: function(x3, y3) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x3, y3);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x3, y3);
          break;
        }
        default: {
          this._context.moveTo(x3 + this._radius, y3);
          this._context.arc(x3, y3, this._radius, 0, tau);
          break;
        }
      }
    },
    result: noop
  };

  // ../node_modules/d3-geo/src/path/measure.js
  var lengthSum2 = adder_default();

  // ../node_modules/d3-geo/src/path/string.js
  function PathString() {
    this._string = [];
  }
  PathString.prototype = {
    _radius: 4.5,
    _circle: circle(4.5),
    pointRadius: function(_) {
      if ((_ = +_) !== this._radius)
        this._radius = _, this._circle = null;
      return this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._string.push("Z");
      this._point = NaN;
    },
    point: function(x3, y3) {
      switch (this._point) {
        case 0: {
          this._string.push("M", x3, ",", y3);
          this._point = 1;
          break;
        }
        case 1: {
          this._string.push("L", x3, ",", y3);
          break;
        }
        default: {
          if (this._circle == null)
            this._circle = circle(this._radius);
          this._string.push("M", x3, ",", y3, this._circle);
          break;
        }
      }
    },
    result: function() {
      if (this._string.length) {
        var result = this._string.join("");
        this._string = [];
        return result;
      } else {
        return null;
      }
    }
  };
  function circle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }

  // ../node_modules/d3-geo/src/clip/index.js
  function clip_default(pointVisible, clipLine, interpolate, start2) {
    return function(rotate2, sink) {
      var line = clipLine(sink), rotatedStart = rotate2.invert(start2[0], start2[1]), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon2, segments, ring;
      var clip = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon2 = [];
        },
        polygonEnd: function() {
          clip.point = point2;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge_default2(segments);
          var startInside = polygonContains_default(polygon2, rotatedStart);
          if (segments.length) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            polygon_default(segments, compareIntersection, startInside, interpolate, sink);
          } else if (startInside) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted)
            sink.polygonEnd(), polygonStarted = false;
          segments = polygon2 = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };
      function point2(lambda, phi) {
        var point3 = rotate2(lambda, phi);
        if (pointVisible(lambda = point3[0], phi = point3[1]))
          sink.point(lambda, phi);
      }
      function pointLine(lambda, phi) {
        var point3 = rotate2(lambda, phi);
        line.point(point3[0], point3[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point2;
        line.lineEnd();
      }
      function pointRing(lambda, phi) {
        ring.push([lambda, phi]);
        var point3 = rotate2(lambda, phi);
        ringSink.point(point3[0], point3[1]);
      }
      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();
        var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point3;
        ring.pop();
        polygon2.push(ring);
        ring = null;
        if (!n)
          return;
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m = segment.length - 1) > 0) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m; ++i)
              sink.point((point3 = segment[i])[0], point3[1]);
            sink.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2)
          ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(validSegment));
      }
      return clip;
    };
  }
  function validSegment(segment) {
    return segment.length > 1;
  }
  function compareIntersection(a2, b) {
    return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi - epsilon3 : halfPi - a2[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon3 : halfPi - b[1]);
  }

  // ../node_modules/d3-geo/src/clip/antimeridian.js
  var antimeridian_default = clip_default(
    function() {
      return true;
    },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi, -halfPi]
  );
  function clipAntimeridianLine(stream) {
    var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda1, phi1) {
        var sign1 = lambda1 > 0 ? pi : -pi, delta = abs(lambda1 - lambda0);
        if (abs(delta - pi) < epsilon3) {
          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          stream.point(lambda1, phi0);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi) {
          if (abs(lambda0 - sign0) < epsilon3)
            lambda0 -= sign0 * epsilon3;
          if (abs(lambda1 - sign1) < epsilon3)
            lambda1 -= sign1 * epsilon3;
          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          clean = 0;
        }
        stream.point(lambda0 = lambda1, phi0 = phi1);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda0 = phi0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
    var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
    return abs(sinLambda0Lambda1) > epsilon3 ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
  }
  function clipAntimeridianInterpolate(from2, to, direction, stream) {
    var phi;
    if (from2 == null) {
      phi = direction * halfPi;
      stream.point(-pi, phi);
      stream.point(0, phi);
      stream.point(pi, phi);
      stream.point(pi, 0);
      stream.point(pi, -phi);
      stream.point(0, -phi);
      stream.point(-pi, -phi);
      stream.point(-pi, 0);
      stream.point(-pi, phi);
    } else if (abs(from2[0] - to[0]) > epsilon3) {
      var lambda = from2[0] < to[0] ? pi : -pi;
      phi = direction * lambda / 2;
      stream.point(-lambda, phi);
      stream.point(0, phi);
      stream.point(lambda, phi);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  // ../node_modules/d3-geo/src/clip/circle.js
  function circle_default(radius, delta) {
    var cr = cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon3;
    function interpolate(from2, to, direction, stream) {
      circleStream(stream, radius, delta, direction, from2, to);
    }
    function visible(lambda, phi) {
      return cos(lambda) * cos(phi) > cr;
    }
    function clipLine(stream) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(lambda, phi) {
          var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
          if (!point0 && (v00 = v0 = v))
            stream.lineStart();
          if (v !== v0) {
            point2 = intersect2(point0, point1);
            if (!point2 || pointEqual_default(point0, point2) || pointEqual_default(point1, point2)) {
              point1[0] += epsilon3;
              point1[1] += epsilon3;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              stream.lineStart();
              point2 = intersect2(point1, point0);
              stream.point(point2[0], point2[1]);
            } else {
              point2 = intersect2(point0, point1);
              stream.point(point2[0], point2[1]);
              stream.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect2(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                stream.lineStart();
                stream.point(t[0][0], t[0][1]);
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
              } else {
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
                stream.lineStart();
                stream.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !pointEqual_default(point0, point1))) {
            stream.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0)
            stream.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect2(a2, b, two) {
      var pa = cartesian(a2), pb = cartesian(b);
      var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant)
        return !two && a2;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A2 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c2);
      cartesianAddInPlace(A2, B2);
      var u = n1xn2, w = cartesianDot(A2, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A2, A2) - 1);
      if (t2 < 0)
        return;
      var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);
      cartesianAddInPlace(q, A2);
      q = spherical(q);
      if (!two)
        return q;
      var lambda0 = a2[0], lambda1 = b[0], phi0 = a2[1], phi1 = b[1], z2;
      if (lambda1 < lambda0)
        z2 = lambda0, lambda0 = lambda1, lambda1 = z2;
      var delta2 = lambda1 - lambda0, polar = abs(delta2 - pi) < epsilon3, meridian = polar || delta2 < epsilon3;
      if (!polar && phi1 < phi0)
        z2 = phi0, phi0 = phi1, phi1 = z2;
      if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon3 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
        var q1 = cartesianScale(u, (-w + t) / uu);
        cartesianAddInPlace(q1, A2);
        return [q, spherical(q1)];
      }
    }
    function code(lambda, phi) {
      var r = smallRadius ? radius : pi - radius, code2 = 0;
      if (lambda < -r)
        code2 |= 1;
      else if (lambda > r)
        code2 |= 2;
      if (phi < -r)
        code2 |= 4;
      else if (phi > r)
        code2 |= 8;
      return code2;
    }
    return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
  }

  // ../node_modules/d3-geo/src/transform.js
  function transformer(methods) {
    return function(stream) {
      var s = new TransformStream();
      for (var key2 in methods)
        s[key2] = methods[key2];
      s.stream = stream;
      return s;
    };
  }
  function TransformStream() {
  }
  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x3, y3) {
      this.stream.point(x3, y3);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };

  // ../node_modules/d3-geo/src/projection/fit.js
  function fitExtent(projection2, extent, object2) {
    var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], clip = projection2.clipExtent && projection2.clipExtent();
    projection2.scale(150).translate([0, 0]);
    if (clip != null)
      projection2.clipExtent(null);
    stream_default(object2, projection2.stream(bounds_default2));
    var b = bounds_default2.result(), k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x3 = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y3 = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    if (clip != null)
      projection2.clipExtent(clip);
    return projection2.scale(k * 150).translate([x3, y3]);
  }
  function fitSize(projection2, size, object2) {
    return fitExtent(projection2, [[0, 0], size], object2);
  }

  // ../node_modules/d3-geo/src/projection/resample.js
  var maxDepth = 16;
  var cosMinDistance = cos(30 * radians);
  function resample_default(project, delta2) {
    return +delta2 ? resample(project, delta2) : resampleNone(project);
  }
  function resampleNone(project) {
    return transformer({
      point: function(x3, y3) {
        x3 = project(x3, y3);
        this.stream.point(x3[0], x3[1]);
      }
    });
  }
  function resample(project, delta2) {
    function resampleLineTo(x02, y02, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
      var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
      if (d2 > 4 * delta2 && depth--) {
        var a2 = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a2 * a2 + b * b + c * c), phi2 = asin(c /= m), lambda2 = abs(abs(c) - 1) < epsilon3 || abs(lambda0 - lambda1) < epsilon3 ? (lambda0 + lambda1) / 2 : atan2(b, a2), p = project(lambda2, phi2), x22 = p[0], y22 = p[1], dx2 = x22 - x02, dy2 = y22 - y02, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x02, y02, lambda0, a0, b0, c0, x22, y22, lambda2, a2 /= m, b /= m, c, depth, stream);
          stream.point(x22, y22);
          resampleLineTo(x22, y22, lambda2, a2, b, c, x12, y12, lambda1, a1, b1, c1, depth, stream);
        }
      }
    }
    return function(stream) {
      var lambda00, x00, y00, a00, b00, c00, lambda0, x02, y02, a0, b0, c0;
      var resampleStream = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resampleStream.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resampleStream.lineStart = lineStart;
        }
      };
      function point2(x3, y3) {
        x3 = project(x3, y3);
        stream.point(x3[0], x3[1]);
      }
      function lineStart() {
        x02 = NaN;
        resampleStream.point = linePoint;
        stream.lineStart();
      }
      function linePoint(lambda, phi) {
        var c = cartesian([lambda, phi]), p = project(lambda, phi);
        resampleLineTo(x02, y02, lambda0, a0, b0, c0, x02 = p[0], y02 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x02, y02);
      }
      function lineEnd() {
        resampleStream.point = point2;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resampleStream.point = ringPoint;
        resampleStream.lineEnd = ringEnd;
      }
      function ringPoint(lambda, phi) {
        linePoint(lambda00 = lambda, phi), x00 = x02, y00 = y02, a00 = a0, b00 = b0, c00 = c0;
        resampleStream.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x02, y02, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
        resampleStream.lineEnd = lineEnd;
        lineEnd();
      }
      return resampleStream;
    };
  }

  // ../node_modules/d3-geo/src/projection/index.js
  var transformRadians = transformer({
    point: function(x3, y3) {
      this.stream.point(x3 * radians, y3 * radians);
    }
  });
  function projection(project) {
    return projectionMutator(function() {
      return project;
    })();
  }
  function projectionMutator(projectAt) {
    var project, k = 150, x3 = 480, y3 = 250, dx, dy, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate2, projectRotate, theta = null, preclip = antimeridian_default, x02 = null, y02, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample = resample_default(projectTransform, delta2), cache2, cacheStream;
    function projection2(point2) {
      point2 = projectRotate(point2[0] * radians, point2[1] * radians);
      return [point2[0] * k + dx, dy - point2[1] * k];
    }
    function invert2(point2) {
      point2 = projectRotate.invert((point2[0] - dx) / k, (dy - point2[1]) / k);
      return point2 && [point2[0] * degrees, point2[1] * degrees];
    }
    function projectTransform(x4, y4) {
      return x4 = project(x4, y4), [x4[0] * k + dx, dy - x4[1] * k];
    }
    projection2.stream = function(stream) {
      return cache2 && cacheStream === stream ? cache2 : cache2 = transformRadians(preclip(rotate2, projectResample(postclip(cacheStream = stream))));
    };
    projection2.clipAngle = function(_) {
      return arguments.length ? (preclip = +_ ? circle_default(theta = _ * radians, 6 * radians) : (theta = null, antimeridian_default), reset()) : theta * degrees;
    };
    projection2.clipExtent = function(_) {
      return arguments.length ? (postclip = _ == null ? (x02 = y02 = x12 = y12 = null, identity_default3) : clipExtent(x02 = +_[0][0], y02 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x02 == null ? null : [[x02, y02], [x12, y12]];
    };
    projection2.scale = function(_) {
      return arguments.length ? (k = +_, recenter()) : k;
    };
    projection2.translate = function(_) {
      return arguments.length ? (x3 = +_[0], y3 = +_[1], recenter()) : [x3, y3];
    };
    projection2.center = function(_) {
      return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
    };
    projection2.rotate = function(_) {
      return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
    };
    projection2.precision = function(_) {
      return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
    };
    projection2.fitExtent = function(extent, object2) {
      return fitExtent(projection2, extent, object2);
    };
    projection2.fitSize = function(size, object2) {
      return fitSize(projection2, size, object2);
    };
    function recenter() {
      projectRotate = compose_default(rotate2 = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
      var center2 = project(lambda, phi);
      dx = x3 - center2[0] * k;
      dy = y3 + center2[1] * k;
      return reset();
    }
    function reset() {
      cache2 = cacheStream = null;
      return projection2;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection2.invert = project.invert && invert2;
      return recenter();
    };
  }

  // ../node_modules/d3-geo/src/projection/azimuthal.js
  function azimuthalRaw(scale) {
    return function(x3, y3) {
      var cx = cos(x3), cy = cos(y3), k = scale(cx * cy);
      return [
        k * cy * sin(x3),
        k * sin(y3)
      ];
    };
  }
  function azimuthalInvert(angle) {
    return function(x3, y3) {
      var z2 = sqrt(x3 * x3 + y3 * y3), c = angle(z2), sc = sin(c), cc = cos(c);
      return [
        atan2(x3 * sc, z2 * cc),
        asin(z2 && y3 * sc / z2)
      ];
    };
  }

  // ../node_modules/d3-geo/src/projection/azimuthalEqualArea.js
  var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
    return sqrt(2 / (1 + cxcy));
  });
  azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z2) {
    return 2 * asin(z2 / 2);
  });

  // ../node_modules/d3-geo/src/projection/azimuthalEquidistant.js
  var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
    return (c = acos(c)) && c / sin(c);
  });
  azimuthalEquidistantRaw.invert = azimuthalInvert(function(z2) {
    return z2;
  });
  function azimuthalEquidistant_default() {
    return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
  }

  // ../node_modules/d3-geo/src/projection/mercator.js
  function mercatorRaw(lambda, phi) {
    return [lambda, log(tan((halfPi + phi) / 2))];
  }
  mercatorRaw.invert = function(x3, y3) {
    return [x3, 2 * atan(exp(y3)) - halfPi];
  };

  // ../node_modules/d3-geo/src/projection/equirectangular.js
  function equirectangularRaw(lambda, phi) {
    return [lambda, phi];
  }
  equirectangularRaw.invert = equirectangularRaw;

  // ../node_modules/d3-geo/src/projection/gnomonic.js
  function gnomonicRaw(x3, y3) {
    var cy = cos(y3), k = cos(x3) * cy;
    return [cy * sin(x3) / k, sin(y3) / k];
  }
  gnomonicRaw.invert = azimuthalInvert(atan);

  // ../node_modules/d3-geo/src/projection/naturalEarth1.js
  function naturalEarth1Raw(lambda, phi) {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    return [
      lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
      phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
    ];
  }
  naturalEarth1Raw.invert = function(x3, y3) {
    var phi = y3, i = 25, delta;
    do {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y3) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
    } while (abs(delta) > epsilon3 && --i > 0);
    return [
      x3 / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
      phi
    ];
  };

  // ../node_modules/d3-geo/src/projection/orthographic.js
  function orthographicRaw(x3, y3) {
    return [cos(y3) * sin(x3), sin(y3)];
  }
  orthographicRaw.invert = azimuthalInvert(asin);

  // ../node_modules/d3-geo/src/projection/stereographic.js
  function stereographicRaw(x3, y3) {
    var cy = cos(y3), k = 1 + cos(x3) * cy;
    return [cy * sin(x3) / k, sin(y3) / k];
  }
  stereographicRaw.invert = azimuthalInvert(function(z2) {
    return 2 * atan(z2);
  });

  // ../node_modules/d3-geo/src/projection/transverseMercator.js
  function transverseMercatorRaw(lambda, phi) {
    return [log(tan((halfPi + phi) / 2)), -lambda];
  }
  transverseMercatorRaw.invert = function(x3, y3) {
    return [-y3, 2 * atan(exp(x3)) - halfPi];
  };

  // ../node_modules/@turf/buffer/dist/es/index.js
  function buffer2(geojson, radius, options) {
    options = options || {};
    var units = options.units || "kilometers";
    var steps = options.steps || 8;
    if (!geojson)
      throw new Error("geojson is required");
    if (typeof options !== "object")
      throw new Error("options must be an object");
    if (typeof steps !== "number")
      throw new Error("steps must be an number");
    if (radius === void 0)
      throw new Error("radius is required");
    if (steps <= 0)
      throw new Error("steps must be greater than 0");
    var results = [];
    switch (geojson.type) {
      case "GeometryCollection":
        geomEach(geojson, function(geometry) {
          var buffered = bufferFeature(geometry, radius, units, steps);
          if (buffered)
            results.push(buffered);
        });
        return featureCollection(results);
      case "FeatureCollection":
        featureEach(geojson, function(feature3) {
          var multiBuffered = bufferFeature(feature3, radius, units, steps);
          if (multiBuffered) {
            featureEach(multiBuffered, function(buffered) {
              if (buffered)
                results.push(buffered);
            });
          }
        });
        return featureCollection(results);
    }
    return bufferFeature(geojson, radius, units, steps);
  }
  function bufferFeature(geojson, radius, units, steps) {
    var properties = geojson.properties || {};
    var geometry = geojson.type === "Feature" ? geojson.geometry : geojson;
    if (geometry.type === "GeometryCollection") {
      var results = [];
      geomEach(geojson, function(geometry2) {
        var buffered2 = bufferFeature(geometry2, radius, units, steps);
        if (buffered2)
          results.push(buffered2);
      });
      return featureCollection(results);
    }
    var projection2 = defineProjection(geometry);
    var projected = {
      type: geometry.type,
      coordinates: projectCoords(geometry.coordinates, projection2)
    };
    var reader = new import_turf_jsts.GeoJSONReader();
    var geom = reader.read(projected);
    var distance = radiansToLength(lengthToRadians(radius, units), "meters");
    var buffered = import_turf_jsts.BufferOp.bufferOp(geom, distance, steps);
    var writer = new import_turf_jsts.GeoJSONWriter();
    buffered = writer.write(buffered);
    if (coordsIsNaN(buffered.coordinates))
      return void 0;
    var result = {
      type: buffered.type,
      coordinates: unprojectCoords(buffered.coordinates, projection2)
    };
    return feature2(result, properties);
  }
  function coordsIsNaN(coords) {
    if (Array.isArray(coords[0]))
      return coordsIsNaN(coords[0]);
    return isNaN(coords[0]);
  }
  function projectCoords(coords, proj) {
    if (typeof coords[0] !== "object")
      return proj(coords);
    return coords.map(function(coord) {
      return projectCoords(coord, proj);
    });
  }
  function unprojectCoords(coords, proj) {
    if (typeof coords[0] !== "object")
      return proj.invert(coords);
    return coords.map(function(coord) {
      return unprojectCoords(coord, proj);
    });
  }
  function defineProjection(geojson) {
    var coords = es_default7(geojson).geometry.coordinates;
    var rotation = [-coords[0], -coords[1]];
    return azimuthalEquidistant_default().rotate(rotation).scale(earthRadius);
  }
  var es_default32 = buffer2;

  // ../node_modules/@turf/union/dist/es/index.js
  var import_polygon_clipping2 = __toESM(require_polygon_clipping_umd(), 1);

  // ../node_modules/@turf/intersect/dist/es/index.js
  var import_polygon_clipping3 = __toESM(require_polygon_clipping_umd(), 1);

  // ../node_modules/@turf/dissolve/dist/es/index.js
  var import_polygon_clipping4 = __toESM(require_polygon_clipping_umd(), 1);

  // ../node_modules/@turf/mask/dist/es/index.js
  var import_polygon_clipping5 = __toESM(require_polygon_clipping_umd(), 1);

  // Source/custom/utils/LatLngPoint.js
  var LatLngPoint = class {
    constructor(lng, lat, alt) {
      this._lng = Number(lng || 0);
      this._lat = Number(lat || 0);
      this._alt = Number(alt || 0);
    }
    get lng() {
      return this._lng;
    }
    set lng(lng) {
      this._lng = +lng;
      this._position = null;
    }
    get lat() {
      return this._lat;
    }
    set lat(lat) {
      this._lat = +lat;
      this._position = null;
    }
    get alt() {
      return this._alt || 0;
    }
    set alt(alt) {
      this._alt = +alt;
      this._position = null;
    }
    clone() {
      let position = new LatLngPoint();
      position.lng = this.lng || 0;
      position.lat = this.lat || 0;
      position.alt = this.alt || 0;
      return position;
    }
    format() {
      this.lng = this.lng.toFixed(LatLngPoint.FormatLength);
      this.lat = this.lat.toFixed(LatLngPoint.FormatLength);
      this.alt = this.alt.toFixed(LatLngPoint.FormatLength);
      return this;
    }
    toArray(noAlt) {
      this.format();
      if (noAlt) {
        return [this.lng, this.lat];
      } else {
        return [this.lng, this.lat, this.alt];
      }
    }
    toString() {
      this.format();
      return `${this.lng},${this.lat},${this.alt}`;
    }
    toCartesian(clone2 = false) {
      if (!clone2 && this._position) {
        return this._position;
      } else {
        return Cesium.Cartesian3.fromDegrees(this.lng, this.lat, this.alt);
      }
    }
    toCartographic() {
      return Cesium.Cartographic.fromDegrees(this.lng, this.lat, this.alt);
    }
    equals(other) {
      return this === other || other instanceof LatLngPoint && this._alt == other._alt && this._lat == other._lat && this._lng == other._lng;
    }
    static parse(position, time) {
      if (!position) {
        return new LatLngPoint();
      }
      let result;
      if (typeof position == "string") {
        result = LatLngPoint.fromString(position);
      } else if (Array.isArray(position)) {
        result = LatLngPoint.fromArray(position);
      } else if (position instanceof LatLngPoint) {
        result = position.clone();
      } else if (Cesium.defined(position.lat) && Cesium.defined(position.lng)) {
        result = new LatLngPoint(position.lng, position.lat, position.alt);
        for (let key2 in position) {
          result[key2] = position[key2];
        }
      } else if (position instanceof Cesium.Cartesian3 || position._value || position.getValue) {
        result = LatLngPoint.fromCartesian(position, time);
        result._position = position;
      } else if (Cesium.defined(position.x) && Cesium.defined(position.y) && Cesium.defined(position.z)) {
        position = new Cesium.Cartesian3(position.x, position.y, position.z);
        result = LatLngPoint.fromCartesian(position, time);
        result._position = position;
      } else {
        result = new LatLngPoint();
        console.log("\u5750\u6807\u89E3\u6790\u5931\u8D25\uFF0C\u8BF7\u786E\u8BA4\u53C2\u6570\u662F\u5426\u65E0\u8BEF", position);
      }
      return result;
    }
    static parseCartesian3(position, time) {
      return LatLngPoint.parse(position, time).toCartesian();
    }
    static fromArray(arr2) {
      let position = new LatLngPoint();
      if (Array.isArray(arr2)) {
        position.lng = arr2[0] || 0;
        position.lat = arr2[1] || 0;
        position.alt = arr2[2] || 0;
      }
      return position;
    }
    static fromString(str) {
      let position = new LatLngPoint();
      if (str && typeof str == "string") {
        let arr2 = str.split(",");
        position = this.fromArray(arr2);
      }
      return position;
    }
    static fromCartesian(cartesian2, time) {
      let result = new LatLngPoint();
      let _position;
      if (cartesian2) {
        if (cartesian2 instanceof Cesium.Cartesian3) {
          _position = cartesian2;
        } else if (cartesian2._value && cartesian2._value instanceof Cesium.Cartesian3) {
          _position = cartesian2._value;
        } else if (typeof cartesian2.getValue == "function") {
          _position = cartesian2.getValue(time || Cesium.JulianDate.now());
        }
      }
      if (_position) {
        let carto = Cesium.Cartographic.fromCartesian(_position);
        if (carto) {
          result.lat = Cesium.Math.toDegrees(carto.latitude);
          result.lng = Cesium.Math.toDegrees(carto.longitude);
          result.alt = carto.height;
          result.format();
        }
      }
      result._position = cartesian2;
      return result;
    }
    static fromCartographic(cartographic) {
      let result = new LatLngPoint();
      result.lat = Cesium.Math.toDegrees(cartographic.latitude);
      result.lng = Cesium.Math.toDegrees(cartographic.longitude);
      result.alt = cartographic.height;
      return result;
    }
  };
  LatLngPoint.FormatLength = 6;
  LatLngPoint.FormatAltLength = 1;
  var LatLngPoint_default = LatLngPoint;

  // Source/custom/utils/PointUtil.js
  var getMaxHeight = function(positions, defaultVal = 0) {
    if (positions == null || positions.length == 0) {
      return defaultVal;
    }
    let maxHeight = defaultVal;
    for (let i = 0; i < positions.length; i++) {
      let tempCarto = Cesium.Cartographic.fromCartesian(positions[i]);
      if (i == 0) {
        maxHeight = tempCarto.height;
      }
      if (tempCarto.height > maxHeight) {
        maxHeight = tempCarto.height;
      }
    }
    return maxHeight.toFixed(LatLngPoint_default.FormatAltLength);
  };
  var getOnLinePointByLen = function(p1, p2, len, addBS) {
    let mtx4 = Cesium.Transforms.eastNorthUpToFixedFrame(p1);
    let mtx4_inverser = Cesium.Matrix4.inverse(mtx4, new Cesium.Matrix4());
    p1 = Cesium.Matrix4.multiplyByPoint(mtx4_inverser, p1, new Cesium.Cartesian3());
    p2 = Cesium.Matrix4.multiplyByPoint(mtx4_inverser, p2, new Cesium.Cartesian3());
    let substrct = Cesium.Cartesian3.subtract(p2, p1, new Cesium.Cartesian3());
    let dis = Cesium.Cartesian3.distance(p1, p2);
    let scale = len / dis;
    if (addBS) {
      scale += 1;
    }
    let newP = Cesium.Cartesian3.multiplyByScalar(substrct, scale, new Cesium.Cartesian3());
    newP = Cesium.Matrix4.multiplyByPoint(mtx4, newP, new Cesium.Cartesian3());
    return newP;
  };
  var setPositionsHeight = function(positions, height = 0) {
    if (!positions) {
      return positions;
    }
    if (Array.isArray(positions)) {
      let arr2 = [];
      for (let i = 0, len = positions.length; i < len; i++) {
        let car = Cesium.Cartographic.fromCartesian(positions[i]);
        let point2 = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
        arr2.push(point2);
      }
      return arr2;
    } else {
      let car = Cesium.Cartographic.fromCartesian(positions);
      return Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
    }
  };
  var getSurfaceHeight = function(scene, position, options = {}) {
    if (!position) {
      return position;
    }
    if (scene && scene.scene) {
      scene = scene.scene;
    }
    let _has3dtiles = Cesium.defaultValue(options.has3dtiles, false);
    if (_has3dtiles) {
      return getSurface3DTilesHeight(scene, position, options);
    } else {
      return getSurfaceTerrainHeight(scene, position, options);
    }
  };
  var getSurface3DTilesHeight = function(scene, position, options = {}) {
    options.cartographic = options.cartographic || Cesium.Cartographic.fromCartesian(position);
    let carto = options.cartographic;
    let callback = options.callback;
    if (options.asyn) {
      scene.clampToHeightMostDetailed([position], options.objectsToExclude, 0.2).then(function(clampedPositions) {
        let clampedPt = clampedPositions[0];
        if (Cesium.defined(clampedPt)) {
          let cartiles = Cesium.Cartographic.fromCartesian(clampedPt);
          let heightTiles = cartiles.height;
          if (Cesium.defined(heightTiles) && heightTiles > -1e3) {
            if (callback) {
              callback(heightTiles, cartiles);
            }
            return;
          }
        }
        getSurfaceTerrainHeight(scene, position, options);
      });
    } else {
      let heightTiles = scene.sampleHeight(carto, options.objectsToExclude, 0.2);
      if (Cesium.defined(heightTiles) && heightTiles > -1e3) {
        if (callback) {
          callback(heightTiles, carto);
        }
        return heightTiles;
      }
    }
    return 0;
  };
  function getSurfaceTerrainHeight(scene, position, options = {}) {
    let carto = options.cartographic || Cesium.Cartographic.fromCartesian(position);
    let callback = options.callback;
    let _hasTerrain = Boolean(scene.terrainProvider._layers);
    if (!_hasTerrain) {
      if (callback) {
        callback(carto.height, carto);
      }
      return carto.height;
    }
    if (options.asyn) {
      Promise.resolve(Cesium.sampleTerrainMostDetailed(scene.terrainProvider, [carto])).then(function(samples) {
        let clampedCart = samples[0];
        let heightTerrain;
        if (Cesium.defined(clampedCart) && Cesium.defined(clampedCart.height)) {
          heightTerrain = clampedCart.height;
        } else {
          heightTerrain = scene.globe.getHeight(carto);
        }
        if (callback) {
          callback(heightTerrain, carto);
        }
      });
    } else {
      let heightTerrain = scene.globe.getHeight(carto);
      if (heightTerrain && heightTerrain > -1e3) {
        if (callback) {
          callback(heightTerrain, carto);
        }
        return heightTerrain;
      } else {
        return carto.height;
      }
    }
    return 0;
  }
  var PointUtil_default = { getMaxHeight, getOnLinePointByLen, setPositionsHeight, getSurfaceHeight, getSurface3DTilesHeight };

  // ../node_modules/proj4/lib/global.js
  function global_default(defs2) {
    defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
    defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
    defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
    defs2.WGS84 = defs2["EPSG:4326"];
    defs2["EPSG:3785"] = defs2["EPSG:3857"];
    defs2.GOOGLE = defs2["EPSG:3857"];
    defs2["EPSG:900913"] = defs2["EPSG:3857"];
    defs2["EPSG:102113"] = defs2["EPSG:3857"];
  }

  // ../node_modules/proj4/lib/constants/values.js
  var PJD_3PARAM = 1;
  var PJD_7PARAM = 2;
  var PJD_GRIDSHIFT = 3;
  var PJD_WGS84 = 4;
  var PJD_NODATUM = 5;
  var SRS_WGS84_SEMIMAJOR = 6378137;
  var SRS_WGS84_SEMIMINOR = 6356752314e-3;
  var SRS_WGS84_ESQUARED = 0.0066943799901413165;
  var SEC_TO_RAD = 484813681109536e-20;
  var HALF_PI = Math.PI / 2;
  var SIXTH = 0.16666666666666666;
  var RA4 = 0.04722222222222222;
  var RA6 = 0.022156084656084655;
  var EPSLN = 1e-10;
  var D2R2 = 0.017453292519943295;
  var R2D2 = 57.29577951308232;
  var FORTPI = Math.PI / 4;
  var TWO_PI = Math.PI * 2;
  var SPI = 3.14159265359;

  // ../node_modules/proj4/lib/constants/PrimeMeridian.js
  var exports2 = {};
  exports2.greenwich = 0;
  exports2.lisbon = -9.131906111111;
  exports2.paris = 2.337229166667;
  exports2.bogota = -74.080916666667;
  exports2.madrid = -3.687938888889;
  exports2.rome = 12.452333333333;
  exports2.bern = 7.439583333333;
  exports2.jakarta = 106.807719444444;
  exports2.ferro = -17.666666666667;
  exports2.brussels = 4.367975;
  exports2.stockholm = 18.058277777778;
  exports2.athens = 23.7163375;
  exports2.oslo = 10.722916666667;

  // ../node_modules/proj4/lib/constants/units.js
  var units_default = {
    ft: { to_meter: 0.3048 },
    "us-ft": { to_meter: 1200 / 3937 }
  };

  // ../node_modules/proj4/lib/match.js
  var ignoredChar = /[\s_\-\/\(\)]/g;
  function match(obj, key2) {
    if (obj[key2]) {
      return obj[key2];
    }
    var keys = Object.keys(obj);
    var lkey = key2.toLowerCase().replace(ignoredChar, "");
    var i = -1;
    var testkey, processedKey;
    while (++i < keys.length) {
      testkey = keys[i];
      processedKey = testkey.toLowerCase().replace(ignoredChar, "");
      if (processedKey === lkey) {
        return obj[testkey];
      }
    }
  }

  // ../node_modules/proj4/lib/projString.js
  function projString_default(defData) {
    var self2 = {};
    var paramObj = defData.split("+").map(function(v) {
      return v.trim();
    }).filter(function(a2) {
      return a2;
    }).reduce(function(p, a2) {
      var split = a2.split("=");
      split.push(true);
      p[split[0].toLowerCase()] = split[1];
      return p;
    }, {});
    var paramName, paramVal, paramOutname;
    var params2 = {
      proj: "projName",
      datum: "datumCode",
      rf: function(v) {
        self2.rf = parseFloat(v);
      },
      lat_0: function(v) {
        self2.lat0 = v * D2R2;
      },
      lat_1: function(v) {
        self2.lat1 = v * D2R2;
      },
      lat_2: function(v) {
        self2.lat2 = v * D2R2;
      },
      lat_ts: function(v) {
        self2.lat_ts = v * D2R2;
      },
      lon_0: function(v) {
        self2.long0 = v * D2R2;
      },
      lon_1: function(v) {
        self2.long1 = v * D2R2;
      },
      lon_2: function(v) {
        self2.long2 = v * D2R2;
      },
      alpha: function(v) {
        self2.alpha = parseFloat(v) * D2R2;
      },
      gamma: function(v) {
        self2.rectified_grid_angle = parseFloat(v);
      },
      lonc: function(v) {
        self2.longc = v * D2R2;
      },
      x_0: function(v) {
        self2.x0 = parseFloat(v);
      },
      y_0: function(v) {
        self2.y0 = parseFloat(v);
      },
      k_0: function(v) {
        self2.k0 = parseFloat(v);
      },
      k: function(v) {
        self2.k0 = parseFloat(v);
      },
      a: function(v) {
        self2.a = parseFloat(v);
      },
      b: function(v) {
        self2.b = parseFloat(v);
      },
      r_a: function() {
        self2.R_A = true;
      },
      zone: function(v) {
        self2.zone = parseInt(v, 10);
      },
      south: function() {
        self2.utmSouth = true;
      },
      towgs84: function(v) {
        self2.datum_params = v.split(",").map(function(a2) {
          return parseFloat(a2);
        });
      },
      to_meter: function(v) {
        self2.to_meter = parseFloat(v);
      },
      units: function(v) {
        self2.units = v;
        var unit = match(units_default, v);
        if (unit) {
          self2.to_meter = unit.to_meter;
        }
      },
      from_greenwich: function(v) {
        self2.from_greenwich = v * D2R2;
      },
      pm: function(v) {
        var pm = match(exports2, v);
        self2.from_greenwich = (pm ? pm : parseFloat(v)) * D2R2;
      },
      nadgrids: function(v) {
        if (v === "@null") {
          self2.datumCode = "none";
        } else {
          self2.nadgrids = v;
        }
      },
      axis: function(v) {
        var legalAxis = "ewnsud";
        if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
          self2.axis = v;
        }
      },
      approx: function() {
        self2.approx = true;
      }
    };
    for (paramName in paramObj) {
      paramVal = paramObj[paramName];
      if (paramName in params2) {
        paramOutname = params2[paramName];
        if (typeof paramOutname === "function") {
          paramOutname(paramVal);
        } else {
          self2[paramOutname] = paramVal;
        }
      } else {
        self2[paramName] = paramVal;
      }
    }
    if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
      self2.datumCode = self2.datumCode.toLowerCase();
    }
    return self2;
  }

  // ../node_modules/wkt-parser/parser.js
  var parser_default = parseString;
  var NEUTRAL = 1;
  var KEYWORD = 2;
  var NUMBER = 3;
  var QUOTED = 4;
  var AFTERQUOTE = 5;
  var ENDED = -1;
  var whitespace = /\s/;
  var latin = /[A-Za-z]/;
  var keyword = /[A-Za-z84_]/;
  var endThings = /[,\]]/;
  var digets = /[\d\.E\-\+]/;
  function Parser(text) {
    if (typeof text !== "string") {
      throw new Error("not a string");
    }
    this.text = text.trim();
    this.level = 0;
    this.place = 0;
    this.root = null;
    this.stack = [];
    this.currentObject = null;
    this.state = NEUTRAL;
  }
  Parser.prototype.readCharicter = function() {
    var char = this.text[this.place++];
    if (this.state !== QUOTED) {
      while (whitespace.test(char)) {
        if (this.place >= this.text.length) {
          return;
        }
        char = this.text[this.place++];
      }
    }
    switch (this.state) {
      case NEUTRAL:
        return this.neutral(char);
      case KEYWORD:
        return this.keyword(char);
      case QUOTED:
        return this.quoted(char);
      case AFTERQUOTE:
        return this.afterquote(char);
      case NUMBER:
        return this.number(char);
      case ENDED:
        return;
    }
  };
  Parser.prototype.afterquote = function(char) {
    if (char === '"') {
      this.word += '"';
      this.state = QUOTED;
      return;
    }
    if (endThings.test(char)) {
      this.word = this.word.trim();
      this.afterItem(char);
      return;
    }
    throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
  };
  Parser.prototype.afterItem = function(char) {
    if (char === ",") {
      if (this.word !== null) {
        this.currentObject.push(this.word);
      }
      this.word = null;
      this.state = NEUTRAL;
      return;
    }
    if (char === "]") {
      this.level--;
      if (this.word !== null) {
        this.currentObject.push(this.word);
        this.word = null;
      }
      this.state = NEUTRAL;
      this.currentObject = this.stack.pop();
      if (!this.currentObject) {
        this.state = ENDED;
      }
      return;
    }
  };
  Parser.prototype.number = function(char) {
    if (digets.test(char)) {
      this.word += char;
      return;
    }
    if (endThings.test(char)) {
      this.word = parseFloat(this.word);
      this.afterItem(char);
      return;
    }
    throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
  };
  Parser.prototype.quoted = function(char) {
    if (char === '"') {
      this.state = AFTERQUOTE;
      return;
    }
    this.word += char;
    return;
  };
  Parser.prototype.keyword = function(char) {
    if (keyword.test(char)) {
      this.word += char;
      return;
    }
    if (char === "[") {
      var newObjects = [];
      newObjects.push(this.word);
      this.level++;
      if (this.root === null) {
        this.root = newObjects;
      } else {
        this.currentObject.push(newObjects);
      }
      this.stack.push(this.currentObject);
      this.currentObject = newObjects;
      this.state = NEUTRAL;
      return;
    }
    if (endThings.test(char)) {
      this.afterItem(char);
      return;
    }
    throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
  };
  Parser.prototype.neutral = function(char) {
    if (latin.test(char)) {
      this.word = char;
      this.state = KEYWORD;
      return;
    }
    if (char === '"') {
      this.word = "";
      this.state = QUOTED;
      return;
    }
    if (digets.test(char)) {
      this.word = char;
      this.state = NUMBER;
      return;
    }
    if (endThings.test(char)) {
      this.afterItem(char);
      return;
    }
    throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
  };
  Parser.prototype.output = function() {
    while (this.place < this.text.length) {
      this.readCharicter();
    }
    if (this.state === ENDED) {
      return this.root;
    }
    throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
  };
  function parseString(txt) {
    var parser = new Parser(txt);
    return parser.output();
  }

  // ../node_modules/wkt-parser/process.js
  function mapit(obj, key2, value) {
    if (Array.isArray(key2)) {
      value.unshift(key2);
      key2 = null;
    }
    var thing = key2 ? {} : obj;
    var out = value.reduce(function(newObj, item) {
      sExpr(item, newObj);
      return newObj;
    }, thing);
    if (key2) {
      obj[key2] = out;
    }
  }
  function sExpr(v, obj) {
    if (!Array.isArray(v)) {
      obj[v] = true;
      return;
    }
    var key2 = v.shift();
    if (key2 === "PARAMETER") {
      key2 = v.shift();
    }
    if (v.length === 1) {
      if (Array.isArray(v[0])) {
        obj[key2] = {};
        sExpr(v[0], obj[key2]);
        return;
      }
      obj[key2] = v[0];
      return;
    }
    if (!v.length) {
      obj[key2] = true;
      return;
    }
    if (key2 === "TOWGS84") {
      obj[key2] = v;
      return;
    }
    if (key2 === "AXIS") {
      if (!(key2 in obj)) {
        obj[key2] = [];
      }
      obj[key2].push(v);
      return;
    }
    if (!Array.isArray(key2)) {
      obj[key2] = {};
    }
    var i;
    switch (key2) {
      case "UNIT":
      case "PRIMEM":
      case "VERT_DATUM":
        obj[key2] = {
          name: v[0].toLowerCase(),
          convert: v[1]
        };
        if (v.length === 3) {
          sExpr(v[2], obj[key2]);
        }
        return;
      case "SPHEROID":
      case "ELLIPSOID":
        obj[key2] = {
          name: v[0],
          a: v[1],
          rf: v[2]
        };
        if (v.length === 4) {
          sExpr(v[3], obj[key2]);
        }
        return;
      case "PROJECTEDCRS":
      case "PROJCRS":
      case "GEOGCS":
      case "GEOCCS":
      case "PROJCS":
      case "LOCAL_CS":
      case "GEODCRS":
      case "GEODETICCRS":
      case "GEODETICDATUM":
      case "EDATUM":
      case "ENGINEERINGDATUM":
      case "VERT_CS":
      case "VERTCRS":
      case "VERTICALCRS":
      case "COMPD_CS":
      case "COMPOUNDCRS":
      case "ENGINEERINGCRS":
      case "ENGCRS":
      case "FITTED_CS":
      case "LOCAL_DATUM":
      case "DATUM":
        v[0] = ["name", v[0]];
        mapit(obj, key2, v);
        return;
      default:
        i = -1;
        while (++i < v.length) {
          if (!Array.isArray(v[i])) {
            return sExpr(v, obj[key2]);
          }
        }
        return mapit(obj, key2, v);
    }
  }

  // ../node_modules/wkt-parser/index.js
  var D2R3 = 0.017453292519943295;
  function rename(obj, params2) {
    var outName = params2[0];
    var inName = params2[1];
    if (!(outName in obj) && inName in obj) {
      obj[outName] = obj[inName];
      if (params2.length === 3) {
        obj[outName] = params2[2](obj[outName]);
      }
    }
  }
  function d2r(input) {
    return input * D2R3;
  }
  function cleanWKT(wkt) {
    if (wkt.type === "GEOGCS") {
      wkt.projName = "longlat";
    } else if (wkt.type === "LOCAL_CS") {
      wkt.projName = "identity";
      wkt.local = true;
    } else {
      if (typeof wkt.PROJECTION === "object") {
        wkt.projName = Object.keys(wkt.PROJECTION)[0];
      } else {
        wkt.projName = wkt.PROJECTION;
      }
    }
    if (wkt.AXIS) {
      var axisOrder = "";
      for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
        var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
        if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
          axisOrder += "n";
        } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
          axisOrder += "s";
        } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
          axisOrder += "e";
        } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
          axisOrder += "w";
        }
      }
      if (axisOrder.length === 2) {
        axisOrder += "u";
      }
      if (axisOrder.length === 3) {
        wkt.axis = axisOrder;
      }
    }
    if (wkt.UNIT) {
      wkt.units = wkt.UNIT.name.toLowerCase();
      if (wkt.units === "metre") {
        wkt.units = "meter";
      }
      if (wkt.UNIT.convert) {
        if (wkt.type === "GEOGCS") {
          if (wkt.DATUM && wkt.DATUM.SPHEROID) {
            wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
          }
        } else {
          wkt.to_meter = wkt.UNIT.convert;
        }
      }
    }
    var geogcs = wkt.GEOGCS;
    if (wkt.type === "GEOGCS") {
      geogcs = wkt;
    }
    if (geogcs) {
      if (geogcs.DATUM) {
        wkt.datumCode = geogcs.DATUM.name.toLowerCase();
      } else {
        wkt.datumCode = geogcs.name.toLowerCase();
      }
      if (wkt.datumCode.slice(0, 2) === "d_") {
        wkt.datumCode = wkt.datumCode.slice(2);
      }
      if (wkt.datumCode === "new_zealand_geodetic_datum_1949" || wkt.datumCode === "new_zealand_1949") {
        wkt.datumCode = "nzgd49";
      }
      if (wkt.datumCode === "wgs_1984" || wkt.datumCode === "world_geodetic_system_1984") {
        if (wkt.PROJECTION === "Mercator_Auxiliary_Sphere") {
          wkt.sphere = true;
        }
        wkt.datumCode = "wgs84";
      }
      if (wkt.datumCode.slice(-6) === "_ferro") {
        wkt.datumCode = wkt.datumCode.slice(0, -6);
      }
      if (wkt.datumCode.slice(-8) === "_jakarta") {
        wkt.datumCode = wkt.datumCode.slice(0, -8);
      }
      if (~wkt.datumCode.indexOf("belge")) {
        wkt.datumCode = "rnb72";
      }
      if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
        wkt.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
        if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
          wkt.ellps = "intl";
        }
        wkt.a = geogcs.DATUM.SPHEROID.a;
        wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
      }
      if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
        wkt.datum_params = geogcs.DATUM.TOWGS84;
      }
      if (~wkt.datumCode.indexOf("osgb_1936")) {
        wkt.datumCode = "osgb36";
      }
      if (~wkt.datumCode.indexOf("osni_1952")) {
        wkt.datumCode = "osni52";
      }
      if (~wkt.datumCode.indexOf("tm65") || ~wkt.datumCode.indexOf("geodetic_datum_of_1965")) {
        wkt.datumCode = "ire65";
      }
      if (wkt.datumCode === "ch1903+") {
        wkt.datumCode = "ch1903";
      }
      if (~wkt.datumCode.indexOf("israel")) {
        wkt.datumCode = "isr93";
      }
    }
    if (wkt.b && !isFinite(wkt.b)) {
      wkt.b = wkt.a;
    }
    function toMeter(input) {
      var ratio2 = wkt.to_meter || 1;
      return input * ratio2;
    }
    var renamer = function(a2) {
      return rename(wkt, a2);
    };
    var list = [
      ["standard_parallel_1", "Standard_Parallel_1"],
      ["standard_parallel_1", "Latitude of 1st standard parallel"],
      ["standard_parallel_2", "Standard_Parallel_2"],
      ["standard_parallel_2", "Latitude of 2nd standard parallel"],
      ["false_easting", "False_Easting"],
      ["false_easting", "False easting"],
      ["false-easting", "Easting at false origin"],
      ["false_northing", "False_Northing"],
      ["false_northing", "False northing"],
      ["false_northing", "Northing at false origin"],
      ["central_meridian", "Central_Meridian"],
      ["central_meridian", "Longitude of natural origin"],
      ["central_meridian", "Longitude of false origin"],
      ["latitude_of_origin", "Latitude_Of_Origin"],
      ["latitude_of_origin", "Central_Parallel"],
      ["latitude_of_origin", "Latitude of natural origin"],
      ["latitude_of_origin", "Latitude of false origin"],
      ["scale_factor", "Scale_Factor"],
      ["k0", "scale_factor"],
      ["latitude_of_center", "Latitude_Of_Center"],
      ["latitude_of_center", "Latitude_of_center"],
      ["lat0", "latitude_of_center", d2r],
      ["longitude_of_center", "Longitude_Of_Center"],
      ["longitude_of_center", "Longitude_of_center"],
      ["longc", "longitude_of_center", d2r],
      ["x0", "false_easting", toMeter],
      ["y0", "false_northing", toMeter],
      ["long0", "central_meridian", d2r],
      ["lat0", "latitude_of_origin", d2r],
      ["lat0", "standard_parallel_1", d2r],
      ["lat1", "standard_parallel_1", d2r],
      ["lat2", "standard_parallel_2", d2r],
      ["azimuth", "Azimuth"],
      ["alpha", "azimuth", d2r],
      ["srsCode", "name"]
    ];
    list.forEach(renamer);
    if (!wkt.long0 && wkt.longc && (wkt.projName === "Albers_Conic_Equal_Area" || wkt.projName === "Lambert_Azimuthal_Equal_Area")) {
      wkt.long0 = wkt.longc;
    }
    if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === "Stereographic_South_Pole" || wkt.projName === "Polar Stereographic (variant B)")) {
      wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
      wkt.lat_ts = wkt.lat1;
    }
  }
  function wkt_parser_default(wkt) {
    var lisp = parser_default(wkt);
    var type = lisp.shift();
    var name2 = lisp.shift();
    lisp.unshift(["name", name2]);
    lisp.unshift(["type", type]);
    var obj = {};
    sExpr(lisp, obj);
    cleanWKT(obj);
    return obj;
  }

  // ../node_modules/proj4/lib/defs.js
  function defs(name2) {
    var that = this;
    if (arguments.length === 2) {
      var def = arguments[1];
      if (typeof def === "string") {
        if (def.charAt(0) === "+") {
          defs[name2] = projString_default(arguments[1]);
        } else {
          defs[name2] = wkt_parser_default(arguments[1]);
        }
      } else {
        defs[name2] = def;
      }
    } else if (arguments.length === 1) {
      if (Array.isArray(name2)) {
        return name2.map(function(v) {
          if (Array.isArray(v)) {
            defs.apply(that, v);
          } else {
            defs(v);
          }
        });
      } else if (typeof name2 === "string") {
        if (name2 in defs) {
          return defs[name2];
        }
      } else if ("EPSG" in name2) {
        defs["EPSG:" + name2.EPSG] = name2;
      } else if ("ESRI" in name2) {
        defs["ESRI:" + name2.ESRI] = name2;
      } else if ("IAU2000" in name2) {
        defs["IAU2000:" + name2.IAU2000] = name2;
      } else {
        console.log(name2);
      }
      return;
    }
  }
  global_default(defs);
  var defs_default = defs;

  // ../node_modules/proj4/lib/parseCode.js
  function testObj(code) {
    return typeof code === "string";
  }
  function testDef(code) {
    return code in defs_default;
  }
  var codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
  function testWKT(code) {
    return codeWords.some(function(word) {
      return code.indexOf(word) > -1;
    });
  }
  var codes = ["3857", "900913", "3785", "102113"];
  function checkMercator(item) {
    var auth = match(item, "authority");
    if (!auth) {
      return;
    }
    var code = match(auth, "epsg");
    return code && codes.indexOf(code) > -1;
  }
  function checkProjStr(item) {
    var ext = match(item, "extension");
    if (!ext) {
      return;
    }
    return match(ext, "proj4");
  }
  function testProj(code) {
    return code[0] === "+";
  }
  function parse(code) {
    if (testObj(code)) {
      if (testDef(code)) {
        return defs_default[code];
      }
      if (testWKT(code)) {
        var out = wkt_parser_default(code);
        if (checkMercator(out)) {
          return defs_default["EPSG:3857"];
        }
        var maybeProjStr = checkProjStr(out);
        if (maybeProjStr) {
          return projString_default(maybeProjStr);
        }
        return out;
      }
      if (testProj(code)) {
        return projString_default(code);
      }
    } else {
      return code;
    }
  }
  var parseCode_default = parse;

  // ../node_modules/proj4/lib/extend.js
  function extend_default(destination2, source) {
    destination2 = destination2 || {};
    var value, property;
    if (!source) {
      return destination2;
    }
    for (property in source) {
      value = source[property];
      if (value !== void 0) {
        destination2[property] = value;
      }
    }
    return destination2;
  }

  // ../node_modules/proj4/lib/common/msfnz.js
  function msfnz_default(eccent, sinphi, cosphi) {
    var con = eccent * sinphi;
    return cosphi / Math.sqrt(1 - con * con);
  }

  // ../node_modules/proj4/lib/common/sign.js
  function sign_default(x3) {
    return x3 < 0 ? -1 : 1;
  }

  // ../node_modules/proj4/lib/common/adjust_lon.js
  function adjust_lon_default(x3) {
    return Math.abs(x3) <= SPI ? x3 : x3 - sign_default(x3) * TWO_PI;
  }

  // ../node_modules/proj4/lib/common/tsfnz.js
  function tsfnz_default(eccent, phi, sinphi) {
    var con = eccent * sinphi;
    var com = 0.5 * eccent;
    con = Math.pow((1 - con) / (1 + con), com);
    return Math.tan(0.5 * (HALF_PI - phi)) / con;
  }

  // ../node_modules/proj4/lib/common/phi2z.js
  function phi2z_default(eccent, ts) {
    var eccnth = 0.5 * eccent;
    var con, dphi;
    var phi = HALF_PI - 2 * Math.atan(ts);
    for (var i = 0; i <= 15; i++) {
      con = eccent * Math.sin(phi);
      dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
      phi += dphi;
      if (Math.abs(dphi) <= 1e-10) {
        return phi;
      }
    }
    return -9999;
  }

  // ../node_modules/proj4/lib/projections/merc.js
  function init() {
    var con = this.b / this.a;
    this.es = 1 - con * con;
    if (!("x0" in this)) {
      this.x0 = 0;
    }
    if (!("y0" in this)) {
      this.y0 = 0;
    }
    this.e = Math.sqrt(this.es);
    if (this.lat_ts) {
      if (this.sphere) {
        this.k0 = Math.cos(this.lat_ts);
      } else {
        this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
      }
    } else {
      if (!this.k0) {
        if (this.k) {
          this.k0 = this.k;
        } else {
          this.k0 = 1;
        }
      }
    }
  }
  function forward(p) {
    var lon = p.x;
    var lat = p.y;
    if (lat * R2D2 > 90 && lat * R2D2 < -90 && lon * R2D2 > 180 && lon * R2D2 < -180) {
      return null;
    }
    var x3, y3;
    if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
      return null;
    } else {
      if (this.sphere) {
        x3 = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
        y3 = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
      } else {
        var sinphi = Math.sin(lat);
        var ts = tsfnz_default(this.e, lat, sinphi);
        x3 = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
        y3 = this.y0 - this.a * this.k0 * Math.log(ts);
      }
      p.x = x3;
      p.y = y3;
      return p;
    }
  }
  function inverse(p) {
    var x3 = p.x - this.x0;
    var y3 = p.y - this.y0;
    var lon, lat;
    if (this.sphere) {
      lat = HALF_PI - 2 * Math.atan(Math.exp(-y3 / (this.a * this.k0)));
    } else {
      var ts = Math.exp(-y3 / (this.a * this.k0));
      lat = phi2z_default(this.e, ts);
      if (lat === -9999) {
        return null;
      }
    }
    lon = adjust_lon_default(this.long0 + x3 / (this.a * this.k0));
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
  var merc_default = {
    init,
    forward,
    inverse,
    names
  };

  // ../node_modules/proj4/lib/projections/longlat.js
  function init2() {
  }
  function identity2(pt) {
    return pt;
  }
  var names2 = ["longlat", "identity"];
  var longlat_default = {
    init: init2,
    forward: identity2,
    inverse: identity2,
    names: names2
  };

  // ../node_modules/proj4/lib/projections.js
  var projs = [merc_default, longlat_default];
  var names3 = {};
  var projStore = [];
  function add2(proj, i) {
    var len = projStore.length;
    if (!proj.names) {
      console.log(i);
      return true;
    }
    projStore[len] = proj;
    proj.names.forEach(function(n) {
      names3[n.toLowerCase()] = len;
    });
    return this;
  }
  function get(name2) {
    if (!name2) {
      return false;
    }
    var n = name2.toLowerCase();
    if (typeof names3[n] !== "undefined" && projStore[names3[n]]) {
      return projStore[names3[n]];
    }
  }
  function start() {
    projs.forEach(add2);
  }
  var projections_default = {
    start,
    add: add2,
    get
  };

  // ../node_modules/proj4/lib/constants/Ellipsoid.js
  var exports3 = {};
  exports3.MERIT = {
    a: 6378137,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  };
  exports3.SGS85 = {
    a: 6378136,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  };
  exports3.GRS80 = {
    a: 6378137,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  };
  exports3.IAU76 = {
    a: 6378140,
    rf: 298.257,
    ellipseName: "IAU 1976"
  };
  exports3.airy = {
    a: 6377563396e-3,
    b: 635625691e-2,
    ellipseName: "Airy 1830"
  };
  exports3.APL4 = {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  };
  exports3.NWL9D = {
    a: 6378145,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  };
  exports3.mod_airy = {
    a: 6377340189e-3,
    b: 6356034446e-3,
    ellipseName: "Modified Airy"
  };
  exports3.andrae = {
    a: 637710443e-2,
    rf: 300,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  };
  exports3.aust_SA = {
    a: 6378160,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  };
  exports3.GRS67 = {
    a: 6378160,
    rf: 298.247167427,
    ellipseName: "GRS 67(IUGG 1967)"
  };
  exports3.bessel = {
    a: 6377397155e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  };
  exports3.bess_nam = {
    a: 6377483865e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  };
  exports3.clrk66 = {
    a: 63782064e-1,
    b: 63565838e-1,
    ellipseName: "Clarke 1866"
  };
  exports3.clrk80 = {
    a: 6378249145e-3,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  };
  exports3.clrk58 = {
    a: 6378293645208759e-9,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  };
  exports3.CPM = {
    a: 63757387e-1,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  };
  exports3.delmbr = {
    a: 6376428,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  };
  exports3.engelis = {
    a: 637813605e-2,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  };
  exports3.evrst30 = {
    a: 6377276345e-3,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  };
  exports3.evrst48 = {
    a: 6377304063e-3,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  };
  exports3.evrst56 = {
    a: 6377301243e-3,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  };
  exports3.evrst69 = {
    a: 6377295664e-3,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  };
  exports3.evrstSS = {
    a: 6377298556e-3,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  };
  exports3.fschr60 = {
    a: 6378166,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  };
  exports3.fschr60m = {
    a: 6378155,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  };
  exports3.fschr68 = {
    a: 6378150,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  };
  exports3.helmert = {
    a: 6378200,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  };
  exports3.hough = {
    a: 6378270,
    rf: 297,
    ellipseName: "Hough"
  };
  exports3.intl = {
    a: 6378388,
    rf: 297,
    ellipseName: "International 1909 (Hayford)"
  };
  exports3.kaula = {
    a: 6378163,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  };
  exports3.lerch = {
    a: 6378139,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  };
  exports3.mprts = {
    a: 6397300,
    rf: 191,
    ellipseName: "Maupertius 1738"
  };
  exports3.new_intl = {
    a: 63781575e-1,
    b: 63567722e-1,
    ellipseName: "New International 1967"
  };
  exports3.plessis = {
    a: 6376523,
    rf: 6355863,
    ellipseName: "Plessis 1817 (France)"
  };
  exports3.krass = {
    a: 6378245,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  };
  exports3.SEasia = {
    a: 6378155,
    b: 63567733205e-4,
    ellipseName: "Southeast Asia"
  };
  exports3.walbeck = {
    a: 6376896,
    b: 63558348467e-4,
    ellipseName: "Walbeck"
  };
  exports3.WGS60 = {
    a: 6378165,
    rf: 298.3,
    ellipseName: "WGS 60"
  };
  exports3.WGS66 = {
    a: 6378145,
    rf: 298.25,
    ellipseName: "WGS 66"
  };
  exports3.WGS7 = {
    a: 6378135,
    rf: 298.26,
    ellipseName: "WGS 72"
  };
  var WGS84 = exports3.WGS84 = {
    a: 6378137,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  };
  exports3.sphere = {
    a: 6370997,
    b: 6370997,
    ellipseName: "Normal Sphere (r=6370997)"
  };

  // ../node_modules/proj4/lib/deriveConstants.js
  function eccentricity(a2, b, rf, R_A) {
    var a22 = a2 * a2;
    var b2 = b * b;
    var es = (a22 - b2) / a22;
    var e = 0;
    if (R_A) {
      a2 *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
      a22 = a2 * a2;
      es = 0;
    } else {
      e = Math.sqrt(es);
    }
    var ep2 = (a22 - b2) / b2;
    return {
      es,
      e,
      ep2
    };
  }
  function sphere(a2, b, rf, ellps, sphere2) {
    if (!a2) {
      var ellipse = match(exports3, ellps);
      if (!ellipse) {
        ellipse = WGS84;
      }
      a2 = ellipse.a;
      b = ellipse.b;
      rf = ellipse.rf;
    }
    if (rf && !b) {
      b = (1 - 1 / rf) * a2;
    }
    if (rf === 0 || Math.abs(a2 - b) < EPSLN) {
      sphere2 = true;
      b = a2;
    }
    return {
      a: a2,
      b,
      rf,
      sphere: sphere2
    };
  }

  // ../node_modules/proj4/lib/constants/Datum.js
  var exports4 = {};
  exports4.wgs84 = {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  };
  exports4.ch1903 = {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  };
  exports4.ggrs87 = {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  };
  exports4.nad83 = {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  };
  exports4.nad27 = {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  };
  exports4.potsdam = {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  };
  exports4.carthage = {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  };
  exports4.hermannskogel = {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  };
  exports4.osni52 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  };
  exports4.ire65 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  };
  exports4.rassadiran = {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  };
  exports4.nzgd49 = {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  };
  exports4.osgb36 = {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Airy 1830"
  };
  exports4.s_jtsk = {
    towgs84: "589,76,480",
    ellipse: "bessel",
    datumName: "S-JTSK (Ferro)"
  };
  exports4.beduaram = {
    towgs84: "-106,-87,188",
    ellipse: "clrk80",
    datumName: "Beduaram"
  };
  exports4.gunung_segara = {
    towgs84: "-403,684,41",
    ellipse: "bessel",
    datumName: "Gunung Segara Jakarta"
  };
  exports4.rnb72 = {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  };

  // ../node_modules/proj4/lib/datum.js
  function datum(datumCode, datum_params, a2, b, es, ep2, nadgrids) {
    var out = {};
    if (datumCode === void 0 || datumCode === "none") {
      out.datum_type = PJD_NODATUM;
    } else {
      out.datum_type = PJD_WGS84;
    }
    if (datum_params) {
      out.datum_params = datum_params.map(parseFloat);
      if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
        out.datum_type = PJD_3PARAM;
      }
      if (out.datum_params.length > 3) {
        if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
          out.datum_type = PJD_7PARAM;
          out.datum_params[3] *= SEC_TO_RAD;
          out.datum_params[4] *= SEC_TO_RAD;
          out.datum_params[5] *= SEC_TO_RAD;
          out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
        }
      }
    }
    if (nadgrids) {
      out.datum_type = PJD_GRIDSHIFT;
      out.grids = nadgrids;
    }
    out.a = a2;
    out.b = b;
    out.es = es;
    out.ep2 = ep2;
    return out;
  }
  var datum_default = datum;

  // ../node_modules/proj4/lib/nadgrid.js
  var loadedNadgrids = {};
  function nadgrid(key2, data) {
    var view = new DataView(data);
    var isLittleEndian = detectLittleEndian(view);
    var header = readHeader(view, isLittleEndian);
    if (header.nSubgrids > 1) {
      console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
    }
    var subgrids = readSubgrids(view, header, isLittleEndian);
    var nadgrid2 = { header, subgrids };
    loadedNadgrids[key2] = nadgrid2;
    return nadgrid2;
  }
  function getNadgrids(nadgrids) {
    if (nadgrids === void 0) {
      return null;
    }
    var grids = nadgrids.split(",");
    return grids.map(parseNadgridString);
  }
  function parseNadgridString(value) {
    if (value.length === 0) {
      return null;
    }
    var optional = value[0] === "@";
    if (optional) {
      value = value.slice(1);
    }
    if (value === "null") {
      return { name: "null", mandatory: !optional, grid: null, isNull: true };
    }
    return {
      name: value,
      mandatory: !optional,
      grid: loadedNadgrids[value] || null,
      isNull: false
    };
  }
  function secondsToRadians(seconds) {
    return seconds / 3600 * Math.PI / 180;
  }
  function detectLittleEndian(view) {
    var nFields = view.getInt32(8, false);
    if (nFields === 11) {
      return false;
    }
    nFields = view.getInt32(8, true);
    if (nFields !== 11) {
      console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
    }
    return true;
  }
  function readHeader(view, isLittleEndian) {
    return {
      nFields: view.getInt32(8, isLittleEndian),
      nSubgridFields: view.getInt32(24, isLittleEndian),
      nSubgrids: view.getInt32(40, isLittleEndian),
      shiftType: decodeString(view, 56, 56 + 8).trim(),
      fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
      fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
      toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
      toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
    };
  }
  function decodeString(view, start2, end) {
    return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
  }
  function readSubgrids(view, header, isLittleEndian) {
    var gridOffset = 176;
    var grids = [];
    for (var i = 0; i < header.nSubgrids; i++) {
      var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
      var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
      var lngColumnCount = Math.round(
        1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval
      );
      var latColumnCount = Math.round(
        1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval
      );
      grids.push({
        ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
        del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
        lim: [lngColumnCount, latColumnCount],
        count: subHeader.gridNodeCount,
        cvs: mapNodes(nodes)
      });
    }
    return grids;
  }
  function mapNodes(nodes) {
    return nodes.map(function(r) {
      return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];
    });
  }
  function readGridHeader(view, offset, isLittleEndian) {
    return {
      name: decodeString(view, offset + 8, offset + 16).trim(),
      parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
      lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
      upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
      lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
      upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
      latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
      longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
      gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
    };
  }
  function readGridNodes(view, offset, gridHeader, isLittleEndian) {
    var nodesOffset = offset + 176;
    var gridRecordLength = 16;
    var gridShiftRecords = [];
    for (var i = 0; i < gridHeader.gridNodeCount; i++) {
      var record = {
        latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
        longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
        latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
        longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian)
      };
      gridShiftRecords.push(record);
    }
    return gridShiftRecords;
  }

  // ../node_modules/proj4/lib/Proj.js
  function Projection(srsCode, callback) {
    if (!(this instanceof Projection)) {
      return new Projection(srsCode);
    }
    callback = callback || function(error) {
      if (error) {
        throw error;
      }
    };
    var json = parseCode_default(srsCode);
    if (typeof json !== "object") {
      callback(srsCode);
      return;
    }
    var ourProj = Projection.projections.get(json.projName);
    if (!ourProj) {
      callback(srsCode);
      return;
    }
    if (json.datumCode && json.datumCode !== "none") {
      var datumDef = match(exports4, json.datumCode);
      if (datumDef) {
        json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
        json.ellps = datumDef.ellipse;
        json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
      }
    }
    json.k0 = json.k0 || 1;
    json.axis = json.axis || "enu";
    json.ellps = json.ellps || "wgs84";
    json.lat1 = json.lat1 || json.lat0;
    var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
    var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
    var nadgrids = getNadgrids(json.nadgrids);
    var datumObj = json.datum || datum_default(
      json.datumCode,
      json.datum_params,
      sphere_.a,
      sphere_.b,
      ecc.es,
      ecc.ep2,
      nadgrids
    );
    extend_default(this, json);
    extend_default(this, ourProj);
    this.a = sphere_.a;
    this.b = sphere_.b;
    this.rf = sphere_.rf;
    this.sphere = sphere_.sphere;
    this.es = ecc.es;
    this.e = ecc.e;
    this.ep2 = ecc.ep2;
    this.datum = datumObj;
    this.init();
    callback(null, this);
  }
  Projection.projections = projections_default;
  Projection.projections.start();
  var Proj_default = Projection;

  // ../node_modules/proj4/lib/datumUtils.js
  function compareDatums(source, dest) {
    if (source.datum_type !== dest.datum_type) {
      return false;
    } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
      return false;
    } else if (source.datum_type === PJD_3PARAM) {
      return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
    } else if (source.datum_type === PJD_7PARAM) {
      return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
    } else {
      return true;
    }
  }
  function geodeticToGeocentric(p, es, a2) {
    var Longitude = p.x;
    var Latitude = p.y;
    var Height = p.z ? p.z : 0;
    var Rn;
    var Sin_Lat;
    var Sin2_Lat;
    var Cos_Lat;
    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
      Latitude = -HALF_PI;
    } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
      Latitude = HALF_PI;
    } else if (Latitude < -HALF_PI) {
      return { x: -Infinity, y: -Infinity, z: p.z };
    } else if (Latitude > HALF_PI) {
      return { x: Infinity, y: Infinity, z: p.z };
    }
    if (Longitude > Math.PI) {
      Longitude -= 2 * Math.PI;
    }
    Sin_Lat = Math.sin(Latitude);
    Cos_Lat = Math.cos(Latitude);
    Sin2_Lat = Sin_Lat * Sin_Lat;
    Rn = a2 / Math.sqrt(1 - es * Sin2_Lat);
    return {
      x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
      y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
      z: (Rn * (1 - es) + Height) * Sin_Lat
    };
  }
  function geocentricToGeodetic(p, es, a2, b) {
    var genau = 1e-12;
    var genau2 = genau * genau;
    var maxiter = 30;
    var P;
    var RR;
    var CT;
    var ST;
    var RX;
    var RK;
    var RN;
    var CPHI0;
    var SPHI0;
    var CPHI;
    var SPHI;
    var SDPHI;
    var iter;
    var X = p.x;
    var Y = p.y;
    var Z2 = p.z ? p.z : 0;
    var Longitude;
    var Latitude;
    var Height;
    P = Math.sqrt(X * X + Y * Y);
    RR = Math.sqrt(X * X + Y * Y + Z2 * Z2);
    if (P / a2 < genau) {
      Longitude = 0;
      if (RR / a2 < genau) {
        Latitude = HALF_PI;
        Height = -b;
        return {
          x: p.x,
          y: p.y,
          z: p.z
        };
      }
    } else {
      Longitude = Math.atan2(Y, X);
    }
    CT = Z2 / RR;
    ST = P / RR;
    RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
    CPHI0 = ST * (1 - es) * RX;
    SPHI0 = CT * RX;
    iter = 0;
    do {
      iter++;
      RN = a2 / Math.sqrt(1 - es * SPHI0 * SPHI0);
      Height = P * CPHI0 + Z2 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
      RK = es * RN / (RN + Height);
      RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
      CPHI = ST * (1 - RK) * RX;
      SPHI = CT * RX;
      SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
      CPHI0 = CPHI;
      SPHI0 = SPHI;
    } while (SDPHI * SDPHI > genau2 && iter < maxiter);
    Latitude = Math.atan(SPHI / Math.abs(CPHI));
    return {
      x: Longitude,
      y: Latitude,
      z: Height
    };
  }
  function geocentricToWgs84(p, datum_type, datum_params) {
    if (datum_type === PJD_3PARAM) {
      return {
        x: p.x + datum_params[0],
        y: p.y + datum_params[1],
        z: p.z + datum_params[2]
      };
    } else if (datum_type === PJD_7PARAM) {
      var Dx_BF = datum_params[0];
      var Dy_BF = datum_params[1];
      var Dz_BF = datum_params[2];
      var Rx_BF = datum_params[3];
      var Ry_BF = datum_params[4];
      var Rz_BF = datum_params[5];
      var M_BF = datum_params[6];
      return {
        x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
        y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
        z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
      };
    }
  }
  function geocentricFromWgs84(p, datum_type, datum_params) {
    if (datum_type === PJD_3PARAM) {
      return {
        x: p.x - datum_params[0],
        y: p.y - datum_params[1],
        z: p.z - datum_params[2]
      };
    } else if (datum_type === PJD_7PARAM) {
      var Dx_BF = datum_params[0];
      var Dy_BF = datum_params[1];
      var Dz_BF = datum_params[2];
      var Rx_BF = datum_params[3];
      var Ry_BF = datum_params[4];
      var Rz_BF = datum_params[5];
      var M_BF = datum_params[6];
      var x_tmp = (p.x - Dx_BF) / M_BF;
      var y_tmp = (p.y - Dy_BF) / M_BF;
      var z_tmp = (p.z - Dz_BF) / M_BF;
      return {
        x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
        y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
        z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
      };
    }
  }

  // ../node_modules/proj4/lib/datum_transform.js
  function checkParams(type) {
    return type === PJD_3PARAM || type === PJD_7PARAM;
  }
  function datum_transform_default(source, dest, point2) {
    if (compareDatums(source, dest)) {
      return point2;
    }
    if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
      return point2;
    }
    var source_a = source.a;
    var source_es = source.es;
    if (source.datum_type === PJD_GRIDSHIFT) {
      var gridShiftCode = applyGridShift(source, false, point2);
      if (gridShiftCode !== 0) {
        return void 0;
      }
      source_a = SRS_WGS84_SEMIMAJOR;
      source_es = SRS_WGS84_ESQUARED;
    }
    var dest_a = dest.a;
    var dest_b = dest.b;
    var dest_es = dest.es;
    if (dest.datum_type === PJD_GRIDSHIFT) {
      dest_a = SRS_WGS84_SEMIMAJOR;
      dest_b = SRS_WGS84_SEMIMINOR;
      dest_es = SRS_WGS84_ESQUARED;
    }
    if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
      return point2;
    }
    point2 = geodeticToGeocentric(point2, source_es, source_a);
    if (checkParams(source.datum_type)) {
      point2 = geocentricToWgs84(point2, source.datum_type, source.datum_params);
    }
    if (checkParams(dest.datum_type)) {
      point2 = geocentricFromWgs84(point2, dest.datum_type, dest.datum_params);
    }
    point2 = geocentricToGeodetic(point2, dest_es, dest_a, dest_b);
    if (dest.datum_type === PJD_GRIDSHIFT) {
      var destGridShiftResult = applyGridShift(dest, true, point2);
      if (destGridShiftResult !== 0) {
        return void 0;
      }
    }
    return point2;
  }
  function applyGridShift(source, inverse32, point2) {
    if (source.grids === null || source.grids.length === 0) {
      console.log("Grid shift grids not found");
      return -1;
    }
    var input = { x: -point2.x, y: point2.y };
    var output = { x: Number.NaN, y: Number.NaN };
    var onlyMandatoryGrids = false;
    var attemptedGrids = [];
    for (var i = 0; i < source.grids.length; i++) {
      var grid = source.grids[i];
      attemptedGrids.push(grid.name);
      if (grid.isNull) {
        output = input;
        break;
      }
      onlyMandatoryGrids = grid.mandatory;
      if (grid.grid === null) {
        if (grid.mandatory) {
          console.log("Unable to find mandatory grid '" + grid.name + "'");
          return -1;
        }
        continue;
      }
      var subgrid = grid.grid.subgrids[0];
      var epsilon4 = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
      var minX = subgrid.ll[0] - epsilon4;
      var minY = subgrid.ll[1] - epsilon4;
      var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon4;
      var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon4;
      if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
        continue;
      }
      output = applySubgridShift(input, inverse32, subgrid);
      if (!isNaN(output.x)) {
        break;
      }
    }
    if (isNaN(output.x)) {
      console.log("Failed to find a grid shift table for location '" + -input.x * R2D2 + " " + input.y * R2D2 + " tried: '" + attemptedGrids + "'");
      return -1;
    }
    point2.x = -output.x;
    point2.y = output.y;
    return 0;
  }
  function applySubgridShift(pin, inverse32, ct) {
    var val = { x: Number.NaN, y: Number.NaN };
    if (isNaN(pin.x)) {
      return val;
    }
    var tb = { x: pin.x, y: pin.y };
    tb.x -= ct.ll[0];
    tb.y -= ct.ll[1];
    tb.x = adjust_lon_default(tb.x - Math.PI) + Math.PI;
    var t = nadInterpolate(tb, ct);
    if (inverse32) {
      if (isNaN(t.x)) {
        return val;
      }
      t.x = tb.x - t.x;
      t.y = tb.y - t.y;
      var i = 9, tol = 1e-12;
      var dif, del;
      do {
        del = nadInterpolate(t, ct);
        if (isNaN(del.x)) {
          console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
          break;
        }
        dif = { x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y) };
        t.x += dif.x;
        t.y += dif.y;
      } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
      if (i < 0) {
        console.log("Inverse grid shift iterator failed to converge.");
        return val;
      }
      val.x = adjust_lon_default(t.x + ct.ll[0]);
      val.y = t.y + ct.ll[1];
    } else {
      if (!isNaN(t.x)) {
        val.x = pin.x + t.x;
        val.y = pin.y + t.y;
      }
    }
    return val;
  }
  function nadInterpolate(pin, ct) {
    var t = { x: pin.x / ct.del[0], y: pin.y / ct.del[1] };
    var indx = { x: Math.floor(t.x), y: Math.floor(t.y) };
    var frct = { x: t.x - 1 * indx.x, y: t.y - 1 * indx.y };
    var val = { x: Number.NaN, y: Number.NaN };
    var inx;
    if (indx.x < 0 || indx.x >= ct.lim[0]) {
      return val;
    }
    if (indx.y < 0 || indx.y >= ct.lim[1]) {
      return val;
    }
    inx = indx.y * ct.lim[0] + indx.x;
    var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
    inx++;
    var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
    inx += ct.lim[0];
    var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
    inx--;
    var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
    var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
    val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
    val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
    return val;
  }

  // ../node_modules/proj4/lib/adjust_axis.js
  function adjust_axis_default(crs, denorm, point2) {
    var xin = point2.x, yin = point2.y, zin = point2.z || 0;
    var v, t, i;
    var out = {};
    for (i = 0; i < 3; i++) {
      if (denorm && i === 2 && point2.z === void 0) {
        continue;
      }
      if (i === 0) {
        v = xin;
        if ("ew".indexOf(crs.axis[i]) !== -1) {
          t = "x";
        } else {
          t = "y";
        }
      } else if (i === 1) {
        v = yin;
        if ("ns".indexOf(crs.axis[i]) !== -1) {
          t = "y";
        } else {
          t = "x";
        }
      } else {
        v = zin;
        t = "z";
      }
      switch (crs.axis[i]) {
        case "e":
          out[t] = v;
          break;
        case "w":
          out[t] = -v;
          break;
        case "n":
          out[t] = v;
          break;
        case "s":
          out[t] = -v;
          break;
        case "u":
          if (point2[t] !== void 0) {
            out.z = v;
          }
          break;
        case "d":
          if (point2[t] !== void 0) {
            out.z = -v;
          }
          break;
        default:
          return null;
      }
    }
    return out;
  }

  // ../node_modules/proj4/lib/common/toPoint.js
  function toPoint_default(array2) {
    var out = {
      x: array2[0],
      y: array2[1]
    };
    if (array2.length > 2) {
      out.z = array2[2];
    }
    if (array2.length > 3) {
      out.m = array2[3];
    }
    return out;
  }

  // ../node_modules/proj4/lib/checkSanity.js
  function checkSanity_default(point2) {
    checkCoord(point2.x);
    checkCoord(point2.y);
  }
  function checkCoord(num) {
    if (typeof Number.isFinite === "function") {
      if (Number.isFinite(num)) {
        return;
      }
      throw new TypeError("coordinates must be finite numbers");
    }
    if (typeof num !== "number" || num !== num || !isFinite(num)) {
      throw new TypeError("coordinates must be finite numbers");
    }
  }

  // ../node_modules/proj4/lib/transform.js
  function checkNotWGS(source, dest) {
    return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== "WGS84";
  }
  function transform(source, dest, point2, enforceAxis) {
    var wgs842;
    if (Array.isArray(point2)) {
      point2 = toPoint_default(point2);
    }
    checkSanity_default(point2);
    if (source.datum && dest.datum && checkNotWGS(source, dest)) {
      wgs842 = new Proj_default("WGS84");
      point2 = transform(source, wgs842, point2, enforceAxis);
      source = wgs842;
    }
    if (enforceAxis && source.axis !== "enu") {
      point2 = adjust_axis_default(source, false, point2);
    }
    if (source.projName === "longlat") {
      point2 = {
        x: point2.x * D2R2,
        y: point2.y * D2R2,
        z: point2.z || 0
      };
    } else {
      if (source.to_meter) {
        point2 = {
          x: point2.x * source.to_meter,
          y: point2.y * source.to_meter,
          z: point2.z || 0
        };
      }
      point2 = source.inverse(point2);
      if (!point2) {
        return;
      }
    }
    if (source.from_greenwich) {
      point2.x += source.from_greenwich;
    }
    point2 = datum_transform_default(source.datum, dest.datum, point2);
    if (!point2) {
      return;
    }
    if (dest.from_greenwich) {
      point2 = {
        x: point2.x - dest.from_greenwich,
        y: point2.y,
        z: point2.z || 0
      };
    }
    if (dest.projName === "longlat") {
      point2 = {
        x: point2.x * R2D2,
        y: point2.y * R2D2,
        z: point2.z || 0
      };
    } else {
      point2 = dest.forward(point2);
      if (dest.to_meter) {
        point2 = {
          x: point2.x / dest.to_meter,
          y: point2.y / dest.to_meter,
          z: point2.z || 0
        };
      }
    }
    if (enforceAxis && dest.axis !== "enu") {
      return adjust_axis_default(dest, true, point2);
    }
    return point2;
  }

  // ../node_modules/proj4/lib/core.js
  var wgs84 = Proj_default("WGS84");
  function transformer2(from2, to, coords, enforceAxis) {
    var transformedArray, out, keys;
    if (Array.isArray(coords)) {
      transformedArray = transform(from2, to, coords, enforceAxis) || { x: NaN, y: NaN };
      if (coords.length > 2) {
        if (typeof from2.name !== "undefined" && from2.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
          if (typeof transformedArray.z === "number") {
            return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
          } else {
            return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
          }
        } else {
          return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
        }
      } else {
        return [transformedArray.x, transformedArray.y];
      }
    } else {
      out = transform(from2, to, coords, enforceAxis);
      keys = Object.keys(coords);
      if (keys.length === 2) {
        return out;
      }
      keys.forEach(function(key2) {
        if (typeof from2.name !== "undefined" && from2.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
          if (key2 === "x" || key2 === "y" || key2 === "z") {
            return;
          }
        } else {
          if (key2 === "x" || key2 === "y") {
            return;
          }
        }
        out[key2] = coords[key2];
      });
      return out;
    }
  }
  function checkProj(item) {
    if (item instanceof Proj_default) {
      return item;
    }
    if (item.oProj) {
      return item.oProj;
    }
    return Proj_default(item);
  }
  function proj4(fromProj, toProj, coord) {
    fromProj = checkProj(fromProj);
    var single = false;
    var obj;
    if (typeof toProj === "undefined") {
      toProj = fromProj;
      fromProj = wgs84;
      single = true;
    } else if (typeof toProj.x !== "undefined" || Array.isArray(toProj)) {
      coord = toProj;
      toProj = fromProj;
      fromProj = wgs84;
      single = true;
    }
    toProj = checkProj(toProj);
    if (coord) {
      return transformer2(fromProj, toProj, coord);
    } else {
      obj = {
        forward: function(coords, enforceAxis) {
          return transformer2(fromProj, toProj, coords, enforceAxis);
        },
        inverse: function(coords, enforceAxis) {
          return transformer2(toProj, fromProj, coords, enforceAxis);
        }
      };
      if (single) {
        obj.oProj = toProj;
      }
      return obj;
    }
  }
  var core_default = proj4;

  // ../node_modules/mgrs/mgrs.js
  var NUM_100K_SETS = 6;
  var SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
  var SET_ORIGIN_ROW_LETTERS = "AFAFAF";
  var A = 65;
  var I = 73;
  var O = 79;
  var V = 86;
  var Z = 90;
  var mgrs_default = {
    forward: forward2,
    inverse: inverse2,
    toPoint
  };
  function forward2(ll, accuracy) {
    accuracy = accuracy || 5;
    return encode(LLtoUTM({
      lat: ll[1],
      lon: ll[0]
    }), accuracy);
  }
  function inverse2(mgrs) {
    var bbox2 = UTMtoLL(decode(mgrs.toUpperCase()));
    if (bbox2.lat && bbox2.lon) {
      return [bbox2.lon, bbox2.lat, bbox2.lon, bbox2.lat];
    }
    return [bbox2.left, bbox2.bottom, bbox2.right, bbox2.top];
  }
  function toPoint(mgrs) {
    var bbox2 = UTMtoLL(decode(mgrs.toUpperCase()));
    if (bbox2.lat && bbox2.lon) {
      return [bbox2.lon, bbox2.lat];
    }
    return [(bbox2.left + bbox2.right) / 2, (bbox2.top + bbox2.bottom) / 2];
  }
  function degToRad(deg) {
    return deg * (Math.PI / 180);
  }
  function radToDeg(rad) {
    return 180 * (rad / Math.PI);
  }
  function LLtoUTM(ll) {
    var Lat = ll.lat;
    var Long = ll.lon;
    var a2 = 6378137;
    var eccSquared = 669438e-8;
    var k0 = 0.9996;
    var LongOrigin;
    var eccPrimeSquared;
    var N, T, C, A2, M;
    var LatRad = degToRad(Lat);
    var LongRad = degToRad(Long);
    var LongOriginRad;
    var ZoneNumber;
    ZoneNumber = Math.floor((Long + 180) / 6) + 1;
    if (Long === 180) {
      ZoneNumber = 60;
    }
    if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
      ZoneNumber = 32;
    }
    if (Lat >= 72 && Lat < 84) {
      if (Long >= 0 && Long < 9) {
        ZoneNumber = 31;
      } else if (Long >= 9 && Long < 21) {
        ZoneNumber = 33;
      } else if (Long >= 21 && Long < 33) {
        ZoneNumber = 35;
      } else if (Long >= 33 && Long < 42) {
        ZoneNumber = 37;
      }
    }
    LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
    LongOriginRad = degToRad(LongOrigin);
    eccPrimeSquared = eccSquared / (1 - eccSquared);
    N = a2 / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
    T = Math.tan(LatRad) * Math.tan(LatRad);
    C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
    A2 = Math.cos(LatRad) * (LongRad - LongOriginRad);
    M = a2 * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
    var UTMEasting = k0 * N * (A2 + (1 - T + C) * A2 * A2 * A2 / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 / 120) + 5e5;
    var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A2 * A2 / 2 + (5 - T + 9 * C + 4 * C * C) * A2 * A2 * A2 * A2 / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 * A2 / 720));
    if (Lat < 0) {
      UTMNorthing += 1e7;
    }
    return {
      northing: Math.round(UTMNorthing),
      easting: Math.round(UTMEasting),
      zoneNumber: ZoneNumber,
      zoneLetter: getLetterDesignator(Lat)
    };
  }
  function UTMtoLL(utm) {
    var UTMNorthing = utm.northing;
    var UTMEasting = utm.easting;
    var zoneLetter = utm.zoneLetter;
    var zoneNumber = utm.zoneNumber;
    if (zoneNumber < 0 || zoneNumber > 60) {
      return null;
    }
    var k0 = 0.9996;
    var a2 = 6378137;
    var eccSquared = 669438e-8;
    var eccPrimeSquared;
    var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
    var N1, T1, C12, R1, D, M;
    var LongOrigin;
    var mu, phi1Rad;
    var x3 = UTMEasting - 5e5;
    var y3 = UTMNorthing;
    if (zoneLetter < "N") {
      y3 -= 1e7;
    }
    LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
    eccPrimeSquared = eccSquared / (1 - eccSquared);
    M = y3 / k0;
    mu = M / (a2 * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
    phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
    N1 = a2 / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
    T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
    C12 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
    R1 = a2 * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
    D = x3 / (N1 * k0);
    var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C12 - 4 * C12 * C12 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C12 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C12 * C12) * D * D * D * D * D * D / 720);
    lat = radToDeg(lat);
    var lon = (D - (1 + 2 * T1 + C12) * D * D * D / 6 + (5 - 2 * C12 + 28 * T1 - 3 * C12 * C12 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
    lon = LongOrigin + radToDeg(lon);
    var result;
    if (utm.accuracy) {
      var topRight = UTMtoLL({
        northing: utm.northing + utm.accuracy,
        easting: utm.easting + utm.accuracy,
        zoneLetter: utm.zoneLetter,
        zoneNumber: utm.zoneNumber
      });
      result = {
        top: topRight.lat,
        right: topRight.lon,
        bottom: lat,
        left: lon
      };
    } else {
      result = {
        lat,
        lon
      };
    }
    return result;
  }
  function getLetterDesignator(lat) {
    var LetterDesignator = "Z";
    if (84 >= lat && lat >= 72) {
      LetterDesignator = "X";
    } else if (72 > lat && lat >= 64) {
      LetterDesignator = "W";
    } else if (64 > lat && lat >= 56) {
      LetterDesignator = "V";
    } else if (56 > lat && lat >= 48) {
      LetterDesignator = "U";
    } else if (48 > lat && lat >= 40) {
      LetterDesignator = "T";
    } else if (40 > lat && lat >= 32) {
      LetterDesignator = "S";
    } else if (32 > lat && lat >= 24) {
      LetterDesignator = "R";
    } else if (24 > lat && lat >= 16) {
      LetterDesignator = "Q";
    } else if (16 > lat && lat >= 8) {
      LetterDesignator = "P";
    } else if (8 > lat && lat >= 0) {
      LetterDesignator = "N";
    } else if (0 > lat && lat >= -8) {
      LetterDesignator = "M";
    } else if (-8 > lat && lat >= -16) {
      LetterDesignator = "L";
    } else if (-16 > lat && lat >= -24) {
      LetterDesignator = "K";
    } else if (-24 > lat && lat >= -32) {
      LetterDesignator = "J";
    } else if (-32 > lat && lat >= -40) {
      LetterDesignator = "H";
    } else if (-40 > lat && lat >= -48) {
      LetterDesignator = "G";
    } else if (-48 > lat && lat >= -56) {
      LetterDesignator = "F";
    } else if (-56 > lat && lat >= -64) {
      LetterDesignator = "E";
    } else if (-64 > lat && lat >= -72) {
      LetterDesignator = "D";
    } else if (-72 > lat && lat >= -80) {
      LetterDesignator = "C";
    }
    return LetterDesignator;
  }
  function encode(utm, accuracy) {
    var seasting = "00000" + utm.easting, snorthing = "00000" + utm.northing;
    return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
  }
  function get100kID(easting, northing, zoneNumber) {
    var setParm = get100kSetForZone(zoneNumber);
    var setColumn = Math.floor(easting / 1e5);
    var setRow = Math.floor(northing / 1e5) % 20;
    return getLetter100kID(setColumn, setRow, setParm);
  }
  function get100kSetForZone(i) {
    var setParm = i % NUM_100K_SETS;
    if (setParm === 0) {
      setParm = NUM_100K_SETS;
    }
    return setParm;
  }
  function getLetter100kID(column, row, parm) {
    var index = parm - 1;
    var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
    var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
    var colInt = colOrigin + column - 1;
    var rowInt = rowOrigin + row;
    var rollover = false;
    if (colInt > Z) {
      colInt = colInt - Z + A - 1;
      rollover = true;
    }
    if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
      colInt++;
    }
    if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
      colInt++;
      if (colInt === I) {
        colInt++;
      }
    }
    if (colInt > Z) {
      colInt = colInt - Z + A - 1;
    }
    if (rowInt > V) {
      rowInt = rowInt - V + A - 1;
      rollover = true;
    } else {
      rollover = false;
    }
    if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
      rowInt++;
    }
    if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
      rowInt++;
      if (rowInt === I) {
        rowInt++;
      }
    }
    if (rowInt > V) {
      rowInt = rowInt - V + A - 1;
    }
    var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
    return twoLetter;
  }
  function decode(mgrsString) {
    if (mgrsString && mgrsString.length === 0) {
      throw "MGRSPoint coverting from nothing";
    }
    var length2 = mgrsString.length;
    var hunK = null;
    var sb = "";
    var testChar;
    var i = 0;
    while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
      if (i >= 2) {
        throw "MGRSPoint bad conversion from: " + mgrsString;
      }
      sb += testChar;
      i++;
    }
    var zoneNumber = parseInt(sb, 10);
    if (i === 0 || i + 3 > length2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    var zoneLetter = mgrsString.charAt(i++);
    if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
      throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
    }
    hunK = mgrsString.substring(i, i += 2);
    var set2 = get100kSetForZone(zoneNumber);
    var east100k = getEastingFromChar(hunK.charAt(0), set2);
    var north100k = getNorthingFromChar(hunK.charAt(1), set2);
    while (north100k < getMinNorthing(zoneLetter)) {
      north100k += 2e6;
    }
    var remainder = length2 - i;
    if (remainder % 2 !== 0) {
      throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
    }
    var sep = remainder / 2;
    var sepEasting = 0;
    var sepNorthing = 0;
    var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
    if (sep > 0) {
      accuracyBonus = 1e5 / Math.pow(10, sep);
      sepEastingString = mgrsString.substring(i, i + sep);
      sepEasting = parseFloat(sepEastingString) * accuracyBonus;
      sepNorthingString = mgrsString.substring(i + sep);
      sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
    }
    easting = sepEasting + east100k;
    northing = sepNorthing + north100k;
    return {
      easting,
      northing,
      zoneLetter,
      zoneNumber,
      accuracy: accuracyBonus
    };
  }
  function getEastingFromChar(e, set2) {
    var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set2 - 1);
    var eastingValue = 1e5;
    var rewindMarker = false;
    while (curCol !== e.charCodeAt(0)) {
      curCol++;
      if (curCol === I) {
        curCol++;
      }
      if (curCol === O) {
        curCol++;
      }
      if (curCol > Z) {
        if (rewindMarker) {
          throw "Bad character: " + e;
        }
        curCol = A;
        rewindMarker = true;
      }
      eastingValue += 1e5;
    }
    return eastingValue;
  }
  function getNorthingFromChar(n, set2) {
    if (n > "V") {
      throw "MGRSPoint given invalid Northing " + n;
    }
    var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set2 - 1);
    var northingValue = 0;
    var rewindMarker = false;
    while (curRow !== n.charCodeAt(0)) {
      curRow++;
      if (curRow === I) {
        curRow++;
      }
      if (curRow === O) {
        curRow++;
      }
      if (curRow > V) {
        if (rewindMarker) {
          throw "Bad character: " + n;
        }
        curRow = A;
        rewindMarker = true;
      }
      northingValue += 1e5;
    }
    return northingValue;
  }
  function getMinNorthing(zoneLetter) {
    var northing;
    switch (zoneLetter) {
      case "C":
        northing = 11e5;
        break;
      case "D":
        northing = 2e6;
        break;
      case "E":
        northing = 28e5;
        break;
      case "F":
        northing = 37e5;
        break;
      case "G":
        northing = 46e5;
        break;
      case "H":
        northing = 55e5;
        break;
      case "J":
        northing = 64e5;
        break;
      case "K":
        northing = 73e5;
        break;
      case "L":
        northing = 82e5;
        break;
      case "M":
        northing = 91e5;
        break;
      case "N":
        northing = 0;
        break;
      case "P":
        northing = 8e5;
        break;
      case "Q":
        northing = 17e5;
        break;
      case "R":
        northing = 26e5;
        break;
      case "S":
        northing = 35e5;
        break;
      case "T":
        northing = 44e5;
        break;
      case "U":
        northing = 53e5;
        break;
      case "V":
        northing = 62e5;
        break;
      case "W":
        northing = 7e6;
        break;
      case "X":
        northing = 79e5;
        break;
      default:
        northing = -1;
    }
    if (northing >= 0) {
      return northing;
    } else {
      throw "Invalid zone letter: " + zoneLetter;
    }
  }

  // ../node_modules/proj4/lib/Point.js
  function Point(x3, y3, z2) {
    if (!(this instanceof Point)) {
      return new Point(x3, y3, z2);
    }
    if (Array.isArray(x3)) {
      this.x = x3[0];
      this.y = x3[1];
      this.z = x3[2] || 0;
    } else if (typeof x3 === "object") {
      this.x = x3.x;
      this.y = x3.y;
      this.z = x3.z || 0;
    } else if (typeof x3 === "string" && typeof y3 === "undefined") {
      var coords = x3.split(",");
      this.x = parseFloat(coords[0], 10);
      this.y = parseFloat(coords[1], 10);
      this.z = parseFloat(coords[2], 10) || 0;
    } else {
      this.x = x3;
      this.y = y3;
      this.z = z2 || 0;
    }
    console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
  }
  Point.fromMGRS = function(mgrsStr) {
    return new Point(toPoint(mgrsStr));
  };
  Point.prototype.toMGRS = function(accuracy) {
    return forward2([this.x, this.y], accuracy);
  };
  var Point_default = Point;

  // ../node_modules/proj4/lib/common/pj_enfn.js
  var C00 = 1;
  var C02 = 0.25;
  var C04 = 0.046875;
  var C06 = 0.01953125;
  var C08 = 0.01068115234375;
  var C22 = 0.75;
  var C44 = 0.46875;
  var C46 = 0.013020833333333334;
  var C48 = 0.007120768229166667;
  var C66 = 0.3645833333333333;
  var C68 = 0.005696614583333333;
  var C88 = 0.3076171875;
  function pj_enfn_default(es) {
    var en = [];
    en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
    en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
    var t = es * es;
    en[2] = t * (C44 - es * (C46 + es * C48));
    t *= es;
    en[3] = t * (C66 - es * C68);
    en[4] = t * es * C88;
    return en;
  }

  // ../node_modules/proj4/lib/common/pj_mlfn.js
  function pj_mlfn_default(phi, sphi, cphi, en) {
    cphi *= sphi;
    sphi *= sphi;
    return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
  }

  // ../node_modules/proj4/lib/common/pj_inv_mlfn.js
  var MAX_ITER = 20;
  function pj_inv_mlfn_default(arg, es, en) {
    var k = 1 / (1 - es);
    var phi = arg;
    for (var i = MAX_ITER; i; --i) {
      var s = Math.sin(phi);
      var t = 1 - es * s * s;
      t = (pj_mlfn_default(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
      phi -= t;
      if (Math.abs(t) < EPSLN) {
        return phi;
      }
    }
    return phi;
  }

  // ../node_modules/proj4/lib/projections/tmerc.js
  function init3() {
    this.x0 = this.x0 !== void 0 ? this.x0 : 0;
    this.y0 = this.y0 !== void 0 ? this.y0 : 0;
    this.long0 = this.long0 !== void 0 ? this.long0 : 0;
    this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
    if (this.es) {
      this.en = pj_enfn_default(this.es);
      this.ml0 = pj_mlfn_default(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
    }
  }
  function forward3(p) {
    var lon = p.x;
    var lat = p.y;
    var delta_lon = adjust_lon_default(lon - this.long0);
    var con;
    var x3, y3;
    var sin_phi = Math.sin(lat);
    var cos_phi = Math.cos(lat);
    if (!this.es) {
      var b = cos_phi * Math.sin(delta_lon);
      if (Math.abs(Math.abs(b) - 1) < EPSLN) {
        return 93;
      } else {
        x3 = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
        y3 = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
        b = Math.abs(y3);
        if (b >= 1) {
          if (b - 1 > EPSLN) {
            return 93;
          } else {
            y3 = 0;
          }
        } else {
          y3 = Math.acos(y3);
        }
        if (lat < 0) {
          y3 = -y3;
        }
        y3 = this.a * this.k0 * (y3 - this.lat0) + this.y0;
      }
    } else {
      var al = cos_phi * delta_lon;
      var als = Math.pow(al, 2);
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
      var t = Math.pow(tq, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      al = al / Math.sqrt(con);
      var ml = pj_mlfn_default(lat, sin_phi, cos_phi, this.en);
      x3 = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
      y3 = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
    }
    p.x = x3;
    p.y = y3;
    return p;
  }
  function inverse3(p) {
    var con, phi;
    var lat, lon;
    var x3 = (p.x - this.x0) * (1 / this.a);
    var y3 = (p.y - this.y0) * (1 / this.a);
    if (!this.es) {
      var f = Math.exp(x3 / this.k0);
      var g = 0.5 * (f - 1 / f);
      var temp2 = this.lat0 + y3 / this.k0;
      var h = Math.cos(temp2);
      con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
      lat = Math.asin(con);
      if (y3 < 0) {
        lat = -lat;
      }
      if (g === 0 && h === 0) {
        lon = 0;
      } else {
        lon = adjust_lon_default(Math.atan2(g, h) + this.long0);
      }
    } else {
      con = this.ml0 + y3 / this.k0;
      phi = pj_inv_mlfn_default(con, this.es, this.en);
      if (Math.abs(phi) < HALF_PI) {
        var sin_phi = Math.sin(phi);
        var cos_phi = Math.cos(phi);
        var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
        var c = this.ep2 * Math.pow(cos_phi, 2);
        var cs = Math.pow(c, 2);
        var t = Math.pow(tan_phi, 2);
        var ts = Math.pow(t, 2);
        con = 1 - this.es * Math.pow(sin_phi, 2);
        var d = x3 * Math.sqrt(con) / this.k0;
        var ds = Math.pow(d, 2);
        con = con * tan_phi;
        lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
        lon = adjust_lon_default(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
      } else {
        lat = HALF_PI * sign_default(y3);
        lon = 0;
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names4 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
  var tmerc_default = {
    init: init3,
    forward: forward3,
    inverse: inverse3,
    names: names4
  };

  // ../node_modules/proj4/lib/common/sinh.js
  function sinh_default(x3) {
    var r = Math.exp(x3);
    r = (r - 1 / r) / 2;
    return r;
  }

  // ../node_modules/proj4/lib/common/hypot.js
  function hypot_default(x3, y3) {
    x3 = Math.abs(x3);
    y3 = Math.abs(y3);
    var a2 = Math.max(x3, y3);
    var b = Math.min(x3, y3) / (a2 ? a2 : 1);
    return a2 * Math.sqrt(1 + Math.pow(b, 2));
  }

  // ../node_modules/proj4/lib/common/log1py.js
  function log1py_default(x3) {
    var y3 = 1 + x3;
    var z2 = y3 - 1;
    return z2 === 0 ? x3 : x3 * Math.log(y3) / z2;
  }

  // ../node_modules/proj4/lib/common/asinhy.js
  function asinhy_default(x3) {
    var y3 = Math.abs(x3);
    y3 = log1py_default(y3 * (1 + y3 / (hypot_default(1, y3) + 1)));
    return x3 < 0 ? -y3 : y3;
  }

  // ../node_modules/proj4/lib/common/gatg.js
  function gatg_default(pp, B2) {
    var cos_2B = 2 * Math.cos(2 * B2);
    var i = pp.length - 1;
    var h1 = pp[i];
    var h2 = 0;
    var h;
    while (--i >= 0) {
      h = -h2 + cos_2B * h1 + pp[i];
      h2 = h1;
      h1 = h;
    }
    return B2 + h * Math.sin(2 * B2);
  }

  // ../node_modules/proj4/lib/common/clens.js
  function clens_default(pp, arg_r) {
    var r = 2 * Math.cos(arg_r);
    var i = pp.length - 1;
    var hr1 = pp[i];
    var hr2 = 0;
    var hr;
    while (--i >= 0) {
      hr = -hr2 + r * hr1 + pp[i];
      hr2 = hr1;
      hr1 = hr;
    }
    return Math.sin(arg_r) * hr;
  }

  // ../node_modules/proj4/lib/common/cosh.js
  function cosh_default(x3) {
    var r = Math.exp(x3);
    r = (r + 1 / r) / 2;
    return r;
  }

  // ../node_modules/proj4/lib/common/clens_cmplx.js
  function clens_cmplx_default(pp, arg_r, arg_i) {
    var sin_arg_r = Math.sin(arg_r);
    var cos_arg_r = Math.cos(arg_r);
    var sinh_arg_i = sinh_default(arg_i);
    var cosh_arg_i = cosh_default(arg_i);
    var r = 2 * cos_arg_r * cosh_arg_i;
    var i = -2 * sin_arg_r * sinh_arg_i;
    var j = pp.length - 1;
    var hr = pp[j];
    var hi1 = 0;
    var hr1 = 0;
    var hi = 0;
    var hr2;
    var hi2;
    while (--j >= 0) {
      hr2 = hr1;
      hi2 = hi1;
      hr1 = hr;
      hi1 = hi;
      hr = -hr2 + r * hr1 - i * hi1 + pp[j];
      hi = -hi2 + i * hr1 + r * hi1;
    }
    r = sin_arg_r * cosh_arg_i;
    i = cos_arg_r * sinh_arg_i;
    return [r * hr - i * hi, r * hi + i * hr];
  }

  // ../node_modules/proj4/lib/projections/etmerc.js
  function init4() {
    if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
      throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
    }
    if (this.approx) {
      tmerc_default.init.apply(this);
      this.forward = tmerc_default.forward;
      this.inverse = tmerc_default.inverse;
    }
    this.x0 = this.x0 !== void 0 ? this.x0 : 0;
    this.y0 = this.y0 !== void 0 ? this.y0 : 0;
    this.long0 = this.long0 !== void 0 ? this.long0 : 0;
    this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
    this.cgb = [];
    this.cbg = [];
    this.utg = [];
    this.gtu = [];
    var f = this.es / (1 + Math.sqrt(1 - this.es));
    var n = f / (2 - f);
    var np = n;
    this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
    this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
    np = np * n;
    this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
    this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
    np = np * n;
    this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
    this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
    np = np * n;
    this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
    this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
    np = np * n;
    this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
    this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
    np = np * n;
    this.cgb[5] = np * (601676 / 22275);
    this.cbg[5] = np * (444337 / 155925);
    np = Math.pow(n, 2);
    this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
    this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
    this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
    this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
    this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
    np = np * n;
    this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
    this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
    np = np * n;
    this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
    this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
    np = np * n;
    this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
    this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
    np = np * n;
    this.utg[5] = np * (-20648693 / 638668800);
    this.gtu[5] = np * (212378941 / 319334400);
    var Z2 = gatg_default(this.cbg, this.lat0);
    this.Zb = -this.Qn * (Z2 + clens_default(this.gtu, 2 * Z2));
  }
  function forward4(p) {
    var Ce = adjust_lon_default(p.x - this.long0);
    var Cn = p.y;
    Cn = gatg_default(this.cbg, Cn);
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
    Ce = Math.atan2(sin_Ce * cos_Cn, hypot_default(sin_Cn, cos_Cn * cos_Ce));
    Ce = asinhy_default(Math.tan(Ce));
    var tmp = clens_cmplx_default(this.gtu, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    var x3;
    var y3;
    if (Math.abs(Ce) <= 2.623395162778) {
      x3 = this.a * (this.Qn * Ce) + this.x0;
      y3 = this.a * (this.Qn * Cn + this.Zb) + this.y0;
    } else {
      x3 = Infinity;
      y3 = Infinity;
    }
    p.x = x3;
    p.y = y3;
    return p;
  }
  function inverse4(p) {
    var Ce = (p.x - this.x0) * (1 / this.a);
    var Cn = (p.y - this.y0) * (1 / this.a);
    Cn = (Cn - this.Zb) / this.Qn;
    Ce = Ce / this.Qn;
    var lon;
    var lat;
    if (Math.abs(Ce) <= 2.623395162778) {
      var tmp = clens_cmplx_default(this.utg, 2 * Cn, 2 * Ce);
      Cn = Cn + tmp[0];
      Ce = Ce + tmp[1];
      Ce = Math.atan(sinh_default(Ce));
      var sin_Cn = Math.sin(Cn);
      var cos_Cn = Math.cos(Cn);
      var sin_Ce = Math.sin(Ce);
      var cos_Ce = Math.cos(Ce);
      Cn = Math.atan2(sin_Cn * cos_Ce, hypot_default(sin_Ce, cos_Ce * cos_Cn));
      Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
      lon = adjust_lon_default(Ce + this.long0);
      lat = gatg_default(this.cgb, Cn);
    } else {
      lon = Infinity;
      lat = Infinity;
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names5 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
  var etmerc_default = {
    init: init4,
    forward: forward4,
    inverse: inverse4,
    names: names5
  };

  // ../node_modules/proj4/lib/common/adjust_zone.js
  function adjust_zone_default(zone, lon) {
    if (zone === void 0) {
      zone = Math.floor((adjust_lon_default(lon) + Math.PI) * 30 / Math.PI) + 1;
      if (zone < 0) {
        return 0;
      } else if (zone > 60) {
        return 60;
      }
    }
    return zone;
  }

  // ../node_modules/proj4/lib/projections/utm.js
  var dependsOn = "etmerc";
  function init5() {
    var zone = adjust_zone_default(this.zone, this.long0);
    if (zone === void 0) {
      throw new Error("unknown utm zone");
    }
    this.lat0 = 0;
    this.long0 = (6 * Math.abs(zone) - 183) * D2R2;
    this.x0 = 5e5;
    this.y0 = this.utmSouth ? 1e7 : 0;
    this.k0 = 0.9996;
    etmerc_default.init.apply(this);
    this.forward = etmerc_default.forward;
    this.inverse = etmerc_default.inverse;
  }
  var names6 = ["Universal Transverse Mercator System", "utm"];
  var utm_default = {
    init: init5,
    names: names6,
    dependsOn
  };

  // ../node_modules/proj4/lib/common/srat.js
  function srat_default(esinp, exp2) {
    return Math.pow((1 - esinp) / (1 + esinp), exp2);
  }

  // ../node_modules/proj4/lib/projections/gauss.js
  var MAX_ITER2 = 20;
  function init6() {
    var sphi = Math.sin(this.lat0);
    var cphi = Math.cos(this.lat0);
    cphi *= cphi;
    this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
    this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
    this.phic0 = Math.asin(sphi / this.C);
    this.ratexp = 0.5 * this.C * this.e;
    this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat_default(this.e * sphi, this.ratexp));
  }
  function forward5(p) {
    var lon = p.x;
    var lat = p.y;
    p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat_default(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
    p.x = this.C * lon;
    return p;
  }
  function inverse5(p) {
    var DEL_TOL = 1e-14;
    var lon = p.x / this.C;
    var lat = p.y;
    var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
    for (var i = MAX_ITER2; i > 0; --i) {
      lat = 2 * Math.atan(num * srat_default(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;
      if (Math.abs(lat - p.y) < DEL_TOL) {
        break;
      }
      p.y = lat;
    }
    if (!i) {
      return null;
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names7 = ["gauss"];
  var gauss_default = {
    init: init6,
    forward: forward5,
    inverse: inverse5,
    names: names7
  };

  // ../node_modules/proj4/lib/projections/sterea.js
  function init7() {
    gauss_default.init.apply(this);
    if (!this.rc) {
      return;
    }
    this.sinc0 = Math.sin(this.phic0);
    this.cosc0 = Math.cos(this.phic0);
    this.R2 = 2 * this.rc;
    if (!this.title) {
      this.title = "Oblique Stereographic Alternative";
    }
  }
  function forward6(p) {
    var sinc, cosc, cosl, k;
    p.x = adjust_lon_default(p.x - this.long0);
    gauss_default.forward.apply(this, [p]);
    sinc = Math.sin(p.y);
    cosc = Math.cos(p.y);
    cosl = Math.cos(p.x);
    k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
    p.x = k * cosc * Math.sin(p.x);
    p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
    p.x = this.a * p.x + this.x0;
    p.y = this.a * p.y + this.y0;
    return p;
  }
  function inverse6(p) {
    var sinc, cosc, lon, lat, rho;
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;
    p.x /= this.k0;
    p.y /= this.k0;
    if (rho = Math.sqrt(p.x * p.x + p.y * p.y)) {
      var c = 2 * Math.atan2(rho, this.R2);
      sinc = Math.sin(c);
      cosc = Math.cos(c);
      lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
      lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
    } else {
      lat = this.phic0;
      lon = 0;
    }
    p.x = lon;
    p.y = lat;
    gauss_default.inverse.apply(this, [p]);
    p.x = adjust_lon_default(p.x + this.long0);
    return p;
  }
  var names8 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
  var sterea_default = {
    init: init7,
    forward: forward6,
    inverse: inverse6,
    names: names8
  };

  // ../node_modules/proj4/lib/projections/stere.js
  function ssfn_(phit, sinphi, eccen) {
    sinphi *= eccen;
    return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
  }
  function init8() {
    this.coslat0 = Math.cos(this.lat0);
    this.sinlat0 = Math.sin(this.lat0);
    if (this.sphere) {
      if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
        this.k0 = 0.5 * (1 + sign_default(this.lat0) * Math.sin(this.lat_ts));
      }
    } else {
      if (Math.abs(this.coslat0) <= EPSLN) {
        if (this.lat0 > 0) {
          this.con = 1;
        } else {
          this.con = -1;
        }
      }
      this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
      if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
        this.k0 = 0.5 * this.cons * msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz_default(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
      }
      this.ms1 = msfnz_default(this.e, this.sinlat0, this.coslat0);
      this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
      this.cosX0 = Math.cos(this.X0);
      this.sinX0 = Math.sin(this.X0);
    }
  }
  function forward7(p) {
    var lon = p.x;
    var lat = p.y;
    var sinlat = Math.sin(lat);
    var coslat = Math.cos(lat);
    var A2, X, sinX, cosX, ts, rh;
    var dlon = adjust_lon_default(lon - this.long0);
    if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
      p.x = NaN;
      p.y = NaN;
      return p;
    }
    if (this.sphere) {
      A2 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
      p.x = this.a * A2 * coslat * Math.sin(dlon) + this.x0;
      p.y = this.a * A2 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
      return p;
    } else {
      X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
      cosX = Math.cos(X);
      sinX = Math.sin(X);
      if (Math.abs(this.coslat0) <= EPSLN) {
        ts = tsfnz_default(this.e, lat * this.con, this.con * sinlat);
        rh = 2 * this.a * this.k0 * ts / this.cons;
        p.x = this.x0 + rh * Math.sin(lon - this.long0);
        p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
        return p;
      } else if (Math.abs(this.sinlat0) < EPSLN) {
        A2 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
        p.y = A2 * sinX;
      } else {
        A2 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
        p.y = A2 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
      }
      p.x = A2 * cosX * Math.sin(dlon) + this.x0;
    }
    return p;
  }
  function inverse7(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon, lat, ts, ce, Chi;
    var rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (this.sphere) {
      var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
      lon = this.long0;
      lat = this.lat0;
      if (rh <= EPSLN) {
        p.x = lon;
        p.y = lat;
        return p;
      }
      lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
      if (Math.abs(this.coslat0) < EPSLN) {
        if (this.lat0 > 0) {
          lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -1 * p.y));
        } else {
          lon = adjust_lon_default(this.long0 + Math.atan2(p.x, p.y));
        }
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
      }
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      if (Math.abs(this.coslat0) <= EPSLN) {
        if (rh <= EPSLN) {
          lat = this.lat0;
          lon = this.long0;
          p.x = lon;
          p.y = lat;
          return p;
        }
        p.x *= this.con;
        p.y *= this.con;
        ts = rh * this.cons / (2 * this.a * this.k0);
        lat = this.con * phi2z_default(this.e, ts);
        lon = this.con * adjust_lon_default(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
      } else {
        ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
        lon = this.long0;
        if (rh <= EPSLN) {
          Chi = this.X0;
        } else {
          Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
          lon = adjust_lon_default(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
        }
        lat = -1 * phi2z_default(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names9 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
  var stere_default = {
    init: init8,
    forward: forward7,
    inverse: inverse7,
    names: names9,
    ssfn_
  };

  // ../node_modules/proj4/lib/projections/somerc.js
  function init9() {
    var phy0 = this.lat0;
    this.lambda0 = this.long0;
    var sinPhy0 = Math.sin(phy0);
    var semiMajorAxis = this.a;
    var invF = this.rf;
    var flattening = 1 / invF;
    var e22 = 2 * flattening - Math.pow(flattening, 2);
    var e = this.e = Math.sqrt(e22);
    this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e22) / (1 - e22 * Math.pow(sinPhy0, 2));
    this.alpha = Math.sqrt(1 + e22 / (1 - e22) * Math.pow(Math.cos(phy0), 4));
    this.b0 = Math.asin(sinPhy0 / this.alpha);
    var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
    var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
    var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
    this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
  }
  function forward8(p) {
    var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
    var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
    var S = -this.alpha * (Sa1 + Sa2) + this.K;
    var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
    var I2 = this.alpha * (p.x - this.lambda0);
    var rotI = Math.atan(Math.sin(I2) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I2)));
    var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I2));
    p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
    p.x = this.R * rotI + this.x0;
    return p;
  }
  function inverse8(p) {
    var Y = p.x - this.x0;
    var X = p.y - this.y0;
    var rotI = Y / this.R;
    var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
    var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
    var I2 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
    var lambda = this.lambda0 + I2 / this.alpha;
    var S = 0;
    var phy = b;
    var prevPhy = -1e3;
    var iteration = 0;
    while (Math.abs(phy - prevPhy) > 1e-7) {
      if (++iteration > 20) {
        return;
      }
      S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
      prevPhy = phy;
      phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
    }
    p.x = lambda;
    p.y = phy;
    return p;
  }
  var names10 = ["somerc"];
  var somerc_default = {
    init: init9,
    forward: forward8,
    inverse: inverse8,
    names: names10
  };

  // ../node_modules/proj4/lib/projections/omerc.js
  var TOL = 1e-7;
  function isTypeA(P) {
    var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
    var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
    return "no_uoff" in P || "no_off" in P || typeAProjections.indexOf(projectionName) !== -1;
  }
  function init10() {
    var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0, AB;
    this.no_off = isTypeA(this);
    this.no_rot = "no_rot" in this;
    var alp = false;
    if ("alpha" in this) {
      alp = true;
    }
    var gam = false;
    if ("rectified_grid_angle" in this) {
      gam = true;
    }
    if (alp) {
      alpha_c = this.alpha;
    }
    if (gam) {
      gamma = this.rectified_grid_angle * D2R2;
    }
    if (alp || gam) {
      lamc = this.longc;
    } else {
      lam1 = this.long1;
      phi1 = this.lat1;
      lam2 = this.long2;
      phi2 = this.lat2;
      if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
        throw new Error();
      }
    }
    var one_es = 1 - this.es;
    com = Math.sqrt(one_es);
    if (Math.abs(this.lat0) > EPSLN) {
      sinph0 = Math.sin(this.lat0);
      cosph0 = Math.cos(this.lat0);
      con = 1 - this.es * sinph0 * sinph0;
      this.B = cosph0 * cosph0;
      this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
      this.A = this.B * this.k0 * com / con;
      D = this.B * com / (cosph0 * Math.sqrt(con));
      F = D * D - 1;
      if (F <= 0) {
        F = 0;
      } else {
        F = Math.sqrt(F);
        if (this.lat0 < 0) {
          F = -F;
        }
      }
      this.E = F += D;
      this.E *= Math.pow(tsfnz_default(this.e, this.lat0, sinph0), this.B);
    } else {
      this.B = 1 / com;
      this.A = this.k0;
      this.E = D = F = 1;
    }
    if (alp || gam) {
      if (alp) {
        gamma0 = Math.asin(Math.sin(alpha_c) / D);
        if (!gam) {
          gamma = alpha_c;
        }
      } else {
        gamma0 = gamma;
        alpha_c = Math.asin(D * Math.sin(gamma0));
      }
      this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
    } else {
      H = Math.pow(tsfnz_default(this.e, phi1, Math.sin(phi1)), this.B);
      L = Math.pow(tsfnz_default(this.e, phi2, Math.sin(phi2)), this.B);
      F = this.E / H;
      p = (L - H) / (L + H);
      J = this.E * this.E;
      J = (J - L * H) / (J + L * H);
      con = lam1 - lam2;
      if (con < -Math.pi) {
        lam2 -= TWO_PI;
      } else if (con > Math.pi) {
        lam2 += TWO_PI;
      }
      this.lam0 = adjust_lon_default(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
      gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon_default(lam1 - this.lam0)) / (F - 1 / F));
      gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
    }
    this.singam = Math.sin(gamma0);
    this.cosgam = Math.cos(gamma0);
    this.sinrot = Math.sin(gamma);
    this.cosrot = Math.cos(gamma);
    this.rB = 1 / this.B;
    this.ArB = this.A * this.rB;
    this.BrA = 1 / this.ArB;
    AB = this.A * this.B;
    if (this.no_off) {
      this.u_0 = 0;
    } else {
      this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
      if (this.lat0 < 0) {
        this.u_0 = -this.u_0;
      }
    }
    F = 0.5 * gamma0;
    this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
    this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
  }
  function forward9(p) {
    var coords = {};
    var S, T, U, V2, W, temp2, u, v;
    p.x = p.x - this.lam0;
    if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
      W = this.E / Math.pow(tsfnz_default(this.e, p.y, Math.sin(p.y)), this.B);
      temp2 = 1 / W;
      S = 0.5 * (W - temp2);
      T = 0.5 * (W + temp2);
      V2 = Math.sin(this.B * p.x);
      U = (S * this.singam - V2 * this.cosgam) / T;
      if (Math.abs(Math.abs(U) - 1) < EPSLN) {
        throw new Error();
      }
      v = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
      temp2 = Math.cos(this.B * p.x);
      if (Math.abs(temp2) < TOL) {
        u = this.A * p.x;
      } else {
        u = this.ArB * Math.atan2(S * this.cosgam + V2 * this.singam, temp2);
      }
    } else {
      v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
      u = this.ArB * p.y;
    }
    if (this.no_rot) {
      coords.x = u;
      coords.y = v;
    } else {
      u -= this.u_0;
      coords.x = v * this.cosrot + u * this.sinrot;
      coords.y = u * this.cosrot - v * this.sinrot;
    }
    coords.x = this.a * coords.x + this.x0;
    coords.y = this.a * coords.y + this.y0;
    return coords;
  }
  function inverse9(p) {
    var u, v, Qp, Sp, Tp, Vp, Up;
    var coords = {};
    p.x = (p.x - this.x0) * (1 / this.a);
    p.y = (p.y - this.y0) * (1 / this.a);
    if (this.no_rot) {
      v = p.y;
      u = p.x;
    } else {
      v = p.x * this.cosrot - p.y * this.sinrot;
      u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
    }
    Qp = Math.exp(-this.BrA * v);
    Sp = 0.5 * (Qp - 1 / Qp);
    Tp = 0.5 * (Qp + 1 / Qp);
    Vp = Math.sin(this.BrA * u);
    Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
    if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
      coords.x = 0;
      coords.y = Up < 0 ? -HALF_PI : HALF_PI;
    } else {
      coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
      coords.y = phi2z_default(this.e, Math.pow(coords.y, 1 / this.B));
      if (coords.y === Infinity) {
        throw new Error();
      }
      coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u));
    }
    coords.x += this.lam0;
    return coords;
  }
  var names11 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
  var omerc_default = {
    init: init10,
    forward: forward9,
    inverse: inverse9,
    names: names11
  };

  // ../node_modules/proj4/lib/projections/lcc.js
  function init11() {
    if (!this.lat2) {
      this.lat2 = this.lat1;
    }
    if (!this.k0) {
      this.k0 = 1;
    }
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    var temp2 = this.b / this.a;
    this.e = Math.sqrt(1 - temp2 * temp2);
    var sin1 = Math.sin(this.lat1);
    var cos1 = Math.cos(this.lat1);
    var ms1 = msfnz_default(this.e, sin1, cos1);
    var ts1 = tsfnz_default(this.e, this.lat1, sin1);
    var sin22 = Math.sin(this.lat2);
    var cos22 = Math.cos(this.lat2);
    var ms2 = msfnz_default(this.e, sin22, cos22);
    var ts2 = tsfnz_default(this.e, this.lat2, sin22);
    var ts0 = tsfnz_default(this.e, this.lat0, Math.sin(this.lat0));
    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
      this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
    } else {
      this.ns = sin1;
    }
    if (isNaN(this.ns)) {
      this.ns = sin1;
    }
    this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
    this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
    if (!this.title) {
      this.title = "Lambert Conformal Conic";
    }
  }
  function forward10(p) {
    var lon = p.x;
    var lat = p.y;
    if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
      lat = sign_default(lat) * (HALF_PI - 2 * EPSLN);
    }
    var con = Math.abs(Math.abs(lat) - HALF_PI);
    var ts, rh1;
    if (con > EPSLN) {
      ts = tsfnz_default(this.e, lat, Math.sin(lat));
      rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
    } else {
      con = lat * this.ns;
      if (con <= 0) {
        return null;
      }
      rh1 = 0;
    }
    var theta = this.ns * adjust_lon_default(lon - this.long0);
    p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
    p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
    return p;
  }
  function inverse10(p) {
    var rh1, con, ts;
    var lat, lon;
    var x3 = (p.x - this.x0) / this.k0;
    var y3 = this.rh - (p.y - this.y0) / this.k0;
    if (this.ns > 0) {
      rh1 = Math.sqrt(x3 * x3 + y3 * y3);
      con = 1;
    } else {
      rh1 = -Math.sqrt(x3 * x3 + y3 * y3);
      con = -1;
    }
    var theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * x3, con * y3);
    }
    if (rh1 !== 0 || this.ns > 0) {
      con = 1 / this.ns;
      ts = Math.pow(rh1 / (this.a * this.f0), con);
      lat = phi2z_default(this.e, ts);
      if (lat === -9999) {
        return null;
      }
    } else {
      lat = -HALF_PI;
    }
    lon = adjust_lon_default(theta / this.ns + this.long0);
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names12 = [
    "Lambert Tangential Conformal Conic Projection",
    "Lambert_Conformal_Conic",
    "Lambert_Conformal_Conic_1SP",
    "Lambert_Conformal_Conic_2SP",
    "lcc",
    "Lambert Conic Conformal (1SP)",
    "Lambert Conic Conformal (2SP)"
  ];
  var lcc_default = {
    init: init11,
    forward: forward10,
    inverse: inverse10,
    names: names12
  };

  // ../node_modules/proj4/lib/projections/krovak.js
  function init12() {
    this.a = 6377397155e-3;
    this.es = 0.006674372230614;
    this.e = Math.sqrt(this.es);
    if (!this.lat0) {
      this.lat0 = 0.863937979737193;
    }
    if (!this.long0) {
      this.long0 = 0.7417649320975901 - 0.308341501185665;
    }
    if (!this.k0) {
      this.k0 = 0.9999;
    }
    this.s45 = 0.785398163397448;
    this.s90 = 2 * this.s45;
    this.fi0 = this.lat0;
    this.e2 = this.es;
    this.e = Math.sqrt(this.e2);
    this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
    this.uq = 1.04216856380474;
    this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
    this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
    this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
    this.k1 = this.k0;
    this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
    this.s0 = 1.37008346281555;
    this.n = Math.sin(this.s0);
    this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
    this.ad = this.s90 - this.uq;
  }
  function forward11(p) {
    var gfi, u, deltav, s, d, eps, ro;
    var lon = p.x;
    var lat = p.y;
    var delta_lon = adjust_lon_default(lon - this.long0);
    gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
    u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
    deltav = -delta_lon * this.alfa;
    s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
    d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
    eps = this.n * d;
    ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
    p.y = ro * Math.cos(eps) / 1;
    p.x = ro * Math.sin(eps) / 1;
    if (!this.czech) {
      p.y *= -1;
      p.x *= -1;
    }
    return p;
  }
  function inverse11(p) {
    var u, deltav, s, d, eps, ro, fi1;
    var ok;
    var tmp = p.x;
    p.x = p.y;
    p.y = tmp;
    if (!this.czech) {
      p.y *= -1;
      p.x *= -1;
    }
    ro = Math.sqrt(p.x * p.x + p.y * p.y);
    eps = Math.atan2(p.y, p.x);
    d = eps / Math.sin(this.s0);
    s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
    u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
    deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
    p.x = this.long0 - deltav / this.alfa;
    fi1 = u;
    ok = 0;
    var iter = 0;
    do {
      p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
      if (Math.abs(fi1 - p.y) < 1e-10) {
        ok = 1;
      }
      fi1 = p.y;
      iter += 1;
    } while (ok === 0 && iter < 15);
    if (iter >= 15) {
      return null;
    }
    return p;
  }
  var names13 = ["Krovak", "krovak"];
  var krovak_default = {
    init: init12,
    forward: forward11,
    inverse: inverse11,
    names: names13
  };

  // ../node_modules/proj4/lib/common/mlfn.js
  function mlfn_default(e0, e1, e22, e3, phi) {
    return e0 * phi - e1 * Math.sin(2 * phi) + e22 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
  }

  // ../node_modules/proj4/lib/common/e0fn.js
  function e0fn_default(x3) {
    return 1 - 0.25 * x3 * (1 + x3 / 16 * (3 + 1.25 * x3));
  }

  // ../node_modules/proj4/lib/common/e1fn.js
  function e1fn_default(x3) {
    return 0.375 * x3 * (1 + 0.25 * x3 * (1 + 0.46875 * x3));
  }

  // ../node_modules/proj4/lib/common/e2fn.js
  function e2fn_default(x3) {
    return 0.05859375 * x3 * x3 * (1 + 0.75 * x3);
  }

  // ../node_modules/proj4/lib/common/e3fn.js
  function e3fn_default(x3) {
    return x3 * x3 * x3 * (35 / 3072);
  }

  // ../node_modules/proj4/lib/common/gN.js
  function gN_default(a2, e, sinphi) {
    var temp2 = e * sinphi;
    return a2 / Math.sqrt(1 - temp2 * temp2);
  }

  // ../node_modules/proj4/lib/common/adjust_lat.js
  function adjust_lat_default(x3) {
    return Math.abs(x3) < HALF_PI ? x3 : x3 - sign_default(x3) * Math.PI;
  }

  // ../node_modules/proj4/lib/common/imlfn.js
  function imlfn_default(ml, e0, e1, e22, e3) {
    var phi;
    var dphi;
    phi = ml / e0;
    for (var i = 0; i < 15; i++) {
      dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e22 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e22 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
      phi += dphi;
      if (Math.abs(dphi) <= 1e-10) {
        return phi;
      }
    }
    return NaN;
  }

  // ../node_modules/proj4/lib/projections/cass.js
  function init13() {
    if (!this.sphere) {
      this.e0 = e0fn_default(this.es);
      this.e1 = e1fn_default(this.es);
      this.e2 = e2fn_default(this.es);
      this.e3 = e3fn_default(this.es);
      this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
    }
  }
  function forward12(p) {
    var x3, y3;
    var lam = p.x;
    var phi = p.y;
    lam = adjust_lon_default(lam - this.long0);
    if (this.sphere) {
      x3 = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
      y3 = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
    } else {
      var sinphi = Math.sin(phi);
      var cosphi = Math.cos(phi);
      var nl = gN_default(this.a, this.e, sinphi);
      var tl = Math.tan(phi) * Math.tan(phi);
      var al = lam * Math.cos(phi);
      var asq = al * al;
      var cl = this.es * cosphi * cosphi / (1 - this.es);
      var ml = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
      x3 = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
      y3 = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
    }
    p.x = x3 + this.x0;
    p.y = y3 + this.y0;
    return p;
  }
  function inverse12(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var x3 = p.x / this.a;
    var y3 = p.y / this.a;
    var phi, lam;
    if (this.sphere) {
      var dd = y3 + this.lat0;
      phi = Math.asin(Math.sin(dd) * Math.cos(x3));
      lam = Math.atan2(Math.tan(x3), Math.cos(dd));
    } else {
      var ml1 = this.ml0 / this.a + y3;
      var phi1 = imlfn_default(ml1, this.e0, this.e1, this.e2, this.e3);
      if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
        p.x = this.long0;
        p.y = HALF_PI;
        if (y3 < 0) {
          p.y *= -1;
        }
        return p;
      }
      var nl1 = gN_default(this.a, this.e, Math.sin(phi1));
      var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
      var tl1 = Math.pow(Math.tan(phi1), 2);
      var dl = x3 * this.a / nl1;
      var dsq = dl * dl;
      phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
      lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
    }
    p.x = adjust_lon_default(lam + this.long0);
    p.y = adjust_lat_default(phi);
    return p;
  }
  var names14 = ["Cassini", "Cassini_Soldner", "cass"];
  var cass_default = {
    init: init13,
    forward: forward12,
    inverse: inverse12,
    names: names14
  };

  // ../node_modules/proj4/lib/common/qsfnz.js
  function qsfnz_default(eccent, sinphi) {
    var con;
    if (eccent > 1e-7) {
      con = eccent * sinphi;
      return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    } else {
      return 2 * sinphi;
    }
  }

  // ../node_modules/proj4/lib/projections/laea.js
  var S_POLE = 1;
  var N_POLE = 2;
  var EQUIT = 3;
  var OBLIQ = 4;
  function init14() {
    var t = Math.abs(this.lat0);
    if (Math.abs(t - HALF_PI) < EPSLN) {
      this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
    } else if (Math.abs(t) < EPSLN) {
      this.mode = this.EQUIT;
    } else {
      this.mode = this.OBLIQ;
    }
    if (this.es > 0) {
      var sinphi;
      this.qp = qsfnz_default(this.e, 1);
      this.mmf = 0.5 / (1 - this.es);
      this.apa = authset(this.es);
      switch (this.mode) {
        case this.N_POLE:
          this.dd = 1;
          break;
        case this.S_POLE:
          this.dd = 1;
          break;
        case this.EQUIT:
          this.rq = Math.sqrt(0.5 * this.qp);
          this.dd = 1 / this.rq;
          this.xmf = 1;
          this.ymf = 0.5 * this.qp;
          break;
        case this.OBLIQ:
          this.rq = Math.sqrt(0.5 * this.qp);
          sinphi = Math.sin(this.lat0);
          this.sinb1 = qsfnz_default(this.e, sinphi) / this.qp;
          this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
          this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
          this.ymf = (this.xmf = this.rq) / this.dd;
          this.xmf *= this.dd;
          break;
      }
    } else {
      if (this.mode === this.OBLIQ) {
        this.sinph0 = Math.sin(this.lat0);
        this.cosph0 = Math.cos(this.lat0);
      }
    }
  }
  function forward13(p) {
    var x3, y3, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
    var lam = p.x;
    var phi = p.y;
    lam = adjust_lon_default(lam - this.long0);
    if (this.sphere) {
      sinphi = Math.sin(phi);
      cosphi = Math.cos(phi);
      coslam = Math.cos(lam);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        y3 = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
        if (y3 <= EPSLN) {
          return null;
        }
        y3 = Math.sqrt(2 / y3);
        x3 = y3 * cosphi * Math.sin(lam);
        y3 *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE) {
          coslam = -coslam;
        }
        if (Math.abs(phi + this.lat0) < EPSLN) {
          return null;
        }
        y3 = FORTPI - phi * 0.5;
        y3 = 2 * (this.mode === this.S_POLE ? Math.cos(y3) : Math.sin(y3));
        x3 = y3 * Math.sin(lam);
        y3 *= coslam;
      }
    } else {
      sinb = 0;
      cosb = 0;
      b = 0;
      coslam = Math.cos(lam);
      sinlam = Math.sin(lam);
      sinphi = Math.sin(phi);
      q = qsfnz_default(this.e, sinphi);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        sinb = q / this.qp;
        cosb = Math.sqrt(1 - sinb * sinb);
      }
      switch (this.mode) {
        case this.OBLIQ:
          b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
          break;
        case this.EQUIT:
          b = 1 + cosb * coslam;
          break;
        case this.N_POLE:
          b = HALF_PI + phi;
          q = this.qp - q;
          break;
        case this.S_POLE:
          b = phi - HALF_PI;
          q = this.qp + q;
          break;
      }
      if (Math.abs(b) < EPSLN) {
        return null;
      }
      switch (this.mode) {
        case this.OBLIQ:
        case this.EQUIT:
          b = Math.sqrt(2 / b);
          if (this.mode === this.OBLIQ) {
            y3 = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
          } else {
            y3 = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
          }
          x3 = this.xmf * b * cosb * sinlam;
          break;
        case this.N_POLE:
        case this.S_POLE:
          if (q >= 0) {
            x3 = (b = Math.sqrt(q)) * sinlam;
            y3 = coslam * (this.mode === this.S_POLE ? b : -b);
          } else {
            x3 = y3 = 0;
          }
          break;
      }
    }
    p.x = this.a * x3 + this.x0;
    p.y = this.a * y3 + this.y0;
    return p;
  }
  function inverse13(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var x3 = p.x / this.a;
    var y3 = p.y / this.a;
    var lam, phi, cCe, sCe, q, rho, ab;
    if (this.sphere) {
      var cosz = 0, rh, sinz = 0;
      rh = Math.sqrt(x3 * x3 + y3 * y3);
      phi = rh * 0.5;
      if (phi > 1) {
        return null;
      }
      phi = 2 * Math.asin(phi);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        sinz = Math.sin(phi);
        cosz = Math.cos(phi);
      }
      switch (this.mode) {
        case this.EQUIT:
          phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y3 * sinz / rh);
          x3 *= sinz;
          y3 = cosz * rh;
          break;
        case this.OBLIQ:
          phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y3 * sinz * this.cosph0 / rh);
          x3 *= sinz * this.cosph0;
          y3 = (cosz - Math.sin(phi) * this.sinph0) * rh;
          break;
        case this.N_POLE:
          y3 = -y3;
          phi = HALF_PI - phi;
          break;
        case this.S_POLE:
          phi -= HALF_PI;
          break;
      }
      lam = y3 === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x3, y3);
    } else {
      ab = 0;
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        x3 /= this.dd;
        y3 *= this.dd;
        rho = Math.sqrt(x3 * x3 + y3 * y3);
        if (rho < EPSLN) {
          p.x = this.long0;
          p.y = this.lat0;
          return p;
        }
        sCe = 2 * Math.asin(0.5 * rho / this.rq);
        cCe = Math.cos(sCe);
        x3 *= sCe = Math.sin(sCe);
        if (this.mode === this.OBLIQ) {
          ab = cCe * this.sinb1 + y3 * sCe * this.cosb1 / rho;
          q = this.qp * ab;
          y3 = rho * this.cosb1 * cCe - y3 * this.sinb1 * sCe;
        } else {
          ab = y3 * sCe / rho;
          q = this.qp * ab;
          y3 = rho * cCe;
        }
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE) {
          y3 = -y3;
        }
        q = x3 * x3 + y3 * y3;
        if (!q) {
          p.x = this.long0;
          p.y = this.lat0;
          return p;
        }
        ab = 1 - q / this.qp;
        if (this.mode === this.S_POLE) {
          ab = -ab;
        }
      }
      lam = Math.atan2(x3, y3);
      phi = authlat(Math.asin(ab), this.apa);
    }
    p.x = adjust_lon_default(this.long0 + lam);
    p.y = phi;
    return p;
  }
  var P00 = 0.3333333333333333;
  var P01 = 0.17222222222222222;
  var P02 = 0.10257936507936508;
  var P10 = 0.06388888888888888;
  var P11 = 0.0664021164021164;
  var P20 = 0.016415012942191543;
  function authset(es) {
    var t;
    var APA = [];
    APA[0] = es * P00;
    t = es * es;
    APA[0] += t * P01;
    APA[1] = t * P10;
    t *= es;
    APA[0] += t * P02;
    APA[1] += t * P11;
    APA[2] = t * P20;
    return APA;
  }
  function authlat(beta, APA) {
    var t = beta + beta;
    return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
  }
  var names15 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
  var laea_default = {
    init: init14,
    forward: forward13,
    inverse: inverse13,
    names: names15,
    S_POLE,
    N_POLE,
    EQUIT,
    OBLIQ
  };

  // ../node_modules/proj4/lib/common/asinz.js
  function asinz_default(x3) {
    if (Math.abs(x3) > 1) {
      x3 = x3 > 1 ? 1 : -1;
    }
    return Math.asin(x3);
  }

  // ../node_modules/proj4/lib/projections/aea.js
  function init15() {
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e3 = Math.sqrt(this.es);
    this.sin_po = Math.sin(this.lat1);
    this.cos_po = Math.cos(this.lat1);
    this.t1 = this.sin_po;
    this.con = this.sin_po;
    this.ms1 = msfnz_default(this.e3, this.sin_po, this.cos_po);
    this.qs1 = qsfnz_default(this.e3, this.sin_po, this.cos_po);
    this.sin_po = Math.sin(this.lat2);
    this.cos_po = Math.cos(this.lat2);
    this.t2 = this.sin_po;
    this.ms2 = msfnz_default(this.e3, this.sin_po, this.cos_po);
    this.qs2 = qsfnz_default(this.e3, this.sin_po, this.cos_po);
    this.sin_po = Math.sin(this.lat0);
    this.cos_po = Math.cos(this.lat0);
    this.t3 = this.sin_po;
    this.qs0 = qsfnz_default(this.e3, this.sin_po, this.cos_po);
    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
      this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
    } else {
      this.ns0 = this.con;
    }
    this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
    this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
  }
  function forward14(p) {
    var lon = p.x;
    var lat = p.y;
    this.sin_phi = Math.sin(lat);
    this.cos_phi = Math.cos(lat);
    var qs = qsfnz_default(this.e3, this.sin_phi, this.cos_phi);
    var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
    var theta = this.ns0 * adjust_lon_default(lon - this.long0);
    var x3 = rh1 * Math.sin(theta) + this.x0;
    var y3 = this.rh - rh1 * Math.cos(theta) + this.y0;
    p.x = x3;
    p.y = y3;
    return p;
  }
  function inverse14(p) {
    var rh1, qs, con, theta, lon, lat;
    p.x -= this.x0;
    p.y = this.rh - p.y + this.y0;
    if (this.ns0 >= 0) {
      rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
      con = 1;
    } else {
      rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
      con = -1;
    }
    theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * p.x, con * p.y);
    }
    con = rh1 * this.ns0 / this.a;
    if (this.sphere) {
      lat = Math.asin((this.c - con * con) / (2 * this.ns0));
    } else {
      qs = (this.c - con * con) / this.ns0;
      lat = this.phi1z(this.e3, qs);
    }
    lon = adjust_lon_default(theta / this.ns0 + this.long0);
    p.x = lon;
    p.y = lat;
    return p;
  }
  function phi1z(eccent, qs) {
    var sinphi, cosphi, con, com, dphi;
    var phi = asinz_default(0.5 * qs);
    if (eccent < EPSLN) {
      return phi;
    }
    var eccnts = eccent * eccent;
    for (var i = 1; i <= 25; i++) {
      sinphi = Math.sin(phi);
      cosphi = Math.cos(phi);
      con = eccent * sinphi;
      com = 1 - con * con;
      dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
      phi = phi + dphi;
      if (Math.abs(dphi) <= 1e-7) {
        return phi;
      }
    }
    return null;
  }
  var names16 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
  var aea_default = {
    init: init15,
    forward: forward14,
    inverse: inverse14,
    names: names16,
    phi1z
  };

  // ../node_modules/proj4/lib/projections/gnom.js
  function init16() {
    this.sin_p14 = Math.sin(this.lat0);
    this.cos_p14 = Math.cos(this.lat0);
    this.infinity_dist = 1e3 * this.a;
    this.rc = 1;
  }
  function forward15(p) {
    var sinphi, cosphi;
    var dlon;
    var coslon;
    var ksp;
    var g;
    var x3, y3;
    var lon = p.x;
    var lat = p.y;
    dlon = adjust_lon_default(lon - this.long0);
    sinphi = Math.sin(lat);
    cosphi = Math.cos(lat);
    coslon = Math.cos(dlon);
    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
    ksp = 1;
    if (g > 0 || Math.abs(g) <= EPSLN) {
      x3 = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
      y3 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
    } else {
      x3 = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
      y3 = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
    }
    p.x = x3;
    p.y = y3;
    return p;
  }
  function inverse15(p) {
    var rh;
    var sinc, cosc;
    var c;
    var lon, lat;
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;
    p.x /= this.k0;
    p.y /= this.k0;
    if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
      c = Math.atan2(rh, this.rc);
      sinc = Math.sin(c);
      cosc = Math.cos(c);
      lat = asinz_default(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
      lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
      lon = adjust_lon_default(this.long0 + lon);
    } else {
      lat = this.phic0;
      lon = 0;
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names17 = ["gnom"];
  var gnom_default = {
    init: init16,
    forward: forward15,
    inverse: inverse15,
    names: names17
  };

  // ../node_modules/proj4/lib/common/iqsfnz.js
  function iqsfnz_default(eccent, q) {
    var temp2 = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
    if (Math.abs(Math.abs(q) - temp2) < 1e-6) {
      if (q < 0) {
        return -1 * HALF_PI;
      } else {
        return HALF_PI;
      }
    }
    var phi = Math.asin(0.5 * q);
    var dphi;
    var sin_phi;
    var cos_phi;
    var con;
    for (var i = 0; i < 30; i++) {
      sin_phi = Math.sin(phi);
      cos_phi = Math.cos(phi);
      con = eccent * sin_phi;
      dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
      phi += dphi;
      if (Math.abs(dphi) <= 1e-10) {
        return phi;
      }
    }
    return NaN;
  }

  // ../node_modules/proj4/lib/projections/cea.js
  function init17() {
    if (!this.sphere) {
      this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }
  function forward16(p) {
    var lon = p.x;
    var lat = p.y;
    var x3, y3;
    var dlon = adjust_lon_default(lon - this.long0);
    if (this.sphere) {
      x3 = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
      y3 = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
    } else {
      var qs = qsfnz_default(this.e, Math.sin(lat));
      x3 = this.x0 + this.a * this.k0 * dlon;
      y3 = this.y0 + this.a * qs * 0.5 / this.k0;
    }
    p.x = x3;
    p.y = y3;
    return p;
  }
  function inverse16(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon, lat;
    if (this.sphere) {
      lon = adjust_lon_default(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
      lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
    } else {
      lat = iqsfnz_default(this.e, 2 * p.y * this.k0 / this.a);
      lon = adjust_lon_default(this.long0 + p.x / (this.a * this.k0));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names18 = ["cea"];
  var cea_default = {
    init: init17,
    forward: forward16,
    inverse: inverse16,
    names: names18
  };

  // ../node_modules/proj4/lib/projections/eqc.js
  function init18() {
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.lat0 = this.lat0 || 0;
    this.long0 = this.long0 || 0;
    this.lat_ts = this.lat_ts || 0;
    this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
    this.rc = Math.cos(this.lat_ts);
  }
  function forward17(p) {
    var lon = p.x;
    var lat = p.y;
    var dlon = adjust_lon_default(lon - this.long0);
    var dlat = adjust_lat_default(lat - this.lat0);
    p.x = this.x0 + this.a * dlon * this.rc;
    p.y = this.y0 + this.a * dlat;
    return p;
  }
  function inverse17(p) {
    var x3 = p.x;
    var y3 = p.y;
    p.x = adjust_lon_default(this.long0 + (x3 - this.x0) / (this.a * this.rc));
    p.y = adjust_lat_default(this.lat0 + (y3 - this.y0) / this.a);
    return p;
  }
  var names19 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
  var eqc_default = {
    init: init18,
    forward: forward17,
    inverse: inverse17,
    names: names19
  };

  // ../node_modules/proj4/lib/projections/poly.js
  var MAX_ITER3 = 20;
  function init19() {
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e = Math.sqrt(this.es);
    this.e0 = e0fn_default(this.es);
    this.e1 = e1fn_default(this.es);
    this.e2 = e2fn_default(this.es);
    this.e3 = e3fn_default(this.es);
    this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
  function forward18(p) {
    var lon = p.x;
    var lat = p.y;
    var x3, y3, el;
    var dlon = adjust_lon_default(lon - this.long0);
    el = dlon * Math.sin(lat);
    if (this.sphere) {
      if (Math.abs(lat) <= EPSLN) {
        x3 = this.a * dlon;
        y3 = -1 * this.a * this.lat0;
      } else {
        x3 = this.a * Math.sin(el) / Math.tan(lat);
        y3 = this.a * (adjust_lat_default(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
      }
    } else {
      if (Math.abs(lat) <= EPSLN) {
        x3 = this.a * dlon;
        y3 = -1 * this.ml0;
      } else {
        var nl = gN_default(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
        x3 = nl * Math.sin(el);
        y3 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
      }
    }
    p.x = x3 + this.x0;
    p.y = y3 + this.y0;
    return p;
  }
  function inverse18(p) {
    var lon, lat, x3, y3, i;
    var al, bl;
    var phi, dphi;
    x3 = p.x - this.x0;
    y3 = p.y - this.y0;
    if (this.sphere) {
      if (Math.abs(y3 + this.a * this.lat0) <= EPSLN) {
        lon = adjust_lon_default(x3 / this.a + this.long0);
        lat = 0;
      } else {
        al = this.lat0 + y3 / this.a;
        bl = x3 * x3 / this.a / this.a + al * al;
        phi = al;
        var tanphi;
        for (i = MAX_ITER3; i; --i) {
          tanphi = Math.tan(phi);
          dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
          phi += dphi;
          if (Math.abs(dphi) <= EPSLN) {
            lat = phi;
            break;
          }
        }
        lon = adjust_lon_default(this.long0 + Math.asin(x3 * Math.tan(phi) / this.a) / Math.sin(lat));
      }
    } else {
      if (Math.abs(y3 + this.ml0) <= EPSLN) {
        lat = 0;
        lon = adjust_lon_default(this.long0 + x3 / this.a);
      } else {
        al = (this.ml0 + y3) / this.a;
        bl = x3 * x3 / this.a / this.a + al * al;
        phi = al;
        var cl, mln, mlnp, ma;
        var con;
        for (i = MAX_ITER3; i; --i) {
          con = this.e * Math.sin(phi);
          cl = Math.sqrt(1 - con * con) * Math.tan(phi);
          mln = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
          mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
          ma = mln / this.a;
          dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
          phi -= dphi;
          if (Math.abs(dphi) <= EPSLN) {
            lat = phi;
            break;
          }
        }
        cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
        lon = adjust_lon_default(this.long0 + Math.asin(x3 * cl / this.a) / Math.sin(lat));
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names20 = ["Polyconic", "poly"];
  var poly_default = {
    init: init19,
    forward: forward18,
    inverse: inverse18,
    names: names20
  };

  // ../node_modules/proj4/lib/projections/nzmg.js
  function init20() {
    this.A = [];
    this.A[1] = 0.6399175073;
    this.A[2] = -0.1358797613;
    this.A[3] = 0.063294409;
    this.A[4] = -0.02526853;
    this.A[5] = 0.0117879;
    this.A[6] = -55161e-7;
    this.A[7] = 26906e-7;
    this.A[8] = -1333e-6;
    this.A[9] = 67e-5;
    this.A[10] = -34e-5;
    this.B_re = [];
    this.B_im = [];
    this.B_re[1] = 0.7557853228;
    this.B_im[1] = 0;
    this.B_re[2] = 0.249204646;
    this.B_im[2] = 3371507e-9;
    this.B_re[3] = -1541739e-9;
    this.B_im[3] = 0.04105856;
    this.B_re[4] = -0.10162907;
    this.B_im[4] = 0.01727609;
    this.B_re[5] = -0.26623489;
    this.B_im[5] = -0.36249218;
    this.B_re[6] = -0.6870983;
    this.B_im[6] = -1.1651967;
    this.C_re = [];
    this.C_im = [];
    this.C_re[1] = 1.3231270439;
    this.C_im[1] = 0;
    this.C_re[2] = -0.577245789;
    this.C_im[2] = -7809598e-9;
    this.C_re[3] = 0.508307513;
    this.C_im[3] = -0.112208952;
    this.C_re[4] = -0.15094762;
    this.C_im[4] = 0.18200602;
    this.C_re[5] = 1.01418179;
    this.C_im[5] = 1.64497696;
    this.C_re[6] = 1.9660549;
    this.C_im[6] = 2.5127645;
    this.D = [];
    this.D[1] = 1.5627014243;
    this.D[2] = 0.5185406398;
    this.D[3] = -0.03333098;
    this.D[4] = -0.1052906;
    this.D[5] = -0.0368594;
    this.D[6] = 7317e-6;
    this.D[7] = 0.0122;
    this.D[8] = 394e-5;
    this.D[9] = -13e-4;
  }
  function forward19(p) {
    var n;
    var lon = p.x;
    var lat = p.y;
    var delta_lat = lat - this.lat0;
    var delta_lon = lon - this.long0;
    var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
    var d_lambda = delta_lon;
    var d_phi_n = 1;
    var d_psi = 0;
    for (n = 1; n <= 10; n++) {
      d_phi_n = d_phi_n * d_phi;
      d_psi = d_psi + this.A[n] * d_phi_n;
    }
    var th_re = d_psi;
    var th_im = d_lambda;
    var th_n_re = 1;
    var th_n_im = 0;
    var th_n_re1;
    var th_n_im1;
    var z_re = 0;
    var z_im = 0;
    for (n = 1; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
      z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
    }
    p.x = z_im * this.a + this.x0;
    p.y = z_re * this.a + this.y0;
    return p;
  }
  function inverse19(p) {
    var n;
    var x3 = p.x;
    var y3 = p.y;
    var delta_x = x3 - this.x0;
    var delta_y = y3 - this.y0;
    var z_re = delta_y / this.a;
    var z_im = delta_x / this.a;
    var z_n_re = 1;
    var z_n_im = 0;
    var z_n_re1;
    var z_n_im1;
    var th_re = 0;
    var th_im = 0;
    for (n = 1; n <= 6; n++) {
      z_n_re1 = z_n_re * z_re - z_n_im * z_im;
      z_n_im1 = z_n_im * z_re + z_n_re * z_im;
      z_n_re = z_n_re1;
      z_n_im = z_n_im1;
      th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
      th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
    }
    for (var i = 0; i < this.iterations; i++) {
      var th_n_re = th_re;
      var th_n_im = th_im;
      var th_n_re1;
      var th_n_im1;
      var num_re = z_re;
      var num_im = z_im;
      for (n = 2; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
        num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
      }
      th_n_re = 1;
      th_n_im = 0;
      var den_re = this.B_re[1];
      var den_im = this.B_im[1];
      for (n = 2; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
        den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
      }
      var den2 = den_re * den_re + den_im * den_im;
      th_re = (num_re * den_re + num_im * den_im) / den2;
      th_im = (num_im * den_re - num_re * den_im) / den2;
    }
    var d_psi = th_re;
    var d_lambda = th_im;
    var d_psi_n = 1;
    var d_phi = 0;
    for (n = 1; n <= 9; n++) {
      d_psi_n = d_psi_n * d_psi;
      d_phi = d_phi + this.D[n] * d_psi_n;
    }
    var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
    var lon = this.long0 + d_lambda;
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names21 = ["New_Zealand_Map_Grid", "nzmg"];
  var nzmg_default = {
    init: init20,
    forward: forward19,
    inverse: inverse19,
    names: names21
  };

  // ../node_modules/proj4/lib/projections/mill.js
  function init21() {
  }
  function forward20(p) {
    var lon = p.x;
    var lat = p.y;
    var dlon = adjust_lon_default(lon - this.long0);
    var x3 = this.x0 + this.a * dlon;
    var y3 = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
    p.x = x3;
    p.y = y3;
    return p;
  }
  function inverse20(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon = adjust_lon_default(this.long0 + p.x / this.a);
    var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names22 = ["Miller_Cylindrical", "mill"];
  var mill_default = {
    init: init21,
    forward: forward20,
    inverse: inverse20,
    names: names22
  };

  // ../node_modules/proj4/lib/projections/sinu.js
  var MAX_ITER4 = 20;
  function init22() {
    if (!this.sphere) {
      this.en = pj_enfn_default(this.es);
    } else {
      this.n = 1;
      this.m = 0;
      this.es = 0;
      this.C_y = Math.sqrt((this.m + 1) / this.n);
      this.C_x = this.C_y / (this.m + 1);
    }
  }
  function forward21(p) {
    var x3, y3;
    var lon = p.x;
    var lat = p.y;
    lon = adjust_lon_default(lon - this.long0);
    if (this.sphere) {
      if (!this.m) {
        lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
      } else {
        var k = this.n * Math.sin(lat);
        for (var i = MAX_ITER4; i; --i) {
          var V2 = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
          lat -= V2;
          if (Math.abs(V2) < EPSLN) {
            break;
          }
        }
      }
      x3 = this.a * this.C_x * lon * (this.m + Math.cos(lat));
      y3 = this.a * this.C_y * lat;
    } else {
      var s = Math.sin(lat);
      var c = Math.cos(lat);
      y3 = this.a * pj_mlfn_default(lat, s, c, this.en);
      x3 = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
    }
    p.x = x3;
    p.y = y3;
    return p;
  }
  function inverse21(p) {
    var lat, temp2, lon, s;
    p.x -= this.x0;
    lon = p.x / this.a;
    p.y -= this.y0;
    lat = p.y / this.a;
    if (this.sphere) {
      lat /= this.C_y;
      lon = lon / (this.C_x * (this.m + Math.cos(lat)));
      if (this.m) {
        lat = asinz_default((this.m * lat + Math.sin(lat)) / this.n);
      } else if (this.n !== 1) {
        lat = asinz_default(Math.sin(lat) / this.n);
      }
      lon = adjust_lon_default(lon + this.long0);
      lat = adjust_lat_default(lat);
    } else {
      lat = pj_inv_mlfn_default(p.y / this.a, this.es, this.en);
      s = Math.abs(lat);
      if (s < HALF_PI) {
        s = Math.sin(lat);
        temp2 = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
        lon = adjust_lon_default(temp2);
      } else if (s - EPSLN < HALF_PI) {
        lon = this.long0;
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names23 = ["Sinusoidal", "sinu"];
  var sinu_default = {
    init: init22,
    forward: forward21,
    inverse: inverse21,
    names: names23
  };

  // ../node_modules/proj4/lib/projections/moll.js
  function init23() {
  }
  function forward22(p) {
    var lon = p.x;
    var lat = p.y;
    var delta_lon = adjust_lon_default(lon - this.long0);
    var theta = lat;
    var con = Math.PI * Math.sin(lat);
    while (true) {
      var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
      theta += delta_theta;
      if (Math.abs(delta_theta) < EPSLN) {
        break;
      }
    }
    theta /= 2;
    if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
      delta_lon = 0;
    }
    var x3 = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
    var y3 = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
    p.x = x3;
    p.y = y3;
    return p;
  }
  function inverse22(p) {
    var theta;
    var arg;
    p.x -= this.x0;
    p.y -= this.y0;
    arg = p.y / (1.4142135623731 * this.a);
    if (Math.abs(arg) > 0.999999999999) {
      arg = 0.999999999999;
    }
    theta = Math.asin(arg);
    var lon = adjust_lon_default(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));
    if (lon < -Math.PI) {
      lon = -Math.PI;
    }
    if (lon > Math.PI) {
      lon = Math.PI;
    }
    arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
    if (Math.abs(arg) > 1) {
      arg = 1;
    }
    var lat = Math.asin(arg);
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names24 = ["Mollweide", "moll"];
  var moll_default = {
    init: init23,
    forward: forward22,
    inverse: inverse22,
    names: names24
  };

  // ../node_modules/proj4/lib/projections/eqdc.js
  function init24() {
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    this.lat2 = this.lat2 || this.lat1;
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e = Math.sqrt(this.es);
    this.e0 = e0fn_default(this.es);
    this.e1 = e1fn_default(this.es);
    this.e2 = e2fn_default(this.es);
    this.e3 = e3fn_default(this.es);
    this.sinphi = Math.sin(this.lat1);
    this.cosphi = Math.cos(this.lat1);
    this.ms1 = msfnz_default(this.e, this.sinphi, this.cosphi);
    this.ml1 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat1);
    if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
      this.ns = this.sinphi;
    } else {
      this.sinphi = Math.sin(this.lat2);
      this.cosphi = Math.cos(this.lat2);
      this.ms2 = msfnz_default(this.e, this.sinphi, this.cosphi);
      this.ml2 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat2);
      this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
    }
    this.g = this.ml1 + this.ms1 / this.ns;
    this.ml0 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
    this.rh = this.a * (this.g - this.ml0);
  }
  function forward23(p) {
    var lon = p.x;
    var lat = p.y;
    var rh1;
    if (this.sphere) {
      rh1 = this.a * (this.g - lat);
    } else {
      var ml = mlfn_default(this.e0, this.e1, this.e2, this.e3, lat);
      rh1 = this.a * (this.g - ml);
    }
    var theta = this.ns * adjust_lon_default(lon - this.long0);
    var x3 = this.x0 + rh1 * Math.sin(theta);
    var y3 = this.y0 + this.rh - rh1 * Math.cos(theta);
    p.x = x3;
    p.y = y3;
    return p;
  }
  function inverse23(p) {
    p.x -= this.x0;
    p.y = this.rh - p.y + this.y0;
    var con, rh1, lat, lon;
    if (this.ns >= 0) {
      rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
      con = 1;
    } else {
      rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
      con = -1;
    }
    var theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * p.x, con * p.y);
    }
    if (this.sphere) {
      lon = adjust_lon_default(this.long0 + theta / this.ns);
      lat = adjust_lat_default(this.g - rh1 / this.a);
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      var ml = this.g - rh1 / this.a;
      lat = imlfn_default(ml, this.e0, this.e1, this.e2, this.e3);
      lon = adjust_lon_default(this.long0 + theta / this.ns);
      p.x = lon;
      p.y = lat;
      return p;
    }
  }
  var names25 = ["Equidistant_Conic", "eqdc"];
  var eqdc_default = {
    init: init24,
    forward: forward23,
    inverse: inverse23,
    names: names25
  };

  // ../node_modules/proj4/lib/projections/vandg.js
  function init25() {
    this.R = this.a;
  }
  function forward24(p) {
    var lon = p.x;
    var lat = p.y;
    var dlon = adjust_lon_default(lon - this.long0);
    var x3, y3;
    if (Math.abs(lat) <= EPSLN) {
      x3 = this.x0 + this.R * dlon;
      y3 = this.y0;
    }
    var theta = asinz_default(2 * Math.abs(lat / Math.PI));
    if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
      x3 = this.x0;
      if (lat >= 0) {
        y3 = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
      } else {
        y3 = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
      }
    }
    var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
    var asq = al * al;
    var sinth = Math.sin(theta);
    var costh = Math.cos(theta);
    var g = costh / (sinth + costh - 1);
    var gsq = g * g;
    var m = g * (2 / sinth - 1);
    var msq = m * m;
    var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
    if (dlon < 0) {
      con = -con;
    }
    x3 = this.x0 + con;
    var q = asq + g;
    con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
    if (lat >= 0) {
      y3 = this.y0 + con;
    } else {
      y3 = this.y0 - con;
    }
    p.x = x3;
    p.y = y3;
    return p;
  }
  function inverse24(p) {
    var lon, lat;
    var xx, yy, xys, c1, c2, c3;
    var a1;
    var m1;
    var con;
    var th1;
    var d;
    p.x -= this.x0;
    p.y -= this.y0;
    con = Math.PI * this.R;
    xx = p.x / con;
    yy = p.y / con;
    xys = xx * xx + yy * yy;
    c1 = -Math.abs(yy) * (1 + xys);
    c2 = c1 - 2 * yy * yy + xx * xx;
    c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
    d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
    a1 = (c1 - c2 * c2 / 3 / c3) / c3;
    m1 = 2 * Math.sqrt(-a1 / 3);
    con = 3 * d / a1 / m1;
    if (Math.abs(con) > 1) {
      if (con >= 0) {
        con = 1;
      } else {
        con = -1;
      }
    }
    th1 = Math.acos(con) / 3;
    if (p.y >= 0) {
      lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
    } else {
      lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
    }
    if (Math.abs(xx) < EPSLN) {
      lon = this.long0;
    } else {
      lon = adjust_lon_default(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names26 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
  var vandg_default = {
    init: init25,
    forward: forward24,
    inverse: inverse24,
    names: names26
  };

  // ../node_modules/proj4/lib/projections/aeqd.js
  function init26() {
    this.sin_p12 = Math.sin(this.lat0);
    this.cos_p12 = Math.cos(this.lat0);
  }
  function forward25(p) {
    var lon = p.x;
    var lat = p.y;
    var sinphi = Math.sin(p.y);
    var cosphi = Math.cos(p.y);
    var dlon = adjust_lon_default(lon - this.long0);
    var e0, e1, e22, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
    if (this.sphere) {
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
        p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
        return p;
      } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
        p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
        return p;
      } else {
        cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
        c = Math.acos(cos_c);
        kp = c ? c / Math.sin(c) : 1;
        p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
        p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
        return p;
      }
    } else {
      e0 = e0fn_default(this.es);
      e1 = e1fn_default(this.es);
      e22 = e2fn_default(this.es);
      e3 = e3fn_default(this.es);
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        Mlp = this.a * mlfn_default(e0, e1, e22, e3, HALF_PI);
        Ml = this.a * mlfn_default(e0, e1, e22, e3, lat);
        p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
        p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
        return p;
      } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        Mlp = this.a * mlfn_default(e0, e1, e22, e3, HALF_PI);
        Ml = this.a * mlfn_default(e0, e1, e22, e3, lat);
        p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
        p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
        return p;
      } else {
        tanphi = sinphi / cosphi;
        Nl1 = gN_default(this.a, this.e, this.sin_p12);
        Nl = gN_default(this.a, this.e, sinphi);
        psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
        Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
        if (Az === 0) {
          s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
        } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
          s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
        } else {
          s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
        }
        G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
        H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
        GH = G * H;
        Hs = H * H;
        s2 = s * s;
        s3 = s2 * s;
        s4 = s3 * s;
        s5 = s4 * s;
        c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
        p.x = this.x0 + c * Math.sin(Az);
        p.y = this.y0 + c * Math.cos(Az);
        return p;
      }
    }
  }
  function inverse25(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var rh, z2, sinz, cosz, lon, lat, con, e0, e1, e22, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A2, B2, D, Ee, F, sinpsi;
    if (this.sphere) {
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      if (rh > 2 * HALF_PI * this.a) {
        return;
      }
      z2 = rh / this.a;
      sinz = Math.sin(z2);
      cosz = Math.cos(z2);
      lon = this.long0;
      if (Math.abs(rh) <= EPSLN) {
        lat = this.lat0;
      } else {
        lat = asinz_default(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
        con = Math.abs(this.lat0) - HALF_PI;
        if (Math.abs(con) <= EPSLN) {
          if (this.lat0 >= 0) {
            lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -p.y));
          } else {
            lon = adjust_lon_default(this.long0 - Math.atan2(-p.x, p.y));
          }
        } else {
          lon = adjust_lon_default(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
        }
      }
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      e0 = e0fn_default(this.es);
      e1 = e1fn_default(this.es);
      e22 = e2fn_default(this.es);
      e3 = e3fn_default(this.es);
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        Mlp = this.a * mlfn_default(e0, e1, e22, e3, HALF_PI);
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        M = Mlp - rh;
        lat = imlfn_default(M / this.a, e0, e1, e22, e3);
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -1 * p.y));
        p.x = lon;
        p.y = lat;
        return p;
      } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        Mlp = this.a * mlfn_default(e0, e1, e22, e3, HALF_PI);
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        M = rh - Mlp;
        lat = imlfn_default(M / this.a, e0, e1, e22, e3);
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x, p.y));
        p.x = lon;
        p.y = lat;
        return p;
      } else {
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        Az = Math.atan2(p.x, p.y);
        N1 = gN_default(this.a, this.e, this.sin_p12);
        cosAz = Math.cos(Az);
        tmp = this.e * this.cos_p12 * cosAz;
        A2 = -tmp * tmp / (1 - this.es);
        B2 = 3 * this.es * (1 - A2) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
        D = rh / N1;
        Ee = D - A2 * (1 + A2) * Math.pow(D, 3) / 6 - B2 * (1 + 3 * A2) * Math.pow(D, 4) / 24;
        F = 1 - A2 * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
        psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
        lon = adjust_lon_default(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
        sinpsi = Math.sin(psi);
        lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
        p.x = lon;
        p.y = lat;
        return p;
      }
    }
  }
  var names27 = ["Azimuthal_Equidistant", "aeqd"];
  var aeqd_default = {
    init: init26,
    forward: forward25,
    inverse: inverse25,
    names: names27
  };

  // ../node_modules/proj4/lib/projections/ortho.js
  function init27() {
    this.sin_p14 = Math.sin(this.lat0);
    this.cos_p14 = Math.cos(this.lat0);
  }
  function forward26(p) {
    var sinphi, cosphi;
    var dlon;
    var coslon;
    var ksp;
    var g, x3, y3;
    var lon = p.x;
    var lat = p.y;
    dlon = adjust_lon_default(lon - this.long0);
    sinphi = Math.sin(lat);
    cosphi = Math.cos(lat);
    coslon = Math.cos(dlon);
    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
    ksp = 1;
    if (g > 0 || Math.abs(g) <= EPSLN) {
      x3 = this.a * ksp * cosphi * Math.sin(dlon);
      y3 = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
    }
    p.x = x3;
    p.y = y3;
    return p;
  }
  function inverse26(p) {
    var rh;
    var z2;
    var sinz, cosz;
    var con;
    var lon, lat;
    p.x -= this.x0;
    p.y -= this.y0;
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    z2 = asinz_default(rh / this.a);
    sinz = Math.sin(z2);
    cosz = Math.cos(z2);
    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = asinz_default(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
    con = Math.abs(this.lat0) - HALF_PI;
    if (Math.abs(con) <= EPSLN) {
      if (this.lat0 >= 0) {
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -p.y));
      } else {
        lon = adjust_lon_default(this.long0 - Math.atan2(-p.x, p.y));
      }
      p.x = lon;
      p.y = lat;
      return p;
    }
    lon = adjust_lon_default(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
    p.x = lon;
    p.y = lat;
    return p;
  }
  var names28 = ["ortho"];
  var ortho_default = {
    init: init27,
    forward: forward26,
    inverse: inverse26,
    names: names28
  };

  // ../node_modules/proj4/lib/projections/qsc.js
  var FACE_ENUM = {
    FRONT: 1,
    RIGHT: 2,
    BACK: 3,
    LEFT: 4,
    TOP: 5,
    BOTTOM: 6
  };
  var AREA_ENUM = {
    AREA_0: 1,
    AREA_1: 2,
    AREA_2: 3,
    AREA_3: 4
  };
  function init28() {
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.lat0 = this.lat0 || 0;
    this.long0 = this.long0 || 0;
    this.lat_ts = this.lat_ts || 0;
    this.title = this.title || "Quadrilateralized Spherical Cube";
    if (this.lat0 >= HALF_PI - FORTPI / 2) {
      this.face = FACE_ENUM.TOP;
    } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
      this.face = FACE_ENUM.BOTTOM;
    } else if (Math.abs(this.long0) <= FORTPI) {
      this.face = FACE_ENUM.FRONT;
    } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
      this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
    } else {
      this.face = FACE_ENUM.BACK;
    }
    if (this.es !== 0) {
      this.one_minus_f = 1 - (this.a - this.b) / this.a;
      this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
    }
  }
  function forward27(p) {
    var xy = { x: 0, y: 0 };
    var lat, lon;
    var theta, phi;
    var t, mu;
    var area2 = { value: 0 };
    p.x -= this.long0;
    if (this.es !== 0) {
      lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
    } else {
      lat = p.y;
    }
    lon = p.x;
    if (this.face === FACE_ENUM.TOP) {
      phi = HALF_PI - lat;
      if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
        area2.value = AREA_ENUM.AREA_0;
        theta = lon - HALF_PI;
      } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
        area2.value = AREA_ENUM.AREA_1;
        theta = lon > 0 ? lon - SPI : lon + SPI;
      } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
        area2.value = AREA_ENUM.AREA_2;
        theta = lon + HALF_PI;
      } else {
        area2.value = AREA_ENUM.AREA_3;
        theta = lon;
      }
    } else if (this.face === FACE_ENUM.BOTTOM) {
      phi = HALF_PI + lat;
      if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
        area2.value = AREA_ENUM.AREA_0;
        theta = -lon + HALF_PI;
      } else if (lon < FORTPI && lon >= -FORTPI) {
        area2.value = AREA_ENUM.AREA_1;
        theta = -lon;
      } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
        area2.value = AREA_ENUM.AREA_2;
        theta = -lon - HALF_PI;
      } else {
        area2.value = AREA_ENUM.AREA_3;
        theta = lon > 0 ? -lon + SPI : -lon - SPI;
      }
    } else {
      var q, r, s;
      var sinlat, coslat;
      var sinlon, coslon;
      if (this.face === FACE_ENUM.RIGHT) {
        lon = qsc_shift_lon_origin(lon, +HALF_PI);
      } else if (this.face === FACE_ENUM.BACK) {
        lon = qsc_shift_lon_origin(lon, +SPI);
      } else if (this.face === FACE_ENUM.LEFT) {
        lon = qsc_shift_lon_origin(lon, -HALF_PI);
      }
      sinlat = Math.sin(lat);
      coslat = Math.cos(lat);
      sinlon = Math.sin(lon);
      coslon = Math.cos(lon);
      q = coslat * coslon;
      r = coslat * sinlon;
      s = sinlat;
      if (this.face === FACE_ENUM.FRONT) {
        phi = Math.acos(q);
        theta = qsc_fwd_equat_face_theta(phi, s, r, area2);
      } else if (this.face === FACE_ENUM.RIGHT) {
        phi = Math.acos(r);
        theta = qsc_fwd_equat_face_theta(phi, s, -q, area2);
      } else if (this.face === FACE_ENUM.BACK) {
        phi = Math.acos(-q);
        theta = qsc_fwd_equat_face_theta(phi, s, -r, area2);
      } else if (this.face === FACE_ENUM.LEFT) {
        phi = Math.acos(-r);
        theta = qsc_fwd_equat_face_theta(phi, s, q, area2);
      } else {
        phi = theta = 0;
        area2.value = AREA_ENUM.AREA_0;
      }
    }
    mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
    t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
    if (area2.value === AREA_ENUM.AREA_1) {
      mu += HALF_PI;
    } else if (area2.value === AREA_ENUM.AREA_2) {
      mu += SPI;
    } else if (area2.value === AREA_ENUM.AREA_3) {
      mu += 1.5 * SPI;
    }
    xy.x = t * Math.cos(mu);
    xy.y = t * Math.sin(mu);
    xy.x = xy.x * this.a + this.x0;
    xy.y = xy.y * this.a + this.y0;
    p.x = xy.x;
    p.y = xy.y;
    return p;
  }
  function inverse27(p) {
    var lp = { lam: 0, phi: 0 };
    var mu, nu, cosmu, tannu;
    var tantheta, theta, cosphi, phi;
    var t;
    var area2 = { value: 0 };
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;
    nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
    mu = Math.atan2(p.y, p.x);
    if (p.x >= 0 && p.x >= Math.abs(p.y)) {
      area2.value = AREA_ENUM.AREA_0;
    } else if (p.y >= 0 && p.y >= Math.abs(p.x)) {
      area2.value = AREA_ENUM.AREA_1;
      mu -= HALF_PI;
    } else if (p.x < 0 && -p.x >= Math.abs(p.y)) {
      area2.value = AREA_ENUM.AREA_2;
      mu = mu < 0 ? mu + SPI : mu - SPI;
    } else {
      area2.value = AREA_ENUM.AREA_3;
      mu += HALF_PI;
    }
    t = SPI / 12 * Math.tan(mu);
    tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
    theta = Math.atan(tantheta);
    cosmu = Math.cos(mu);
    tannu = Math.tan(nu);
    cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
    if (cosphi < -1) {
      cosphi = -1;
    } else if (cosphi > 1) {
      cosphi = 1;
    }
    if (this.face === FACE_ENUM.TOP) {
      phi = Math.acos(cosphi);
      lp.phi = HALF_PI - phi;
      if (area2.value === AREA_ENUM.AREA_0) {
        lp.lam = theta + HALF_PI;
      } else if (area2.value === AREA_ENUM.AREA_1) {
        lp.lam = theta < 0 ? theta + SPI : theta - SPI;
      } else if (area2.value === AREA_ENUM.AREA_2) {
        lp.lam = theta - HALF_PI;
      } else {
        lp.lam = theta;
      }
    } else if (this.face === FACE_ENUM.BOTTOM) {
      phi = Math.acos(cosphi);
      lp.phi = phi - HALF_PI;
      if (area2.value === AREA_ENUM.AREA_0) {
        lp.lam = -theta + HALF_PI;
      } else if (area2.value === AREA_ENUM.AREA_1) {
        lp.lam = -theta;
      } else if (area2.value === AREA_ENUM.AREA_2) {
        lp.lam = -theta - HALF_PI;
      } else {
        lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
      }
    } else {
      var q, r, s;
      q = cosphi;
      t = q * q;
      if (t >= 1) {
        s = 0;
      } else {
        s = Math.sqrt(1 - t) * Math.sin(theta);
      }
      t += s * s;
      if (t >= 1) {
        r = 0;
      } else {
        r = Math.sqrt(1 - t);
      }
      if (area2.value === AREA_ENUM.AREA_1) {
        t = r;
        r = -s;
        s = t;
      } else if (area2.value === AREA_ENUM.AREA_2) {
        r = -r;
        s = -s;
      } else if (area2.value === AREA_ENUM.AREA_3) {
        t = r;
        r = s;
        s = -t;
      }
      if (this.face === FACE_ENUM.RIGHT) {
        t = q;
        q = -r;
        r = t;
      } else if (this.face === FACE_ENUM.BACK) {
        q = -q;
        r = -r;
      } else if (this.face === FACE_ENUM.LEFT) {
        t = q;
        q = r;
        r = -t;
      }
      lp.phi = Math.acos(-s) - HALF_PI;
      lp.lam = Math.atan2(r, q);
      if (this.face === FACE_ENUM.RIGHT) {
        lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
      } else if (this.face === FACE_ENUM.BACK) {
        lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
      } else if (this.face === FACE_ENUM.LEFT) {
        lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
      }
    }
    if (this.es !== 0) {
      var invert_sign;
      var tanphi, xa;
      invert_sign = lp.phi < 0 ? 1 : 0;
      tanphi = Math.tan(lp.phi);
      xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
      lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
      if (invert_sign) {
        lp.phi = -lp.phi;
      }
    }
    lp.lam += this.long0;
    p.x = lp.lam;
    p.y = lp.phi;
    return p;
  }
  function qsc_fwd_equat_face_theta(phi, y3, x3, area2) {
    var theta;
    if (phi < EPSLN) {
      area2.value = AREA_ENUM.AREA_0;
      theta = 0;
    } else {
      theta = Math.atan2(y3, x3);
      if (Math.abs(theta) <= FORTPI) {
        area2.value = AREA_ENUM.AREA_0;
      } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
        area2.value = AREA_ENUM.AREA_1;
        theta -= HALF_PI;
      } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
        area2.value = AREA_ENUM.AREA_2;
        theta = theta >= 0 ? theta - SPI : theta + SPI;
      } else {
        area2.value = AREA_ENUM.AREA_3;
        theta += HALF_PI;
      }
    }
    return theta;
  }
  function qsc_shift_lon_origin(lon, offset) {
    var slon = lon + offset;
    if (slon < -SPI) {
      slon += TWO_PI;
    } else if (slon > +SPI) {
      slon -= TWO_PI;
    }
    return slon;
  }
  var names29 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
  var qsc_default = {
    init: init28,
    forward: forward27,
    inverse: inverse27,
    names: names29
  };

  // ../node_modules/proj4/lib/projections/robin.js
  var COEFS_X = [
    [1, 22199e-21, -715515e-10, 31103e-10],
    [0.9986, -482243e-9, -24897e-9, -13309e-10],
    [0.9954, -83103e-8, -448605e-10, -986701e-12],
    [0.99, -135364e-8, -59661e-9, 36777e-10],
    [0.9822, -167442e-8, -449547e-11, -572411e-11],
    [0.973, -214868e-8, -903571e-10, 18736e-12],
    [0.96, -305085e-8, -900761e-10, 164917e-11],
    [0.9427, -382792e-8, -653386e-10, -26154e-10],
    [0.9216, -467746e-8, -10457e-8, 481243e-11],
    [0.8962, -536223e-8, -323831e-10, -543432e-11],
    [0.8679, -609363e-8, -113898e-9, 332484e-11],
    [0.835, -698325e-8, -640253e-10, 934959e-12],
    [0.7986, -755338e-8, -500009e-10, 935324e-12],
    [0.7597, -798324e-8, -35971e-9, -227626e-11],
    [0.7186, -851367e-8, -701149e-10, -86303e-10],
    [0.6732, -986209e-8, -199569e-9, 191974e-10],
    [0.6213, -0.010418, 883923e-10, 624051e-11],
    [0.5722, -906601e-8, 182e-6, 624051e-11],
    [0.5322, -677797e-8, 275608e-9, 624051e-11]
  ];
  var COEFS_Y = [
    [-520417e-23, 0.0124, 121431e-23, -845284e-16],
    [0.062, 0.0124, -126793e-14, 422642e-15],
    [0.124, 0.0124, 507171e-14, -160604e-14],
    [0.186, 0.0123999, -190189e-13, 600152e-14],
    [0.248, 0.0124002, 710039e-13, -224e-10],
    [0.31, 0.0123992, -264997e-12, 835986e-13],
    [0.372, 0.0124029, 988983e-12, -311994e-12],
    [0.434, 0.0123893, -369093e-11, -435621e-12],
    [0.4958, 0.0123198, -102252e-10, -345523e-12],
    [0.5571, 0.0121916, -154081e-10, -582288e-12],
    [0.6176, 0.0119938, -241424e-10, -525327e-12],
    [0.6769, 0.011713, -320223e-10, -516405e-12],
    [0.7346, 0.0113541, -397684e-10, -609052e-12],
    [0.7903, 0.0109107, -489042e-10, -104739e-11],
    [0.8435, 0.0103431, -64615e-9, -140374e-14],
    [0.8936, 969686e-8, -64636e-9, -8547e-9],
    [0.9394, 840947e-8, -192841e-9, -42106e-10],
    [0.9761, 616527e-8, -256e-6, -42106e-10],
    [1, 328947e-8, -319159e-9, -42106e-10]
  ];
  var FXC = 0.8487;
  var FYC = 1.3523;
  var C1 = R2D2 / 5;
  var RC1 = 1 / C1;
  var NODES = 18;
  var poly3_val = function(coefs, x3) {
    return coefs[0] + x3 * (coefs[1] + x3 * (coefs[2] + x3 * coefs[3]));
  };
  var poly3_der = function(coefs, x3) {
    return coefs[1] + x3 * (2 * coefs[2] + x3 * 3 * coefs[3]);
  };
  function newton_rapshon(f_df, start2, max_err, iters) {
    var x3 = start2;
    for (; iters; --iters) {
      var upd = f_df(x3);
      x3 -= upd;
      if (Math.abs(upd) < max_err) {
        break;
      }
    }
    return x3;
  }
  function init29() {
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.long0 = this.long0 || 0;
    this.es = 0;
    this.title = this.title || "Robinson";
  }
  function forward28(ll) {
    var lon = adjust_lon_default(ll.x - this.long0);
    var dphi = Math.abs(ll.y);
    var i = Math.floor(dphi * C1);
    if (i < 0) {
      i = 0;
    } else if (i >= NODES) {
      i = NODES - 1;
    }
    dphi = R2D2 * (dphi - RC1 * i);
    var xy = {
      x: poly3_val(COEFS_X[i], dphi) * lon,
      y: poly3_val(COEFS_Y[i], dphi)
    };
    if (ll.y < 0) {
      xy.y = -xy.y;
    }
    xy.x = xy.x * this.a * FXC + this.x0;
    xy.y = xy.y * this.a * FYC + this.y0;
    return xy;
  }
  function inverse28(xy) {
    var ll = {
      x: (xy.x - this.x0) / (this.a * FXC),
      y: Math.abs(xy.y - this.y0) / (this.a * FYC)
    };
    if (ll.y >= 1) {
      ll.x /= COEFS_X[NODES][0];
      ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
    } else {
      var i = Math.floor(ll.y * NODES);
      if (i < 0) {
        i = 0;
      } else if (i >= NODES) {
        i = NODES - 1;
      }
      for (; ; ) {
        if (COEFS_Y[i][0] > ll.y) {
          --i;
        } else if (COEFS_Y[i + 1][0] <= ll.y) {
          ++i;
        } else {
          break;
        }
      }
      var coefs = COEFS_Y[i];
      var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
      t = newton_rapshon(function(x3) {
        return (poly3_val(coefs, x3) - ll.y) / poly3_der(coefs, x3);
      }, t, EPSLN, 100);
      ll.x /= poly3_val(COEFS_X[i], t);
      ll.y = (5 * i + t) * D2R2;
      if (xy.y < 0) {
        ll.y = -ll.y;
      }
    }
    ll.x = adjust_lon_default(ll.x + this.long0);
    return ll;
  }
  var names30 = ["Robinson", "robin"];
  var robin_default = {
    init: init29,
    forward: forward28,
    inverse: inverse28,
    names: names30
  };

  // ../node_modules/proj4/lib/projections/geocent.js
  function init30() {
    this.name = "geocent";
  }
  function forward29(p) {
    var point2 = geodeticToGeocentric(p, this.es, this.a);
    return point2;
  }
  function inverse29(p) {
    var point2 = geocentricToGeodetic(p, this.es, this.a, this.b);
    return point2;
  }
  var names31 = ["Geocentric", "geocentric", "geocent", "Geocent"];
  var geocent_default = {
    init: init30,
    forward: forward29,
    inverse: inverse29,
    names: names31
  };

  // ../node_modules/proj4/lib/projections/tpers.js
  var mode = {
    N_POLE: 0,
    S_POLE: 1,
    EQUIT: 2,
    OBLIQ: 3
  };
  var params = {
    h: { def: 1e5, num: true },
    azi: { def: 0, num: true, degrees: true },
    tilt: { def: 0, num: true, degrees: true },
    long0: { def: 0, num: true },
    lat0: { def: 0, num: true }
  };
  function init31() {
    Object.keys(params).forEach(function(p) {
      if (typeof this[p] === "undefined") {
        this[p] = params[p].def;
      } else if (params[p].num && isNaN(this[p])) {
        throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
      } else if (params[p].num) {
        this[p] = parseFloat(this[p]);
      }
      if (params[p].degrees) {
        this[p] = this[p] * D2R2;
      }
    }.bind(this));
    if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
      this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
    } else if (Math.abs(this.lat0) < EPSLN) {
      this.mode = mode.EQUIT;
    } else {
      this.mode = mode.OBLIQ;
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
    this.pn1 = this.h / this.a;
    if (this.pn1 <= 0 || this.pn1 > 1e10) {
      throw new Error("Invalid height");
    }
    this.p = 1 + this.pn1;
    this.rp = 1 / this.p;
    this.h1 = 1 / this.pn1;
    this.pfact = (this.p + 1) * this.h1;
    this.es = 0;
    var omega = this.tilt;
    var gamma = this.azi;
    this.cg = Math.cos(gamma);
    this.sg = Math.sin(gamma);
    this.cw = Math.cos(omega);
    this.sw = Math.sin(omega);
  }
  function forward30(p) {
    p.x -= this.long0;
    var sinphi = Math.sin(p.y);
    var cosphi = Math.cos(p.y);
    var coslam = Math.cos(p.x);
    var x3, y3;
    switch (this.mode) {
      case mode.OBLIQ:
        y3 = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
        break;
      case mode.EQUIT:
        y3 = cosphi * coslam;
        break;
      case mode.S_POLE:
        y3 = -sinphi;
        break;
      case mode.N_POLE:
        y3 = sinphi;
        break;
    }
    y3 = this.pn1 / (this.p - y3);
    x3 = y3 * cosphi * Math.sin(p.x);
    switch (this.mode) {
      case mode.OBLIQ:
        y3 *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
        break;
      case mode.EQUIT:
        y3 *= sinphi;
        break;
      case mode.N_POLE:
        y3 *= -(cosphi * coslam);
        break;
      case mode.S_POLE:
        y3 *= cosphi * coslam;
        break;
    }
    var yt, ba;
    yt = y3 * this.cg + x3 * this.sg;
    ba = 1 / (yt * this.sw * this.h1 + this.cw);
    x3 = (x3 * this.cg - y3 * this.sg) * this.cw * ba;
    y3 = yt * ba;
    p.x = x3 * this.a;
    p.y = y3 * this.a;
    return p;
  }
  function inverse30(p) {
    p.x /= this.a;
    p.y /= this.a;
    var r = { x: p.x, y: p.y };
    var bm, bq, yt;
    yt = 1 / (this.pn1 - p.y * this.sw);
    bm = this.pn1 * p.x * yt;
    bq = this.pn1 * p.y * this.cw * yt;
    p.x = bm * this.cg + bq * this.sg;
    p.y = bq * this.cg - bm * this.sg;
    var rh = hypot_default(p.x, p.y);
    if (Math.abs(rh) < EPSLN) {
      r.x = 0;
      r.y = p.y;
    } else {
      var cosz, sinz;
      sinz = 1 - rh * rh * this.pfact;
      sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
      cosz = Math.sqrt(1 - sinz * sinz);
      switch (this.mode) {
        case mode.OBLIQ:
          r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
          p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
          p.x *= sinz * this.cosph0;
          break;
        case mode.EQUIT:
          r.y = Math.asin(p.y * sinz / rh);
          p.y = cosz * rh;
          p.x *= sinz;
          break;
        case mode.N_POLE:
          r.y = Math.asin(cosz);
          p.y = -p.y;
          break;
        case mode.S_POLE:
          r.y = -Math.asin(cosz);
          break;
      }
      r.x = Math.atan2(p.x, p.y);
    }
    p.x = r.x + this.long0;
    p.y = r.y;
    return p;
  }
  var names32 = ["Tilted_Perspective", "tpers"];
  var tpers_default = {
    init: init31,
    forward: forward30,
    inverse: inverse30,
    names: names32
  };

  // ../node_modules/proj4/lib/projections/geos.js
  function init32() {
    this.flip_axis = this.sweep === "x" ? 1 : 0;
    this.h = Number(this.h);
    this.radius_g_1 = this.h / this.a;
    if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
      throw new Error();
    }
    this.radius_g = 1 + this.radius_g_1;
    this.C = this.radius_g * this.radius_g - 1;
    if (this.es !== 0) {
      var one_es = 1 - this.es;
      var rone_es = 1 / one_es;
      this.radius_p = Math.sqrt(one_es);
      this.radius_p2 = one_es;
      this.radius_p_inv2 = rone_es;
      this.shape = "ellipse";
    } else {
      this.radius_p = 1;
      this.radius_p2 = 1;
      this.radius_p_inv2 = 1;
      this.shape = "sphere";
    }
    if (!this.title) {
      this.title = "Geostationary Satellite View";
    }
  }
  function forward31(p) {
    var lon = p.x;
    var lat = p.y;
    var tmp, v_x, v_y, v_z;
    lon = lon - this.long0;
    if (this.shape === "ellipse") {
      lat = Math.atan(this.radius_p2 * Math.tan(lat));
      var r = this.radius_p / hypot_default(this.radius_p * Math.cos(lat), Math.sin(lat));
      v_x = r * Math.cos(lon) * Math.cos(lat);
      v_y = r * Math.sin(lon) * Math.cos(lat);
      v_z = r * Math.sin(lat);
      if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0) {
        p.x = Number.NaN;
        p.y = Number.NaN;
        return p;
      }
      tmp = this.radius_g - v_x;
      if (this.flip_axis) {
        p.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
        p.y = this.radius_g_1 * Math.atan(v_z / tmp);
      } else {
        p.x = this.radius_g_1 * Math.atan(v_y / tmp);
        p.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
      }
    } else if (this.shape === "sphere") {
      tmp = Math.cos(lat);
      v_x = Math.cos(lon) * tmp;
      v_y = Math.sin(lon) * tmp;
      v_z = Math.sin(lat);
      tmp = this.radius_g - v_x;
      if (this.flip_axis) {
        p.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
        p.y = this.radius_g_1 * Math.atan(v_z / tmp);
      } else {
        p.x = this.radius_g_1 * Math.atan(v_y / tmp);
        p.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
      }
    }
    p.x = p.x * this.a;
    p.y = p.y * this.a;
    return p;
  }
  function inverse31(p) {
    var v_x = -1;
    var v_y = 0;
    var v_z = 0;
    var a2, b, det, k;
    p.x = p.x / this.a;
    p.y = p.y / this.a;
    if (this.shape === "ellipse") {
      if (this.flip_axis) {
        v_z = Math.tan(p.y / this.radius_g_1);
        v_y = Math.tan(p.x / this.radius_g_1) * hypot_default(1, v_z);
      } else {
        v_y = Math.tan(p.x / this.radius_g_1);
        v_z = Math.tan(p.y / this.radius_g_1) * hypot_default(1, v_y);
      }
      var v_zp = v_z / this.radius_p;
      a2 = v_y * v_y + v_zp * v_zp + v_x * v_x;
      b = 2 * this.radius_g * v_x;
      det = b * b - 4 * a2 * this.C;
      if (det < 0) {
        p.x = Number.NaN;
        p.y = Number.NaN;
        return p;
      }
      k = (-b - Math.sqrt(det)) / (2 * a2);
      v_x = this.radius_g + k * v_x;
      v_y *= k;
      v_z *= k;
      p.x = Math.atan2(v_y, v_x);
      p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
      p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
    } else if (this.shape === "sphere") {
      if (this.flip_axis) {
        v_z = Math.tan(p.y / this.radius_g_1);
        v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1 + v_z * v_z);
      } else {
        v_y = Math.tan(p.x / this.radius_g_1);
        v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1 + v_y * v_y);
      }
      a2 = v_y * v_y + v_z * v_z + v_x * v_x;
      b = 2 * this.radius_g * v_x;
      det = b * b - 4 * a2 * this.C;
      if (det < 0) {
        p.x = Number.NaN;
        p.y = Number.NaN;
        return p;
      }
      k = (-b - Math.sqrt(det)) / (2 * a2);
      v_x = this.radius_g + k * v_x;
      v_y *= k;
      v_z *= k;
      p.x = Math.atan2(v_y, v_x);
      p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
    }
    p.x = p.x + this.long0;
    return p;
  }
  var names33 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
  var geos_default = {
    init: init32,
    forward: forward31,
    inverse: inverse31,
    names: names33
  };

  // ../node_modules/proj4/projs.js
  function projs_default(proj42) {
    proj42.Proj.projections.add(tmerc_default);
    proj42.Proj.projections.add(etmerc_default);
    proj42.Proj.projections.add(utm_default);
    proj42.Proj.projections.add(sterea_default);
    proj42.Proj.projections.add(stere_default);
    proj42.Proj.projections.add(somerc_default);
    proj42.Proj.projections.add(omerc_default);
    proj42.Proj.projections.add(lcc_default);
    proj42.Proj.projections.add(krovak_default);
    proj42.Proj.projections.add(cass_default);
    proj42.Proj.projections.add(laea_default);
    proj42.Proj.projections.add(aea_default);
    proj42.Proj.projections.add(gnom_default);
    proj42.Proj.projections.add(cea_default);
    proj42.Proj.projections.add(eqc_default);
    proj42.Proj.projections.add(poly_default);
    proj42.Proj.projections.add(nzmg_default);
    proj42.Proj.projections.add(mill_default);
    proj42.Proj.projections.add(sinu_default);
    proj42.Proj.projections.add(moll_default);
    proj42.Proj.projections.add(eqdc_default);
    proj42.Proj.projections.add(vandg_default);
    proj42.Proj.projections.add(aeqd_default);
    proj42.Proj.projections.add(ortho_default);
    proj42.Proj.projections.add(qsc_default);
    proj42.Proj.projections.add(robin_default);
    proj42.Proj.projections.add(geocent_default);
    proj42.Proj.projections.add(tpers_default);
    proj42.Proj.projections.add(geos_default);
  }

  // ../node_modules/proj4/lib/index.js
  core_default.defaultDatum = "WGS84";
  core_default.Proj = Proj_default;
  core_default.WGS84 = new core_default.Proj("WGS84");
  core_default.Point = Point_default;
  core_default.toPoint = toPoint_default;
  core_default.defs = defs_default;
  core_default.nadgrid = nadgrid;
  core_default.transform = transform;
  core_default.mgrs = mgrs_default;
  core_default.version = "__VERSION__";
  projs_default(core_default);
  var lib_default = core_default;

  // Source/custom/const/CRS.js
  var CRS = {
    EPSG3857: "EPSG:3857",
    EPSG4326: "EPSG:4326",
    EPSG4490: "EPSG:4490",
    CGCS2000_GK_Zone_3: "CGCS2000_GK_Zone_3",
    CGCS2000_GK_Zone_6: "CGCS2000_GK_Zone_6",
    CGCS2000_GK_CM_3: "CGCS2000_GK_CM_3",
    CGCS2000_GK_CM_6: "CGCS2000_GK_CM_6"
  };
  var CRS_default = CRS;

  // Source/custom/utils/PointTrans.js
  var degree2dms = function(value) {
    value = Math.abs(value);
    let degree = Math.floor(value);
    let minute = Math.floor((value - degree) * 60);
    let second = Math.round((value - degree) * 3600 % 60);
    return {
      degree,
      minute,
      second,
      str: degree + "\xB0 " + minute + "'  " + second + '"'
    };
  };
  var dms2degree = function(degree, minute, second) {
    let ten = Math.abs(degree) + minute / 60 + second / 3600;
    return ten;
  };
  var getCGCS2000EPSGByLng = function(lng, fd6, hasAddDH = true) {
    let epsgID;
    if (fd6) {
      let n6 = parseInt(lng / 6) + 1;
      if (n6 < 13 || n6 > 23) {
        return void 0;
      }
      if (hasAddDH) {
        epsgID = n6 + 4478;
      } else {
        epsgID = n6 + 4489;
      }
    } else {
      let n3 = parseInt((lng - 1.5) / 3) + 1;
      if (n3 < 25 || n3 > 45) {
        return void 0;
      }
      if (hasAddDH) {
        epsgID = n3 + 4488;
      } else {
        epsgID = n3 + 4509;
      }
    }
    return "EPSG:" + epsgID;
  };
  var getCGCS2000EPSGByX = function(x3) {
    let dh = parseInt(x3.toString().slice(0, 2));
    if (dh >= 13 && dh <= 23) {
      return "EPSG:" + (dh + 4478);
    } else if (dh >= 25 && dh <= 45) {
      return "EPSG:" + (dh + 4488);
    } else {
      return void 0;
    }
  };
  var proj4Trans = function(arrdata, fromProjParams, toProjParams = "EPSG:4326") {
    if (!fromProjParams || !toProjParams || fromProjParams == toProjParams) {
      return arrdata;
    }
    try {
      if (fromProjParams == CRS_default.CGCS2000_GK_Zone_3 || fromProjParams == CRS_default.CGCS2000_GK_Zone_6) {
        fromProjParams = getCGCS2000EPSGByX(arrdata[0]);
      }
      if (toProjParams == CRS_default.CGCS2000_GK_Zone_3) {
        toProjParams = getCGCS2000EPSGByLng(arrdata[0], false, true);
      } else if (toProjParams == CRS_default.CGCS2000_GK_Zone_6) {
        toProjParams = getCGCS2000EPSGByLng(arrdata[0], true, true);
      } else if (toProjParams == CRS_default.CGCS2000_GK_CM_3) {
        toProjParams = getCGCS2000EPSGByLng(arrdata[0], false, false);
      } else if (toProjParams == CRS_default.CGCS2000_GK_CM_6) {
        toProjParams = getCGCS2000EPSGByLng(arrdata[0], true, false);
      }
      if (!fromProjParams || !toProjParams || fromProjParams == toProjParams) {
        return arrdata;
      }
      let arr2 = lib_default(fromProjParams, toProjParams, arrdata);
      if (Cesium.defined(arr2) && arr2.length > 1 && !isNaN(arr2[0]) && arr2[0] != Infinity) {
        return arr2;
      }
    } catch (e) {
    }
    return arrdata;
  };
  var proj4TransArr = function(coords, fromProjParams, toProjParams = "EPSG:4326") {
    if (!fromProjParams || fromProjParams == toProjParams) {
      return coords;
    }
    let arr2 = [];
    for (let i = 0, len = coords.length; i < len; i++) {
      let item = coords[i];
      if (Array.isArray(item[0])) {
        let arr22 = proj4TransArr(item, fromProjParams, toProjParams);
        if (arr22 && arr22.length > 0) {
          arr2.push(arr22);
        }
      } else {
        let arr22 = proj4Trans(item, fromProjParams, toProjParams);
        if (arr22) {
          arr2.push(arr22);
        }
      }
    }
    return arr2;
  };
  var cartesian2lonlat = function(cartesian2, noAlt) {
    let carto = Cesium.Cartographic.fromCartesian(cartesian2);
    if (carto == null) {
      return null;
    }
    let x3 = formatNum(Cesium.Math.toDegrees(carto.longitude), LatLngPoint_default.FormatLength);
    let y3 = formatNum(Cesium.Math.toDegrees(carto.latitude), LatLngPoint_default.FormatLength);
    if (noAlt) {
      return [x3, y3];
    } else {
      let z2 = formatNum(carto.height, LatLngPoint_default.FormatAltLength);
      return [x3, y3, z2];
    }
  };
  var cartesians2lonlats = function(positions, noAlt) {
    let coordinates = [];
    for (let i = 0, len = positions.length; i < len; i++) {
      let point2 = cartesian2lonlat(positions[i], noAlt);
      if (point2) {
        coordinates.push(point2);
      }
    }
    return coordinates;
  };
  var cartesian2mercator = function(position) {
    if (!position) {
      return null;
    }
    let lonlat = cartesian2lonlat(position);
    return lonlat2mercator(lonlat);
  };
  var cartesians2mercators = function(positions) {
    let arrNew = [];
    for (let i = 0, len = positions.length; i < len; i++) {
      let point2 = cartesian2mercator(positions[i]);
      if (point2) {
        arrNew.push(point2);
      }
    }
    return arrNew;
  };
  var lonlat2cartesian = function(coord, defHeight = 0) {
    if (!coord || coord.length < 2) {
      return null;
    }
    return Cesium.Cartesian3.fromDegrees(coord[0], coord[1], coord[2] || defHeight);
  };
  var lonlats2cartesians = function(coords, defHeight) {
    let arr2 = [];
    for (let i = 0, len = coords.length; i < len; i++) {
      let item = coords[i];
      if (Array.isArray(item[0])) {
        let arr22 = lonlats2cartesians(item, defHeight);
        if (arr22 && arr22.length > 0) {
          arr2.push(arr22);
        }
      } else {
        let cartesian2 = lonlat2cartesian(item, defHeight);
        if (cartesian2) {
          arr2.push(cartesian2);
        }
      }
    }
    return arr2;
  };
  var lonlat2mercator = function(lnglat) {
    return jwd2mct(lnglat);
  };
  var lonlats2mercators = function(arr2) {
    let arrNew = [];
    for (let i = 0, len = arr2.length; i < len; i++) {
      let point2 = lonlat2mercator(arr2[i]);
      arrNew.push(point2);
    }
    return arrNew;
  };
  var mercator2cartesian = function(point2, height) {
    if (isNaN(point2[0]) || isNaN(point2[1])) {
      return null;
    }
    let lonlat = mercator2lonlat(point2);
    if (Cesium.defined(height)) {
      lonlat[2] = height;
    }
    return lonlat2cartesian(lonlat);
  };
  var mercators2cartesians = function(arr2, height) {
    let arrNew = [];
    for (let i = 0, len = arr2.length; i < len; i++) {
      let point2 = mercator2cartesian(arr2[i], height);
      if (point2) {
        arrNew.push(point2);
      }
    }
    return arrNew;
  };
  var mercator2lonlat = function(point2) {
    return mct2jwd(point2);
  };
  var mercators2lonlats = function(arr2) {
    let arrNew = [];
    for (let i = 0, len = arr2.length; i < len; i++) {
      let point2 = mercator2lonlat(arr2[i]);
      arrNew.push(point2);
    }
    return arrNew;
  };
  function formatNum(num, digits) {
    return Number(num).toFixed(digits || 0);
  }
  var x_PI = 3.141592653589793 * 3e3 / 180;
  var PI = 3.141592653589793;
  var a = 6378245;
  var ee = 0.006693421622965943;
  function transformlat(lng, lat) {
    let ret = -100 + 2 * lng + 3 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));
    ret += (20 * Math.sin(6 * lng * PI) + 20 * Math.sin(2 * lng * PI)) * 2 / 3;
    ret += (20 * Math.sin(lat * PI) + 40 * Math.sin(lat / 3 * PI)) * 2 / 3;
    ret += (160 * Math.sin(lat / 12 * PI) + 320 * Math.sin(lat * PI / 30)) * 2 / 3;
    return ret;
  }
  function transformlng(lng, lat) {
    let ret = 300 + lng + 2 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));
    ret += (20 * Math.sin(6 * lng * PI) + 20 * Math.sin(2 * lng * PI)) * 2 / 3;
    ret += (20 * Math.sin(lng * PI) + 40 * Math.sin(lng / 3 * PI)) * 2 / 3;
    ret += (150 * Math.sin(lng / 12 * PI) + 300 * Math.sin(lng / 30 * PI)) * 2 / 3;
    return ret;
  }
  function out_of_china(lng, lat) {
    return lng < 72.004 || lng > 137.8347 || lat < 0.8293 || lat > 55.8271 || false;
  }
  var bd2gcj = function(arrdata) {
    let bd_lon = Number(arrdata[0]);
    let bd_lat = Number(arrdata[1]);
    let x_pi = 3.141592653589793 * 3e3 / 180;
    let x3 = bd_lon - 65e-4;
    let y3 = bd_lat - 6e-3;
    let z2 = Math.sqrt(x3 * x3 + y3 * y3) - 2e-5 * Math.sin(y3 * x_pi);
    let theta = Math.atan2(y3, x3) - 3e-6 * Math.cos(x3 * x_pi);
    let gg_lng = z2 * Math.cos(theta);
    let gg_lat = z2 * Math.sin(theta);
    gg_lng = Number(gg_lng).toFixed(6);
    gg_lat = Number(gg_lat).toFixed(6);
    return [gg_lng, gg_lat];
  };
  var gcj2bd = function(arrdata) {
    let lng = Number(arrdata[0]);
    let lat = Number(arrdata[1]);
    let z2 = Math.sqrt(lng * lng + lat * lat) + 2e-5 * Math.sin(lat * x_PI);
    let theta = Math.atan2(lat, lng) + 3e-6 * Math.cos(lng * x_PI);
    let bd_lng = z2 * Math.cos(theta) + 65e-4;
    let bd_lat = z2 * Math.sin(theta) + 6e-3;
    bd_lng = Number(bd_lng).toFixed(6);
    bd_lat = Number(bd_lat).toFixed(6);
    return [bd_lng, bd_lat];
  };
  var wgs2gcj = function(arrdata) {
    let lng = Number(arrdata[0]);
    let lat = Number(arrdata[1]);
    if (out_of_china(lng, lat)) {
      return [lng, lat];
    } else {
      let dlat = transformlat(lng - 105, lat - 35);
      let dlng = transformlng(lng - 105, lat - 35);
      let radlat = lat / 180 * PI;
      let magic = Math.sin(radlat);
      magic = 1 - ee * magic * magic;
      let sqrtmagic = Math.sqrt(magic);
      dlat = dlat * 180 / (a * (1 - ee) / (magic * sqrtmagic) * PI);
      dlng = dlng * 180 / (a / sqrtmagic * Math.cos(radlat) * PI);
      let mglat = lat + dlat;
      let mglng = lng + dlng;
      mglng = Number(mglng).toFixed(6);
      mglat = Number(mglat).toFixed(6);
      return [mglng, mglat];
    }
  };
  var gcj2wgs = function(arrdata) {
    let lng = Number(arrdata[0]);
    let lat = Number(arrdata[1]);
    if (out_of_china(lng, lat)) {
      return [lng, lat];
    } else {
      let dlat = transformlat(lng - 105, lat - 35);
      let dlng = transformlng(lng - 105, lat - 35);
      let radlat = lat / 180 * PI;
      let magic = Math.sin(radlat);
      magic = 1 - ee * magic * magic;
      let sqrtmagic = Math.sqrt(magic);
      dlat = dlat * 180 / (a * (1 - ee) / (magic * sqrtmagic) * PI);
      dlng = dlng * 180 / (a / sqrtmagic * Math.cos(radlat) * PI);
      let mglat = lat + dlat;
      let mglng = lng + dlng;
      let jd = lng * 2 - mglng;
      let wd = lat * 2 - mglat;
      jd = Number(jd).toFixed(6);
      wd = Number(wd).toFixed(6);
      return [jd, wd];
    }
  };
  var bd2wgs = function(arrdata) {
    return gcj2wgs(bd2gcj(arrdata));
  };
  var wgs2bd = function(arrdata) {
    return gcj2bd(wgs2gcj(arrdata));
  };
  var jwd2mct = function(arrdata) {
    let lng = Number(arrdata[0]);
    let lat = Number(arrdata[1]);
    let x3 = lng * 2003750834e-2 / 180;
    let y3 = Math.log(Math.tan((90 + lat) * PI / 360)) / (PI / 180);
    y3 = y3 * 2003750834e-2 / 180;
    x3 = Number(x3).toFixed(2);
    y3 = Number(y3).toFixed(2);
    return [x3, y3, arrdata[2] || 0];
  };
  var mct2jwd = function(arrdata) {
    let lng = Number(arrdata[0]);
    let lat = Number(arrdata[1]);
    let x3 = lng / 2003750834e-2 * 180;
    let y3 = lat / 2003750834e-2 * 180;
    y3 = 180 / PI * (2 * Math.atan(Math.exp(y3 * PI / 180)) - PI / 2);
    x3 = Number(x3).toFixed(6);
    y3 = Number(y3).toFixed(6);
    return [x3, y3, arrdata[2] || 0];
  };
  var PointTrans_default = {
    degree2dms,
    dms2degree,
    getCGCS2000EPSGByLng,
    getCGCS2000EPSGByX,
    proj4Trans,
    proj4TransArr,
    cartesian2lonlat,
    cartesians2lonlats,
    cartesian2mercator,
    cartesians2mercators,
    lonlat2cartesian,
    lonlats2cartesians,
    lonlat2mercator,
    lonlats2mercators,
    mercator2cartesian,
    mercators2cartesians,
    mercator2lonlat,
    mercators2lonlats,
    bd2gcj,
    gcj2bd,
    wgs2gcj,
    gcj2wgs,
    bd2wgs,
    wgs2bd,
    jwd2mct,
    mct2jwd
  };

  // Source/custom/utils/LatLngArray.js
  var LatLngArray = class {
    static toCartesians(value) {
      if (!Array.isArray(value)) {
        return value;
      }
      let _positions = [];
      value.forEach(function(item) {
        if (item instanceof Cesium.Cartesian3) {
          _positions.push(item);
          return;
        }
        let _point = LatLngPoint_default.parse(item);
        if (!_point) {
          return;
        }
        _positions.push(_point.toCartesian(true));
      });
      return _positions;
    }
    static toPoints(value) {
      if (!Array.isArray(value)) {
        return value;
      }
      let _points = [];
      value.forEach(function(item) {
        if (item instanceof LatLngPoint_default) {
          _points.push(item);
          return;
        }
        let _point = LatLngPoint_default.parse(item);
        if (!_point) {
          return;
        }
        _points.push(_point);
      });
      return _points;
    }
    static toArray(value, noAlt) {
      if (!Array.isArray(value)) {
        return value;
      }
      let _points = [];
      value.forEach(function(item) {
        if (Array.isArray(item)) {
          _points.push(item);
          return;
        }
        let _point = LatLngPoint_default.parse(item);
        if (!_point) {
          return;
        }
        _points.push(_point.toArray(noAlt));
      });
      return _points;
    }
  };
  var LatLngArray_default = LatLngArray;

  // Source/custom/utils/Poly.js
  var cartesians2lonlats2 = PointTrans_default.cartesians2lonlats;
  var lonlats2cartesians2 = PointTrans_default.lonlats2cartesians;
  var getMaxHeight2 = PointUtil_default.getMaxHeight;
  var getOnLinePointByLen2 = PointUtil_default.getOnLinePointByLen;
  var getSurfaceHeight2 = PointUtil_default.getSurfaceHeight;
  var setPositionsHeight2 = PointUtil_default.setPositionsHeight;
  var buffer3 = function(geojson, width, steps) {
    try {
      if (!es_default32) {
        throw new Error("turf\u4E0D\u5B58\u5728");
      }
    } catch (e) {
      console.log("buffer\uFF1A\u8BE5\u65B9\u6CD5\u4F9D\u8D56turf\u5E93\uFF0C\u8BF7\u5F15\u5165\u8BE5\u5E93\u3002", e);
      return geojson;
    }
    try {
      width = Cesium.defaultValue(width, 1);
      if (geojson?.geometry?.type == "Polygon") {
        geojson.geometry.coordinates[0].push(geojson.geometry.coordinates[0][0]);
      }
      geojson = es_default32(geojson, width, { units: "meters", steps: steps || 8 });
    } catch (e) {
      console.log("PolyUtil buffer:\u7F13\u51B2\u5206\u6790\u5F02\u5E38", e);
    }
    return geojson;
  };
  var bufferPoints = function(points, width, steps) {
    try {
      width = Cesium.defaultValue(width, 1);
      let coordinates = LatLngArray_default.toArray(points);
      if (coordinates[0][0] != coordinates[coordinates.length - 1][0] && coordinates[0][1] != coordinates[coordinates.length - 1][1]) {
        coordinates.push(coordinates[0]);
      }
      let polygon2 = {
        type: "Feature",
        geometry: { type: "Polygon", coordinates: [coordinates] }
      };
      let geojson = es_default32(polygon2, width, { units: "meters", steps: steps || 8 });
      return LatLngArray_default.toPoints(geojson.geometry.coordinates[0]);
    } catch (e) {
      console.log("PolyUtil buffer:\u7F13\u51B2\u5206\u6790\u5F02\u5E38", e);
    }
    return points;
  };
  var getGranularity = function(positions, splitNum = 10) {
    let recta = Cesium.Rectangle.fromCartesianArray(positions);
    let granularity = Math.max(recta.height, recta.width);
    granularity /= splitNum;
    return granularity;
  };
  var interPolygon = function(options) {
    let scene = options.scene;
    let positions = [];
    let pos = options.positions;
    for (let i = 0; i < pos.length; i++) {
      positions.push(pos[i].clone());
    }
    let granularity = getGranularity(positions, options.splitNum);
    let arrPoly = [];
    let polygonGeometry = new Cesium.PolygonGeometry.fromPositions({
      positions,
      vertexFormat: Cesium.PerInstanceColorAppearance.FLAT_VERTEX_FORMAT,
      granularity
    });
    let geom = new Cesium.PolygonGeometry.createGeometry(polygonGeometry);
    let i0, i1, i2;
    let cartesian1, cartesian2, cartesian3;
    for (let i = 0; i < geom.indices.length; i += 3) {
      i0 = geom.indices[i];
      i1 = geom.indices[i + 1];
      i2 = geom.indices[i + 2];
      cartesian1 = new Cesium.Cartesian3(
        geom.attributes.position.values[i0 * 3],
        geom.attributes.position.values[i0 * 3 + 1],
        geom.attributes.position.values[i0 * 3 + 2]
      );
      arrPoly.push(cartesian1);
      cartesian2 = new Cesium.Cartesian3(
        geom.attributes.position.values[i1 * 3],
        geom.attributes.position.values[i1 * 3 + 1],
        geom.attributes.position.values[i1 * 3 + 2]
      );
      arrPoly.push(cartesian2);
      cartesian3 = new Cesium.Cartesian3(
        geom.attributes.position.values[i2 * 3],
        geom.attributes.position.values[i2 * 3 + 1],
        geom.attributes.position.values[i2 * 3 + 2]
      );
      arrPoly.push(cartesian3);
    }
    let maxHeight = 0;
    let minHeight = 9999;
    let onlyPoint = Cesium.defaultValue(options.onlyPoint, false);
    function onFormatPoint(position, noHeight) {
      let height;
      let point2;
      let pointDM;
      let carto;
      if (noHeight) {
        delete options.callback;
        height = getSurfaceHeight2(scene, position, options);
        carto = Cesium.Cartographic.fromCartesian(position);
        point2 = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0);
        pointDM = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, height);
      } else {
        carto = Cesium.Cartographic.fromCartesian(position);
        height = carto.height;
        point2 = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0);
        pointDM = position;
      }
      if (maxHeight < height) {
        maxHeight = height;
      }
      if (minHeight > height) {
        minHeight = height;
      }
      return {
        height,
        point: point2,
        pointDM
      };
    }
    function interCallback(raisedPositions, noHeight) {
      let arrSJW = [];
      let obj1, obj2, obj3;
      for (let i = 0; i < raisedPositions.length; i += 3) {
        obj1 = onFormatPoint(raisedPositions[i], noHeight);
        obj2 = onFormatPoint(raisedPositions[i + 1], noHeight);
        obj3 = onFormatPoint(raisedPositions[i + 2], noHeight);
        if (onlyPoint) {
          addPointFoyArrOnly(arrSJW, obj1);
          addPointFoyArrOnly(arrSJW, obj2);
          addPointFoyArrOnly(arrSJW, obj3);
        } else {
          arrSJW.push({
            point1: obj1,
            point2: obj2,
            point3: obj3
          });
        }
      }
      if (Cesium.defined(options.minHeight)) {
        minHeight = Math.max(options.minHeight, minHeight);
        maxHeight = Math.max(maxHeight, minHeight);
      }
      let result = {
        granularity,
        maxHeight,
        minHeight,
        list: arrSJW
      };
      let callback = options.callback;
      if (callback) {
        callback(result);
      }
      return result;
    }
    if (options.asyn) {
      return computeSurfacePoints({
        scene,
        positions: arrPoly,
        has3dtiles: options.has3dtiles,
        callback: interCallback
      });
    } else {
      return interCallback(arrPoly, true);
    }
  };
  function addPointFoyArrOnly(arr2, newItem) {
    let isIn = false;
    let point2 = newItem.point;
    for (let z2 = 0; z2 < arr2.length; z2++) {
      let item = arr2[z2].point;
      if (point2.x == item.x && point2.y == item.y && point2.z == item.z) {
        isIn = true;
        break;
      }
    }
    if (!isIn) {
      arr2.push(newItem);
    }
  }
  var getHeightRange = function(positions, scene, options) {
    let resultInter = interPolygon({
      positions,
      scene,
      ...options
    });
    return {
      has3dtiles: resultInter._has3dtiles,
      maxHeight: resultInter.maxHeight,
      minHeight: resultInter.minHeight
    };
  };
  function getTriangleArea(pos1, pos2, pos3) {
    let a2 = Cesium.Cartesian3.distance(pos1, pos2);
    let b = Cesium.Cartesian3.distance(pos2, pos3);
    let c = Cesium.Cartesian3.distance(pos3, pos1);
    let S = (a2 + b + c) / 2;
    return Math.sqrt(S * (S - a2) * (S - b) * (S - c));
  }
  var computeVolume = function(options) {
    let resultInter = interPolygon(options);
    if (resultInter) {
      resultInter = updateVolumeByMinHeight(resultInter);
    }
    return resultInter;
  };
  var updateVolumeByMinHeight = function(resultInter) {
    let minHeight = resultInter.minHeight;
    let totalArea = 0;
    let totalVolume = 0;
    for (let i = 0, len = resultInter.list.length; i < len; i++) {
      let item = resultInter.list[i];
      let pt1 = item.point1;
      let pt2 = item.point2;
      let pt3 = item.point3;
      let bottomArea = getTriangleArea(pt1.point, pt2.point, pt3.point);
      item.area = bottomArea;
      totalArea += bottomArea;
      let height1 = pt1.height;
      let height2 = pt2.height;
      let height3 = pt3.height;
      if (height1 < minHeight) {
        height1 = minHeight;
      }
      if (height2 < minHeight) {
        height2 = minHeight;
      }
      if (height3 < minHeight) {
        height3 = minHeight;
      }
      let cutVolume = bottomArea * (height1 - minHeight + height2 - minHeight + height3 - minHeight) / 3;
      item.cutVolume = cutVolume;
      totalVolume = totalVolume + cutVolume;
    }
    resultInter.totalArea = totalArea;
    resultInter.totalVolume = totalVolume;
    return resultInter;
  };
  var updateVolume = function(resultInter, cutHeight) {
    if (!resultInter) {
      return;
    }
    let minHeight = resultInter.minHeight;
    let totalVolume = resultInter.totalVolume;
    if (cutHeight <= minHeight) {
      resultInter.fillVolume = 0;
      resultInter.digVolume = totalVolume;
      return resultInter;
    }
    let totalV = 0;
    let totalBottomV = 0;
    for (let i = 0, len = resultInter.list.length; i < len; i++) {
      let item = resultInter.list[i];
      totalV += item.area * (cutHeight - minHeight);
      let pt1 = item.point1;
      let pt2 = item.point2;
      let pt3 = item.point3;
      let height1 = pt1.height;
      let height2 = pt2.height;
      let height3 = pt3.height;
      if (height1 < cutHeight) {
        height1 = cutHeight;
      }
      if (height2 < cutHeight) {
        height2 = cutHeight;
      }
      if (height3 < cutHeight) {
        height3 = cutHeight;
      }
      totalBottomV += item.area * (height1 - cutHeight + height2 - cutHeight + height3 - cutHeight) / 3;
    }
    resultInter.digVolume = totalBottomV;
    resultInter.fillVolume = totalV - (totalVolume - totalBottomV);
    return resultInter;
  };
  var getEllipseOuterPositions = function(options) {
    let position = options.position;
    if (!position) {
      return null;
    }
    position = LatLngPoint_default.parseCartesian3(position);
    let count = Cesium.defaultValue(options.count, 1);
    let semiMajorAxis = Cesium.defaultValue(options.semiMajorAxis, options.radius);
    let semiMinorAxis = Cesium.defaultValue(options.semiMinorAxis, options.radius);
    let rotation = Cesium.defaultValue(options.rotation, 0);
    if (!semiMajorAxis || !semiMinorAxis) {
      return [position, position, position];
    }
    let cep = Cesium.EllipseGeometryLibrary.computeEllipsePositions(
      {
        center: position,
        semiMajorAxis,
        semiMinorAxis,
        rotation,
        granularity: Math.PI / (16 * count)
      },
      true,
      true
    );
    let arr2 = cep.outerPositions;
    let positions = [];
    for (let i = 0, len = arr2.length; i < len; i += 3) {
      let pt = new Cesium.Cartesian3(arr2[i], arr2[i + 1], arr2[i + 2]);
      positions.push(pt);
    }
    return positions;
  };
  var formatRectangle = function(rectangle, digits = LatLngPoint_default.FormatLength) {
    let west = Cesium.Math.toDegrees(rectangle.west).toFixed(digits);
    let east = Cesium.Math.toDegrees(rectangle.east).toFixed(digits);
    let north = Cesium.Math.toDegrees(rectangle.north).toFixed(digits);
    let south = Cesium.Math.toDegrees(rectangle.south).toFixed(digits);
    if (west > east) {
      let temp2 = west;
      west = east;
      east = temp2;
    }
    if (south > north) {
      let temp2 = south;
      south = north;
      north = temp2;
    }
    return {
      xmin: west,
      xmax: east,
      ymin: south,
      ymax: north
    };
  };
  var getRectangle = function(positions, isFormat) {
    if (!positions) {
      return null;
    }
    for (let i = positions.length - 1; i >= 0; i--) {
      if (!Cesium.defined(positions[i])) {
        positions.splice(i, 1);
      }
    }
    positions = LatLngArray_default.toCartesians(positions);
    let rectangle = Cesium.Rectangle.fromCartesianArray(positions);
    if (isFormat) {
      return formatRectangle(rectangle);
    } else {
      return rectangle;
    }
  };
  var getPositionsRectVertex = function(positions, rotation = 0) {
    let rectangle = Cesium.Rectangle.fromCartesianArray(positions);
    let height = getMaxHeight2(positions);
    let arr2 = getRectangleOuterPositions({
      rectangle,
      rotation,
      height
    });
    return arr2;
  };
  var getRectangleOuterPositions = function(options) {
    let rectangle = options.rectangle;
    let rotation = Cesium.defaultValue(options.rotation, 0);
    let height = Cesium.defaultValue(options.height, 0);
    if (rotation == 0) {
      return [
        Cesium.Cartesian3.fromRadians(rectangle.west, rectangle.south, height),
        Cesium.Cartesian3.fromRadians(rectangle.east, rectangle.south, height),
        Cesium.Cartesian3.fromRadians(rectangle.east, rectangle.north, height),
        Cesium.Cartesian3.fromRadians(rectangle.west, rectangle.north, height)
      ];
    }
    let granularity = Cesium.defaultValue(options.granularity, Cesium.Math.RADIANS_PER_DEGREE);
    let rectangleScratch = new Cesium.Rectangle();
    let nwScratch = new Cesium.Cartographic();
    let computedOptions = Cesium.RectangleGeometryLibrary.computeOptions(rectangle, granularity, rotation, 0, rectangleScratch, nwScratch);
    let w_height = computedOptions.height;
    let w_width = computedOptions.width;
    let ellipsoid = Cesium.defaultValue(options.ellipsoid, Cesium.Ellipsoid.WGS84);
    let scratchRectanglePoints = [new Cesium.Cartesian3(), new Cesium.Cartesian3(), new Cesium.Cartesian3(), new Cesium.Cartesian3()];
    Cesium.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, 0, scratchRectanglePoints[0]);
    Cesium.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, 0, w_width - 1, scratchRectanglePoints[1]);
    Cesium.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, w_height - 1, w_width - 1, scratchRectanglePoints[2]);
    Cesium.RectangleGeometryLibrary.computePosition(computedOptions, ellipsoid, false, w_height - 1, 0, scratchRectanglePoints[3]);
    if (height != 0) {
      scratchRectanglePoints = setPositionsHeight2(scratchRectanglePoints, height);
    }
    return scratchRectanglePoints;
  };
  var getRectPositionsByCenter = function(options) {
    let center2 = options.center;
    let width = options.width;
    let height = options.height;
    let rotation = Cesium.defaultValue(options.rotation, 0);
    let originX = Cesium.defaultValue(options.originX, 0.5);
    let originY = Cesium.defaultValue(options.originY, 0.5);
    let scratchEnuMatrix = new Cesium.Matrix4();
    let scratchRotationQuat = new Cesium.Quaternion();
    let scratchSrtMatrix = new Cesium.Matrix4();
    let localPositions = [
      Cesium.Cartesian3.fromElements(-originX, -originY, 0),
      Cesium.Cartesian3.fromElements(1 - originX, -originY, 0),
      Cesium.Cartesian3.fromElements(1 - originX, 1 - originY, 0),
      Cesium.Cartesian3.fromElements(-originX, 1 - originY, 0)
    ];
    let enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center2, Cesium.Ellipsoid.WGS84, scratchEnuMatrix);
    let rotationQuat = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Z, rotation, scratchRotationQuat);
    let cmftqrs = Cesium.Matrix4.fromTranslationQuaternionRotationScale;
    let srtMatrix = cmftqrs(Cesium.Cartesian3.ZERO, rotationQuat, Cesium.Cartesian3.fromElements(width, height), scratchSrtMatrix);
    let modelMatrix = Cesium.Matrix4.multiply(enuMatrix, srtMatrix, srtMatrix);
    let result = [];
    localPositions.forEach(function(lp, index) {
      if (typeof result[index] == "undefined") {
        result[index] = new Cesium.Cartesian3();
      }
      Cesium.Matrix4.multiplyByPoint(modelMatrix, lp, result[index]);
    });
    return result;
  };
  var isInPoly = function(position, coordinates) {
    try {
      if (!booleanPointInPolygon) {
        throw new Error("turf\u4E0D\u5B58\u5728");
      }
    } catch (e) {
      console.log("isInPoly\uFF1A\u8BE5\u65B9\u6CD5\u4F9D\u8D56turf\u5E93\uFF0C\u8BF7\u5F15\u5165\u8BE5\u5E93\u3002", e);
      return false;
    }
    let pt = {
      type: "Feature",
      geometry: { type: "Point", coordinates: LatLngPoint_default.parse(position).toArray() }
    };
    let poly = { type: "Polygon", coordinates: [LatLngArray_default.toArray(coordinates)] };
    return booleanPointInPolygon(pt, poly);
  };
  var getBezierCurve = function(positions, closure) {
    if (!positions || positions.length < 3) {
      return positions;
    }
    let coordinates = cartesians2lonlats2(positions);
    if (closure) {
      coordinates.push(coordinates[0]);
    }
    let defHeight = coordinates[coordinates.length - 1][2];
    try {
      if (!es_default5) {
        throw new Error("turf\u4E0D\u5B58\u5728");
      }
    } catch (e) {
      console.log("getBezierCurve\uFF1A\u8BE5\u65B9\u6CD5\u4F9D\u8D56turf\u5E93\uFF0C\u8BF7\u5F15\u5165\u8BE5\u5E93\u3002", e);
      return positions;
    }
    let curved = es_default5({
      type: "Feature",
      geometry: {
        type: "LineString",
        coordinates
      }
    });
    let result = lonlats2cartesians2(curved.geometry.coordinates, defHeight);
    if (closure) {
      result.push(result[0]);
    }
    return result;
  };
  var interPolyline = function(options) {
    let positions = options.positions;
    let scene = options.scene;
    let granularity = getGranularity(positions, options.splitNum || 100);
    if (granularity <= 0) {
      granularity = null;
    }
    let flatPositions = Cesium.PolylinePipeline.generateArc({
      positions,
      height: options.height,
      minDistance: options.minDistance,
      granularity
    });
    let arr2 = [];
    for (let i = 0; i < flatPositions.length; i += 3) {
      let position = Cesium.Cartesian3.unpack(flatPositions, i);
      if (scene && Cesium.defaultValue(options.surfaceHeight, true)) {
        delete options.callback;
        let height = getSurfaceHeight2(scene, position, options);
        let car = Cesium.Cartographic.fromCartesian(position);
        position = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
      }
      arr2.push(position);
    }
    return arr2;
  };
  var interLine = function(positions, options = {}) {
    if (!positions || positions.length < 2) {
      return positions;
    }
    let granularity;
    if (options.splitNum) {
      granularity = getGranularity(positions, options.splitNum);
      if (granularity <= 0) {
        granularity = null;
      }
    }
    let arr2 = [positions[0]];
    for (let index = 1, length2 = positions.length; index < length2; index++) {
      let startP = positions[index - 1];
      let endP = positions[index];
      let interPositions = Cesium.PolylinePipeline.generateArc({
        positions: [startP, endP],
        minDistance: options.minDistance,
        granularity
      });
      let h1 = Cesium.Cartographic.fromCartesian(startP).height;
      let h2 = Cesium.Cartographic.fromCartesian(endP).height;
      let hstep = (h2 - h1) / interPositions.length;
      for (let i = 3, len = interPositions.length; i < len; i += 3) {
        let position = Cesium.Cartesian3.unpack(interPositions, i);
        let car = Cesium.Cartographic.fromCartesian(position);
        let height = Number((h1 + hstep * i).toFixed(1));
        position = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
        arr2.push(position);
      }
    }
    return arr2;
  };
  var computeSurfaceLine = function(options) {
    return surfaceLineWork.start(options);
  };
  var computeSurfacePoints = function(options) {
    options.split = false;
    return surfaceLineWork.start(options);
  };
  var surfaceLineWork = {
    start: function(params2) {
      this.params = params2;
      this.scene = params2.map ? params2.map.scene : params2.scene;
      if (!this.scene) {
        console.log(`surfaceLineWork: \u8BF7\u4F20\u5165scene\u53C2\u6570`, params2);
        return;
      }
      let positions = params2.positions;
      if (positions == null || positions.length == 0) {
        this.end(positions);
        return;
      }
      this.positions = positions;
      let _split = Cesium.defaultValue(params2.split, true);
      if (_split) {
        positions = interPolyline({
          ...params2,
          scene: this.scene,
          positions
        });
        let positionsClone = [];
        for (let i = 0, len = positions.length; i < len; ++i) {
          positionsClone.push(positions[i].clone());
        }
        this.positions = positionsClone;
      }
      let _has3dtiles = Cesium.defaultValue(params2.has3dtiles, Cesium.defined(pick3DTileset(this.scene, positions)));
      let _hasTerrain = Boolean(this.scene.terrainProvider._layers);
      this._has3dtiles = _has3dtiles;
      this._hasTerrain = _hasTerrain;
      if (!_hasTerrain && !_has3dtiles) {
        this.end(positions);
        return;
      }
      if (_hasTerrain) {
        this.clampToTerrain(positions);
      } else {
        this.clampTo3DTileset(positions);
      }
      return this;
    },
    clampToTerrain: function(positions) {
      let ellipsoid = this.scene.globe.ellipsoid;
      let cartographicArray = ellipsoid.cartesianArrayToCartographicArray(positions);
      let tempHeight = Cesium.Cartographic.fromCartesian(positions[0]).height;
      let that = this;
      Promise.resolve(Cesium.sampleTerrainMostDetailed(this.scene.terrainProvider, cartographicArray)).then(function(samples) {
        samples = that.removeNullData(samples);
        let noHeight = false;
        let offset = Cesium.defaultValue(that.params.offset, 0);
        let _terrainExaggeration = that.scene._terrainExaggeration ? that.scene._terrainExaggeration : 1;
        for (let i = 0; i < samples.length; ++i) {
          if (samples[i].height == null) {
            noHeight = true;
            samples[i].height = tempHeight;
          } else {
            samples[i].height = offset + samples[i].height * _terrainExaggeration;
          }
        }
        let raisedPositions = ellipsoid.cartographicArrayToCartesianArray(samples);
        if (that._has3dtiles) {
          that.clampTo3DTileset(raisedPositions);
        } else {
          that.end(raisedPositions, noHeight);
        }
      });
    },
    clampTo3DTileset: function(positions) {
      let that = this;
      let positionsClone = [];
      for (let i = 0, len = positions.length; i < len; ++i) {
        positionsClone.push(positions[i].clone());
      }
      this.scene.clampToHeightMostDetailed(positionsClone, this.params.objectsToExclude, 0.2).then(function(clampedCartesians) {
        clampedCartesians = that.removeNullData(clampedCartesians);
        if (clampedCartesians.length == 0) {
          clampedCartesians = positions;
        }
        that.end(clampedCartesians);
      });
    },
    end: function(raisedPositions, noHeight) {
      let callback = this.params.callback;
      if (callback) {
        callback(raisedPositions, noHeight, this.positions);
      }
    },
    removeNullData: function(samples) {
      let arrNew = [];
      for (let i = 0; i < samples.length; ++i) {
        if (samples[i] != null) {
          arrNew.push(samples[i]);
        }
      }
      return arrNew;
    }
  };
  var computeStepSurfaceLine = function(options) {
    let positions = options.positions;
    let arrStepPoints = [];
    let params2 = {};
    for (let key2 in options) {
      if (key2 == "positions" || key2 == "callback" || key2 == "end" || key2 == "endItem") {
        continue;
      }
      params2[key2] = options[key2];
    }
    let index = 0;
    let allcount = positions.length - 1;
    function getLineFD() {
      if (index >= allcount) {
        if (options.callback) {
          options.callback(arrStepPoints);
        }
        if (options.end) {
          options.end(arrStepPoints);
        }
        return;
      }
      params2.positions = [positions[index], positions[index + 1]];
      params2.callback = function(raisedPositions, noHeight) {
        if (options.endItem) {
          options.endItem(raisedPositions, noHeight, index);
        }
        arrStepPoints.push(raisedPositions);
        index++;
        getLineFD();
      };
      surfaceLineWork.start(params2);
    }
    getLineFD();
  };
  var getLinkedPointList = function(startPoint, endPoint, angularityFactor, numOfSingleLine) {
    let result = [];
    let startPosition = Cesium.Cartographic.fromCartesian(startPoint);
    let endPosition = Cesium.Cartographic.fromCartesian(endPoint);
    let startLon = startPosition.longitude * 180 / Math.PI;
    let startLat = startPosition.latitude * 180 / Math.PI;
    let endLon = endPosition.longitude * 180 / Math.PI;
    let endLat = endPosition.latitude * 180 / Math.PI;
    let dist = Math.sqrt((startLon - endLon) * (startLon - endLon) + (startLat - endLat) * (startLat - endLat));
    let angularity = dist * angularityFactor;
    let startVec = Cesium.Cartesian3.clone(startPoint);
    let endVec = Cesium.Cartesian3.clone(endPoint);
    let startLength = Cesium.Cartesian3.distance(startVec, Cesium.Cartesian3.ZERO);
    let endLength = Cesium.Cartesian3.distance(endVec, Cesium.Cartesian3.ZERO);
    Cesium.Cartesian3.normalize(startVec, startVec);
    Cesium.Cartesian3.normalize(endVec, endVec);
    if (Cesium.Cartesian3.distance(startVec, endVec) == 0) {
      return result;
    }
    let omega = Cesium.Cartesian3.angleBetween(startVec, endVec);
    result.push(startPoint);
    for (let i = 1; i < numOfSingleLine - 1; i++) {
      let t = i * 1 / (numOfSingleLine - 1);
      let invT = 1 - t;
      let startScalar = Math.sin(invT * omega) / Math.sin(omega);
      let endScalar = Math.sin(t * omega) / Math.sin(omega);
      let startScalarVec = Cesium.Cartesian3.multiplyByScalar(startVec, startScalar, new Cesium.Cartesian3());
      let endScalarVec = Cesium.Cartesian3.multiplyByScalar(endVec, endScalar, new Cesium.Cartesian3());
      let centerVec = Cesium.Cartesian3.add(startScalarVec, endScalarVec, new Cesium.Cartesian3());
      let ht = t * Math.PI;
      let centerLength = startLength * invT + endLength * t + Math.sin(ht) * angularity;
      centerVec = Cesium.Cartesian3.multiplyByScalar(centerVec, centerLength, centerVec);
      result.push(centerVec);
    }
    result.push(endPoint);
    return result;
  };
  var getOffsetLine = function(positions, offset) {
    let arrNew = [];
    for (let i = 1; i < positions.length; i++) {
      let point1 = positions[i - 1];
      let point2 = positions[i];
      let dir12 = Cesium.Cartesian3.subtract(point1, point2, new Cesium.Cartesian3());
      let dir21left = Cesium.Cartesian3.cross(point1, dir12, new Cesium.Cartesian3());
      let p1offset = computedOffsetData(point1, dir21left, offset * 1e3);
      let p2offset = computedOffsetData(point2, dir21left, offset * 1e3);
      if (i == 1) {
        arrNew.push(p1offset);
      }
      arrNew.push(p2offset);
    }
    return arrNew;
  };
  function computedOffsetData(ori, dir, wid) {
    let currRay = new Cesium.Ray(ori, dir);
    return Cesium.Ray.getPoint(currRay, wid, new Cesium.Cartesian3());
  }
  var sliceByMaxDistance = function(positions, maxDistance, options = {}) {
    if (positions.length < 2) {
      return positions;
    }
    for (let i = positions.length - 1; i >= 1; i--) {
      let pt1 = positions[i];
      let pt2 = positions[i - 1];
      let distance = Cesium.Cartesian3.distance(pt1, pt2);
      maxDistance -= distance;
      if (maxDistance == 0) {
        if (options.point) {
          return pt1;
        } else {
          return positions.slice(i);
        }
      } else if (maxDistance < 0) {
        maxDistance += distance;
        let newpt = getOnLinePointByLen2(pt1, pt2, maxDistance);
        if (options.point) {
          return newpt;
        } else {
          return [newpt].concat(positions.slice(i));
        }
      }
    }
    return positions;
  };
  var convex2 = function(coordinates) {
    if (coordinates.length > 0) {
      try {
        if (!convex) {
          throw new Error("turf\u4E0D\u5B58\u5728");
        }
      } catch (e) {
        console.log("convex\uFF1A\u8BE5\u65B9\u6CD5\u4F9D\u8D56turf\u5E93\uFF0C\u8BF7\u5F15\u5165\u8BE5\u5E93\u3002", e);
        return coordinates;
      }
      let pts = [];
      for (let i = 0; i < coordinates.length; i++) {
        pts.push({
          type: "Feature",
          geometry: { type: "Point", coordinates: coordinates[i] }
        });
      }
      let hull = convex({ type: "FeatureCollection", features: pts });
      if (hull) {
        let coords = hull?.geometry?.coordinates;
        if (coords && coords.length > 0) {
          coordinates = coords[0];
        }
      }
    }
    return coordinates;
  };
  function pick3DTileset(scene, positions) {
    if (!positions) {
      return null;
    }
    if (positions instanceof Cesium.Cartesian3) {
      positions = [positions];
    }
    for (let i = 0, len = positions.length; i < len; ++i) {
      let position = positions[i];
      let coorPX = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position);
      if (!Cesium.defined(coorPX)) {
        continue;
      }
      let pickedObject = scene.pick(coorPX, 10, 10);
      if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.primitive) && pickedObject.primitive instanceof Cesium.Cesium3DTileset) {
        return pickedObject.primitive;
      }
    }
    return null;
  }
  var Poly_default = {
    buffer: buffer3,
    bufferPoints,
    getGranularity,
    interPolygon,
    getHeightRange,
    computeVolume,
    updateVolumeByMinHeight,
    updateVolume,
    getEllipseOuterPositions,
    formatRectangle,
    getRectangle,
    getPositionsRectVertex,
    getRectangleOuterPositions,
    getRectPositionsByCenter,
    isInPoly,
    getBezierCurve,
    interPolyline,
    interLine,
    computeSurfaceLine,
    computeSurfacePoints,
    computeStepSurfaceLine,
    getLinkedPointList,
    getOffsetLine,
    sliceByMaxDistance,
    convex: convex2,
    pick3DTileset
  };

  // Source/custom/utils/Measure.js
  var computeStepSurfaceLine2 = Poly_default.computeStepSurfaceLine;
  var interPolygon2 = Poly_default.interPolygon;
  var updateVolume2 = Poly_default.updateVolume;
  var updateVolumeByMinHeight2 = Poly_default.updateVolumeByMinHeight;
  var getDistance = function(positions) {
    if (!Cesium.defined(positions) || positions.length < 2) {
      return 0;
    }
    let distance = 0;
    for (let i = 1, len = positions.length; i < len; i++) {
      distance += Cesium.Cartesian3.distance(positions[i - 1], positions[i]);
    }
    return distance;
  };
  var getSurfaceDistance = function(positions) {
    if (!Cesium.defined(positions) || positions.length < 2) {
      return 0;
    }
    let distance = 0;
    for (let i = 1, len = positions.length; i < len; i++) {
      let c1 = Cesium.Cartographic.fromCartesian(positions[i - 1]);
      let c2 = Cesium.Cartographic.fromCartesian(positions[i]);
      let geodesic = new Cesium.EllipsoidGeodesic();
      geodesic.setEndPoints(c1, c2);
      let s = geodesic.surfaceDistance;
      s = Math.sqrt(Math.pow(s, 2) + Math.pow(c2.height - c1.height, 2));
      distance += s;
    }
    return distance;
  };
  var getClampDistance = function(positions, options) {
    let all_distance = 0;
    let arrDistance = [];
    computeStepSurfaceLine2({
      scene: options.scene,
      positions,
      splitNum: options.splitNum,
      has3dtiles: options.has3dtiles,
      endItem: function(raisedPositions, noHeight, index) {
        let distance = getSurfaceDistance(raisedPositions);
        if (noHeight && options.disTerrainScale) {
          distance = distance * options.disTerrainScale;
        }
        all_distance += distance;
        arrDistance.push(distance);
        if (options.endItem) {
          options.endItem({
            index,
            positions: raisedPositions,
            distance,
            arrDistance,
            all_distance
          });
        }
      },
      end: function() {
        if (options.callback) {
          options.callback(all_distance, arrDistance);
        }
      }
    });
  };
  var getArea = function(positions) {
    if (!positions || !Array.isArray(positions) || positions.length < 3) {
      return 0;
    }
    let geometry = Cesium.CoplanarPolygonGeometry.createGeometry(
      Cesium.CoplanarPolygonGeometry.fromPositions({
        positions,
        vertexFormat: Cesium.VertexFormat.POSITION_ONLY
      })
    );
    let result = 0;
    if (!geometry) {
      return result;
    }
    let flatPositions = geometry.attributes.position.values;
    let indices = geometry.indices;
    for (let i = 0; i < indices.length; i += 3) {
      let p0 = Cesium.Cartesian3.unpack(flatPositions, indices[i] * 3, new Cesium.Cartesian3());
      let p1 = Cesium.Cartesian3.unpack(flatPositions, indices[i + 1] * 3, new Cesium.Cartesian3());
      let p2 = Cesium.Cartesian3.unpack(flatPositions, indices[i + 2] * 3, new Cesium.Cartesian3());
      result += getTriangleArea2(p0, p1, p2);
    }
    return result;
  };
  var getTriangleArea2 = function(pos1, pos2, pos3) {
    let v0 = Cesium.Cartesian3.subtract(pos1, pos2, new Cesium.Cartesian3());
    let v1 = Cesium.Cartesian3.subtract(pos3, pos2, new Cesium.Cartesian3());
    let cross = Cesium.Cartesian3.cross(v0, v1, v0);
    return Cesium.Cartesian3.magnitude(cross) * 0.5;
  };
  var getClampArea = function(positions, options) {
    function _restultArea(resultInter2) {
      let area2 = 0;
      for (let i = 0, len = resultInter2.list.length; i < len; i++) {
        let item = resultInter2.list[i];
        let pt1 = item.point1;
        let pt2 = item.point2;
        let pt3 = item.point3;
        area2 += getTriangleArea2(pt1.pointDM, pt2.pointDM, pt3.pointDM);
      }
      return area2;
    }
    let callback = options.callback;
    let resultInter = interPolygon2({
      positions,
      scene: options.scene,
      splitNum: options.splitNum,
      has3dtiles: options.has3dtiles,
      asyn: options.asyn,
      callback: function(resultInter2) {
        let area2 = _restultArea(resultInter2);
        if (callback) {
          callback(area2, resultInter2);
        }
      }
    });
    if (options.asyn) {
      return null;
    } else {
      let area2 = _restultArea(resultInter);
      if (callback) {
        callback(area2, resultInter);
      }
      return area2;
    }
  };
  var getAngle = function(startPosition, endPosition, isNorthZero) {
    let mat = Cesium.Transforms.eastNorthUpToFixedFrame(endPosition);
    mat = Cesium.Matrix4.getMatrix3(mat, new Cesium.Matrix3());
    let xaxis = Cesium.Matrix3.getColumn(mat, 0, new Cesium.Cartesian3());
    let yaxis = Cesium.Matrix3.getColumn(mat, 1, new Cesium.Cartesian3());
    let zaxis = Cesium.Matrix3.getColumn(mat, 2, new Cesium.Cartesian3());
    let dir = Cesium.Cartesian3.subtract(startPosition, endPosition, new Cesium.Cartesian3());
    dir = Cesium.Cartesian3.cross(dir, zaxis, dir);
    dir = Cesium.Cartesian3.cross(zaxis, dir, dir);
    dir = Cesium.Cartesian3.normalize(dir, dir);
    let heading = Cesium.Cartesian3.angleBetween(xaxis, dir);
    let ay = Cesium.Cartesian3.angleBetween(yaxis, dir);
    if (ay > Math.PI * 0.5) {
      heading = 2 * Math.PI - heading;
    }
    let hDegrees = 360 - Cesium.Math.toDegrees(heading) - 180;
    if (isNorthZero) {
      hDegrees += 90;
    }
    if (hDegrees < 0) {
      hDegrees = hDegrees + 360;
    } else if (hDegrees > 360) {
      hDegrees = hDegrees - 360;
    }
    return hDegrees.toFixed(1);
  };
  var getVolume = function(positions, options) {
    if (!positions || !Array.isArray(positions) || positions.length < 3) {
      return 0;
    }
    function _restultVolume(interPolygonObj) {
      if (options.minHeight) {
        interPolygonObj.minHeight = options.minHeight;
      }
      interPolygonObj = updateVolumeByMinHeight2(interPolygonObj);
      let _jzmHeight = options.height ?? interPolygonObj.minHeight;
      let fillV = updateVolume2(interPolygonObj, _jzmHeight);
      let { digVolume = 0, fillVolume = 0, totalVolume = 0, totalArea = 0, maxHeight = 0, minHeight = 0 } = fillV;
      let res = { digVolume, fillVolume, totalVolume, totalArea, maxHeight, minHeight };
      if (digVolume < 0) {
        delete res["digVolume"];
      }
      if (fillVolume < 0) {
        delete res["fillVolume"];
      }
      return res;
    }
    let callback = options.callback;
    let resultInter = interPolygon2({
      positions,
      scene: options.scene,
      splitNum: options.splitNum,
      has3dtiles: options.has3dtiles,
      asyn: options.asyn,
      callback: (interPolygonObj) => {
        let result = _restultVolume(interPolygonObj);
        if (callback) {
          callback(result);
        }
      }
    });
    if (options.asyn) {
      return null;
    } else {
      let volume = _restultVolume(resultInter);
      if (callback) {
        callback(volume, resultInter);
      }
      return volume;
    }
  };
  var formatDistance = function(val, unit) {
    if (val == null) {
      return "";
    }
    if (unit == null || unit == "auto") {
      if (val < 1e3) {
        unit = "m";
      } else {
        unit = "km";
      }
    }
    let valstr = "";
    switch (unit) {
      default:
      case "m":
        valstr = val.toFixed(2) + "_\u7C73";
        break;
      case "km":
        valstr = (val * 1e-3).toFixed(2) + "_\u516C\u91CC";
        break;
      case "mile":
        valstr = (val * 54e-5).toFixed(2) + "_\u6D77\u91CC";
        break;
      case "zhang":
        valstr = (val * 0.3).toFixed(2) + "_\u4E08";
        break;
    }
    return valstr;
  };
  var formatArea = function(val, unit) {
    if (val == null) {
      return "";
    }
    if (unit == null || unit == "auto") {
      if (val < 1e6) {
        unit = "m";
      } else {
        unit = "km";
      }
    }
    let valstr = "";
    switch (unit) {
      default:
      case "m":
        valstr = val.toFixed(2) + "_\u5E73\u65B9\u7C73";
        break;
      case "km":
        valstr = (val / 1e6).toFixed(2) + "_\u5E73\u65B9\u516C\u91CC";
        break;
      case "mu":
        valstr = (val * 15e-4).toFixed(2) + "_\u4EA9";
        break;
      case "ha":
        valstr = (val * 1e-4).toFixed(2) + "_\u516C\u9877";
        break;
    }
    return valstr;
  };
  var formatVolume = function(val, unit) {
    if (val == null) {
      return "";
    }
    if (val < 1e4) {
      return val.toFixed(2) + "_\u7ACB\u65B9\u7C73";
    } else {
      return (val / 1e4).toFixed(2) + "_\u4E07\u7ACB\u65B9\u7C73";
    }
  };
  var Measure_default = {
    getDistance,
    getSurfaceDistance,
    getClampDistance,
    getArea,
    getTriangleArea: getTriangleArea2,
    getClampArea,
    getAngle,
    getVolume,
    formatDistance,
    formatArea,
    formatVolume
  };

  // Source/custom/utils/gistools/GisTools.js
  var _dis = 5;
  var GisTools = class {
    static pointDistToLine(x3, y3, startx, starty, endx, endy) {
      let se = (startx - endx) * (startx - endx) + (starty - endy) * (starty - endy);
      let p = (x3 - startx) * (endx - startx) + (y3 - starty) * (endy - starty);
      let r = p / se;
      let outx = startx + r * (endx - startx);
      let outy = starty + r * (endy - starty);
      let des = Math.sqrt((x3 - outx) * (x3 - outx) + (y3 - outy) * (y3 - outy));
      return des;
    }
    static isPointOnSegment(px, py, p1x, p1y, p2x, p2y) {
      if (px - _dis > p1x && px + _dis > p2x || px + _dis < p1x && px - _dis < p2x) {
        return 0;
      }
      if (py - _dis > p1y && py + _dis > p2y || py + _dis < p1y && py - _dis < p2y) {
        return 0;
      }
      let d = GisTools.pointDistToLine(px, py, p1x, p1y, p2x, p2y);
      if (d < _dis) {
        return 1;
      } else {
        return 0;
      }
    }
    static pointInLine(px, py, polyline) {
      let flag = 0;
      let line = [];
      if (Array.isArray(polyline[0])) {
        line = polyline;
      } else {
        line.push(polyline);
      }
      for (var polyIndex = 0; polyIndex < line.length; polyIndex++) {
        let subpoly = line[polyIndex];
        let length2 = subpoly.length / 2;
        for (var i = 0; i < length2 - 1; i++) {
          let j;
          j = i + 1;
          let sx = subpoly[2 * i], sy = subpoly[2 * i + 1], tx = subpoly[2 * j], ty = subpoly[2 * j + 1];
          if (GisTools.isPointOnSegment(px, py, sx, sy, tx, ty) == 1) {
            return 1;
          }
        }
      }
      return 0;
    }
    static pointInPolygon(px, py, polygen) {
      let flag = 0;
      let poly = [];
      if (Array.isArray(polygen[0])) {
        poly = polygen;
      } else {
        poly.push(polygen);
      }
      for (var polyIndex = 0; polyIndex < poly.length; polyIndex++) {
        let subpoly = poly[polyIndex];
        let length2 = subpoly.length / 2;
        for (var i = 0, l = length2, j = l - 1; i < l; j = i, i++) {
          let sx = subpoly[2 * i], sy = subpoly[2 * i + 1], tx = subpoly[2 * j], ty = subpoly[2 * j + 1];
          if (sx === px && sy === py || tx === px && ty === py) {
            return 1;
          }
          if (sy < py && ty >= py || sy >= py && ty < py) {
            let x3 = sx + (py - sy) * (tx - sx) / (ty - sy);
            if (x3 === px) {
              return 1;
            }
            if (x3 > px) {
              flag = !flag;
            }
          }
        }
      }
      return flag ? 1 : 0;
    }
    static lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
      var denominator, a2, b, numerator1, numerator2, onLine1 = false, onLine2 = false, res = [null, null];
      denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);
      if (denominator === 0) {
        if (res[0] !== null && res[1] !== null) {
          return res;
        } else {
          return false;
        }
      }
      a2 = line1StartY - line2StartY;
      b = line1StartX - line2StartX;
      numerator1 = (line2EndX - line2StartX) * a2 - (line2EndY - line2StartY) * b;
      numerator2 = (line1EndX - line1StartX) * a2 - (line1EndY - line1StartY) * b;
      a2 = numerator1 / denominator;
      b = numerator2 / denominator;
      res[0] = line1StartX + a2 * (line1EndX - line1StartX);
      res[1] = line1StartY + a2 * (line1EndY - line1StartY);
      if (b > 0 && b < 1) {
        return res;
      } else {
        return false;
      }
    }
    static polyWith(polyOut, polyIn) {
      let lengthOut = polyOut.length / 2;
      let lengthIn = polyIn.length / 2;
      let flag = false;
      let bY;
      let aX;
      let aY;
      let bX;
      let dY;
      let cX;
      let cY;
      let dX;
      for (let i = 0; i < lengthOut; i++) {
        if (i != lengthOut - 1) {
          aX = polyOut[i * 2];
          aY = polyOut[i * 2 + 1];
          bX = polyOut[i * 2 + 2];
          bY = polyOut[i * 2 + 3];
        } else {
          aX = polyOut[i * 2];
          aY = polyOut[i * 2 + 1];
          bX = polyOut[0];
          bY = polyOut[1];
        }
        for (let j = 0; j < lengthIn; j++) {
          if (j != lengthIn - 1) {
            cX = polyIn[j * 2];
            cY = polyIn[j * 2 + 1];
            dX = polyIn[j * 2 + 2];
            dY = polyIn[j * 2 + 3];
          } else {
            cX = polyIn[j * 2];
            cY = polyIn[j * 2 + 1];
            dX = polyIn[0];
            dY = polyIn[1];
          }
          if (GisTools.lineIntersects(aX, aY, bX, bY, cX, cY, dX, dY) != false) {
            return 1;
          }
        }
      }
      let firstX = polyIn[0];
      let firstY = polyIn[1];
      if (GisTools.pointInPolygon(firstX, firstY, polyOut)) {
        return 2;
      }
      return 3;
    }
    static boxToPolyArr(left, bottom, right, top) {
      let arr2 = [];
      arr2.push(left);
      arr2.push(bottom);
      arr2.push(left);
      arr2.push(top);
      arr2.push(right);
      arr2.push(top);
      arr2.push(right);
      arr2.push(bottom);
      arr2.push(left);
      arr2.push(bottom);
      return arr2;
    }
    static boxScale(box, pointBoxDisance) {
      box[0] = box[0] - pointBoxDisance * 0.5;
      box[1] = box[1] - pointBoxDisance * 0.5;
      box[2] = box[2] + pointBoxDisance * 0.5;
      box[3] = box[3] + pointBoxDisance * 0.5;
      return box;
    }
    static getExtensionPoint(p1, p2, d) {
      let xab = p2[0] - p1[0];
      let yab = p2[1] - p1[1];
      let xd = p2[0];
      let yd = p2[1];
      if (xab == 0) {
        if (yab > 0) {
          yd = p2[1] + d;
        } else {
          yd = p2[1] - d;
        }
      } else {
        let xbd = Math.sqrt(d * d / (yab / xab * (yab / xab) + 1));
        if (xab < 0) {
          xbd = -xbd;
        }
        xd = p2[0] + xbd;
        yd = p2[1] + yab / xab * xbd;
      }
      return [xd, yd];
    }
    static lineOffset(coords, distance) {
      let segments = [];
      let finalCoords = [];
      coords.forEach(function(currentCoords, index) {
        if (index !== coords.length - 1) {
          let segment = GisTools.processSegment(currentCoords, coords[index + 1], distance);
          segments.push(segment);
          if (index > 0) {
            let seg2Coords = segments[index - 1];
            let intersects = GisTools.lineIntersects(
              segment[0][0],
              segment[0][1],
              segment[1][0],
              segment[1][1],
              seg2Coords[0][0],
              seg2Coords[0][1],
              seg2Coords[1][0],
              seg2Coords[1][1]
            );
            if (intersects !== false) {
              seg2Coords[1] = intersects;
              segment[0] = intersects;
            }
            finalCoords.push(seg2Coords[0]);
            if (index === coords.length - 2) {
              finalCoords.push(segment[0]);
              finalCoords.push(segment[1]);
            }
          }
          if (coords.length === 2) {
            finalCoords.push(segment[0]);
            finalCoords.push(segment[1]);
          }
        }
      });
      return finalCoords;
    }
    static processSegment(pointAngle1, pointAngle2, offset) {
      let point1 = pointAngle1[0];
      let point2 = pointAngle2[0];
      let L = Math.sqrt((point1[0] - point2[0]) * (point1[0] - point2[0]) + (point1[1] - point2[1]) * (point1[1] - point2[1]));
      let out1x = point1[0] + offset * (point2[1] - point1[1]) / L;
      let out2x = point2[0] + offset * (point2[1] - point1[1]) / L;
      let out1y = point1[1] + offset * (point1[0] - point2[0]) / L;
      let out2y = point2[1] + offset * (point1[0] - point2[0]) / L;
      return [
        [
          [out1x, out1y],
          pointAngle1[1]
        ],
        [
          [out2x, out2y],
          pointAngle2[1]
        ]
      ];
    }
    static isInBox(box1, box2) {
      if (box1[0] >= box2[0] && box1[1] >= box2[1] && box1[2] <= box2[2] && box1[3] <= box2[3]) {
        return true;
      }
      return false;
    }
    static Utf8ArrayToStr(array2) {
      var out, i, len, c;
      var char2, char3;
      out = "";
      len = array2.length;
      i = 0;
      while (i < len) {
        c = array2[i++];
        switch (c >> 4) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            out += String.fromCharCode(c);
            break;
          case 12:
          case 13:
            char2 = array2[i++];
            out += String.fromCharCode((c & 31) << 6 | char2 & 63);
            break;
          case 14:
            char2 = array2[i++];
            char3 = array2[i++];
            out += String.fromCharCode((c & 15) << 12 | (char2 & 63) << 6 | (char3 & 63) << 0);
            break;
        }
      }
      return out;
    }
  };
  var GisTools_default = GisTools;

  // Source/custom/utils/gistools/GridFilter.js
  var GridFilter = class {
    constructor(tilesize, cellsize, buffer4, maxPerCell) {
      let n = tilesize / cellsize;
      let padding = buffer4 / cellsize;
      this.maxPerCell = maxPerCell == null ? 1 : maxPerCell;
      this.cells = {};
      this.d = n + 2 * padding;
      this.n = n;
      this.padding = padding;
      this.scale = n / tilesize;
      let p = padding / n * tilesize;
      this.min = -p;
      this.max = tilesize + p;
    }
    filter(x3, y3) {
      if (x3 < this.min || x3 > this.max || y3 < this.min || y3 > this.max) {
        return false;
      }
      let cx = this.convertToCellCoord(x3);
      let cy = this.convertToCellCoord(y3);
      let cellIndex = this.d * cy + cx;
      if (this.cells[cellIndex] >= this.maxPerCell) {
        return false;
      } else {
        let i = this.cells[cellIndex];
        if (i == null) {
          this.cells[cellIndex] = 1;
        } else {
          this.cells[cellIndex] = i++;
        }
        return true;
      }
    }
    filterByBox(box) {
      let startX = this.convertToCellCoord(box[0]);
      let endX = this.convertToCellCoord(box[2]);
      let startY = this.convertToCellCoord(box[1]);
      let endY = this.convertToCellCoord(box[3]);
      for (let i = startX; i <= endX; i++) {
        for (let j = startY; j <= endY; j++) {
          let cellIndex = this.d * j + i;
          if (this.cells[cellIndex]) {
            return false;
          }
        }
      }
      for (let i = startX; i <= endX; i++) {
        for (let j = startY; j <= endY; j++) {
          let cellIndex = this.d * j + i;
          this.cells[cellIndex] = 1;
        }
      }
      return true;
    }
    clean() {
      this.cells = {};
      this.saveCount = 0;
    }
    convertToCellCoord(x3) {
      return Math.max(0, Math.min(this.d - 1, Math.floor(x3 * this.scale) + this.padding));
    }
  };
  var GridFilter_default = GridFilter;

  // Source/custom/utils/BeziterLine.js
  var BeziterLine = class {
    static getLine(p0, p1, p2, p3, num, tick) {
      let pointMum = num || 100;
      let _tick = tick || 1;
      let t = _tick / (pointMum - 1);
      let points = [];
      for (let i = 0; i < pointMum; i++) {
        let point2 = this.getBezierNowPoint(p0, p1, p2, p3, i, t);
        points.push(point2);
      }
      return points;
    }
    static getBezierNowPoint(p0, p1, p2, p3, num, tick) {
      return {
        x: this.bezier(p0.x, p1.x, p2.x, p3.x, num * tick),
        y: this.bezier(p0.y, p1.y, p2.y, p3.y, num * tick),
        z: this.bezier(p0.z, p1.z, p2.z, p3.z, num * tick)
      };
    }
    static bezier(p0, p1, p2, p3, t) {
      let P0, P1, P2, P3;
      P0 = p0 * Math.pow(1 - t, 3);
      P1 = 3 * p1 * t * Math.pow(1 - t, 2);
      P2 = 3 * p2 * Math.pow(t, 2) * (1 - t);
      P3 = p3 * Math.pow(t, 3);
      return P0 + P1 + P2 + P3;
    }
  };
  var BeziterLine_default = BeziterLine;

  // Source/custom/analysis/AspectAnalysis.js
  var computeSurfacePoints2 = Poly_default.computeSurfacePoints;
  var getEllipseOuterPositions2 = Poly_default.getEllipseOuterPositions;
  var interPolygon3 = Poly_default.interPolygon;
  var getOnLinePointByLen3 = PointUtil_default.getOnLinePointByLen;
  var getAngle2 = Measure_default.getAngle;
  var AspectAnalysis = class extends TerrainEditBase_default {
    constructor(viewer3, options = {}) {
      super(viewer3, options);
      this.colorScheme = options.colorScheme || {
        step: [0, 0.2, 0.4, 0.6, 0.8, 0.9, 1],
        color: ["#000000", "#2747E0", "#D33B7D", "#D33038", "#FF9742", "#FF9742", "#ffd700"]
      };
      this.options.arrow = this.options.arrow || {};
      this.options.arrow.show = Cesium.defaultValue(this.options.arrow.show, true);
      this.options.arrow.scale = Cesium.defaultValue(this.options.arrow.scale, 0.3);
      this.options.arrow.width = Cesium.defaultValue(this.options.arrow.width, 15);
      this.options.arrow.color = Cesium.defaultValue(this.options.arrow.color, Cesium.Color.YELLOW);
      this.arrowLength = Cesium.defaultValue(this.options.arrow.length, 40);
      this.options.point = this.options.point || {};
      this.options.point.show = Cesium.defaultValue(this.options.point.show, true);
      this.options.point.pixelSize = Cesium.defaultValue(this.options.point.pixelSize, 9);
      this.options.point.color = Cesium.defaultValue(this.options.point.color, Cesium.Color.RED.withAlpha(0.5));
      this.arrowPrimitives = [];
      if (this.options.arrow.show) {
        this.pointInterPrimitives = new Cesium.PointPrimitiveCollection();
        this._map.scene.primitives.add(this.pointInterPrimitives);
      }
    }
    clear() {
      super.clear();
      this._map.scene.globe.material = null;
      if (this.hasResetEnableLighting) {
        this._map.scene.globe.enableLighting = false;
        this._map.clock.currentTime = Cesium.JulianDate.now();
        delete this.hasResetEnableLighting;
      }
      if (this.pointInterPrimitives) {
        this.pointInterPrimitives.removeAll();
      }
      for (let i = 0, len = this.arrowPrimitives.length; i < len; i++) {
        this._map.scene.primitives.remove(this.arrowPrimitives[i]);
      }
      this.arrowPrimitives = [];
      this.instances = [];
      this.arrData = [];
      this.stateAll = 0;
      this.stateOkIndex = 0;
    }
    updateMaterial() {
      let material;
      let shadingUniforms;
      material = Cesium.Material.fromType("AspectRamp");
      shadingUniforms = material.uniforms;
      shadingUniforms.image = this.getColorRamp();
      if (!this._map.scene.globe.enableLighting) {
        this._map.scene.globe.enableLighting = true;
        let now2 = new Date();
        now2.setHours(10);
        this._map.clock.currentTime = Cesium.JulianDate.fromDate(new Date(now2));
        this.hasResetEnableLighting = true;
      }
      this._map.scene.globe.material = material;
    }
    addPolygon(positions, options) {
      let areaObj = super.addPolygon(positions, options);
      this.updateMaterial();
      if (this.options.arrow.show) {
        this.add(positions, options);
      }
      return areaObj;
    }
    removePolygon(item) {
      super.removePolygon(item);
      if (this.pointInterPrimitives) {
        this.pointInterPrimitives.removeAll();
      }
      for (let i = 0, len = this.arrowPrimitives.length; i < len; i++) {
        this._map.scene.primitives.remove(this.arrowPrimitives[i]);
      }
      this.arrowPrimitives = [];
      this.instances = [];
      this.arrData = [];
      this.stateAll = 0;
      this.stateOkIndex = 0;
    }
    add(positions, options = {}) {
      if (!positions || positions.length < 1) {
        return;
      }
      this.eventResult = { positions };
      let splitNum = Cesium.defaultValue(options.splitNum, 8);
      if (positions.length > 2 && splitNum > 1) {
        let resultInter = interPolygon3({
          scene: this._map.scene,
          positions,
          has3dtiles: false,
          onlyPoint: true,
          splitNum
        });
        this.arrowLength = Cesium.Math.chordLength(resultInter.granularity, this._map.scene.globe.ellipsoid.maximumRadius) * this.options.arrow.scale;
        this.eventResult.maxHeight = resultInter.maxHeight;
        this.eventResult.minHeight = resultInter.minHeight;
        positions = [];
        for (let k = 0; k < resultInter.list.length; k++) {
          positions.push(resultInter.list[k].pointDM);
        }
      }
      this.stateAll = positions.length;
      this.stateOkIndex = 0;
      this.instances = [];
      this.arrData = [];
      for (let i = 0; i < this.stateAll; i++) {
        this._fxOnePoint(positions[i], options);
      }
    }
    _fxOnePoint(position, options) {
      if (!position) {
        return;
      }
      let arcPoint = getEllipseOuterPositions2({
        position,
        radius: Cesium.defaultValue(options.radius, 2),
        count: Cesium.defaultValue(options.count, 4)
      });
      arcPoint.push(position);
      let ellipsoid = this._map.scene.globe.ellipsoid;
      let that = this;
      computeSurfacePoints2({
        scene: this._map.scene,
        positions: arcPoint,
        has3dtiles: options.has3dtiles,
        callback: (raisedPositions, noHeight) => {
          if (this.stateAll == 0) {
            return;
          }
          if (noHeight) {
            console.log("\u672A\u83B7\u53D6\u5230\u9AD8\u5EA6\u503C\uFF0C\u8D34\u5730\u9AD8\u5EA6\u8BA1\u7B97\u5B58\u5728\u8BEF\u5DEE");
          }
          let cartographicArray = ellipsoid.cartesianArrayToCartographicArray(raisedPositions);
          let center2 = cartographicArray.pop();
          let maxIndex = 0;
          let maxHeight = cartographicArray[0].height;
          let minIndex = 0;
          let minHeight = cartographicArray[0].height;
          for (let i = 1; i < cartographicArray.length - 1; i++) {
            let item = cartographicArray[i];
            if (item.height > maxHeight) {
              maxHeight = item.height;
              maxIndex = i;
            }
            if (item.height < minHeight) {
              minHeight = item.height;
              minIndex = i;
            }
          }
          let maxPoint = cartographicArray[maxIndex];
          let minPoint = cartographicArray[minIndex];
          let slopeVal1 = that.getSlope(center2, maxPoint);
          let slopeVal2 = that.getSlope(center2, minPoint);
          if (slopeVal1 > slopeVal2) {
            that._fxOnePointOk(position, center2, maxPoint, slopeVal1);
          } else {
            that._fxOnePointOk(position, center2, minPoint, slopeVal2);
          }
        }
      });
    }
    _fxOnePointOk(position, center2, maxPoint, slopeVal) {
      let centerCar = Cesium.Cartographic.toCartesian(center2);
      let maxPointCar = Cesium.Cartographic.toCartesian(maxPoint);
      maxPointCar = getOnLinePointByLen3(centerCar, maxPointCar, this.arrowLength);
      let arrArrowPt;
      if (center2.height > maxPoint.height) {
        arrArrowPt = [centerCar, maxPointCar];
      } else {
        arrArrowPt = [maxPointCar, centerCar];
      }
      let slopeAngle = getAngle2(arrArrowPt[0], arrArrowPt[1], true);
      let slopeValDou = Math.atan(slopeVal) * 180 / Math.PI;
      slopeValDou = Number(slopeValDou.toFixed(2));
      let text1 = slopeValDou + "\xB0";
      let text2 = (slopeVal * 100).toFixed(2) + "%";
      let itemData = {
        position,
        slope: slopeValDou,
        slopeStr1: text1,
        slopeStr2: text2,
        direction: slopeAngle
      };
      if (!this.arrData) {
        this.arrData = [];
      }
      this.arrData.push(itemData);
      if (this.options.arrow.show) {
        let gs = new Cesium.GeometryInstance({
          geometry: new Cesium.PolylineGeometry({
            positions: arrArrowPt,
            ...this.options.arrow
          }),
          vertexFormat: Cesium.PolylineMaterialAppearance.VERTEX_FORMAT,
          id: "polylinedashinstance"
        });
        this.instances.push(gs);
      }
      if (this.options.point.show) {
        let primitive = this.pointInterPrimitives.add({
          position: centerCar,
          ...this.options.point
        });
        primitive.attr = itemData;
        primitive.eventTarget = this;
        primitive.tooltip = Cesium.defaultValue(this.options.tooltip, `\u5761\u5EA6: ${text1}  (${text2})<br />\u5761\u5411: ${slopeAngle}\xB0`);
        primitive.popup = this.options.popup;
      }
      this.stateOkIndex++;
      if (this.stateOkIndex >= this.stateAll) {
        if (this.options.arrow.show && this.instances.length > 0) {
          let arrowPrimitive = this._map.scene.primitives.add(
            new Cesium.Primitive({
              geometryInstances: this.instances,
              appearance: new Cesium.PolylineMaterialAppearance({
                material: Cesium.Material.fromType("PolylineArrow", {
                  color: this.options.arrow.color
                })
              })
            })
          );
          this.arrowPrimitives.push(arrowPrimitive);
          this.instances = [];
        }
      }
    }
    getSlope(c1, c2) {
      if (!c1 || !c2) {
        return;
      }
      let differH = Math.abs(c1.height - c2.height);
      let differV = Cesium.Cartesian3.distance(
        Cesium.Cartographic.toCartesian(c1),
        Cesium.Cartesian3.fromRadians(c2.longitude, c2.latitude, c1.height)
      );
      let value = differH / differV;
      return value;
    }
    getColorRamp() {
      let ramp = document.createElement("canvas");
      ramp.width = 100;
      ramp.height = 1;
      let ctx = ramp.getContext("2d");
      let grd = ctx.createLinearGradient(0, 0, 100, 0);
      let colorScheme = this.colorScheme;
      if (colorScheme.step.length > 0) {
        for (let i = 0, len = colorScheme.step.length; i < len; i++) {
          grd.addColorStop(colorScheme.step[i], colorScheme.color[i]);
        }
      }
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, 100, 1);
      return ramp;
    }
  };
  var AspectAnalysis_default = AspectAnalysis;

  // Source/custom/analysis/ElevationAnalysis.js
  var ElevationAnalysis = class extends TerrainEditBase_default {
    constructor(viewer3, options = {}) {
      super(viewer3, options);
      this._contourSpacing = Cesium.defaultValue(options.spacing, 100);
      this._contourWidth = Cesium.defaultValue(options.width, 1.5);
      this._contourColor = this.getCesiumColor(options.color, Cesium.Color.RED);
      this.colorScheme = options.colorScheme || {
        step: [0, 0.045, 0.1, 0.15, 0.37, 0.54, 1],
        color: ["#000000", "#2747E0", "#D33B7D", "#D33038", "#FF9742", "#FF9742", "#ffd700"]
      };
      this.minHeight = Cesium.defaultValue(options.minHeight, -414);
      this.maxHeight = Cesium.defaultValue(options.maxHeight, 8777);
    }
    getCesiumColor(color, defval) {
      if (color) {
        if (typeof color == "string" && color.constructor == String) {
          return Cesium.Color.fromCssColorString(color);
        } else {
          return color;
        }
      } else {
        return defval;
      }
    }
    clear() {
      super.clear();
      this._map.scene.globe.material = null;
      if (this.hasResetEnableLighting) {
        this._map.scene.globe.enableLighting = false;
        this._map.clock.currentTime = Cesium.JulianDate.now();
        delete this.hasResetEnableLighting;
      }
    }
    updateMaterial() {
      let material;
      let shadingUniforms;
      if (this.options.hasOwnProperty("contourShow") && this.options.contourShow) {
        material = Cesium.Material.fromType("ElevationContour");
        shadingUniforms = material.uniforms;
        shadingUniforms.width = this._contourWidth;
        shadingUniforms.spacing = this._contourSpacing;
        shadingUniforms.color = this._contourColor;
      } else {
        material = Cesium.Material.fromType("ElevationRamp");
        shadingUniforms = material.uniforms;
        shadingUniforms.minimumHeight = this.minHeight;
        shadingUniforms.maximumHeight = this.maxHeight;
        shadingUniforms.image = this.getColorRamp();
      }
      if (!this._map.scene.globe.enableLighting) {
        this._map.scene.globe.enableLighting = true;
        let now2 = new Date();
        now2.setHours(10);
        this._map.clock.currentTime = Cesium.JulianDate.fromDate(new Date(now2));
        this.hasResetEnableLighting = true;
      }
      this._map.scene.globe.material = material;
    }
    addPolygon(positions, options) {
      let areaObj = super.addPolygon(positions, options);
      this.updateMaterial();
      return areaObj;
    }
    getColorRamp() {
      let ramp = document.createElement("canvas");
      ramp.width = 100;
      ramp.height = 1;
      let ctx = ramp.getContext("2d");
      let grd = ctx.createLinearGradient(0, 0, 100, 0);
      let colorScheme = this.colorScheme;
      if (colorScheme.step.length > 0) {
        for (let i = 0, len = colorScheme.step.length; i < len; i++) {
          grd.addColorStop(colorScheme.step[i], colorScheme.color[i]);
        }
      }
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, 100, 1);
      return ramp;
    }
  };
  var ElevationAnalysis_default = ElevationAnalysis;

  // Source/custom/analysis/SectionAnalysis.js
  var computeStepSurfaceLine3 = Poly_default.computeStepSurfaceLine;
  var SectionAnalysis = class {
    constructor(viewer3, options = {}) {
      this._map = viewer3;
      this.options = options;
      this.options.splitNum = Cesium.defaultValue(this.options.splitNum, 10);
    }
    sectionForTerrain(positions, callback) {
      if (positions.length < 2) {
        return;
      }
      let all_distance = 0;
      let arrLen = [];
      let arrHB = [];
      let arrPoint = [];
      computeStepSurfaceLine3({
        map: this._map,
        positions,
        splitNum: this.options.splitNum,
        has3dtiles: this.options.has3dtiles,
        minDistance: this.options.minDistance,
        endItem: (raisedPositions, noHeight, index) => {
          if (!positions || !positions[index] || !positions[index + 1]) {
            return;
          }
          let h1 = Cesium.Cartographic.fromCartesian(positions[index])?.height;
          let h2 = Cesium.Cartographic.fromCartesian(positions[index + 1])?.height;
          let hstep = (h2 - h1) / raisedPositions.length;
          let this_distance = 0;
          for (let i = 0; i < raisedPositions.length; i++) {
            if (i != 0) {
              let templen = Cesium.Cartesian3.distance(raisedPositions[i], raisedPositions[i - 1]);
              all_distance += templen;
              this_distance += templen;
            }
            arrLen.push(Number(all_distance.toFixed(1)));
            let point2 = LatLngPoint_default.fromCartesian(raisedPositions[i]);
            arrHB.push(point2.alt);
            arrPoint.push(point2);
          }
          index++;
        },
        end: () => {
          let result = {
            distance: all_distance,
            arrLen,
            arrHB,
            arrPoint
          };
          callback(result);
        }
      });
    }
  };
  var SectionAnalysis_default = SectionAnalysis;

  // Source/custom/analysis/SightLineAnalysis.js
  var SightLineAnalysis = class {
    constructor(viewer3, options = {}) {
      this._map = viewer3;
      this._visibleColor = Cesium.defaultValue(options.visibleColor, new Cesium.Color(0, 1, 0, 1));
      this._hiddenColor = Cesium.defaultValue(options.hiddenColor, new Cesium.Color(1, 0, 0, 1));
      this._depthFailColor = options.depthFailColor;
      this.origin = options.origin;
      this.target = options.target;
      this.offsetHeight = Cesium.defaultValue(options.offsetHeight, 1.5);
      this.lines = [];
      this.add();
    }
    get visibleColor() {
      return this._visibleColor;
    }
    set visibleColor(val) {
      this._visibleColor = val;
    }
    get hiddenColor() {
      return this._hiddenColor;
    }
    set hiddenColor(val) {
      this._hiddenColor = val;
    }
    get depthFailColor() {
      return this._depthFailColor;
    }
    set depthFailColor(val) {
      this._depthFailColor = val;
    }
    _bindMourseEvent() {
      this.handler = new Cesium.ScreenSpaceEventHandler(this._map.canvas);
      this.handler.setInputAction(this._onClickHandler.bind(this), Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.setInputAction(this._onMouseMoveHandler.bind(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
    _unbindMourseEvent() {
      if (this.handler) {
        this.handler.destroy();
        delete this.handler;
      }
    }
    _onClickHandler(event) {
      var position = event.position;
      var cartesian2 = this._map.scene.pickPosition(position);
      if (!Cesium.defined(cartesian2)) {
        return;
      }
      if (!this.origin) {
        if (this.offsetHeight) {
          cartesian2 = this.addPositionsHeight(cartesian2, this.offsetHeight);
        }
        this.origin = cartesian2;
      } else {
        this._unbindMourseEvent();
      }
    }
    _onMouseMoveHandler(event) {
      var position = event.endPosition;
      var cartesian2 = this._map.scene.pickPosition(position);
      if (!Cesium.defined(cartesian2)) {
        return;
      }
      if (this.origin) {
        this.target = cartesian2;
        this.analysis(this.origin, this.target);
      }
    }
    add() {
      if (this.origin && this.target) {
        if (this.offsetHeight) {
          this.origin = this.addPositionsHeight(this.origin, this.offsetHeight);
        }
        this.analysis(this.origin, this.target);
      } else {
        this._bindMourseEvent();
      }
    }
    analysis(origin, target) {
      this.clear();
      let old_depthTestAgainstTerrain = this._map.scene.globe.depthTestAgainstTerrain;
      this._map.scene.globe.depthTestAgainstTerrain = true;
      let currDir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(target, origin, new Cesium.Cartesian3()), new Cesium.Cartesian3());
      let currRay = new Cesium.Ray(origin, currDir);
      let pickRes = this._map.scene.drillPickFromRay(currRay, 2, this.lines);
      if (Cesium.defined(pickRes) && pickRes.length > 0 && Cesium.defined(pickRes[0]) && Cesium.defined(pickRes[0].position)) {
        let position = pickRes[0].position;
        let distance = Cesium.Cartesian3.distance(origin, target);
        let distanceFx = Cesium.Cartesian3.distance(origin, position);
        if (distanceFx < distance) {
          this._map.scene.globe.depthTestAgainstTerrain = old_depthTestAgainstTerrain;
          let arrEentity2 = this._showPolyline(origin, target, position);
          let result2 = {
            block: true,
            position,
            entity: arrEentity2
          };
          return result2;
        }
      }
      this._map.scene.globe.depthTestAgainstTerrain = old_depthTestAgainstTerrain;
      let arrEentity = this._showPolyline(origin, target);
      let result = {
        block: false,
        entity: arrEentity
      };
      return result;
    }
    addPositionsHeight(positions, addHeight = 0) {
      addHeight = Number(addHeight);
      if (isNaN(addHeight) || addHeight == 0) {
        return positions;
      }
      if (Array.isArray(positions)) {
        let arr2 = [];
        for (let i = 0, len = positions.length; i < len; i++) {
          let car = Cesium.Cartographic.fromCartesian(positions[i]);
          let point2 = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, car.height + addHeight);
          arr2.push(point2);
        }
        return arr2;
      } else {
        let car = Cesium.Cartographic.fromCartesian(positions);
        return Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, car.height + addHeight);
      }
    }
    _showPolyline(origin, target, position) {
      if (position) {
        let entity1 = this._map.entities.add(
          new Cesium.Entity({
            polyline: {
              positions: [origin, position],
              width: 2,
              material: this._visibleColor,
              depthFailMaterial: this._depthFailColor
            }
          })
        );
        this.lines.push(entity1);
        let entity2 = this._map.entities.add(
          new Cesium.Entity({
            polyline: {
              positions: [position, target],
              width: 2,
              material: this._hiddenColor,
              depthFailMaterial: this._depthFailColor
            }
          })
        );
        this.lines.push(entity2);
        return [entity1, entity2];
      } else {
        let entity = this._map.entities.add(
          new Cesium.Entity({
            polyline: {
              positions: [origin, target],
              width: 2,
              material: this._visibleColor,
              depthFailMaterial: this._depthFailColor
            }
          })
        );
        this.lines.push(entity);
        return [entity];
      }
    }
    clear() {
      for (let i = 0, len = this.lines.length; i < len; i++) {
        this._map.entities.remove(this.lines[i]);
      }
      this.lines = [];
    }
  };
  var SightLineAnalysis_default = SightLineAnalysis;

  // Source/custom/analysis/SlopeAnalysis.js
  var SlopeAnalysis = class extends TerrainEditBase_default {
    constructor(viewer3, options = {}) {
      super(viewer3, options);
      this.colorScheme = options.colorScheme || {
        step: [0, 0.29, 0.5, Math.sqrt(2) / 2, 0.87, 0.91, 1],
        color: ["#000000", "#2747E0", "#D33B7D", "#D33038", "#FF9742", "#FF9742", "#ffd700"]
      };
    }
    clear() {
      super.clear();
      this._map.scene.globe.material = null;
      if (this.hasResetEnableLighting) {
        this._map.scene.globe.enableLighting = false;
        this._map.clock.currentTime = Cesium.JulianDate.now();
        delete this.hasResetEnableLighting;
      }
    }
    updateMaterial() {
      let material;
      let shadingUniforms;
      material = Cesium.Material.fromType("SlopeRamp");
      shadingUniforms = material.uniforms;
      shadingUniforms.minimumHeight = this.minHeight;
      shadingUniforms.maximumHeight = this.maxHeight;
      shadingUniforms.image = this.getColorRamp();
      if (!this._map.scene.globe.enableLighting) {
        this._map.scene.globe.enableLighting = true;
        let now2 = new Date();
        now2.setHours(10);
        this._map.clock.currentTime = Cesium.JulianDate.fromDate(new Date(now2));
        this.hasResetEnableLighting = true;
      }
      this._map.scene.globe.material = material;
    }
    addPolygon(positions, options) {
      let areaObj = super.addPolygon(positions, options);
      this.updateMaterial();
      return areaObj;
    }
    getColorRamp() {
      let ramp = document.createElement("canvas");
      ramp.width = 100;
      ramp.height = 1;
      let ctx = ramp.getContext("2d");
      let grd = ctx.createLinearGradient(0, 0, 100, 0);
      let colorScheme = this.colorScheme;
      if (colorScheme.step.length > 0) {
        for (let i = 0, len = colorScheme.step.length; i < len; i++) {
          grd.addColorStop(colorScheme.step[i], colorScheme.color[i]);
        }
      }
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, 100, 1);
      return ramp;
    }
  };
  var SlopeAnalysis_default = SlopeAnalysis;

  // Source/custom/shaders/PhasedArrayRadar.js
  var PhasedArrayRadar_default = `uniform vec4 u_intersectionColor;
uniform float u_intersectionWidth;
uniform vec4 u_lineColor;

bool inSensorShadow(vec3 coneVertexWC, vec3 pointWC)
{
    // Diagonal matrix from the unscaled ellipsoid space to the scaled space.    
    vec3 D = czm_ellipsoidInverseRadii;

    // Sensor vertex in the scaled ellipsoid space
    vec3 q = D * coneVertexWC;
    float qMagnitudeSquared = dot(q, q);
    float test = qMagnitudeSquared - 1.0;
    
    // Sensor vertex to fragment vector in the ellipsoid's scaled space
    vec3 temp = D * pointWC - q;
    float d = dot(temp, q);
    
    // Behind silhouette plane and inside silhouette cone
    return (d < -test) && (d / length(temp) < -sqrt(test));
}

///////////////////////////////////////////////////////////////////////////////

vec4 getLineColor()
{
    return u_lineColor;
}

vec4 getIntersectionColor()
{
    return u_intersectionColor;
}

float getIntersectionWidth()
{
    return u_intersectionWidth;
}

vec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC)
{
    // (s, t) both in the range [0, 1]
    float t = pointMC.z / sensorRadius;
    float s = 1.0 + (atan(pointMC.y, pointMC.x) / czm_twoPi);
    s = s - floor(s);
    
    return vec2(s, t);
}`;

  // Source/custom/shaders/PhasedArrayRadarFS.js
  var PhasedArrayRadarFS_default = `#ifdef GL_OES_standard_derivatives
    #extension GL_OES_standard_derivatives : enable
#endif

uniform bool u_showIntersection;
uniform bool u_showThroughEllipsoid;

uniform float u_radius;
uniform float u_xHalfAngle;
uniform float u_yHalfAngle;
uniform float u_normalDirection;
uniform float u_type;

varying vec3 v_position;
varying vec3 v_positionWC;
varying vec3 v_positionEC;
varying vec3 v_normalEC;

vec4 getColor(float sensorRadius, vec3 pointEC)
{
    czm_materialInput materialInput;

    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;
    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);
    materialInput.str = pointMC / sensorRadius;

    vec3 positionToEyeEC = -v_positionEC;
    materialInput.positionToEyeEC = positionToEyeEC;

    vec3 normalEC = normalize(v_normalEC);
    materialInput.normalEC = u_normalDirection * normalEC;

    czm_material material = czm_getMaterial(materialInput);
    // czm_lightDirectionEC\u5728cesium1.66\u5F00\u59CB\u52A0\u5165\u7684
    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);

}

bool isOnBoundary(float value, float epsilon)
{
    float width = getIntersectionWidth();
    float tolerance = width * epsilon;

#ifdef GL_OES_standard_derivatives
    float delta = max(abs(dFdx(value)), abs(dFdy(value)));
    float pixels = width * delta;
    float temp = abs(value);
    // There are a couple things going on here.
    // First we test the value at the current fragment to see if it is within the tolerance.
    // We also want to check if the value of an adjacent pixel is within the tolerance,
    // but we don't want to admit points that are obviously not on the surface.
    // For example, if we are looking for "value" to be close to 0, but value is 1 and the adjacent value is 2,
    // then the delta would be 1 and "temp - delta" would be "1 - 1" which is zero even though neither of
    // the points is close to zero.
    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);
#else
    return abs(value) < tolerance;
#endif
}

vec4 shade(bool isOnBoundary)
{
    if (u_showIntersection && isOnBoundary)
    {
        return getIntersectionColor();
    }
    if(u_type == 1.0){
        return getLineColor();
    }
    return getColor(u_radius, v_positionEC);
}

float ellipsoidSurfaceFunction(vec3 point)
{
    vec3 scaled = czm_ellipsoidInverseRadii * point;
    return dot(scaled, scaled) - 1.0;
}

void main()
{
    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates
    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates

    //vec3 pixDir = normalize(v_position);
    float positionX = v_position.x;
    float positionY = v_position.y;
    float positionZ = v_position.z;

    vec3 zDir = vec3(0.0, 0.0, 1.0);
    vec3 lineX = vec3(positionX, 0 ,positionZ);
    vec3 lineY = vec3(0, positionY, positionZ);
    float resX = dot(normalize(lineX), zDir);
    if(resX < cos(u_xHalfAngle)-0.00001){
        discard;
    }
    float resY = dot(normalize(lineY), zDir);
    if(resY < cos(u_yHalfAngle)-0.00001){
        discard;
    }


    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);

    // Occluded by the ellipsoid?
	if (!u_showThroughEllipsoid)
	{
	    // Discard if in the ellipsoid
	    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.
	    if (ellipsoidValue < 0.0)
	    {
            discard;
	    }

	    // Discard if in the sensor's shadow
	    if (inSensorShadow(sensorVertexWC, v_positionWC))
	    {
	        discard;
	    }
    }

    // Notes: Each surface functions should have an associated tolerance based on the floating point error.
    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);
    //isOnEllipsoid = false;
    //if((resX >= 0.8 && resX <= 0.81)||(resY >= 0.8 && resY <= 0.81)){
    /*if(false){
        gl_FragColor = vec4(1.0,0.0,0.0,1.0);
    }else{
        gl_FragColor = shade(isOnEllipsoid);
    }
*/
    gl_FragColor = shade(isOnEllipsoid);

}`;

  // Source/custom/shaders/PhasedArrayRadarVS.js
  var PhasedArrayRadarVS_default = `attribute vec4 position;
attribute vec3 normal;

varying vec3 v_position;
varying vec3 v_positionWC;
varying vec3 v_positionEC;
varying vec3 v_normalEC;

void main()
{
    gl_Position = czm_modelViewProjection * position;
    v_position = vec3(position);
    v_positionWC = (czm_model * position).xyz;
    v_positionEC = (czm_modelView * position).xyz;
    v_normalEC = czm_normal * normal;
}`;

  // Source/custom/shaders/PhasedArrayRadarScanPlaneFS.js
  var PhasedArrayRadarScanPlaneFS_default = `#ifdef GL_OES_standard_derivatives
    #extension GL_OES_standard_derivatives : enable
#endif

uniform bool u_showIntersection;
uniform bool u_showThroughEllipsoid;

uniform float u_radius;
uniform float u_xHalfAngle;
uniform float u_yHalfAngle;
uniform float u_normalDirection;
uniform vec4 u_color;

varying vec3 v_position;
varying vec3 v_positionWC;
varying vec3 v_positionEC;
varying vec3 v_normalEC;

vec4 getColor(float sensorRadius, vec3 pointEC)
{
    czm_materialInput materialInput;

    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;
    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);
    materialInput.str = pointMC / sensorRadius;

    vec3 positionToEyeEC = -v_positionEC;
    materialInput.positionToEyeEC = positionToEyeEC;

    vec3 normalEC = normalize(v_normalEC);
    materialInput.normalEC = u_normalDirection * normalEC;

    czm_material material = czm_getMaterial(materialInput);

    material.diffuse = u_color.rgb;
    material.alpha = u_color.a;
    // czm_lightDirectionEC\u5728cesium1.66\u5F00\u59CB\u52A0\u5165\u7684
    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);

}

bool isOnBoundary(float value, float epsilon)
{
    float width = getIntersectionWidth();
    float tolerance = width * epsilon;

#ifdef GL_OES_standard_derivatives
    float delta = max(abs(dFdx(value)), abs(dFdy(value)));
    float pixels = width * delta;
    float temp = abs(value);
    // There are a couple things going on here.
    // First we test the value at the current fragment to see if it is within the tolerance.
    // We also want to check if the value of an adjacent pixel is within the tolerance,
    // but we don't want to admit points that are obviously not on the surface.
    // For example, if we are looking for "value" to be close to 0, but value is 1 and the adjacent value is 2,
    // then the delta would be 1 and "temp - delta" would be "1 - 1" which is zero even though neither of
    // the points is close to zero.
    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);
#else
    return abs(value) < tolerance;
#endif
}

vec4 shade(bool isOnBoundary)
{
    if (u_showIntersection && isOnBoundary)
    {
        return getIntersectionColor();
    }
    return getColor(u_radius, v_positionEC);
}

float ellipsoidSurfaceFunction(vec3 point)
{
    vec3 scaled = czm_ellipsoidInverseRadii * point;
    return dot(scaled, scaled) - 1.0;
}

void main()
{
    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates
    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates

    //vec3 pixDir = normalize(v_position);
    float positionX = v_position.x;
    float positionY = v_position.y;
    float positionZ = v_position.z;

    vec3 zDir = vec3(0.0, 0.0, 1.0);
    vec3 lineX = vec3(positionX, 0 ,positionZ);
    vec3 lineY = vec3(0, positionY, positionZ);
    float resX = dot(normalize(lineX), zDir);
    if(resX < cos(u_xHalfAngle) - 0.0001){
        discard;
    }
    float resY = dot(normalize(lineY), zDir);
    if(resY < cos(u_yHalfAngle)- 0.0001){
        discard;
    }


    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);

    // Occluded by the ellipsoid?
	if (!u_showThroughEllipsoid)
	{
	    // Discard if in the ellipsoid
	    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.
	    if (ellipsoidValue < 0.0)
	    {
            discard;
	    }

	    // Discard if in the sensor's shadow
	    if (inSensorShadow(sensorVertexWC, v_positionWC))
	    {
	        discard;
	    }
    }

    // Notes: Each surface functions should have an associated tolerance based on the floating point error.
    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);
    gl_FragColor = shade(isOnEllipsoid);
}`;

  // Source/custom/primitive/PhasedArrayRadarPrimitive.js
  var BoundingSphere = Cesium.BoundingSphere;
  var Cartesian3 = Cesium.Cartesian3;
  var Color = Cesium.Color;
  var combine = Cesium.combine;
  var ComponentDatatype = Cesium.ComponentDatatype;
  var defaultValue = Cesium.defaultValue;
  var defined = Cesium.defined;
  var DeveloperError = Cesium.DeveloperError;
  var Matrix4 = Cesium.Matrix4;
  var PrimitiveType = Cesium.PrimitiveType;
  var Buffer2 = Cesium.Buffer;
  var BufferUsage = Cesium.BufferUsage;
  var DrawCommand = Cesium.DrawCommand;
  var Pass = Cesium.Pass;
  var RenderState = Cesium.RenderState;
  var ShaderProgram = Cesium.ShaderProgram;
  var ShaderSource = Cesium.ShaderSource;
  var VertexArray = Cesium.VertexArray;
  var BlendingState = Cesium.BlendingState;
  var CullFace = Cesium.CullFace;
  var Material = Cesium.Material;
  var SceneMode = Cesium.SceneMode;
  var VertexFormat = Cesium.VertexFormat;
  var CesiumMath2 = Cesium.Math;
  var Matrix3 = Cesium.Matrix3;
  var JulianDate = Cesium.JulianDate;
  var sin2 = Math.sin;
  var cos2 = Math.cos;
  var tan2 = Math.tan;
  var atan3 = Math.atan;
  var attributeLocations = {
    position: 0,
    normal: 1
  };
  function PhasedArrayRadarPrimitive(options) {
    let that = this;
    options = defaultValue(options, defaultValue.EMPTY_OBJECT);
    this.show = defaultValue(options.show, true);
    this.slice = defaultValue(options.slice, 32);
    this.modelMatrix = Matrix4.clone(options.modelMatrix, new Matrix4());
    this._modelMatrix = new Matrix4();
    this._computedModelMatrix = new Matrix4();
    this._computedScanPlaneModelMatrix = new Matrix4();
    this.radius = defaultValue(options.radius, Number.POSITIVE_INFINITY);
    this._radius = void 0;
    this.xHalfAngle = defaultValue(options.xHalfAngle, 0);
    this._xHalfAngle = void 0;
    this.yHalfAngle = defaultValue(options.yHalfAngle, 0);
    this._yHalfAngle = void 0;
    this.lineColor = defaultValue(options.lineColor, Color.WHITE);
    this.showSectorLines = defaultValue(options.showSectorLines, true);
    this.showSectorSegmentLines = defaultValue(options.showSectorSegmentLines, true);
    this.showLateralSurfaces = defaultValue(options.showLateralSurfaces, true);
    this.material = defined(options.material) ? options.material : Material.fromType(Material.ColorType);
    this._material = void 0;
    this._translucent = void 0;
    this.lateralSurfaceMaterial = defined(options.lateralSurfaceMaterial) ? options.lateralSurfaceMaterial : Material.fromType(Material.ColorType);
    this._lateralSurfaceMaterial = void 0;
    this._lateralSurfaceTranslucent = void 0;
    this.showDomeSurfaces = defaultValue(options.showDomeSurfaces, true);
    this.domeSurfaceMaterial = defined(options.domeSurfaceMaterial) ? options.domeSurfaceMaterial : Material.fromType(Material.ColorType);
    this._domeSurfaceMaterial = void 0;
    this.showDomeLines = defaultValue(options.showDomeLines, true);
    this.showIntersection = defaultValue(options.showIntersection, true);
    this.intersectionColor = defaultValue(options.intersectionColor, Color.WHITE);
    this.intersectionWidth = defaultValue(options.intersectionWidth, 5);
    this.showThroughEllipsoid = defaultValue(options.showThroughEllipsoid, false);
    this._showThroughEllipsoid = void 0;
    this.showScanPlane = defaultValue(options.showScanPlane, true);
    this.scanPlaneColor = defaultValue(options.scanPlaneColor, Color.WHITE);
    this.scanPlaneMode = defaultValue(options.scanPlaneMode, "horizontal");
    this.scanPlaneRate = defaultValue(options.scanPlaneRate, 10);
    this._scanePlaneXHalfAngle = 0;
    this._scanePlaneYHalfAngle = 0;
    this._time = JulianDate.now();
    this._boundingSphere = new BoundingSphere();
    this._boundingSphereWC = new BoundingSphere();
    this._sectorFrontCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.TRIANGLES,
      boundingVolume: this._boundingSphereWC
    });
    this._sectorBackCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.TRIANGLES,
      boundingVolume: this._boundingSphereWC
    });
    this._sectorVA = void 0;
    this._sectorLineCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.LINES,
      boundingVolume: this._boundingSphereWC
    });
    this._sectorLineVA = void 0;
    this._sectorSegmentLineCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.LINES,
      boundingVolume: this._boundingSphereWC
    });
    this._sectorSegmentLineVA = void 0;
    this._domeFrontCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.TRIANGLES,
      boundingVolume: this._boundingSphereWC
    });
    this._domeBackCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.TRIANGLES,
      boundingVolume: this._boundingSphereWC
    });
    this._domeVA = void 0;
    this._domeLineCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.LINES,
      boundingVolume: this._boundingSphereWC
    });
    this._domeLineVA = void 0;
    this._scanPlaneFrontCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.TRIANGLES,
      boundingVolume: this._boundingSphereWC
    });
    this._scanPlaneBackCommand = new DrawCommand({
      owner: this,
      primitiveType: PrimitiveType.TRIANGLES,
      boundingVolume: this._boundingSphereWC
    });
    this._scanRadialCommand = void 0;
    this._colorCommands = [];
    this._frontFaceRS = void 0;
    this._backFaceRS = void 0;
    this._sp = void 0;
    this._uniforms = {
      u_type: function() {
        return 0;
      },
      u_xHalfAngle: function() {
        return that.xHalfAngle;
      },
      u_yHalfAngle: function() {
        return that.yHalfAngle;
      },
      u_radius: function() {
        return that.radius;
      },
      u_showThroughEllipsoid: function() {
        return that.showThroughEllipsoid;
      },
      u_showIntersection: function() {
        return that.showIntersection;
      },
      u_intersectionColor: function() {
        return that.intersectionColor;
      },
      u_intersectionWidth: function() {
        return that.intersectionWidth;
      },
      u_normalDirection: function() {
        return 1;
      },
      u_lineColor: function() {
        return that.lineColor;
      }
    };
    this._scanUniforms = {
      u_xHalfAngle: function() {
        return that._scanePlaneXHalfAngle;
      },
      u_yHalfAngle: function() {
        return that._scanePlaneYHalfAngle;
      },
      u_radius: function() {
        return that.radius;
      },
      u_color: function() {
        return that.scanPlaneColor;
      },
      u_showThroughEllipsoid: function() {
        return that.showThroughEllipsoid;
      },
      u_showIntersection: function() {
        return that.showIntersection;
      },
      u_intersectionColor: function() {
        return that.intersectionColor;
      },
      u_intersectionWidth: function() {
        return that.intersectionWidth;
      },
      u_normalDirection: function() {
        return 1;
      },
      u_lineColor: function() {
        return that.lineColor;
      }
    };
  }
  PhasedArrayRadarPrimitive.prototype.update = function(frameState) {
    let mode2 = frameState.mode;
    if (!this.show || mode2 != SceneMode.SCENE3D) {
      return;
    }
    let createVS = false;
    let createRS = false;
    let createSP = false;
    let xHalfAngle = this.xHalfAngle;
    let yHalfAngle = this.yHalfAngle;
    if (xHalfAngle < 0 || yHalfAngle < 0) {
      throw new DeveloperError("halfAngle must be greater than or equal to zero.");
    }
    if (xHalfAngle == 0 || yHalfAngle == 0) {
      return;
    }
    if (this._xHalfAngle != xHalfAngle || this._yHalfAngle != yHalfAngle) {
      this._xHalfAngle = xHalfAngle;
      this._yHalfAngle = yHalfAngle;
      createVS = true;
    }
    let radius = this.radius;
    if (radius < 0) {
      throw new DeveloperError("this.radius must be greater than or equal to zero.");
    }
    let radiusChanged = false;
    if (this._radius != radius) {
      radiusChanged = true;
      this._radius = radius;
      this._boundingSphere = new BoundingSphere(Cartesian3.ZERO, this.radius);
    }
    let modelMatrixChanged = !Matrix4.equals(this.modelMatrix, this._modelMatrix);
    if (modelMatrixChanged || radiusChanged) {
      Matrix4.clone(this.modelMatrix, this._modelMatrix);
      Matrix4.multiplyByUniformScale(this.modelMatrix, this.radius, this._computedModelMatrix);
      BoundingSphere.transform(this._boundingSphere, this.modelMatrix, this._boundingSphereWC);
    }
    let showThroughEllipsoid = this.showThroughEllipsoid;
    if (this._showThroughEllipsoid != this.showThroughEllipsoid) {
      this._showThroughEllipsoid = showThroughEllipsoid;
      createRS = true;
    }
    let material = this.material;
    if (this._material != material) {
      this._material = material;
      createRS = true;
      createSP = true;
    }
    let translucent = material.isTranslucent();
    if (this._translucent != translucent) {
      this._translucent = translucent;
      createRS = true;
    }
    if (this.showScanPlane) {
      let time = frameState.time;
      let timeDiff = JulianDate.secondsDifference(time, this._time);
      if (timeDiff < 0) {
        this._time = JulianDate.clone(time, this._time);
      }
      let percentage = Math.max(timeDiff % this.scanPlaneRate / this.scanPlaneRate, 0);
      let angle;
      let matrix3Scratch = new Matrix3();
      if (this.scanPlaneMode == "horizontal") {
        angle = 2 * yHalfAngle * percentage - yHalfAngle;
        let cosYHalfAngle = cos2(angle);
        let tanXHalfAngle = tan2(xHalfAngle);
        let maxX = atan3(cosYHalfAngle * tanXHalfAngle);
        this._scanePlaneXHalfAngle = maxX;
        this._scanePlaneYHalfAngle = angle;
        Cesium.Matrix3.fromRotationX(this._scanePlaneYHalfAngle, matrix3Scratch);
      } else {
        angle = 2 * xHalfAngle * percentage - xHalfAngle;
        let tanYHalfAngle = tan2(yHalfAngle);
        let cosXHalfAngle = cos2(angle);
        let maxY = atan3(cosXHalfAngle * tanYHalfAngle);
        this._scanePlaneXHalfAngle = angle;
        this._scanePlaneYHalfAngle = maxY;
        Cesium.Matrix3.fromRotationY(this._scanePlaneXHalfAngle, matrix3Scratch);
      }
      Cesium.Matrix4.multiplyByMatrix3(this.modelMatrix, matrix3Scratch, this._computedScanPlaneModelMatrix);
      Matrix4.multiplyByUniformScale(this._computedScanPlaneModelMatrix, this.radius, this._computedScanPlaneModelMatrix);
    }
    if (createVS) {
      createVertexArray(this, frameState);
    }
    if (createRS) {
      createRenderState(this, showThroughEllipsoid, translucent);
    }
    if (createSP) {
      createShaderProgram(this, frameState, material);
    }
    if (createRS || createSP || this.redrawRS) {
      createCommands(this, translucent);
      this.redrawRS = false;
    }
    let commandList = frameState.commandList;
    let passes = frameState.passes;
    let colorCommands = this._colorCommands;
    if (passes.render) {
      for (let i = 0, len = colorCommands.length; i < len; i++) {
        let colorCommand = colorCommands[i];
        commandList.push(colorCommand);
      }
    }
  };
  var nScratch = new Cartesian3();
  function computeUnitPosiiton(primitive, xHalfAngle, yHalfAngle) {
    let slice3 = primitive.slice;
    let cosYHalfAngle = cos2(yHalfAngle);
    let tanYHalfAngle = tan2(yHalfAngle);
    let cosXHalfAngle = cos2(xHalfAngle);
    let tanXHalfAngle = tan2(xHalfAngle);
    let maxY = atan3(cosXHalfAngle * tanYHalfAngle);
    let maxX = atan3(cosYHalfAngle * tanXHalfAngle);
    let zoy = [];
    for (let i = 0; i < slice3; i++) {
      let phi = 2 * maxY * i / (slice3 - 1) - maxY;
      zoy.push(new Cartesian3(0, sin2(phi), cos2(phi)));
    }
    let zox = [];
    for (let i = 0; i < slice3; i++) {
      let phi = 2 * maxX * i / (slice3 - 1) - maxX;
      zox.push(new Cartesian3(sin2(phi), 0, cos2(phi)));
    }
    return {
      zoy,
      zox
    };
  }
  function computeSectorPositions(primitive, unitPosition) {
    let xHalfAngle = primitive.xHalfAngle, yHalfAngle = primitive.yHalfAngle, zoy = unitPosition.zoy, zox = unitPosition.zox;
    let positions = [];
    let matrix3Scratch = new Matrix3();
    let matrix3 = Matrix3.fromRotationY(xHalfAngle, matrix3Scratch);
    positions.push(
      zoy.map(function(p) {
        return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
      })
    );
    matrix3 = Matrix3.fromRotationX(-yHalfAngle, matrix3Scratch);
    positions.push(
      zox.map(function(p) {
        return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
      }).reverse()
    );
    matrix3 = Matrix3.fromRotationY(-xHalfAngle, matrix3Scratch);
    positions.push(
      zoy.map(function(p) {
        return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
      }).reverse()
    );
    matrix3 = Matrix3.fromRotationX(yHalfAngle, matrix3Scratch);
    positions.push(
      zox.map(function(p) {
        return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
      })
    );
    return positions;
  }
  function createSectorVertexArray(context, positions) {
    let planeLength = Array.prototype.concat.apply([], positions).length - positions.length;
    let vertices = new Float32Array(2 * 3 * 3 * planeLength);
    let k = 0;
    for (let i = 0, len = positions.length; i < len; i++) {
      let planePositions = positions[i];
      let n = Cartesian3.normalize(Cartesian3.cross(planePositions[0], planePositions[planePositions.length - 1], nScratch), nScratch);
      for (let j = 0, planeLen = planePositions.length - 1; j < planeLen; j++) {
        vertices[k++] = 0;
        vertices[k++] = 0;
        vertices[k++] = 0;
        vertices[k++] = -n.x;
        vertices[k++] = -n.y;
        vertices[k++] = -n.z;
        vertices[k++] = planePositions[j].x;
        vertices[k++] = planePositions[j].y;
        vertices[k++] = planePositions[j].z;
        vertices[k++] = -n.x;
        vertices[k++] = -n.y;
        vertices[k++] = -n.z;
        vertices[k++] = planePositions[j + 1].x;
        vertices[k++] = planePositions[j + 1].y;
        vertices[k++] = planePositions[j + 1].z;
        vertices[k++] = -n.x;
        vertices[k++] = -n.y;
        vertices[k++] = -n.z;
      }
    }
    let vertexBuffer = Buffer2.createVertexBuffer({
      context,
      typedArray: vertices,
      usage: BufferUsage.STATIC_DRAW
    });
    let stride = 2 * 3 * Float32Array.BYTES_PER_ELEMENT;
    let attributes = [
      {
        index: attributeLocations.position,
        vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 0,
        strideInBytes: stride
      },
      {
        index: attributeLocations.normal,
        vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 3 * Float32Array.BYTES_PER_ELEMENT,
        strideInBytes: stride
      }
    ];
    return new VertexArray({
      context,
      attributes
    });
  }
  function createSectorLineVertexArray(context, positions) {
    let planeLength = positions.length;
    let vertices = new Float32Array(3 * 3 * planeLength);
    let k = 0;
    for (let i = 0, len = positions.length; i < len; i++) {
      let planePositions = positions[i];
      vertices[k++] = 0;
      vertices[k++] = 0;
      vertices[k++] = 0;
      vertices[k++] = planePositions[0].x;
      vertices[k++] = planePositions[0].y;
      vertices[k++] = planePositions[0].z;
    }
    let vertexBuffer = Buffer2.createVertexBuffer({
      context,
      typedArray: vertices,
      usage: BufferUsage.STATIC_DRAW
    });
    let stride = 3 * Float32Array.BYTES_PER_ELEMENT;
    let attributes = [
      {
        index: attributeLocations.position,
        vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 0,
        strideInBytes: stride
      }
    ];
    return new VertexArray({
      context,
      attributes
    });
  }
  function createSectorSegmentLineVertexArray(context, positions) {
    let planeLength = Array.prototype.concat.apply([], positions).length - positions.length;
    let vertices = new Float32Array(3 * 3 * planeLength);
    let k = 0;
    for (let i = 0, len = positions.length; i < len; i++) {
      let planePositions = positions[i];
      for (let j = 0, planeLen = planePositions.length - 1; j < planeLen; j++) {
        vertices[k++] = planePositions[j].x;
        vertices[k++] = planePositions[j].y;
        vertices[k++] = planePositions[j].z;
        vertices[k++] = planePositions[j + 1].x;
        vertices[k++] = planePositions[j + 1].y;
        vertices[k++] = planePositions[j + 1].z;
      }
    }
    let vertexBuffer = Buffer2.createVertexBuffer({
      context,
      typedArray: vertices,
      usage: BufferUsage.STATIC_DRAW
    });
    let stride = 3 * Float32Array.BYTES_PER_ELEMENT;
    let attributes = [
      {
        index: attributeLocations.position,
        vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 0,
        strideInBytes: stride
      }
    ];
    return new VertexArray({
      context,
      attributes
    });
  }
  function createDomeVertexArray(context) {
    let geometry = Cesium.EllipsoidGeometry.createGeometry(
      new Cesium.EllipsoidGeometry({
        vertexFormat: VertexFormat.POSITION_ONLY,
        stackPartitions: 32,
        slicePartitions: 32
      })
    );
    let vertexArray = VertexArray.fromGeometry({
      context,
      geometry,
      attributeLocations,
      bufferUsage: BufferUsage.STATIC_DRAW,
      interleave: false
    });
    return vertexArray;
  }
  function createDomeLineVertexArray(context) {
    let geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(
      new Cesium.EllipsoidOutlineGeometry({
        vertexFormat: VertexFormat.POSITION_ONLY,
        stackPartitions: 32,
        slicePartitions: 32
      })
    );
    let vertexArray = VertexArray.fromGeometry({
      context,
      geometry,
      attributeLocations,
      bufferUsage: BufferUsage.STATIC_DRAW,
      interleave: false
    });
    return vertexArray;
  }
  function createScanPlaneVertexArray(context, positions) {
    let planeLength = positions.length - 1;
    let vertices = new Float32Array(3 * 3 * planeLength);
    let k = 0;
    for (let i = 0; i < planeLength; i++) {
      vertices[k++] = 0;
      vertices[k++] = 0;
      vertices[k++] = 0;
      vertices[k++] = positions[i].x;
      vertices[k++] = positions[i].y;
      vertices[k++] = positions[i].z;
      vertices[k++] = positions[i + 1].x;
      vertices[k++] = positions[i + 1].y;
      vertices[k++] = positions[i + 1].z;
    }
    let vertexBuffer = Buffer2.createVertexBuffer({
      context,
      typedArray: vertices,
      usage: BufferUsage.STATIC_DRAW
    });
    let stride = 3 * Float32Array.BYTES_PER_ELEMENT;
    let attributes = [
      {
        index: attributeLocations.position,
        vertexBuffer,
        componentsPerAttribute: 3,
        componentDatatype: ComponentDatatype.FLOAT,
        offsetInBytes: 0,
        strideInBytes: stride
      }
    ];
    return new VertexArray({
      context,
      attributes
    });
  }
  function createVertexArray(primitive, frameState) {
    let context = frameState.context;
    let unitSectorPositions = computeUnitPosiiton(primitive, primitive.xHalfAngle, primitive.yHalfAngle);
    let positions = computeSectorPositions(primitive, unitSectorPositions);
    if (primitive.showLateralSurfaces) {
      primitive._sectorVA = createSectorVertexArray(context, positions);
    }
    if (primitive.showSectorLines) {
      primitive._sectorLineVA = createSectorLineVertexArray(context, positions);
    }
    if (primitive.showSectorSegmentLines) {
      primitive._sectorSegmentLineVA = createSectorSegmentLineVertexArray(context, positions);
    }
    if (primitive.showDomeSurfaces) {
      primitive._domeVA = createDomeVertexArray(context);
    }
    if (primitive.showDomeLines) {
      primitive._domeLineVA = createDomeLineVertexArray(context);
    }
    if (primitive.showScanPlane) {
      if (primitive.scanPlaneMode == "horizontal") {
        let unitScanPlanePositions = computeUnitPosiiton(primitive, CesiumMath2.PI_OVER_TWO, 0);
        primitive._scanPlaneVA = createScanPlaneVertexArray(context, unitScanPlanePositions.zox);
      } else {
        let unitScanPlanePositions = computeUnitPosiiton(primitive, 0, CesiumMath2.PI_OVER_TWO);
        primitive._scanPlaneVA = createScanPlaneVertexArray(context, unitScanPlanePositions.zoy);
      }
    }
  }
  function createCommonShaderProgram(primitive, frameState, material) {
    let context = frameState.context;
    let vs = PhasedArrayRadarVS_default;
    let fs = new ShaderSource({
      sources: [PhasedArrayRadar_default, material.shaderSource, PhasedArrayRadarFS_default]
    });
    primitive._sp = ShaderProgram.replaceCache({
      context,
      shaderProgram: primitive._sp,
      vertexShaderSource: vs,
      fragmentShaderSource: fs,
      attributeLocations
    });
    let pickFS = new ShaderSource({
      sources: [PhasedArrayRadar_default, material.shaderSource, PhasedArrayRadarFS_default],
      pickColorQualifier: "uniform"
    });
    primitive._pickSP = ShaderProgram.replaceCache({
      context,
      shaderProgram: primitive._pickSP,
      vertexShaderSource: vs,
      fragmentShaderSource: pickFS,
      attributeLocations
    });
  }
  function createScanPlaneShaderProgram(primitive, frameState, material) {
    let context = frameState.context;
    let vs = PhasedArrayRadarVS_default;
    let fs = new ShaderSource({
      sources: [PhasedArrayRadar_default, material.shaderSource, PhasedArrayRadarScanPlaneFS_default]
    });
    primitive._scanePlaneSP = ShaderProgram.replaceCache({
      context,
      shaderProgram: primitive._scanePlaneSP,
      vertexShaderSource: vs,
      fragmentShaderSource: fs,
      attributeLocations
    });
  }
  function createShaderProgram(primitive, frameState, material) {
    createCommonShaderProgram(primitive, frameState, material);
    if (primitive.showScanPlane) {
      createScanPlaneShaderProgram(primitive, frameState, material);
    }
  }
  function createRenderState(primitive, showThroughEllipsoid, translucent) {
    if (translucent) {
      primitive._frontFaceRS = RenderState.fromCache({
        depthTest: {
          enabled: !showThroughEllipsoid
        },
        depthMask: false,
        blending: BlendingState.ALPHA_BLEND,
        cull: {
          enabled: true,
          face: CullFace.BACK
        }
      });
      primitive._backFaceRS = RenderState.fromCache({
        depthTest: {
          enabled: !showThroughEllipsoid
        },
        depthMask: false,
        blending: BlendingState.ALPHA_BLEND,
        cull: {
          enabled: true,
          face: CullFace.FRONT
        }
      });
      primitive._pickRS = RenderState.fromCache({
        depthTest: {
          enabled: !showThroughEllipsoid
        },
        depthMask: false,
        blending: BlendingState.ALPHA_BLEND
      });
    } else {
      primitive._frontFaceRS = RenderState.fromCache({
        depthTest: {
          enabled: !showThroughEllipsoid
        },
        depthMask: true
      });
      primitive._pickRS = RenderState.fromCache({
        depthTest: {
          enabled: true
        },
        depthMask: true
      });
    }
  }
  function createCommand(primitive, frontCommand, backCommand, frontFaceRS, backFaceRS, sp, va, uniforms, modelMatrix, translucent, pass, isLine) {
    if (translucent && backCommand) {
      backCommand.vertexArray = va;
      backCommand.renderState = backFaceRS;
      backCommand.shaderProgram = sp;
      backCommand.uniformMap = combine(uniforms, primitive._material._uniforms);
      backCommand.uniformMap.u_normalDirection = function() {
        return -1;
      };
      backCommand.pass = pass;
      backCommand.modelMatrix = modelMatrix;
      primitive._colorCommands.push(backCommand);
    }
    frontCommand.vertexArray = va;
    frontCommand.renderState = frontFaceRS;
    frontCommand.shaderProgram = sp;
    frontCommand.uniformMap = combine(uniforms, primitive._material._uniforms);
    if (isLine) {
      frontCommand.uniformMap.u_type = function() {
        return 1;
      };
    }
    frontCommand.pass = pass;
    frontCommand.modelMatrix = modelMatrix;
    primitive._colorCommands.push(frontCommand);
  }
  function createCommands(primitive, translucent) {
    primitive._colorCommands.length = 0;
    let pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;
    if (primitive.showLateralSurfaces) {
      createCommand(
        primitive,
        primitive._sectorFrontCommand,
        primitive._sectorBackCommand,
        primitive._frontFaceRS,
        primitive._backFaceRS,
        primitive._sp,
        primitive._sectorVA,
        primitive._uniforms,
        primitive._computedModelMatrix,
        translucent,
        pass
      );
    }
    if (primitive.showSectorLines) {
      createCommand(
        primitive,
        primitive._sectorLineCommand,
        void 0,
        primitive._frontFaceRS,
        primitive._backFaceRS,
        primitive._sp,
        primitive._sectorLineVA,
        primitive._uniforms,
        primitive._computedModelMatrix,
        translucent,
        pass,
        true
      );
    }
    if (primitive.showSectorSegmentLines) {
      createCommand(
        primitive,
        primitive._sectorSegmentLineCommand,
        void 0,
        primitive._frontFaceRS,
        primitive._backFaceRS,
        primitive._sp,
        primitive._sectorSegmentLineVA,
        primitive._uniforms,
        primitive._computedModelMatrix,
        translucent,
        pass,
        true
      );
    }
    if (primitive.showDomeSurfaces) {
      createCommand(
        primitive,
        primitive._domeFrontCommand,
        primitive._domeBackCommand,
        primitive._frontFaceRS,
        primitive._backFaceRS,
        primitive._sp,
        primitive._domeVA,
        primitive._uniforms,
        primitive._computedModelMatrix,
        translucent,
        pass
      );
    }
    if (primitive.showDomeLines) {
      createCommand(
        primitive,
        primitive._domeLineCommand,
        void 0,
        primitive._frontFaceRS,
        primitive._backFaceRS,
        primitive._sp,
        primitive._domeLineVA,
        primitive._uniforms,
        primitive._computedModelMatrix,
        translucent,
        pass,
        true
      );
    }
    if (primitive.showScanPlane) {
      createCommand(
        primitive,
        primitive._scanPlaneFrontCommand,
        primitive._scanPlaneBackCommand,
        primitive._frontFaceRS,
        primitive._backFaceRS,
        primitive._scanePlaneSP,
        primitive._scanPlaneVA,
        primitive._scanUniforms,
        primitive._computedScanPlaneModelMatrix,
        translucent,
        pass
      );
    }
  }
  var PhasedArrayRadarPrimitive_default = PhasedArrayRadarPrimitive;

  // Source/custom/analysis/ViewShedAnalysis.js
  var fragmentShaderSource = `uniform float czzj;
uniform float dis;
uniform float spzj;
uniform vec3 visibleColor;
uniform vec3 disVisibleColor;
uniform float mixNum;
uniform sampler2D colorTexture;
uniform sampler2D viewShadow;
uniform sampler2D depthTexture;
uniform mat4 _shadowMap_matrix;
uniform vec4 shadowMap_lightPositionEC;
uniform vec3 shadowMap_lightPositionWC;
uniform vec4 shadowMap_lightDirectionEC;
uniform vec3 shadowMap_lightUp;
uniform vec3 shadowMap_lightDir;
uniform vec3 shadowMap_lightRight;
uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness;
uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth;
varying vec2 v_textureCoordinates;
vec4 toEye(in vec2 uv, in float depth){
    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));
    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);
    posInCamera =posInCamera / posInCamera.w;
    return posInCamera;
}
float getDepth(in vec4 depth){
    float z_window = czm_unpackDepth(depth);
    z_window = czm_reverseLogDepth(z_window);
    float n_range = czm_depthRange.near;
    float f_range = czm_depthRange.far;
    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);
}
float _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){
    return texture2D(shadowMap, uv).r;
}
float _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){
    return step(depth, _czm_sampleShadowMap(shadowMap, uv));
}
float _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){
    float depthBias = shadowParameters.depthBias;
    float depth = shadowParameters.depth;
    float nDotL = shadowParameters.nDotL;
    float normalShadingSmooth = shadowParameters.normalShadingSmooth;
    float darkness = shadowParameters.darkness;
    vec2 uv = shadowParameters.texCoords;
    depth -= depthBias;
    vec2 texelStepSize = shadowParameters.texelStepSize;
    float radius = 1.0;
    float dx0 = -texelStepSize.x * radius;
    float dy0 = -texelStepSize.y * radius;
    float dx1 = texelStepSize.x * radius;
    float dy1 = texelStepSize.y * radius;
    float visibility =
    (
    _czm_shadowDepthCompare(shadowMap, uv, depth)
    +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +
    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +
    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +
    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +
    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +
    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +
    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +
    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)
    ) * (1.0 / 9.0)
    ;
    return visibility;
}
vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){
    vec3 v01 = point -planeOrigin;
    float d = dot(planeNormal, v01) ;
    return (point - planeNormal * d);
}
float ptm(vec3 pt){
    return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);
}
void main()
{
    const float PI = 3.141592653589793;
    vec4 color = texture2D(colorTexture, v_textureCoordinates);
    vec4 currD = texture2D(depthTexture, v_textureCoordinates);

    // vec4 stcc = texture2D(viewShadow, v_textureCoordinates);
    // gl_FragColor = currD;
    // return;
    if(currD.r>=1.0){
        gl_FragColor = color;
        return;
    }

    float depth = getDepth(currD);
    // gl_FragColor = vec4(depth,0.0,0.0,1.0);
    // return;
    // float depth = czm_unpackDepth(texture2D(depthTexture, v_textureCoordinates));
    vec4 positionEC = toEye(v_textureCoordinates, depth);
    vec3 normalEC = vec3(1.0);
    czm_shadowParameters shadowParameters;
    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;
    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;
    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;
    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;
    shadowParameters.depthBias *= max(depth * 0.01, 1.0);
    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);
    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0);
    vec4 shadowPosition = _shadowMap_matrix * positionEC;
    shadowPosition /= shadowPosition.w;
    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0))))
    {
        gl_FragColor = color;
        return;
    }

    //\u5750\u6807\u4E0E\u89C6\u70B9\u4F4D\u7F6E\u8DDD\u79BB\uFF0C\u5927\u4E8E\u6700\u5927\u8DDD\u79BB\u5219\u820D\u5F03\u9634\u5F71\u6548\u679C
    vec4 lw = vec4(shadowMap_lightPositionWC,1.0);
    vec4 vw = czm_inverseView* vec4(positionEC.xyz, 1.0);
    if(distance(lw.xyz,vw.xyz)>dis){
        gl_FragColor = color;
        return;
    }


    //\u6C34\u5E73\u5939\u89D2\u9650\u5236
    vec3 ptOnSP = pointProjectOnPlane(shadowMap_lightUp,lw.xyz,vw.xyz);
    directionEC = ptOnSP - lw.xyz;
    float directionECMO = ptm(directionEC.xyz);
    float shadowMap_lightDirMO = ptm(shadowMap_lightDir.xyz);
    float cosJJ = dot(directionEC,shadowMap_lightDir)/(directionECMO*shadowMap_lightDirMO);
    float degJJ = acos(cosJJ)*(180.0 / PI);
    degJJ = abs(degJJ);
    if(degJJ>spzj/2.0){
        gl_FragColor = color;
        return;
    }

    //\u5782\u76F4\u5939\u89D2\u9650\u5236
    vec3 ptOnCZ = pointProjectOnPlane(shadowMap_lightRight,lw.xyz,vw.xyz);
    vec3 dirOnCZ = ptOnCZ - lw.xyz;
    float dirOnCZMO = ptm(dirOnCZ);
    float cosJJCZ = dot(dirOnCZ,shadowMap_lightDir)/(dirOnCZMO*shadowMap_lightDirMO);
    float degJJCZ = acos(cosJJCZ)*(180.0 / PI);
    degJJCZ = abs(degJJCZ);
    if(degJJCZ>czzj/2.0){
        gl_FragColor = color;
        return;
    }

    shadowParameters.texCoords = shadowPosition.xy;
    shadowParameters.depth = shadowPosition.z;
    shadowParameters.nDotL = nDotL;
    float visibility = _czm_shadowVisibility(viewShadow, shadowParameters);
    if(visibility==1.0){
        gl_FragColor = mix(color,vec4(visibleColor,1.0),mixNum);
    }else{
        // if(abs(shadowPosition.z-0.0)<0.01){
        //     return;
        // }
        gl_FragColor = mix(color,vec4(disVisibleColor,1.0),mixNum);
    }
}`;
  var ViewShedAnalysis = class {
    constructor(viewer3, options = {}) {
      this._map = viewer3;
      this.options = options;
      this._horizontalAngle = Cesium.defaultValue(options.horizontalAngle, 120);
      this._verticalAngle = Cesium.defaultValue(options.verticalAngle, 90);
      this._visibleAreaColor = Cesium.defaultValue(options.visibleAreaColor, new Cesium.Color(0, 1, 0));
      this._hiddenAreaColor = Cesium.defaultValue(options.hiddenAreaColor, new Cesium.Color(1, 0, 0));
      this._alpha = Cesium.defaultValue(options.alpha, 0.5);
      this._offsetHeight = Cesium.defaultValue(options.offsetHeight, 1.5);
      this._showFrustum = Cesium.defaultValue(options.showFrustum, true);
      this._maximumDistance = Cesium.defaultValue(options.maximumDistance, 5e3);
      this._enabled = Cesium.defaultValue(options.enabled, true);
      this.add();
    }
    get horizontalAngle() {
      return this._horizontalAngle;
    }
    set horizontalAngle(val) {
      this._horizontalAngle = val;
      if (this._radar) {
        this._radar.redrawRS = true;
        this._radar.xHalfAngle = Cesium.Math.toRadians(val / 2);
      }
    }
    get verticalAngle() {
      return this._verticalAngle;
    }
    set verticalAngle(val) {
      this._verticalAngle = val;
      if (this._radar) {
        this._radar.redrawRS = true;
        this._radar.yHalfAngle = Cesium.Math.toRadians(val / 2);
      }
    }
    get distance() {
      return this._distance;
    }
    set distance(val) {
      this._distance = val;
      if (this._radar) {
        this._radar.redrawRS = true;
        this._radar.radius = val;
      }
    }
    get visibleAreaColor() {
      return this._visibleAreaColor;
    }
    set visibleAreaColor(val) {
      this._visibleAreaColor = val;
    }
    get hiddenAreaColor() {
      return this._hiddenAreaColor;
    }
    set hiddenAreaColor(val) {
      this._hiddenAreaColor = val;
    }
    get alpha() {
      return this._alpha;
    }
    set alpha(val) {
      this._alpha = val;
    }
    get showFrustum() {
      return this._showFrustum;
    }
    set showFrustum(val) {
      this._showFrustum = val;
      if (this._radar) {
        this._radar.show = val;
      }
    }
    get cameraPosition() {
      return this._cameraPosition;
    }
    set cameraPosition(value) {
      this._cameraPosition = value;
    }
    get cameraPoint() {
      return this._cameraPoint;
    }
    get position() {
      return this._position;
    }
    set position(value) {
      this._position = value;
    }
    add() {
      this._defaultColorTexture = new Cesium.Texture({
        context: this._map.scene.context,
        source: {
          width: 1,
          height: 1,
          arrayBufferView: new Uint8Array([0, 0, 0, 0])
        },
        flipY: false
      });
      this._map.terrainShadows = Cesium.ShadowMode.ENABLED;
      if (this.options.cameraPosition) {
        this.cameraPosition = this.options.cameraPosition;
      }
      if (this.options.position) {
        this.position = this.options.position;
      }
      if (this.cameraPosition && this.position) {
        this.cameraPosition = this.addPositionsHeight(this.cameraPosition, this._offsetHeight);
        this._addToScene();
      } else {
        this._bindMourseEvent();
      }
    }
    remove() {
      this._map.terrainShadows = Cesium.ShadowMode.DISABLED;
      this._unbindMourseEvent();
      if (this.postProcess) {
        this._map.scene.postProcessStages.remove(this.postProcess);
        delete this.postProcess;
      }
      if (this._radar) {
        this._map.scene.primitives.remove(this._radar);
        delete this._radar;
      }
      if (this.viewShadowMap) {
        this.viewShadowMap.destroy();
        delete this.viewShadowMap;
      }
      this._map.scene.primitives.remove(this);
      this._map.scene.postProcessStages.remove(this.postProcess);
    }
    _bindMourseEvent() {
      this.handler = new Cesium.ScreenSpaceEventHandler(this._map.canvas);
      this.handler.setInputAction(this._onClickHandler.bind(this), Cesium.ScreenSpaceEventType.LEFT_CLICK);
      this.handler.setInputAction(this._onMouseMoveHandler.bind(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
    _unbindMourseEvent() {
      if (this.handler) {
        this.handler.destroy();
        delete this.handler;
      }
    }
    _onClickHandler(event) {
      var position = event.position;
      var cartesian2 = this._map.scene.pickPosition(position);
      if (!Cesium.defined(cartesian2)) {
        return;
      }
      if (!this._cameraPosition) {
        cartesian2 = this.addPositionsHeight(cartesian2, this._offsetHeight);
        this.cameraPosition = cartesian2;
      } else {
        let len = Cesium.Cartesian3.distance(this._cameraPosition, cartesian2);
        if (len > 5e3) {
          cartesian2 = this.getOnLinePointByLen(this._cameraPosition, cartesian2, 5e3);
        }
        this.position = cartesian2;
        this._addToScene();
        this._unbindMourseEvent();
      }
    }
    _onMouseMoveHandler(event) {
      var position = event.endPosition;
      var cartesian2 = this._map.scene.pickPosition(position);
      if (!Cesium.defined(cartesian2)) {
        return;
      }
      let cp = this._cameraPosition;
      if (cp) {
        let len = Cesium.Cartesian3.distance(cp, cartesian2);
        if (len > 5e3) {
          len = 5e3;
          cartesian2 = this.getOnLinePointByLen(cp, cartesian2, 5e3);
        }
        this.frustumQuaternion = this.getFrustumQuaternion(cp, cartesian2);
        this.distance = Number(len.toFixed(1));
        this.position = cartesian2;
        this._addToScene();
      }
    }
    _addToScene() {
      let scene = this._map.scene;
      let camera_pos = this._cameraPosition;
      let lookat_pos = this._position;
      this.frustumQuaternion = this.getFrustumQuaternion(camera_pos, lookat_pos);
      this.distance = Number(Cesium.Cartesian3.distance(camera_pos, lookat_pos).toFixed(1));
      let lightCamera = new Cesium.Camera(scene);
      lightCamera.position = camera_pos;
      lightCamera.direction = Cesium.Cartesian3.subtract(lookat_pos, camera_pos, new Cesium.Cartesian3(0, 0, 0));
      lightCamera.up = Cesium.Cartesian3.normalize(camera_pos, new Cesium.Cartesian3(0, 0, 0));
      lightCamera.frustum = new Cesium.PerspectiveFrustum({
        fov: Cesium.Math.toRadians(120),
        aspectRatio: scene.canvas.clientWidth / scene.canvas.clientHeight,
        near: 0.1,
        far: 5e3
      });
      if (this.viewShadowMap) {
        this.viewShadowMap._lightCamera = lightCamera;
        this.viewShadowMap._pointLightRadius = this.distance;
      } else {
        this.viewShadowMap = new Cesium.ShadowMap({
          darkness: 1,
          lightCamera,
          enabled: false,
          isPointLight: false,
          isSpotLight: true,
          cascadesEnabled: false,
          context: scene.context,
          pointLightRadius: this.distance,
          maximumDistance: this._maximumDistance
        });
      }
      this._addRectangularSensor();
      if (!this.postProcess) {
        this._addPostProcess();
        this._map.scene.primitives.add(this);
      }
    }
    _addRectangularSensor() {
      let m3 = Cesium.Matrix3.fromQuaternion(this.frustumQuaternion, new Cesium.Matrix3());
      let modelMatrix = Cesium.Matrix4.fromRotationTranslation(m3, this._cameraPosition, new Cesium.Matrix4());
      if (this._radar) {
        modelMatrix = Cesium.Matrix4.fromRotationTranslation(m3, this._cameraPosition, this._radar.modelMatrix);
        this._radar.modelMatrix = modelMatrix;
        return;
      }
      let material = Cesium.Material.fromType("Color", {
        color: new Cesium.Color(0, 1, 1, 0.4)
      });
      this._radar = new PhasedArrayRadarPrimitive_default({
        modelMatrix,
        radius: this.distance,
        xHalfAngle: Cesium.Math.toRadians(this.horizontalAngle / 2),
        yHalfAngle: Cesium.Math.toRadians(this.verticalAngle / 2),
        material,
        lineColor: new Cesium.Color(1, 1, 1, 1),
        slice: 8,
        showScanPlane: false,
        showThroughEllipsoid: false,
        showLateralSurfaces: false,
        showDomeSurfaces: false,
        show: this._showFrustum && this._enabled
      });
      this._map.scene.primitives.add(this._radar);
    }
    _addPostProcess() {
      let that = this;
      let bias = this.viewShadowMap._isPointLight ? this.viewShadowMap._pointBias : this.viewShadowMap._primitiveBias;
      this.postProcess = new Cesium.PostProcessStage({
        fragmentShader: fragmentShaderSource,
        uniforms: {
          czzj: function() {
            return that.verticalAngle;
          },
          dis: function() {
            return that.distance;
          },
          spzj: function() {
            return that.horizontalAngle;
          },
          visibleColor: function() {
            return that.visibleAreaColor;
          },
          disVisibleColor: function() {
            return that.hiddenAreaColor;
          },
          mixNum: function() {
            return that.alpha;
          },
          viewShadow: function() {
            return that.viewShadowMap._shadowMapTexture || that._defaultColorTexture;
          },
          _shadowMap_matrix: function() {
            return that.viewShadowMap._shadowMapMatrix;
          },
          shadowMap_lightPositionEC: function() {
            return that.viewShadowMap._lightPositionEC;
          },
          shadowMap_lightPositionWC: function shadowMap_lightPositionWC() {
            return that.viewShadowMap._lightCamera.position;
          },
          shadowMap_lightDirectionEC: function() {
            return that.viewShadowMap._lightDirectionEC;
          },
          shadowMap_lightUp: function() {
            return that.viewShadowMap._lightCamera.up;
          },
          shadowMap_lightDir: function() {
            return that.viewShadowMap._lightCamera.direction;
          },
          shadowMap_lightRight: function() {
            return that.viewShadowMap._lightCamera.right;
          },
          shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function() {
            let texelStepSize = new Cesium.Cartesian2();
            texelStepSize.x = 1 / that.viewShadowMap._textureSize.x;
            texelStepSize.y = 1 / that.viewShadowMap._textureSize.y;
            return Cesium.Cartesian4.fromElements(texelStepSize.x, texelStepSize.y, bias.depthBias, bias.normalShadingSmooth, this.combinedUniforms1);
          },
          shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function() {
            return Cesium.Cartesian4.fromElements(
              bias.normalOffsetScale,
              that.viewShadowMap._distance,
              that.viewShadowMap.maximumDistance,
              that.viewShadowMap._darkness,
              this.combinedUniforms2
            );
          },
          depthTexture1: function() {
            return that.getSceneDepthTexture(that._map.scene);
          }
        }
      });
      this._map.scene.postProcessStages.add(this.postProcess);
    }
    getSceneDepthTexture(scene) {
      let environmentState = scene._environmentState;
      let view = scene._view;
      let useGlobeDepthFramebuffer = environmentState.useGlobeDepthFramebuffer;
      let globeFramebuffer = useGlobeDepthFramebuffer ? view.globeDepth.framebuffer : void 0;
      let sceneFramebuffer = view.sceneFramebuffer.getFramebuffer();
      let depthTexture = Cesium.defaultValue(globeFramebuffer, sceneFramebuffer).depthStencilTexture;
      return depthTexture;
    }
    getFrustumQuaternion(cpos, position) {
      let direction = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(position, cpos, new Cesium.Cartesian3()), new Cesium.Cartesian3());
      let up = Cesium.Cartesian3.normalize(cpos, new Cesium.Cartesian3());
      let camera = new Cesium.Camera(this._map.scene);
      camera.position = cpos;
      camera.direction = direction;
      camera.up = up;
      direction = camera.directionWC;
      up = camera.upWC;
      let right = camera.rightWC;
      let scratchRight = new Cesium.Cartesian3();
      let scratchRotation = new Cesium.Matrix3();
      let scratchOrientation = new Cesium.Quaternion();
      right = Cesium.Cartesian3.negate(right, scratchRight);
      let rotation = scratchRotation;
      Cesium.Matrix3.setColumn(rotation, 0, right, rotation);
      Cesium.Matrix3.setColumn(rotation, 1, up, rotation);
      Cesium.Matrix3.setColumn(rotation, 2, direction, rotation);
      let orientation = Cesium.Quaternion.fromRotationMatrix(rotation, scratchOrientation);
      return orientation;
    }
    update(frameState) {
      if (this.viewShadowMap) {
        frameState.shadowMaps.push(this.viewShadowMap);
      }
    }
    getOnLinePointByLen(p1, p2, len, addBS) {
      let mtx4 = Cesium.Transforms.eastNorthUpToFixedFrame(p1);
      let mtx4_inverser = Cesium.Matrix4.inverse(mtx4, new Cesium.Matrix4());
      p1 = Cesium.Matrix4.multiplyByPoint(mtx4_inverser, p1, new Cesium.Cartesian3());
      p2 = Cesium.Matrix4.multiplyByPoint(mtx4_inverser, p2, new Cesium.Cartesian3());
      let substrct = Cesium.Cartesian3.subtract(p2, p1, new Cesium.Cartesian3());
      let dis = Cesium.Cartesian3.distance(p1, p2);
      let scale = len / dis;
      if (addBS) {
        scale += 1;
      }
      let newP = Cesium.Cartesian3.multiplyByScalar(substrct, scale, new Cesium.Cartesian3());
      newP = Cesium.Matrix4.multiplyByPoint(mtx4, newP, new Cesium.Cartesian3());
      return newP;
    }
    addPositionsHeight(positions, addHeight = 0) {
      addHeight = Number(addHeight);
      if (isNaN(addHeight) || addHeight == 0) {
        return positions;
      }
      if (Array.isArray(positions)) {
        let arr2 = [];
        for (let i = 0, len = positions.length; i < len; i++) {
          let car = Cesium.Cartographic.fromCartesian(positions[i]);
          let point2 = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, car.height + addHeight);
          arr2.push(point2);
        }
        return arr2;
      } else {
        let car = Cesium.Cartographic.fromCartesian(positions);
        return Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, car.height + addHeight);
      }
    }
  };
  var ViewShedAnalysis_default = ViewShedAnalysis;

  // Source/custom/ext/BillboardCollection.js
  var AttributeCompression = Cesium.AttributeCompression;
  var BoundingSphere2 = Cesium.BoundingSphere;
  var Cartesian2 = Cesium.Cartesian2;
  var Cartesian32 = Cesium.Cartesian3;
  var Color2 = Cesium.Color;
  var ComponentDatatype2 = Cesium.ComponentDatatype;
  var defaultValue2 = Cesium.defaultValue;
  var defined2 = Cesium.defined;
  var destroyObject = Cesium.destroyObject;
  var DeveloperError2 = Cesium.DeveloperError;
  var EncodedCartesian3 = Cesium.EncodedCartesian3;
  var IndexDatatype = Cesium.IndexDatatype;
  var CesiumMath3 = Cesium.Math;
  var Matrix42 = Cesium.Matrix4;
  var WebGLConstants = Cesium.WebGLConstants;
  var Buffer3 = Cesium.Buffer;
  var BufferUsage2 = Cesium.BufferUsage;
  var ContextLimits = Cesium.ContextLimits;
  var DrawCommand2 = Cesium.DrawCommand;
  var Pass2 = Cesium.Pass;
  var RenderState2 = Cesium.RenderState;
  var ShaderProgram2 = Cesium.ShaderProgram;
  var ShaderSource2 = Cesium.ShaderSource;
  var VertexArrayFacade = Cesium.VertexArrayFacade;
  var BillboardCollectionFS = Cesium._shadersBillboardCollectionFS;
  var BillboardCollectionVS = Cesium._shadersExtBillboardCollectionVS;
  var Billboard = Cesium.Billboard;
  var BlendingState2 = Cesium.BlendingState;
  var BlendOption = Cesium.BlendOption;
  var HeightReference = Cesium.HeightReference;
  var HorizontalOrigin = Cesium.HorizontalOrigin;
  var SceneMode2 = Cesium.SceneMode;
  var SDFSettings = Cesium.SDFSettings;
  var TextureAtlas = Cesium.TextureAtlas;
  var VerticalOrigin = Cesium.VerticalOrigin;
  var SHOW_INDEX = Billboard.SHOW_INDEX;
  var POSITION_INDEX = Billboard.POSITION_INDEX;
  var PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX;
  var EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX;
  var HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX;
  var VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX;
  var SCALE_INDEX = Billboard.SCALE_INDEX;
  var IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX;
  var COLOR_INDEX = Billboard.COLOR_INDEX;
  var ROTATION_INDEX = Billboard.ROTATION_INDEX;
  var ALIGNED_AXIS_INDEX = Billboard.ALIGNED_AXIS_INDEX;
  var SCALE_BY_DISTANCE_INDEX = Billboard.SCALE_BY_DISTANCE_INDEX;
  var TRANSLUCENCY_BY_DISTANCE_INDEX = Billboard.TRANSLUCENCY_BY_DISTANCE_INDEX;
  var PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX = Billboard.PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX;
  var DISTANCE_DISPLAY_CONDITION_INDEX = Billboard.DISTANCE_DISPLAY_CONDITION;
  var DISABLE_DEPTH_DISTANCE = Billboard.DISABLE_DEPTH_DISTANCE;
  var TEXTURE_COORDINATE_BOUNDS = Billboard.TEXTURE_COORDINATE_BOUNDS;
  var SDF_INDEX = Billboard.SDF_INDEX;
  var NUMBER_OF_PROPERTIES = Billboard.NUMBER_OF_PROPERTIES;
  var attributeLocations2;
  var attributeLocationsBatched = {
    positionHighAndScale: 0,
    positionLowAndRotation: 1,
    compressedAttribute0: 2,
    compressedAttribute1: 3,
    compressedAttribute2: 4,
    eyeOffset: 5,
    scaleByDistance: 6,
    pixelOffsetScaleByDistance: 7,
    compressedAttribute3: 8,
    textureCoordinateBoundsOrLabelTranslate: 9,
    a_batchId: 10,
    sdf: 11
  };
  var attributeLocationsInstanced = {
    direction: 0,
    positionHighAndScale: 1,
    positionLowAndRotation: 2,
    compressedAttribute0: 3,
    compressedAttribute1: 4,
    compressedAttribute2: 5,
    eyeOffset: 6,
    scaleByDistance: 7,
    pixelOffsetScaleByDistance: 8,
    compressedAttribute3: 9,
    textureCoordinateBoundsOrLabelTranslate: 10,
    a_batchId: 11,
    sdf: 12
  };
  function BillboardCollection(options) {
    options = defaultValue2(options, defaultValue2.EMPTY_OBJECT);
    this._scene = options.scene;
    this._batchTable = options.batchTable;
    this._textureAtlas = void 0;
    this._textureAtlasGUID = void 0;
    this._destroyTextureAtlas = true;
    this._sp = void 0;
    this._spTranslucent = void 0;
    this._rsOpaque = void 0;
    this._rsTranslucent = void 0;
    this._vaf = void 0;
    this._billboards = [];
    this._billboardsToUpdate = [];
    this._billboardsToUpdateIndex = 0;
    this._billboardsRemoved = false;
    this._createVertexArray = false;
    this._shaderRotation = false;
    this._compiledShaderRotation = false;
    this._shaderAlignedAxis = false;
    this._compiledShaderAlignedAxis = false;
    this._shaderScaleByDistance = false;
    this._compiledShaderScaleByDistance = false;
    this._shaderTranslucencyByDistance = false;
    this._compiledShaderTranslucencyByDistance = false;
    this._shaderPixelOffsetScaleByDistance = false;
    this._compiledShaderPixelOffsetScaleByDistance = false;
    this._shaderDistanceDisplayCondition = false;
    this._compiledShaderDistanceDisplayCondition = false;
    this._shaderDisableDepthDistance = false;
    this._compiledShaderDisableDepthDistance = false;
    this._shaderClampToGround = false;
    this._compiledShaderClampToGround = false;
    this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);
    this._maxSize = 0;
    this._maxEyeOffset = 0;
    this._maxScale = 1;
    this._maxPixelOffset = 0;
    this._allHorizontalCenter = true;
    this._allVerticalCenter = true;
    this._allSizedInMeters = true;
    this._baseVolume = new BoundingSphere2();
    this._baseVolumeWC = new BoundingSphere2();
    this._baseVolume2D = new BoundingSphere2();
    this._boundingVolume = new BoundingSphere2();
    this._boundingVolumeDirty = false;
    this._colorCommands = [];
    this._ENUENABLED = defaultValue2(options.enuEnabled, false);
    this.show = defaultValue2(options.show, true);
    this.modelMatrix = Matrix42.clone(
      defaultValue2(options.modelMatrix, Matrix42.IDENTITY)
    );
    this._modelMatrix = Matrix42.clone(Matrix42.IDENTITY);
    this.debugShowBoundingVolume = defaultValue2(
      options.debugShowBoundingVolume,
      false
    );
    this.debugShowTextureAtlas = defaultValue2(
      options.debugShowTextureAtlas,
      false
    );
    this.blendOption = defaultValue2(
      options.blendOption,
      BlendOption.OPAQUE_AND_TRANSLUCENT
    );
    this._blendOption = void 0;
    this._mode = SceneMode2.SCENE3D;
    this._buffersUsage = [
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW,
      BufferUsage2.STATIC_DRAW
    ];
    this._highlightColor = Color2.clone(Color2.WHITE);
    const that = this;
    this._uniforms = {
      u_atlas: function() {
        return that._textureAtlas.texture;
      },
      u_highlightColor: function() {
        return that._highlightColor;
      }
    };
    const scene = this._scene;
    if (defined2(scene) && defined2(scene.terrainProviderChanged)) {
      this._removeCallbackFunc = scene.terrainProviderChanged.addEventListener(
        function() {
          const billboards = this._billboards;
          const length2 = billboards.length;
          for (let i = 0; i < length2; ++i) {
            if (defined2(billboards[i])) {
              billboards[i]._updateClamping();
            }
          }
        },
        this
      );
    }
  }
  Object.defineProperties(BillboardCollection.prototype, {
    length: {
      get: function() {
        removeBillboards(this);
        return this._billboards.length;
      }
    },
    textureAtlas: {
      get: function() {
        return this._textureAtlas;
      },
      set: function(value) {
        if (this._textureAtlas !== value) {
          this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
          this._textureAtlas = value;
          this._createVertexArray = true;
        }
      }
    },
    destroyTextureAtlas: {
      get: function() {
        return this._destroyTextureAtlas;
      },
      set: function(value) {
        this._destroyTextureAtlas = value;
      }
    }
  });
  function destroyBillboards(billboards) {
    const length2 = billboards.length;
    for (let i = 0; i < length2; ++i) {
      if (billboards[i]) {
        billboards[i]._destroy();
      }
    }
  }
  BillboardCollection.prototype.add = function(options) {
    const billboard = new Billboard(options, this);
    billboard._index = this._billboards.length;
    this._billboards.push(billboard);
    this._createVertexArray = true;
    return billboard;
  };
  BillboardCollection.prototype.remove = function(billboard) {
    if (this.contains(billboard)) {
      this._billboards[billboard._index] = void 0;
      this._billboardsRemoved = true;
      this._createVertexArray = true;
      billboard._destroy();
      return true;
    }
    return false;
  };
  BillboardCollection.prototype.removeAll = function() {
    destroyBillboards(this._billboards);
    this._billboards = [];
    this._billboardsToUpdate = [];
    this._billboardsToUpdateIndex = 0;
    this._billboardsRemoved = false;
    this._createVertexArray = true;
  };
  function removeBillboards(billboardCollection) {
    if (billboardCollection._billboardsRemoved) {
      billboardCollection._billboardsRemoved = false;
      const newBillboards = [];
      const billboards = billboardCollection._billboards;
      const length2 = billboards.length;
      for (let i = 0, j = 0; i < length2; ++i) {
        const billboard = billboards[i];
        if (defined2(billboard)) {
          billboard._index = j++;
          newBillboards.push(billboard);
        }
      }
      billboardCollection._billboards = newBillboards;
    }
  }
  BillboardCollection.prototype._updateBillboard = function(billboard, propertyChanged) {
    if (!billboard._dirty) {
      this._billboardsToUpdate[this._billboardsToUpdateIndex++] = billboard;
    }
    ++this._propertiesChanged[propertyChanged];
  };
  BillboardCollection.prototype.contains = function(billboard) {
    return defined2(billboard) && billboard._billboardCollection === this;
  };
  BillboardCollection.prototype.get = function(index) {
    Check.typeOf.number("index", index);
    removeBillboards(this);
    return this._billboards[index];
  };
  var getIndexBuffer;
  function getIndexBufferBatched(context) {
    const sixteenK = 16 * 1024;
    let indexBuffer = context.cache.billboardCollection_indexBufferBatched;
    if (defined2(indexBuffer)) {
      return indexBuffer;
    }
    const length2 = sixteenK * 6 - 6;
    const indices = new Uint16Array(length2);
    for (let i = 0, j = 0; i < length2; i += 6, j += 4) {
      indices[i] = j;
      indices[i + 1] = j + 1;
      indices[i + 2] = j + 2;
      indices[i + 3] = j + 0;
      indices[i + 4] = j + 2;
      indices[i + 5] = j + 3;
    }
    indexBuffer = Buffer3.createIndexBuffer({
      context,
      typedArray: indices,
      usage: BufferUsage2.STATIC_DRAW,
      indexDatatype: IndexDatatype.UNSIGNED_SHORT
    });
    indexBuffer.vertexArrayDestroyable = false;
    context.cache.billboardCollection_indexBufferBatched = indexBuffer;
    return indexBuffer;
  }
  function getIndexBufferInstanced(context) {
    let indexBuffer = context.cache.billboardCollection_indexBufferInstanced;
    if (defined2(indexBuffer)) {
      return indexBuffer;
    }
    indexBuffer = Buffer3.createIndexBuffer({
      context,
      typedArray: new Uint16Array([0, 1, 2, 0, 2, 3]),
      usage: BufferUsage2.STATIC_DRAW,
      indexDatatype: IndexDatatype.UNSIGNED_SHORT
    });
    indexBuffer.vertexArrayDestroyable = false;
    context.cache.billboardCollection_indexBufferInstanced = indexBuffer;
    return indexBuffer;
  }
  function getVertexBufferInstanced(context) {
    let vertexBuffer = context.cache.billboardCollection_vertexBufferInstanced;
    if (defined2(vertexBuffer)) {
      return vertexBuffer;
    }
    vertexBuffer = Buffer3.createVertexBuffer({
      context,
      typedArray: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
      usage: BufferUsage2.STATIC_DRAW
    });
    vertexBuffer.vertexArrayDestroyable = false;
    context.cache.billboardCollection_vertexBufferInstanced = vertexBuffer;
    return vertexBuffer;
  }
  BillboardCollection.prototype.computeNewBuffersUsage = function() {
    const buffersUsage = this._buffersUsage;
    let usageChanged = false;
    const properties = this._propertiesChanged;
    for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
      const newUsage = properties[k] === 0 ? BufferUsage2.STATIC_DRAW : BufferUsage2.STREAM_DRAW;
      usageChanged = usageChanged || buffersUsage[k] !== newUsage;
      buffersUsage[k] = newUsage;
    }
    return usageChanged;
  };
  function createVAF(context, numberOfBillboards, buffersUsage, instanced, batchTable, sdf) {
    const attributes = [
      {
        index: attributeLocations2.positionHighAndScale,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype2.FLOAT,
        usage: buffersUsage[POSITION_INDEX]
      },
      {
        index: attributeLocations2.positionLowAndRotation,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype2.FLOAT,
        usage: buffersUsage[POSITION_INDEX]
      },
      {
        index: attributeLocations2.compressedAttribute0,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype2.FLOAT,
        usage: buffersUsage[PIXEL_OFFSET_INDEX]
      },
      {
        index: attributeLocations2.compressedAttribute1,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype2.FLOAT,
        usage: buffersUsage[TRANSLUCENCY_BY_DISTANCE_INDEX]
      },
      {
        index: attributeLocations2.compressedAttribute2,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype2.FLOAT,
        usage: buffersUsage[COLOR_INDEX]
      },
      {
        index: attributeLocations2.eyeOffset,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype2.FLOAT,
        usage: buffersUsage[EYE_OFFSET_INDEX]
      },
      {
        index: attributeLocations2.scaleByDistance,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype2.FLOAT,
        usage: buffersUsage[SCALE_BY_DISTANCE_INDEX]
      },
      {
        index: attributeLocations2.pixelOffsetScaleByDistance,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype2.FLOAT,
        usage: buffersUsage[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX]
      },
      {
        index: attributeLocations2.compressedAttribute3,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype2.FLOAT,
        usage: buffersUsage[DISTANCE_DISPLAY_CONDITION_INDEX]
      },
      {
        index: attributeLocations2.textureCoordinateBoundsOrLabelTranslate,
        componentsPerAttribute: 4,
        componentDatatype: ComponentDatatype2.FLOAT,
        usage: buffersUsage[TEXTURE_COORDINATE_BOUNDS]
      }
    ];
    if (instanced) {
      attributes.push({
        index: attributeLocations2.direction,
        componentsPerAttribute: 2,
        componentDatatype: ComponentDatatype2.FLOAT,
        vertexBuffer: getVertexBufferInstanced(context)
      });
    }
    if (defined2(batchTable)) {
      attributes.push({
        index: attributeLocations2.a_batchId,
        componentsPerAttribute: 1,
        componentDatatype: ComponentDatatype2.FLOAT,
        bufferUsage: BufferUsage2.STATIC_DRAW
      });
    }
    if (sdf) {
      attributes.push({
        index: attributeLocations2.sdf,
        componentsPerAttribute: 2,
        componentDatatype: ComponentDatatype2.FLOAT,
        usage: buffersUsage[SDF_INDEX]
      });
    }
    const sizeInVertices = instanced ? numberOfBillboards : 4 * numberOfBillboards;
    return new VertexArrayFacade(context, attributes, sizeInVertices, instanced);
  }
  var writePositionScratch = new EncodedCartesian3();
  function writePositionScaleAndRotation(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
    let i;
    const positionHighWriter = vafWriters[attributeLocations2.positionHighAndScale];
    const positionLowWriter = vafWriters[attributeLocations2.positionLowAndRotation];
    const position = billboard._getActualPosition();
    if (billboardCollection._mode === SceneMode2.SCENE3D) {
      BoundingSphere2.expand(
        billboardCollection._baseVolume,
        position,
        billboardCollection._baseVolume
      );
      billboardCollection._boundingVolumeDirty = true;
    }
    EncodedCartesian3.fromCartesian(position, writePositionScratch);
    const scale = billboard.scale;
    const rotation = billboard.rotation;
    if (rotation !== 0) {
      billboardCollection._shaderRotation = true;
    }
    billboardCollection._maxScale = Math.max(
      billboardCollection._maxScale,
      scale
    );
    const high = writePositionScratch.high;
    const low = writePositionScratch.low;
    if (billboardCollection._instanced) {
      i = billboard._index;
      positionHighWriter(i, high.x, high.y, high.z, scale);
      positionLowWriter(i, low.x, low.y, low.z, rotation);
    } else {
      i = billboard._index * 4;
      positionHighWriter(i + 0, high.x, high.y, high.z, scale);
      positionHighWriter(i + 1, high.x, high.y, high.z, scale);
      positionHighWriter(i + 2, high.x, high.y, high.z, scale);
      positionHighWriter(i + 3, high.x, high.y, high.z, scale);
      positionLowWriter(i + 0, low.x, low.y, low.z, rotation);
      positionLowWriter(i + 1, low.x, low.y, low.z, rotation);
      positionLowWriter(i + 2, low.x, low.y, low.z, rotation);
      positionLowWriter(i + 3, low.x, low.y, low.z, rotation);
    }
  }
  var scratchCartesian2 = new Cartesian2();
  var UPPER_BOUND = 32768;
  var LEFT_SHIFT16 = 65536;
  var LEFT_SHIFT12 = 4096;
  var LEFT_SHIFT8 = 256;
  var LEFT_SHIFT7 = 128;
  var LEFT_SHIFT5 = 32;
  var LEFT_SHIFT3 = 8;
  var LEFT_SHIFT2 = 4;
  var RIGHT_SHIFT8 = 1 / 256;
  var LOWER_LEFT = 0;
  var LOWER_RIGHT = 2;
  var UPPER_RIGHT = 3;
  var UPPER_LEFT = 1;
  function writeCompressedAttrib0(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
    let i;
    const writer = vafWriters[attributeLocations2.compressedAttribute0];
    const pixelOffset = billboard.pixelOffset;
    const pixelOffsetX = pixelOffset.x;
    const pixelOffsetY = pixelOffset.y;
    const translate = billboard._translate;
    const translateX = translate.x;
    const translateY = translate.y;
    billboardCollection._maxPixelOffset = Math.max(
      billboardCollection._maxPixelOffset,
      Math.abs(pixelOffsetX + translateX),
      Math.abs(-pixelOffsetY + translateY)
    );
    const horizontalOrigin = billboard.horizontalOrigin;
    let verticalOrigin = billboard._verticalOrigin;
    let show = billboard.show && billboard.clusterShow;
    if (billboard.color.alpha === 0) {
      show = false;
    }
    if (verticalOrigin === VerticalOrigin.BASELINE) {
      verticalOrigin = VerticalOrigin.BOTTOM;
    }
    billboardCollection._allHorizontalCenter = billboardCollection._allHorizontalCenter && horizontalOrigin === HorizontalOrigin.CENTER;
    billboardCollection._allVerticalCenter = billboardCollection._allVerticalCenter && verticalOrigin === VerticalOrigin.CENTER;
    let bottomLeftX = 0;
    let bottomLeftY = 0;
    let width = 0;
    let height = 0;
    const index = billboard._imageIndex;
    if (index !== -1) {
      const imageRectangle = textureAtlasCoordinates[index];
      if (!defined2(imageRectangle)) {
        throw new DeveloperError2(`Invalid billboard image index: ${index}`);
      }
      bottomLeftX = imageRectangle.x;
      bottomLeftY = imageRectangle.y;
      width = imageRectangle.width;
      height = imageRectangle.height;
    }
    const topRightX = bottomLeftX + width;
    const topRightY = bottomLeftY + height;
    let compressed0 = Math.floor(
      CesiumMath3.clamp(pixelOffsetX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND
    ) * LEFT_SHIFT7;
    compressed0 += (horizontalOrigin + 1) * LEFT_SHIFT5;
    compressed0 += (verticalOrigin + 1) * LEFT_SHIFT3;
    compressed0 += (show ? 1 : 0) * LEFT_SHIFT2;
    let compressed1 = Math.floor(
      CesiumMath3.clamp(pixelOffsetY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND
    ) * LEFT_SHIFT8;
    let compressed2 = Math.floor(
      CesiumMath3.clamp(translateX, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND
    ) * LEFT_SHIFT8;
    const tempTanslateY = (CesiumMath3.clamp(translateY, -UPPER_BOUND, UPPER_BOUND) + UPPER_BOUND) * RIGHT_SHIFT8;
    const upperTranslateY = Math.floor(tempTanslateY);
    const lowerTranslateY = Math.floor(
      (tempTanslateY - upperTranslateY) * LEFT_SHIFT8
    );
    compressed1 += upperTranslateY;
    compressed2 += lowerTranslateY;
    scratchCartesian2.x = bottomLeftX;
    scratchCartesian2.y = bottomLeftY;
    const compressedTexCoordsLL = AttributeCompression.compressTextureCoordinates(
      scratchCartesian2
    );
    scratchCartesian2.x = topRightX;
    const compressedTexCoordsLR = AttributeCompression.compressTextureCoordinates(
      scratchCartesian2
    );
    scratchCartesian2.y = topRightY;
    const compressedTexCoordsUR = AttributeCompression.compressTextureCoordinates(
      scratchCartesian2
    );
    scratchCartesian2.x = bottomLeftX;
    const compressedTexCoordsUL = AttributeCompression.compressTextureCoordinates(
      scratchCartesian2
    );
    if (billboardCollection._instanced) {
      i = billboard._index;
      writer(i, compressed0, compressed1, compressed2, compressedTexCoordsLL);
    } else {
      i = billboard._index * 4;
      writer(
        i + 0,
        compressed0 + LOWER_LEFT,
        compressed1,
        compressed2,
        compressedTexCoordsLL
      );
      writer(
        i + 1,
        compressed0 + LOWER_RIGHT,
        compressed1,
        compressed2,
        compressedTexCoordsLR
      );
      writer(
        i + 2,
        compressed0 + UPPER_RIGHT,
        compressed1,
        compressed2,
        compressedTexCoordsUR
      );
      writer(
        i + 3,
        compressed0 + UPPER_LEFT,
        compressed1,
        compressed2,
        compressedTexCoordsUL
      );
    }
  }
  function writeCompressedAttrib1(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
    let i;
    const writer = vafWriters[attributeLocations2.compressedAttribute1];
    const alignedAxis = billboard.alignedAxis;
    if (!Cartesian32.equals(alignedAxis, Cartesian32.ZERO)) {
      billboardCollection._shaderAlignedAxis = true;
    }
    let near = 0;
    let nearValue = 1;
    let far = 1;
    let farValue = 1;
    const translucency = billboard.translucencyByDistance;
    if (defined2(translucency)) {
      near = translucency.near;
      nearValue = translucency.nearValue;
      far = translucency.far;
      farValue = translucency.farValue;
      if (nearValue !== 1 || farValue !== 1) {
        billboardCollection._shaderTranslucencyByDistance = true;
      }
    }
    let width = 0;
    const index = billboard._imageIndex;
    if (index !== -1) {
      const imageRectangle = textureAtlasCoordinates[index];
      if (!defined2(imageRectangle)) {
        throw new DeveloperError2(`Invalid billboard image index: ${index}`);
      }
      width = imageRectangle.width;
    }
    const textureWidth = billboardCollection._textureAtlas.texture.width;
    const imageWidth = Math.round(
      defaultValue2(billboard.width, textureWidth * width)
    );
    billboardCollection._maxSize = Math.max(
      billboardCollection._maxSize,
      imageWidth
    );
    let compressed0 = CesiumMath3.clamp(imageWidth, 0, LEFT_SHIFT16);
    let compressed1 = 0;
    if (Math.abs(Cartesian32.magnitudeSquared(alignedAxis) - 1) < CesiumMath3.EPSILON6) {
      compressed1 = AttributeCompression.octEncodeFloat(alignedAxis);
    }
    nearValue = CesiumMath3.clamp(nearValue, 0, 1);
    nearValue = nearValue === 1 ? 255 : nearValue * 255 | 0;
    compressed0 = compressed0 * LEFT_SHIFT8 + nearValue;
    farValue = CesiumMath3.clamp(farValue, 0, 1);
    farValue = farValue === 1 ? 255 : farValue * 255 | 0;
    compressed1 = compressed1 * LEFT_SHIFT8 + farValue;
    if (billboardCollection._instanced) {
      i = billboard._index;
      writer(i, compressed0, compressed1, near, far);
    } else {
      i = billboard._index * 4;
      writer(i + 0, compressed0, compressed1, near, far);
      writer(i + 1, compressed0, compressed1, near, far);
      writer(i + 2, compressed0, compressed1, near, far);
      writer(i + 3, compressed0, compressed1, near, far);
    }
  }
  function writeCompressedAttrib2(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
    let i;
    const writer = vafWriters[attributeLocations2.compressedAttribute2];
    const color = billboard.color;
    const pickColor = !defined2(billboardCollection._batchTable) ? billboard.getPickId(frameState.context).color : Color2.WHITE;
    const sizeInMeters = billboard.sizeInMeters ? 1 : 0;
    const validAlignedAxis = Math.abs(Cartesian32.magnitudeSquared(billboard.alignedAxis) - 1) < CesiumMath3.EPSILON6 ? 1 : 0;
    billboardCollection._allSizedInMeters = billboardCollection._allSizedInMeters && sizeInMeters === 1;
    let height = 0;
    const index = billboard._imageIndex;
    if (index !== -1) {
      const imageRectangle = textureAtlasCoordinates[index];
      if (!defined2(imageRectangle)) {
        throw new DeveloperError2(`Invalid billboard image index: ${index}`);
      }
      height = imageRectangle.height;
    }
    const dimensions = billboardCollection._textureAtlas.texture.dimensions;
    const imageHeight = Math.round(
      defaultValue2(billboard.height, dimensions.y * height)
    );
    billboardCollection._maxSize = Math.max(
      billboardCollection._maxSize,
      imageHeight
    );
    let labelHorizontalOrigin = defaultValue2(
      billboard._labelHorizontalOrigin,
      -2
    );
    labelHorizontalOrigin += 2;
    const compressed3 = imageHeight * LEFT_SHIFT2 + labelHorizontalOrigin;
    let red = Color2.floatToByte(color.red);
    let green = Color2.floatToByte(color.green);
    let blue = Color2.floatToByte(color.blue);
    const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;
    red = Color2.floatToByte(pickColor.red);
    green = Color2.floatToByte(pickColor.green);
    blue = Color2.floatToByte(pickColor.blue);
    const compressed1 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;
    let compressed2 = Color2.floatToByte(color.alpha) * LEFT_SHIFT16 + Color2.floatToByte(pickColor.alpha) * LEFT_SHIFT8;
    compressed2 += sizeInMeters * 2 + validAlignedAxis;
    if (billboardCollection._instanced) {
      i = billboard._index;
      writer(i, compressed0, compressed1, compressed2, compressed3);
    } else {
      i = billboard._index * 4;
      writer(i + 0, compressed0, compressed1, compressed2, compressed3);
      writer(i + 1, compressed0, compressed1, compressed2, compressed3);
      writer(i + 2, compressed0, compressed1, compressed2, compressed3);
      writer(i + 3, compressed0, compressed1, compressed2, compressed3);
    }
  }
  function writeEyeOffset(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
    let i;
    const writer = vafWriters[attributeLocations2.eyeOffset];
    const eyeOffset = billboard.eyeOffset;
    let eyeOffsetZ = eyeOffset.z;
    if (billboard._heightReference !== HeightReference.NONE) {
      eyeOffsetZ *= 1.005;
    }
    billboardCollection._maxEyeOffset = Math.max(
      billboardCollection._maxEyeOffset,
      Math.abs(eyeOffset.x),
      Math.abs(eyeOffset.y),
      Math.abs(eyeOffsetZ)
    );
    if (billboardCollection._instanced) {
      let width = 0;
      let height = 0;
      const index = billboard._imageIndex;
      if (index !== -1) {
        const imageRectangle = textureAtlasCoordinates[index];
        if (!defined2(imageRectangle)) {
          throw new DeveloperError2(`Invalid billboard image index: ${index}`);
        }
        width = imageRectangle.width;
        height = imageRectangle.height;
      }
      scratchCartesian2.x = width;
      scratchCartesian2.y = height;
      const compressedTexCoordsRange = AttributeCompression.compressTextureCoordinates(
        scratchCartesian2
      );
      i = billboard._index;
      writer(i, eyeOffset.x, eyeOffset.y, eyeOffsetZ, compressedTexCoordsRange);
    } else {
      i = billboard._index * 4;
      writer(i + 0, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0);
      writer(i + 1, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0);
      writer(i + 2, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0);
      writer(i + 3, eyeOffset.x, eyeOffset.y, eyeOffsetZ, 0);
    }
  }
  function writeScaleByDistance(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
    let i;
    const writer = vafWriters[attributeLocations2.scaleByDistance];
    let near = 0;
    let nearValue = 1;
    let far = 1;
    let farValue = 1;
    const scale = billboard.scaleByDistance;
    if (defined2(scale)) {
      near = scale.near;
      nearValue = scale.nearValue;
      far = scale.far;
      farValue = scale.farValue;
      if (nearValue !== 1 || farValue !== 1) {
        billboardCollection._shaderScaleByDistance = true;
      }
    }
    if (billboardCollection._instanced) {
      i = billboard._index;
      writer(i, near, nearValue, far, farValue);
    } else {
      i = billboard._index * 4;
      writer(i + 0, near, nearValue, far, farValue);
      writer(i + 1, near, nearValue, far, farValue);
      writer(i + 2, near, nearValue, far, farValue);
      writer(i + 3, near, nearValue, far, farValue);
    }
  }
  function writePixelOffsetScaleByDistance(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
    let i;
    const writer = vafWriters[attributeLocations2.pixelOffsetScaleByDistance];
    let near = 0;
    let nearValue = 1;
    let far = 1;
    let farValue = 1;
    const pixelOffsetScale = billboard.pixelOffsetScaleByDistance;
    if (defined2(pixelOffsetScale)) {
      near = pixelOffsetScale.near;
      nearValue = pixelOffsetScale.nearValue;
      far = pixelOffsetScale.far;
      farValue = pixelOffsetScale.farValue;
      if (nearValue !== 1 || farValue !== 1) {
        billboardCollection._shaderPixelOffsetScaleByDistance = true;
      }
    }
    if (billboardCollection._instanced) {
      i = billboard._index;
      writer(i, near, nearValue, far, farValue);
    } else {
      i = billboard._index * 4;
      writer(i + 0, near, nearValue, far, farValue);
      writer(i + 1, near, nearValue, far, farValue);
      writer(i + 2, near, nearValue, far, farValue);
      writer(i + 3, near, nearValue, far, farValue);
    }
  }
  function writeCompressedAttribute3(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
    let i;
    const writer = vafWriters[attributeLocations2.compressedAttribute3];
    let near = 0;
    let far = Number.MAX_VALUE;
    const distanceDisplayCondition = billboard.distanceDisplayCondition;
    if (defined2(distanceDisplayCondition)) {
      near = distanceDisplayCondition.near;
      far = distanceDisplayCondition.far;
      near *= near;
      far *= far;
      billboardCollection._shaderDistanceDisplayCondition = true;
    }
    let disableDepthTestDistance = billboard.disableDepthTestDistance;
    const clampToGround = billboard.heightReference === HeightReference.CLAMP_TO_GROUND && frameState.context.depthTexture;
    if (!defined2(disableDepthTestDistance)) {
      disableDepthTestDistance = clampToGround ? 5e3 : 0;
    }
    disableDepthTestDistance *= disableDepthTestDistance;
    if (clampToGround || disableDepthTestDistance > 0) {
      billboardCollection._shaderDisableDepthDistance = true;
      if (disableDepthTestDistance === Number.POSITIVE_INFINITY) {
        disableDepthTestDistance = -1;
      }
    }
    let imageHeight;
    let imageWidth;
    if (!defined2(billboard._labelDimensions)) {
      let height = 0;
      let width = 0;
      const index = billboard._imageIndex;
      if (index !== -1) {
        const imageRectangle = textureAtlasCoordinates[index];
        if (!defined2(imageRectangle)) {
          throw new DeveloperError2(`Invalid billboard image index: ${index}`);
        }
        height = imageRectangle.height;
        width = imageRectangle.width;
      }
      imageHeight = Math.round(
        defaultValue2(
          billboard.height,
          billboardCollection._textureAtlas.texture.dimensions.y * height
        )
      );
      const textureWidth = billboardCollection._textureAtlas.texture.width;
      imageWidth = Math.round(
        defaultValue2(billboard.width, textureWidth * width)
      );
    } else {
      imageWidth = billboard._labelDimensions.x;
      imageHeight = billboard._labelDimensions.y;
    }
    const w = Math.floor(CesiumMath3.clamp(imageWidth, 0, LEFT_SHIFT12));
    const h = Math.floor(CesiumMath3.clamp(imageHeight, 0, LEFT_SHIFT12));
    const dimensions = w * LEFT_SHIFT12 + h;
    if (billboardCollection._instanced) {
      i = billboard._index;
      writer(i, near, far, disableDepthTestDistance, dimensions);
    } else {
      i = billboard._index * 4;
      writer(i + 0, near, far, disableDepthTestDistance, dimensions);
      writer(i + 1, near, far, disableDepthTestDistance, dimensions);
      writer(i + 2, near, far, disableDepthTestDistance, dimensions);
      writer(i + 3, near, far, disableDepthTestDistance, dimensions);
    }
  }
  function writeTextureCoordinateBoundsOrLabelTranslate(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
    if (billboard.heightReference === HeightReference.CLAMP_TO_GROUND) {
      const scene = billboardCollection._scene;
      const context = frameState.context;
      const globeTranslucent = frameState.globeTranslucencyState.translucent;
      const depthTestAgainstTerrain = defined2(scene.globe) && scene.globe.depthTestAgainstTerrain;
      billboardCollection._shaderClampToGround = context.depthTexture && !globeTranslucent && depthTestAgainstTerrain;
    }
    let i;
    const writer = vafWriters[attributeLocations2.textureCoordinateBoundsOrLabelTranslate];
    if (ContextLimits.maximumVertexTextureImageUnits > 0) {
      let translateX = 0;
      let translateY = 0;
      if (defined2(billboard._labelTranslate)) {
        translateX = billboard._labelTranslate.x;
        translateY = billboard._labelTranslate.y;
      }
      if (billboardCollection._instanced) {
        i = billboard._index;
        writer(i, translateX, translateY, 0, 0);
      } else {
        i = billboard._index * 4;
        writer(i + 0, translateX, translateY, 0, 0);
        writer(i + 1, translateX, translateY, 0, 0);
        writer(i + 2, translateX, translateY, 0, 0);
        writer(i + 3, translateX, translateY, 0, 0);
      }
      return;
    }
    let minX = 0;
    let minY = 0;
    let width = 0;
    let height = 0;
    const index = billboard._imageIndex;
    if (index !== -1) {
      const imageRectangle = textureAtlasCoordinates[index];
      if (!defined2(imageRectangle)) {
        throw new DeveloperError2(`Invalid billboard image index: ${index}`);
      }
      minX = imageRectangle.x;
      minY = imageRectangle.y;
      width = imageRectangle.width;
      height = imageRectangle.height;
    }
    const maxX = minX + width;
    const maxY = minY + height;
    if (billboardCollection._instanced) {
      i = billboard._index;
      writer(i, minX, minY, maxX, maxY);
    } else {
      i = billboard._index * 4;
      writer(i + 0, minX, minY, maxX, maxY);
      writer(i + 1, minX, minY, maxX, maxY);
      writer(i + 2, minX, minY, maxX, maxY);
      writer(i + 3, minX, minY, maxX, maxY);
    }
  }
  function writeBatchId(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
    if (!defined2(billboardCollection._batchTable)) {
      return;
    }
    const writer = vafWriters[attributeLocations2.a_batchId];
    const id = billboard._batchIndex;
    let i;
    if (billboardCollection._instanced) {
      i = billboard._index;
      writer(i, id);
    } else {
      i = billboard._index * 4;
      writer(i + 0, id);
      writer(i + 1, id);
      writer(i + 2, id);
      writer(i + 3, id);
    }
  }
  function writeSDF(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
    if (!billboardCollection._sdf) {
      return;
    }
    let i;
    const writer = vafWriters[attributeLocations2.sdf];
    const outlineColor = billboard.outlineColor;
    const outlineWidth = billboard.outlineWidth;
    const red = Color2.floatToByte(outlineColor.red);
    const green = Color2.floatToByte(outlineColor.green);
    const blue = Color2.floatToByte(outlineColor.blue);
    const compressed0 = red * LEFT_SHIFT16 + green * LEFT_SHIFT8 + blue;
    const outlineDistance = outlineWidth / SDFSettings.RADIUS;
    const compressed1 = Color2.floatToByte(outlineColor.alpha) * LEFT_SHIFT16 + Color2.floatToByte(outlineDistance) * LEFT_SHIFT8;
    if (billboardCollection._instanced) {
      i = billboard._index;
      writer(i, compressed0, compressed1);
    } else {
      i = billboard._index * 4;
      writer(i + 0, compressed0 + LOWER_LEFT, compressed1);
      writer(i + 1, compressed0 + LOWER_RIGHT, compressed1);
      writer(i + 2, compressed0 + UPPER_RIGHT, compressed1);
      writer(i + 3, compressed0 + UPPER_LEFT, compressed1);
    }
  }
  function writeBillboard(billboardCollection, frameState, textureAtlasCoordinates, vafWriters, billboard) {
    writePositionScaleAndRotation(
      billboardCollection,
      frameState,
      textureAtlasCoordinates,
      vafWriters,
      billboard
    );
    writeCompressedAttrib0(
      billboardCollection,
      frameState,
      textureAtlasCoordinates,
      vafWriters,
      billboard
    );
    writeCompressedAttrib1(
      billboardCollection,
      frameState,
      textureAtlasCoordinates,
      vafWriters,
      billboard
    );
    writeCompressedAttrib2(
      billboardCollection,
      frameState,
      textureAtlasCoordinates,
      vafWriters,
      billboard
    );
    writeEyeOffset(
      billboardCollection,
      frameState,
      textureAtlasCoordinates,
      vafWriters,
      billboard
    );
    writeScaleByDistance(
      billboardCollection,
      frameState,
      textureAtlasCoordinates,
      vafWriters,
      billboard
    );
    writePixelOffsetScaleByDistance(
      billboardCollection,
      frameState,
      textureAtlasCoordinates,
      vafWriters,
      billboard
    );
    writeCompressedAttribute3(
      billboardCollection,
      frameState,
      textureAtlasCoordinates,
      vafWriters,
      billboard
    );
    writeTextureCoordinateBoundsOrLabelTranslate(
      billboardCollection,
      frameState,
      textureAtlasCoordinates,
      vafWriters,
      billboard
    );
    writeBatchId(
      billboardCollection,
      frameState,
      textureAtlasCoordinates,
      vafWriters,
      billboard
    );
    writeSDF(
      billboardCollection,
      frameState,
      textureAtlasCoordinates,
      vafWriters,
      billboard
    );
  }
  function recomputeActualPositions(billboardCollection, billboards, length2, frameState, modelMatrix, recomputeBoundingVolume) {
    let boundingVolume;
    if (frameState.mode === SceneMode2.SCENE3D) {
      boundingVolume = billboardCollection._baseVolume;
      billboardCollection._boundingVolumeDirty = true;
    } else {
      boundingVolume = billboardCollection._baseVolume2D;
    }
    const positions = [];
    for (let i = 0; i < length2; ++i) {
      const billboard = billboards[i];
      const position = billboard.position;
      const actualPosition = Billboard._computeActualPosition(
        billboard,
        position,
        frameState,
        modelMatrix
      );
      if (defined2(actualPosition)) {
        billboard._setActualPosition(actualPosition);
        if (recomputeBoundingVolume) {
          positions.push(actualPosition);
        } else {
          BoundingSphere2.expand(boundingVolume, actualPosition, boundingVolume);
        }
      }
    }
    if (recomputeBoundingVolume) {
      BoundingSphere2.fromPoints(positions, boundingVolume);
    }
  }
  function updateMode(billboardCollection, frameState) {
    const mode2 = frameState.mode;
    const billboards = billboardCollection._billboards;
    const billboardsToUpdate = billboardCollection._billboardsToUpdate;
    const modelMatrix = billboardCollection._modelMatrix;
    if (billboardCollection._createVertexArray || billboardCollection._mode !== mode2 || mode2 !== SceneMode2.SCENE3D && !Matrix42.equals(modelMatrix, billboardCollection.modelMatrix)) {
      billboardCollection._mode = mode2;
      Matrix42.clone(billboardCollection.modelMatrix, modelMatrix);
      billboardCollection._createVertexArray = true;
      if (mode2 === SceneMode2.SCENE3D || mode2 === SceneMode2.SCENE2D || mode2 === SceneMode2.COLUMBUS_VIEW) {
        recomputeActualPositions(
          billboardCollection,
          billboards,
          billboards.length,
          frameState,
          modelMatrix,
          true
        );
      }
    } else if (mode2 === SceneMode2.MORPHING) {
      recomputeActualPositions(
        billboardCollection,
        billboards,
        billboards.length,
        frameState,
        modelMatrix,
        true
      );
    } else if (mode2 === SceneMode2.SCENE2D || mode2 === SceneMode2.COLUMBUS_VIEW) {
      recomputeActualPositions(
        billboardCollection,
        billboardsToUpdate,
        billboardCollection._billboardsToUpdateIndex,
        frameState,
        modelMatrix,
        false
      );
    }
  }
  function updateBoundingVolume(collection, frameState, boundingVolume) {
    let pixelScale = 1;
    if (!collection._allSizedInMeters || collection._maxPixelOffset !== 0) {
      pixelScale = frameState.camera.getPixelSize(
        boundingVolume,
        frameState.context.drawingBufferWidth,
        frameState.context.drawingBufferHeight
      );
    }
    let size = pixelScale * collection._maxScale * collection._maxSize * 2;
    if (collection._allHorizontalCenter && collection._allVerticalCenter) {
      size *= 0.5;
    }
    const offset = pixelScale * collection._maxPixelOffset + collection._maxEyeOffset;
    boundingVolume.radius += size + offset;
  }
  function createDebugCommand(billboardCollection, context) {
    const fs = "uniform sampler2D billboard_texture; \nvarying vec2 v_textureCoordinates; \nvoid main() \n{ \n    gl_FragColor = texture2D(billboard_texture, v_textureCoordinates); \n} \n";
    const drawCommand = context.createViewportQuadCommand(fs, {
      uniformMap: {
        billboard_texture: function() {
          return billboardCollection._textureAtlas.texture;
        }
      }
    });
    drawCommand.pass = Pass2.OVERLAY;
    return drawCommand;
  }
  var scratchWriterArray = [];
  BillboardCollection.prototype.update = function(frameState) {
    removeBillboards(this);
    if (!this.show) {
      return;
    }
    let billboards = this._billboards;
    let billboardsLength = billboards.length;
    const context = frameState.context;
    this._instanced = context.instancedArrays;
    attributeLocations2 = this._instanced ? attributeLocationsInstanced : attributeLocationsBatched;
    getIndexBuffer = this._instanced ? getIndexBufferInstanced : getIndexBufferBatched;
    let textureAtlas = this._textureAtlas;
    if (!defined2(textureAtlas)) {
      textureAtlas = this._textureAtlas = new TextureAtlas({
        context
      });
      for (let ii = 0; ii < billboardsLength; ++ii) {
        billboards[ii]._loadImage();
      }
    }
    const textureAtlasCoordinates = textureAtlas.textureCoordinates;
    if (textureAtlasCoordinates.length === 0) {
      return;
    }
    updateMode(this, frameState);
    billboards = this._billboards;
    billboardsLength = billboards.length;
    const billboardsToUpdate = this._billboardsToUpdate;
    const billboardsToUpdateLength = this._billboardsToUpdateIndex;
    const properties = this._propertiesChanged;
    const textureAtlasGUID = textureAtlas.guid;
    const createVertexArray2 = this._createVertexArray || this._textureAtlasGUID !== textureAtlasGUID;
    this._textureAtlasGUID = textureAtlasGUID;
    let vafWriters;
    const pass = frameState.passes;
    const picking = pass.pick;
    if (createVertexArray2 || !picking && this.computeNewBuffersUsage()) {
      this._createVertexArray = false;
      for (let k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
        properties[k] = 0;
      }
      this._vaf = this._vaf && this._vaf.destroy();
      if (billboardsLength > 0) {
        this._vaf = createVAF(
          context,
          billboardsLength,
          this._buffersUsage,
          this._instanced,
          this._batchTable,
          this._sdf
        );
        vafWriters = this._vaf.writers;
        for (let i = 0; i < billboardsLength; ++i) {
          const billboard = this._billboards[i];
          billboard._dirty = false;
          writeBillboard(
            this,
            frameState,
            textureAtlasCoordinates,
            vafWriters,
            billboard
          );
        }
        this._vaf.commit(getIndexBuffer(context));
      }
      this._billboardsToUpdateIndex = 0;
    } else if (billboardsToUpdateLength > 0) {
      const writers = scratchWriterArray;
      writers.length = 0;
      if (properties[POSITION_INDEX] || properties[ROTATION_INDEX] || properties[SCALE_INDEX]) {
        writers.push(writePositionScaleAndRotation);
      }
      if (properties[IMAGE_INDEX_INDEX] || properties[PIXEL_OFFSET_INDEX] || properties[HORIZONTAL_ORIGIN_INDEX] || properties[VERTICAL_ORIGIN_INDEX] || properties[SHOW_INDEX]) {
        writers.push(writeCompressedAttrib0);
        if (this._instanced) {
          writers.push(writeEyeOffset);
        }
      }
      if (properties[IMAGE_INDEX_INDEX] || properties[ALIGNED_AXIS_INDEX] || properties[TRANSLUCENCY_BY_DISTANCE_INDEX]) {
        writers.push(writeCompressedAttrib1);
        writers.push(writeCompressedAttrib2);
      }
      if (properties[IMAGE_INDEX_INDEX] || properties[COLOR_INDEX]) {
        writers.push(writeCompressedAttrib2);
      }
      if (properties[EYE_OFFSET_INDEX]) {
        writers.push(writeEyeOffset);
      }
      if (properties[SCALE_BY_DISTANCE_INDEX]) {
        writers.push(writeScaleByDistance);
      }
      if (properties[PIXEL_OFFSET_SCALE_BY_DISTANCE_INDEX]) {
        writers.push(writePixelOffsetScaleByDistance);
      }
      if (properties[DISTANCE_DISPLAY_CONDITION_INDEX] || properties[DISABLE_DEPTH_DISTANCE] || properties[IMAGE_INDEX_INDEX] || properties[POSITION_INDEX]) {
        writers.push(writeCompressedAttribute3);
      }
      if (properties[IMAGE_INDEX_INDEX] || properties[POSITION_INDEX]) {
        writers.push(writeTextureCoordinateBoundsOrLabelTranslate);
      }
      if (properties[SDF_INDEX]) {
        writers.push(writeSDF);
      }
      const numWriters = writers.length;
      vafWriters = this._vaf.writers;
      if (billboardsToUpdateLength / billboardsLength > 0.1) {
        for (let m = 0; m < billboardsToUpdateLength; ++m) {
          const b = billboardsToUpdate[m];
          b._dirty = false;
          for (let n = 0; n < numWriters; ++n) {
            writers[n](this, frameState, textureAtlasCoordinates, vafWriters, b);
          }
        }
        this._vaf.commit(getIndexBuffer(context));
      } else {
        for (let h = 0; h < billboardsToUpdateLength; ++h) {
          const bb = billboardsToUpdate[h];
          bb._dirty = false;
          for (let o = 0; o < numWriters; ++o) {
            writers[o](this, frameState, textureAtlasCoordinates, vafWriters, bb);
          }
          if (this._instanced) {
            this._vaf.subCommit(bb._index, 1);
          } else {
            this._vaf.subCommit(bb._index * 4, 4);
          }
        }
        this._vaf.endSubCommits();
      }
      this._billboardsToUpdateIndex = 0;
    }
    if (billboardsToUpdateLength > billboardsLength * 1.5) {
      billboardsToUpdate.length = billboardsLength;
    }
    if (!defined2(this._vaf) || !defined2(this._vaf.va)) {
      return;
    }
    if (this._boundingVolumeDirty) {
      this._boundingVolumeDirty = false;
      BoundingSphere2.transform(
        this._baseVolume,
        this.modelMatrix,
        this._baseVolumeWC
      );
    }
    let boundingVolume;
    let modelMatrix = Matrix42.IDENTITY;
    if (frameState.mode === SceneMode2.SCENE3D) {
      modelMatrix = this.modelMatrix;
      boundingVolume = BoundingSphere2.clone(
        this._baseVolumeWC,
        this._boundingVolume
      );
    } else {
      boundingVolume = BoundingSphere2.clone(
        this._baseVolume2D,
        this._boundingVolume
      );
    }
    updateBoundingVolume(this, frameState, boundingVolume);
    const blendOptionChanged = this._blendOption !== this.blendOption;
    this._blendOption = this.blendOption;
    if (blendOptionChanged) {
      if (this._blendOption === BlendOption.OPAQUE || this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {
        this._rsOpaque = RenderState2.fromCache({
          depthTest: {
            enabled: true,
            func: WebGLConstants.LESS
          },
          depthMask: true
        });
      } else {
        this._rsOpaque = void 0;
      }
      const useTranslucentDepthMask = this._blendOption === BlendOption.TRANSLUCENT;
      if (this._blendOption === BlendOption.TRANSLUCENT || this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {
        this._rsTranslucent = RenderState2.fromCache({
          depthTest: {
            enabled: true,
            func: useTranslucentDepthMask ? WebGLConstants.LEQUAL : WebGLConstants.LESS
          },
          depthMask: useTranslucentDepthMask,
          blending: BlendingState2.ALPHA_BLEND
        });
      } else {
        this._rsTranslucent = void 0;
      }
    }
    this._shaderDisableDepthDistance = this._shaderDisableDepthDistance || frameState.minimumDisableDepthTestDistance !== 0;
    let vsSource;
    let fsSource;
    let vs;
    let fs;
    let vertDefines;
    const supportVSTextureReads = ContextLimits.maximumVertexTextureImageUnits > 0;
    if (blendOptionChanged || this._shaderRotation !== this._compiledShaderRotation || this._shaderAlignedAxis !== this._compiledShaderAlignedAxis || this._shaderScaleByDistance !== this._compiledShaderScaleByDistance || this._shaderTranslucencyByDistance !== this._compiledShaderTranslucencyByDistance || this._shaderPixelOffsetScaleByDistance !== this._compiledShaderPixelOffsetScaleByDistance || this._shaderDistanceDisplayCondition !== this._compiledShaderDistanceDisplayCondition || this._shaderDisableDepthDistance !== this._compiledShaderDisableDepthDistance || this._shaderClampToGround !== this._compiledShaderClampToGround || this._sdf !== this._compiledSDF) {
      vsSource = BillboardCollectionVS;
      fsSource = BillboardCollectionFS;
      vertDefines = [];
      if (defined2(this._batchTable)) {
        vertDefines.push("VECTOR_TILE");
        vsSource = this._batchTable.getVertexShaderCallback(
          false,
          "a_batchId",
          void 0
        )(vsSource);
        fsSource = this._batchTable.getFragmentShaderCallback(
          false,
          void 0
        )(fsSource);
      }
      vs = new ShaderSource2({
        defines: vertDefines,
        sources: [vsSource]
      });
      if (this._ENUENABLED) {
        vs.defines.push("ENU_ENABLED");
      }
      if (this._instanced) {
        vs.defines.push("INSTANCED");
      }
      if (this._shaderRotation) {
        vs.defines.push("ROTATION");
      }
      if (this._shaderAlignedAxis) {
        vs.defines.push("ALIGNED_AXIS");
      }
      if (this._shaderScaleByDistance) {
        vs.defines.push("EYE_DISTANCE_SCALING");
      }
      if (this._shaderTranslucencyByDistance) {
        vs.defines.push("EYE_DISTANCE_TRANSLUCENCY");
      }
      if (this._shaderPixelOffsetScaleByDistance) {
        vs.defines.push("EYE_DISTANCE_PIXEL_OFFSET");
      }
      if (this._shaderDistanceDisplayCondition) {
        vs.defines.push("DISTANCE_DISPLAY_CONDITION");
      }
      if (this._shaderDisableDepthDistance) {
        vs.defines.push("DISABLE_DEPTH_DISTANCE");
      }
      if (this._shaderClampToGround) {
        if (supportVSTextureReads) {
          vs.defines.push("VERTEX_DEPTH_CHECK");
        } else {
          vs.defines.push("FRAGMENT_DEPTH_CHECK");
        }
      }
      const sdfEdge = 1 - SDFSettings.CUTOFF;
      if (this._sdf) {
        vs.defines.push("SDF");
      }
      const vectorFragDefine = defined2(this._batchTable) ? "VECTOR_TILE" : "";
      if (this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT) {
        fs = new ShaderSource2({
          defines: ["OPAQUE", vectorFragDefine],
          sources: [fsSource]
        });
        if (this._shaderClampToGround) {
          if (supportVSTextureReads) {
            fs.defines.push("VERTEX_DEPTH_CHECK");
          } else {
            fs.defines.push("FRAGMENT_DEPTH_CHECK");
          }
        }
        if (this._sdf) {
          fs.defines.push("SDF");
          fs.defines.push(`SDF_EDGE ${sdfEdge}`);
        }
        this._sp = ShaderProgram2.replaceCache({
          context,
          shaderProgram: this._sp,
          vertexShaderSource: vs,
          fragmentShaderSource: fs,
          attributeLocations: attributeLocations2
        });
        fs = new ShaderSource2({
          defines: ["TRANSLUCENT", vectorFragDefine],
          sources: [fsSource]
        });
        if (this._shaderClampToGround) {
          if (supportVSTextureReads) {
            fs.defines.push("VERTEX_DEPTH_CHECK");
          } else {
            fs.defines.push("FRAGMENT_DEPTH_CHECK");
          }
        }
        if (this._sdf) {
          fs.defines.push("SDF");
          fs.defines.push(`SDF_EDGE ${sdfEdge}`);
        }
        this._spTranslucent = ShaderProgram2.replaceCache({
          context,
          shaderProgram: this._spTranslucent,
          vertexShaderSource: vs,
          fragmentShaderSource: fs,
          attributeLocations: attributeLocations2
        });
      }
      if (this._blendOption === BlendOption.OPAQUE) {
        fs = new ShaderSource2({
          defines: [vectorFragDefine],
          sources: [fsSource]
        });
        if (this._shaderClampToGround) {
          if (supportVSTextureReads) {
            fs.defines.push("VERTEX_DEPTH_CHECK");
          } else {
            fs.defines.push("FRAGMENT_DEPTH_CHECK");
          }
        }
        if (this._sdf) {
          fs.defines.push("SDF");
          fs.defines.push(`SDF_EDGE ${sdfEdge}`);
        }
        this._sp = ShaderProgram2.replaceCache({
          context,
          shaderProgram: this._sp,
          vertexShaderSource: vs,
          fragmentShaderSource: fs,
          attributeLocations: attributeLocations2
        });
      }
      if (this._blendOption === BlendOption.TRANSLUCENT) {
        fs = new ShaderSource2({
          defines: [vectorFragDefine],
          sources: [fsSource]
        });
        if (this._shaderClampToGround) {
          if (supportVSTextureReads) {
            fs.defines.push("VERTEX_DEPTH_CHECK");
          } else {
            fs.defines.push("FRAGMENT_DEPTH_CHECK");
          }
        }
        if (this._sdf) {
          fs.defines.push("SDF");
          fs.defines.push(`SDF_EDGE ${sdfEdge}`);
        }
        this._spTranslucent = ShaderProgram2.replaceCache({
          context,
          shaderProgram: this._spTranslucent,
          vertexShaderSource: vs,
          fragmentShaderSource: fs,
          attributeLocations: attributeLocations2
        });
      }
      this._compiledShaderRotation = this._shaderRotation;
      this._compiledShaderAlignedAxis = this._shaderAlignedAxis;
      this._compiledShaderScaleByDistance = this._shaderScaleByDistance;
      this._compiledShaderTranslucencyByDistance = this._shaderTranslucencyByDistance;
      this._compiledShaderPixelOffsetScaleByDistance = this._shaderPixelOffsetScaleByDistance;
      this._compiledShaderDistanceDisplayCondition = this._shaderDistanceDisplayCondition;
      this._compiledShaderDisableDepthDistance = this._shaderDisableDepthDistance;
      this._compiledShaderClampToGround = this._shaderClampToGround;
      this._compiledSDF = this._sdf;
    }
    const commandList = frameState.commandList;
    if (pass.render || pass.pick) {
      const colorList = this._colorCommands;
      const opaque = this._blendOption === BlendOption.OPAQUE;
      const opaqueAndTranslucent = this._blendOption === BlendOption.OPAQUE_AND_TRANSLUCENT;
      const va = this._vaf.va;
      const vaLength = va.length;
      let uniforms = this._uniforms;
      let pickId;
      if (defined2(this._batchTable)) {
        uniforms = this._batchTable.getUniformMapCallback()(uniforms);
        pickId = this._batchTable.getPickId();
      } else {
        pickId = "v_pickColor";
      }
      colorList.length = vaLength;
      const totalLength = opaqueAndTranslucent ? vaLength * 2 : vaLength;
      for (let j = 0; j < totalLength; ++j) {
        let command = colorList[j];
        if (!defined2(command)) {
          command = colorList[j] = new DrawCommand2();
        }
        const opaqueCommand = opaque || opaqueAndTranslucent && j % 2 === 0;
        command.pass = opaqueCommand || !opaqueAndTranslucent ? Pass2.OPAQUE : Pass2.TRANSLUCENT;
        command.owner = this;
        const index = opaqueAndTranslucent ? Math.floor(j / 2) : j;
        command.boundingVolume = boundingVolume;
        command.modelMatrix = modelMatrix;
        command.count = va[index].indicesCount;
        command.shaderProgram = opaqueCommand ? this._sp : this._spTranslucent;
        command.uniformMap = uniforms;
        command.vertexArray = va[index].va;
        command.renderState = opaqueCommand ? this._rsOpaque : this._rsTranslucent;
        command.debugShowBoundingVolume = this.debugShowBoundingVolume;
        command.pickId = pickId;
        if (this._instanced) {
          command.count = 6;
          command.instanceCount = billboardsLength;
        }
        commandList.push(command);
      }
      if (this.debugShowTextureAtlas) {
        if (!defined2(this.debugCommand)) {
          this.debugCommand = createDebugCommand(this, frameState.context);
        }
        commandList.push(this.debugCommand);
      }
    }
  };
  BillboardCollection.prototype.isDestroyed = function() {
    return false;
  };
  BillboardCollection.prototype.destroy = function() {
    if (defined2(this._removeCallbackFunc)) {
      this._removeCallbackFunc();
      this._removeCallbackFunc = void 0;
    }
    this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
    this._sp = this._sp && this._sp.destroy();
    this._spTranslucent = this._spTranslucent && this._spTranslucent.destroy();
    this._vaf = this._vaf && this._vaf.destroy();
    destroyBillboards(this._billboards);
    return destroyObject(this);
  };
  var BillboardCollection_default = BillboardCollection;

  // Source/custom/ext/CesiumTerrainProvider.js
  var AttributeCompression2 = Cesium.AttributeCompression;
  var BoundingSphere3 = Cesium.BoundingSphere;
  var Cartesian33 = Cesium.Cartesian3;
  var Credit = Cesium.Credit;
  var defaultValue3 = Cesium.defaultValue;
  var defined3 = Cesium.defined;
  var DeveloperError3 = Cesium.DeveloperError;
  var Event = Cesium.Event;
  var GeographicTilingScheme = Cesium.GeographicTilingScheme;
  var WebMercatorTilingScheme = Cesium.WebMercatorTilingScheme;
  var getStringFromTypedArray = Cesium.getStringFromTypedArray;
  var HeightmapTerrainData = Cesium.HeightmapTerrainData;
  var IndexDatatype2 = Cesium.IndexDatatype;
  var OrientedBoundingBox = Cesium.OrientedBoundingBox;
  var QuantizedMeshTerrainData = Cesium.QuantizedMeshTerrainData;
  var Request = Cesium.Request;
  var RequestType = Cesium.RequestType;
  var Resource = Cesium.Resource;
  var RuntimeError2 = Cesium.RuntimeError;
  var TerrainProvider = Cesium.TerrainProvider;
  var TileAvailability = Cesium.TileAvailability;
  var TileProviderError = Cesium.TileProviderError;
  var defer = Cesium.defer;
  function LayerInformation(layer) {
    this.resource = layer.resource;
    this.version = layer.version;
    this.isHeightmap = layer.isHeightmap;
    this.tileUrlTemplates = layer.tileUrlTemplates;
    this.availability = layer.availability;
    this.hasVertexNormals = layer.hasVertexNormals;
    this.hasWaterMask = layer.hasWaterMask;
    this.hasMetadata = layer.hasMetadata;
    this.availabilityLevels = layer.availabilityLevels;
    this.availabilityTilesLoaded = layer.availabilityTilesLoaded;
    this.littleEndianExtensionSize = layer.littleEndianExtensionSize;
    this.availabilityTilesLoaded = layer.availabilityTilesLoaded;
    this.availabilityPromiseCache = {};
  }
  function CesiumTerrainProvider(options) {
    if (!defined3(options) || !defined3(options.url)) {
      throw new DeveloperError3("options.url is required.");
    }
    this._heightmapWidth = 65;
    this._heightmapStructure = void 0;
    this._hasWaterMask = false;
    this._hasVertexNormals = false;
    this._ellipsoid = options.ellipsoid;
    this._requestVertexNormals = defaultValue3(options.requestVertexNormals, false);
    this._requestWaterMask = defaultValue3(options.requestWaterMask, false);
    this._requestMetadata = defaultValue3(options.requestMetadata, true);
    this._errorEvent = new Event();
    var credit = options.credit;
    if (typeof credit === "string") {
      credit = new Credit(credit);
    }
    this._credit = credit;
    this._availability = void 0;
    var deferred = defer();
    this._ready = false;
    this._readyPromise = deferred;
    this._tileCredits = void 0;
    var that = this;
    var lastResource;
    var layerJsonResource;
    var metadataError;
    var layers = this._layers = [];
    var attribution = "";
    var overallAvailability = [];
    var overallMaxZoom = 0;
    Promise.resolve(options.url).then(function(url) {
      var resource = Resource.createIfNeeded(url);
      resource.appendForwardSlash();
      lastResource = resource;
      layerJsonResource = lastResource.getDerivedResource({
        url: "layer.json"
      });
      that._tileCredits = resource.credits;
      requestLayerJson();
    }).otherwise(function(e) {
      deferred.reject(e);
    });
    function parseMetadataSuccess(data) {
      var message;
      if (!data.format) {
        message = "The tile format is not specified in the layer.json file.";
        metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, void 0, void 0, void 0, requestLayerJson);
        return;
      }
      if (!data.tiles || data.tiles.length === 0) {
        message = "The layer.json file does not specify any tile URL templates.";
        metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, void 0, void 0, void 0, requestLayerJson);
        return;
      }
      var hasVertexNormals = false;
      var hasWaterMask = false;
      var hasMetadata = false;
      var littleEndianExtensionSize = true;
      var isHeightmap = false;
      if (data.format === "heightmap-1.0") {
        isHeightmap = true;
        if (!defined3(that._heightmapStructure)) {
          that._heightmapStructure = {
            heightScale: 1 / 5,
            heightOffset: -1e3,
            elementsPerHeight: 1,
            stride: 1,
            elementMultiplier: 256,
            isBigEndian: false,
            lowestEncodedHeight: 0,
            highestEncodedHeight: 256 * 256 - 1
          };
        }
        hasWaterMask = true;
        that._requestWaterMask = true;
      } else if (data.format.indexOf("quantized-mesh-1.") !== 0) {
        message = 'The tile format "' + data.format + '" is invalid or not supported.';
        metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, void 0, void 0, void 0, requestLayerJson);
        return;
      }
      var tileUrlTemplates = data.tiles;
      var maxZoom = data.maxzoom;
      overallMaxZoom = Math.max(overallMaxZoom, maxZoom);
      if (!data.projection || data.projection === "EPSG:4326") {
        that._tilingScheme = new GeographicTilingScheme({
          numberOfLevelZeroTilesX: 2,
          numberOfLevelZeroTilesY: 1,
          ellipsoid: that._ellipsoid
        });
      } else if (data.projection === "EPSG:3857") {
        that._tilingScheme = new WebMercatorTilingScheme({
          numberOfLevelZeroTilesX: 1,
          numberOfLevelZeroTilesY: 1,
          ellipsoid: that._ellipsoid
        });
      } else {
        message = 'The projection "' + data.projection + '" is invalid or not supported.';
        metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, void 0, void 0, void 0, requestLayerJson);
        return;
      }
      that._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(
        that._tilingScheme.ellipsoid,
        that._heightmapWidth,
        that._tilingScheme.getNumberOfXTilesAtLevel(0)
      );
      if (!data.scheme || data.scheme === "tms" || data.scheme === "slippyMap") {
        that._scheme = data.scheme;
      } else {
        message = 'The scheme "' + data.scheme + '" is invalid or not supported.';
        metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, void 0, void 0, void 0, requestLayerJson);
        return;
      }
      var availabilityTilesLoaded;
      if (defined3(data.extensions) && data.extensions.indexOf("octvertexnormals") !== -1) {
        hasVertexNormals = true;
      } else if (defined3(data.extensions) && data.extensions.indexOf("vertexnormals") !== -1) {
        hasVertexNormals = true;
        littleEndianExtensionSize = false;
      }
      if (defined3(data.extensions) && data.extensions.indexOf("watermask") !== -1) {
        hasWaterMask = true;
      }
      if (defined3(data.extensions) && data.extensions.indexOf("metadata") !== -1) {
        hasMetadata = true;
      }
      var availabilityLevels = data.metadataAvailability;
      var availableTiles = data.available;
      var availability;
      if (defined3(availableTiles) && !defined3(availabilityLevels)) {
        availability = new TileAvailability(that._tilingScheme, availableTiles.length);
        for (var level = 0; level < availableTiles.length; ++level) {
          var rangesAtLevel = availableTiles[level];
          var yTiles = that._tilingScheme.getNumberOfYTilesAtLevel(level);
          if (!defined3(overallAvailability[level])) {
            overallAvailability[level] = [];
          }
          for (var rangeIndex = 0; rangeIndex < rangesAtLevel.length; ++rangeIndex) {
            var range = rangesAtLevel[rangeIndex];
            var yStart = yTiles - range.endY - 1;
            var yEnd = yTiles - range.startY - 1;
            overallAvailability[level].push([range.startX, yStart, range.endX, yEnd]);
            availability.addAvailableTileRange(level, range.startX, yStart, range.endX, yEnd);
          }
        }
      } else if (defined3(availabilityLevels)) {
        availabilityTilesLoaded = new TileAvailability(that._tilingScheme, maxZoom);
        availability = new TileAvailability(that._tilingScheme, maxZoom);
        overallAvailability[0] = [
          [0, 0, 1, 0]
        ];
        availability.addAvailableTileRange(0, 0, 0, 1, 0);
      }
      that._hasWaterMask = that._hasWaterMask || hasWaterMask;
      that._hasVertexNormals = that._hasVertexNormals || hasVertexNormals;
      that._hasMetadata = that._hasMetadata || hasMetadata;
      if (defined3(data.attribution)) {
        if (attribution.length > 0) {
          attribution += " ";
        }
        attribution += data.attribution;
      }
      layers.push(new LayerInformation({
        resource: lastResource,
        version: data.version,
        isHeightmap,
        tileUrlTemplates,
        availability,
        hasVertexNormals,
        hasWaterMask,
        hasMetadata,
        availabilityLevels,
        availabilityTilesLoaded,
        littleEndianExtensionSize
      }));
      var parentUrl = data.parentUrl;
      if (defined3(parentUrl)) {
        if (!defined3(availability)) {
          console.log("A layer.json can't have a parentUrl if it does't have an available array.");
          return Promise.resolve();
        }
        lastResource = lastResource.getDerivedResource({
          url: parentUrl
        });
        lastResource.appendForwardSlash();
        layerJsonResource = lastResource.getDerivedResource({
          url: "layer.json"
        });
        var parentMetadata = layerJsonResource.fetchJson();
        return Promise.resolve(parentMetadata).then(parseMetadataSuccess, parseMetadataFailure);
      }
      return Promise.resolve();
    }
    function parseMetadataFailure(data) {
      var message = "An error occurred while accessing " + layerJsonResource.url + ".";
      metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, message, void 0, void 0, void 0, requestLayerJson);
    }
    function metadataSuccess(data) {
      parseMetadataSuccess(data).then(function() {
        if (defined3(metadataError)) {
          return;
        }
        var length2 = overallAvailability.length;
        if (length2 > 0) {
          var availability = that._availability = new TileAvailability(that._tilingScheme, overallMaxZoom);
          for (var level = 0; level < length2; ++level) {
            var levelRanges = overallAvailability[level];
            for (var i = 0; i < levelRanges.length; ++i) {
              var range = levelRanges[i];
              availability.addAvailableTileRange(level, range[0], range[1], range[2], range[3]);
            }
          }
        }
        if (attribution.length > 0) {
          var layerJsonCredit = new Credit(attribution);
          if (defined3(that._tileCredits)) {
            that._tileCredits.push(layerJsonCredit);
          } else {
            that._tileCredits = [layerJsonCredit];
          }
        }
        that._ready = true;
        that._readyPromise.resolve(true);
      });
    }
    function metadataFailure(data) {
      if (defined3(data) && data.statusCode === 404) {
        metadataSuccess({
          tilejson: "2.1.0",
          format: "heightmap-1.0",
          version: "1.0.0",
          scheme: "tms",
          tiles: [
            "{z}/{x}/{y}.terrain?v={version}"
          ]
        });
        return;
      }
      parseMetadataFailure(data);
    }
    function requestLayerJson() {
      Promise.resolve(layerJsonResource.fetchJson()).then(metadataSuccess).otherwise(metadataFailure);
    }
    this.processor = new Cesium.TaskProcessor("RequestData", Number.POSITIVE_INFINITY);
  }
  var QuantizedMeshExtensionIds = {
    OCT_VERTEX_NORMALS: 1,
    WATER_MASK: 2,
    METADATA: 4
  };
  function getRequestHeader(extensionsList) {
    if (!defined3(extensionsList) || extensionsList.length === 0) {
      return {
        Accept: "application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01"
      };
    }
    var extensions = extensionsList.join("-");
    return {
      Accept: "application/vnd.quantized-mesh;extensions=" + extensions + ",application/octet-stream;q=0.9,*/*;q=0.01"
    };
  }
  function createHeightmapTerrainData(provider, buffer4, level, x3, y3) {
    var heightBuffer = new Uint16Array(buffer4, 0, provider._heightmapWidth * provider._heightmapWidth);
    return new HeightmapTerrainData({
      buffer: heightBuffer,
      childTileMask: new Uint8Array(buffer4, heightBuffer.byteLength, 1)[0],
      waterMask: new Uint8Array(buffer4, heightBuffer.byteLength + 1, buffer4.byteLength - heightBuffer.byteLength - 1),
      width: provider._heightmapWidth,
      height: provider._heightmapWidth,
      structure: provider._heightmapStructure,
      credits: provider._tileCredits
    });
  }
  function createQuantizedMeshTerrainData(provider, buffer4, level, x3, y3, layer) {
    var littleEndianExtensionSize = layer.littleEndianExtensionSize;
    var pos = 0;
    var cartesian3Elements = 3;
    var boundingSphereElements = cartesian3Elements + 1;
    var cartesian3Length = Float64Array.BYTES_PER_ELEMENT * cartesian3Elements;
    var boundingSphereLength = Float64Array.BYTES_PER_ELEMENT * boundingSphereElements;
    var encodedVertexElements = 3;
    var encodedVertexLength = Uint16Array.BYTES_PER_ELEMENT * encodedVertexElements;
    var triangleElements = 3;
    var bytesPerIndex = Uint16Array.BYTES_PER_ELEMENT;
    var triangleLength = bytesPerIndex * triangleElements;
    var view = new DataView(buffer4);
    var center2 = new Cartesian33(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true));
    pos += cartesian3Length;
    var minimumHeight = view.getFloat32(pos, true);
    pos += Float32Array.BYTES_PER_ELEMENT;
    var maximumHeight = view.getFloat32(pos, true);
    pos += Float32Array.BYTES_PER_ELEMENT;
    var boundingSphere = new BoundingSphere3(
      new Cartesian33(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true)),
      view.getFloat64(pos + cartesian3Length, true)
    );
    pos += boundingSphereLength;
    var horizonOcclusionPoint = new Cartesian33(view.getFloat64(pos, true), view.getFloat64(pos + 8, true), view.getFloat64(pos + 16, true));
    pos += cartesian3Length;
    var vertexCount = view.getUint32(pos, true);
    pos += Uint32Array.BYTES_PER_ELEMENT;
    var encodedVertexBuffer = new Uint16Array(buffer4, pos, vertexCount * 3);
    pos += vertexCount * encodedVertexLength;
    if (vertexCount > 64 * 1024) {
      bytesPerIndex = Uint32Array.BYTES_PER_ELEMENT;
      triangleLength = bytesPerIndex * triangleElements;
    }
    var uBuffer = encodedVertexBuffer.subarray(0, vertexCount);
    var vBuffer = encodedVertexBuffer.subarray(vertexCount, 2 * vertexCount);
    var heightBuffer = encodedVertexBuffer.subarray(vertexCount * 2, 3 * vertexCount);
    AttributeCompression2.zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer);
    if (pos % bytesPerIndex !== 0) {
      pos += bytesPerIndex - pos % bytesPerIndex;
    }
    var triangleCount = view.getUint32(pos, true);
    pos += Uint32Array.BYTES_PER_ELEMENT;
    var indices = IndexDatatype2.createTypedArrayFromArrayBuffer(vertexCount, buffer4, pos, triangleCount * triangleElements);
    pos += triangleCount * triangleLength;
    var highest = 0;
    var length2 = indices.length;
    for (var i = 0; i < length2; ++i) {
      var code = indices[i];
      indices[i] = highest - code;
      if (code === 0) {
        ++highest;
      }
    }
    var westVertexCount = view.getUint32(pos, true);
    pos += Uint32Array.BYTES_PER_ELEMENT;
    var westIndices = IndexDatatype2.createTypedArrayFromArrayBuffer(vertexCount, buffer4, pos, westVertexCount);
    pos += westVertexCount * bytesPerIndex;
    var southVertexCount = view.getUint32(pos, true);
    pos += Uint32Array.BYTES_PER_ELEMENT;
    var southIndices = IndexDatatype2.createTypedArrayFromArrayBuffer(vertexCount, buffer4, pos, southVertexCount);
    pos += southVertexCount * bytesPerIndex;
    var eastVertexCount = view.getUint32(pos, true);
    pos += Uint32Array.BYTES_PER_ELEMENT;
    var eastIndices = IndexDatatype2.createTypedArrayFromArrayBuffer(vertexCount, buffer4, pos, eastVertexCount);
    pos += eastVertexCount * bytesPerIndex;
    var northVertexCount = view.getUint32(pos, true);
    pos += Uint32Array.BYTES_PER_ELEMENT;
    var northIndices = IndexDatatype2.createTypedArrayFromArrayBuffer(vertexCount, buffer4, pos, northVertexCount);
    pos += northVertexCount * bytesPerIndex;
    var encodedNormalBuffer;
    var waterMaskBuffer;
    while (pos < view.byteLength) {
      var extensionId = view.getUint8(pos, true);
      pos += Uint8Array.BYTES_PER_ELEMENT;
      var extensionLength = view.getUint32(pos, littleEndianExtensionSize);
      pos += Uint32Array.BYTES_PER_ELEMENT;
      if (extensionId === QuantizedMeshExtensionIds.OCT_VERTEX_NORMALS && provider._requestVertexNormals) {
        encodedNormalBuffer = new Uint8Array(buffer4, pos, vertexCount * 2);
      } else if (extensionId === QuantizedMeshExtensionIds.WATER_MASK && provider._requestWaterMask) {
        waterMaskBuffer = new Uint8Array(buffer4, pos, extensionLength);
      } else if (extensionId === QuantizedMeshExtensionIds.METADATA && provider._requestMetadata) {
        var stringLength = view.getUint32(pos, true);
        if (stringLength > 0) {
          var jsonString = getStringFromTypedArray(new Uint8Array(buffer4), pos + Uint32Array.BYTES_PER_ELEMENT, stringLength);
          var metadata = JSON.parse(jsonString);
          var availableTiles = metadata.available;
          if (defined3(availableTiles)) {
            for (var offset = 0; offset < availableTiles.length; ++offset) {
              var availableLevel = level + offset + 1;
              var rangesAtLevel = availableTiles[offset];
              var yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(availableLevel);
              for (var rangeIndex = 0; rangeIndex < rangesAtLevel.length; ++rangeIndex) {
                var range = rangesAtLevel[rangeIndex];
                var yStart = yTiles - range.endY - 1;
                var yEnd = yTiles - range.startY - 1;
                provider.availability.addAvailableTileRange(availableLevel, range.startX, yStart, range.endX, yEnd);
                layer.availability.addAvailableTileRange(availableLevel, range.startX, yStart, range.endX, yEnd);
              }
            }
          }
        }
        layer.availabilityTilesLoaded.addAvailableTileRange(level, x3, y3, x3, y3);
      }
      pos += extensionLength;
    }
    var skirtHeight = provider.getLevelMaximumGeometricError(level) * 0;
    var rectangle = provider._tilingScheme.tileXYToRectangle(x3, y3, level);
    var orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, provider._tilingScheme.ellipsoid);
    return new QuantizedMeshTerrainData({
      center: center2,
      minimumHeight,
      maximumHeight,
      boundingSphere,
      orientedBoundingBox,
      horizonOcclusionPoint,
      quantizedVertices: encodedVertexBuffer,
      encodedNormals: encodedNormalBuffer,
      indices,
      westIndices,
      southIndices,
      eastIndices,
      northIndices,
      westSkirtHeight: skirtHeight,
      southSkirtHeight: skirtHeight,
      eastSkirtHeight: skirtHeight,
      northSkirtHeight: skirtHeight,
      childTileMask: provider.availability.computeChildMaskForTile(level, x3, y3),
      waterMask: waterMaskBuffer,
      credits: provider._tileCredits
    });
  }
  CesiumTerrainProvider.prototype.requestTileGeometry = function(x3, y3, level, request) {
    if (!this._ready) {
      throw new DeveloperError3("requestTileGeometry must not be called before the terrain provider is ready.");
    }
    var layers = this._layers;
    var layerToUse;
    var layerCount = layers.length;
    if (layerCount === 1) {
      layerToUse = layers[0];
    } else {
      for (var i = 0; i < layerCount; ++i) {
        var layer = layers[i];
        if (!defined3(layer.availability) || layer.availability.isTileAvailable(level, x3, y3)) {
          layerToUse = layer;
          break;
        }
      }
    }
    return requestTileGeometry(this, x3, y3, level, layerToUse, request);
  };
  function requestTileGeometry(provider, x3, y3, level, layerToUse, request) {
    if (!defined3(layerToUse)) {
      return Promise.reject(new RuntimeError2("Terrain tile doesn't exist"));
    }
    var urlTemplates = layerToUse.tileUrlTemplates;
    if (urlTemplates.length === 0) {
      return void 0;
    }
    var terrainY;
    if (!provider._scheme || provider._scheme === "tms") {
      var yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(level);
      terrainY = yTiles - y3 - 1;
    } else {
      terrainY = y3;
    }
    var extensionList = [];
    if (provider._requestVertexNormals && layerToUse.hasVertexNormals) {
      extensionList.push(layerToUse.littleEndianExtensionSize ? "octvertexnormals" : "vertexnormals");
    }
    if (provider._requestWaterMask && layerToUse.hasWaterMask) {
      extensionList.push("watermask");
    }
    if (provider._requestMetadata && layerToUse.hasMetadata) {
      extensionList.push("metadata");
    }
    var headers;
    var query;
    var url = urlTemplates[(x3 + terrainY + level) % urlTemplates.length];
    var resource = layerToUse.resource;
    if (defined3(resource._ionEndpoint) && !defined3(resource._ionEndpoint.externalType)) {
      if (extensionList.length !== 0) {
        query = { extensions: extensionList.join("-") };
      }
      headers = getRequestHeader(void 0);
    } else {
      headers = getRequestHeader(extensionList);
    }
    var derivedResoure = resource.getDerivedResource({
      url,
      templateValues: {
        version: layerToUse.version,
        z: level,
        x: x3,
        y: terrainY
      },
      queryParameters: query,
      headers,
      request
    });
    var deferred = defer();
    if (resource._ionEndpoint) {
      headers.Authorization = "Bearer " + resource._ionEndpoint.accessToken;
    }
    let promise = provider.processor.scheduleTask({ url: derivedResoure.url, headers, methodName: "fetchArrayBuffer" });
    promise.then(function(result) {
      if (result == false) {
        return deferred.reject();
      }
      var buffer4 = result.result;
      if (defined3(provider._heightmapStructure)) {
        return deferred.resolve(createHeightmapTerrainData(provider, buffer4, level, x3, y3));
      }
      return deferred.resolve(createQuantizedMeshTerrainData(provider, buffer4, level, x3, y3, layerToUse));
    });
    return deferred.promise;
  }
  Object.defineProperties(CesiumTerrainProvider.prototype, {
    errorEvent: {
      get: function() {
        return this._errorEvent;
      }
    },
    credit: {
      get: function() {
        if (!this._ready) {
          throw new DeveloperError3("credit must not be called before the terrain provider is ready.");
        }
        return this._credit;
      }
    },
    tilingScheme: {
      get: function() {
        if (!this._ready) {
          throw new DeveloperError3("tilingScheme must not be called before the terrain provider is ready.");
        }
        return this._tilingScheme;
      }
    },
    ready: {
      get: function() {
        return this._ready;
      }
    },
    readyPromise: {
      get: function() {
        return this._readyPromise.promise;
      }
    },
    hasWaterMask: {
      get: function() {
        if (!this._ready) {
          throw new DeveloperError3("hasWaterMask must not be called before the terrain provider is ready.");
        }
        return this._hasWaterMask && this._requestWaterMask;
      }
    },
    hasVertexNormals: {
      get: function() {
        if (!this._ready) {
          throw new DeveloperError3("hasVertexNormals must not be called before the terrain provider is ready.");
        }
        return this._hasVertexNormals && this._requestVertexNormals;
      }
    },
    hasMetadata: {
      get: function() {
        if (!this._ready) {
          throw new DeveloperError3("hasMetadata must not be called before the terrain provider is ready.");
        }
        return this._hasMetadata && this._requestMetadata;
      }
    },
    requestVertexNormals: {
      get: function() {
        return this._requestVertexNormals;
      }
    },
    requestWaterMask: {
      get: function() {
        return this._requestWaterMask;
      }
    },
    requestMetadata: {
      get: function() {
        return this._requestMetadata;
      }
    },
    availability: {
      get: function() {
        if (!this._ready) {
          throw new DeveloperError3("availability must not be called before the terrain provider is ready.");
        }
        return this._availability;
      }
    }
  });
  CesiumTerrainProvider.prototype.getLevelMaximumGeometricError = function(level) {
    return this._levelZeroMaximumGeometricError / (1 << level);
  };
  CesiumTerrainProvider.prototype.getTileDataAvailable = function(x3, y3, level) {
    if (!defined3(this._availability)) {
      return void 0;
    }
    if (level > this._availability._maximumLevel) {
      return false;
    }
    if (this._availability.isTileAvailable(level, x3, y3)) {
      return true;
    }
    if (!this._hasMetadata) {
      return false;
    }
    var layers = this._layers;
    var count = layers.length;
    for (var i = 0; i < count; ++i) {
      var layerResult = checkLayer(this, x3, y3, level, layers[i], i === 0);
      if (layerResult.result) {
        return void 0;
      }
    }
    return false;
  };
  CesiumTerrainProvider.prototype.loadTileDataAvailability = function(x3, y3, level) {
    if (!defined3(this._availability) || level > this._availability._maximumLevel || (this._availability.isTileAvailable(level, x3, y3) || !this._hasMetadata)) {
      return void 0;
    }
    var layers = this._layers;
    var count = layers.length;
    for (var i = 0; i < count; ++i) {
      var layerResult = checkLayer(this, x3, y3, level, layers[i], i === 0);
      if (defined3(layerResult.promise)) {
        return layerResult.promise;
      }
    }
  };
  function getAvailabilityTile(layer, x3, y3, level) {
    if (level === 0) {
      return;
    }
    var availabilityLevels = layer.availabilityLevels;
    var parentLevel = level % availabilityLevels === 0 ? level - availabilityLevels : (level / availabilityLevels | 0) * availabilityLevels;
    var divisor = 1 << level - parentLevel;
    var parentX = x3 / divisor | 0;
    var parentY = y3 / divisor | 0;
    return {
      level: parentLevel,
      x: parentX,
      y: parentY
    };
  }
  function checkLayer(provider, x3, y3, level, layer, topLayer) {
    if (!defined3(layer.availabilityLevels)) {
      return {
        result: false
      };
    }
    var cacheKey;
    var deleteFromCache = function() {
      delete layer.availabilityPromiseCache[cacheKey];
    };
    var availabilityTilesLoaded = layer.availabilityTilesLoaded;
    var availability = layer.availability;
    var tile = getAvailabilityTile(layer, x3, y3, level);
    while (defined3(tile)) {
      if (availability.isTileAvailable(tile.level, tile.x, tile.y) && !availabilityTilesLoaded.isTileAvailable(tile.level, tile.x, tile.y)) {
        var requestPromise;
        if (!topLayer) {
          cacheKey = tile.level + "-" + tile.x + "-" + tile.y;
          requestPromise = layer.availabilityPromiseCache[cacheKey];
          if (!defined3(requestPromise)) {
            var request = new Request({
              throttle: true,
              throttleByServer: true,
              type: RequestType.TERRAIN
            });
            requestPromise = requestTileGeometry(provider, tile.x, tile.y, tile.level, layer, request);
            if (defined3(requestPromise)) {
              layer.availabilityPromiseCache[cacheKey] = requestPromise;
              requestPromise.then(deleteFromCache);
            }
          }
        }
        return {
          result: true,
          promise: requestPromise
        };
      }
      tile = getAvailabilityTile(layer, tile.x, tile.y, tile.level);
    }
    return {
      result: false
    };
  }
  CesiumTerrainProvider._getAvailabilityTile = getAvailabilityTile;
  var CesiumTerrainProvider_default = CesiumTerrainProvider;

  // Source/custom/ext/createWorldTerrain.js
  var defaultValue4 = Cesium.defaultValue;
  var IonResource = Cesium.IonResource;
  function createWorldTerrain(options) {
    options = defaultValue4(options, defaultValue4.EMPTY_OBJECT);
    return new CesiumTerrainProvider_default({
      url: IonResource.fromAssetId(1),
      requestVertexNormals: defaultValue4(options.requestVertexNormals, false),
      requestWaterMask: defaultValue4(options.requestWaterMask, false)
    });
  }
  var createWorldTerrain_default = createWorldTerrain;

  // Source/custom/ext/LabelCollectionExt.js
  var import_grapheme_splitter = __toESM(require_grapheme_splitter(), 1);
  var BoundingRectangle = Cesium.BoundingRectangle;
  var Cartesian22 = Cesium.Cartesian2;
  var Color3 = Cesium.Color;
  var defined4 = Cesium.defined;
  var destroyObject2 = Cesium.destroyObject;
  var BlendOption2 = Cesium.BlendOption;
  var HeightReference2 = Cesium.HeightReference;
  var HorizontalOrigin2 = Cesium.HorizontalOrigin;
  var LabelStyle = Cesium.LabelStyle;
  var SDFSettings2 = Cesium.SDFSettings;
  var TextureAtlas2 = Cesium.TextureAtlas;
  var VerticalOrigin2 = Cesium.VerticalOrigin;
  var LabelCollection = Cesium.LabelCollection;
  function Glyph() {
    this.textureInfo = void 0;
    this.dimensions = void 0;
    this.billboard = void 0;
  }
  function GlyphTextureInfo(labelCollection, index, dimensions) {
    this.labelCollection = labelCollection;
    this.index = index;
    this.dimensions = dimensions;
  }
  var defaultLineSpacingPercent = 1.2;
  var whitePixelCanvasId = "ID_WHITE_PIXEL";
  var whitePixelSize = new Cartesian22(4, 4);
  var whitePixelBoundingRegion = new BoundingRectangle(1, 1, 1, 1);
  function addWhitePixelCanvas(textureAtlas) {
    const canvas = document.createElement("canvas");
    canvas.width = whitePixelSize.x;
    canvas.height = whitePixelSize.y;
    const context2D = canvas.getContext("2d");
    context2D.fillStyle = "#fff";
    context2D.fillRect(0, 0, canvas.width, canvas.height);
    textureAtlas.addImage(whitePixelCanvasId, canvas);
  }
  function unbindGlyph(labelCollection, glyph) {
    glyph.textureInfo = void 0;
    glyph.dimensions = void 0;
    const billboard = glyph.billboard;
    if (defined4(billboard)) {
      billboard.show = false;
      billboard.image = void 0;
      if (defined4(billboard._removeCallbackFunc)) {
        billboard._removeCallbackFunc();
        billboard._removeCallbackFunc = void 0;
      }
      labelCollection._spareBillboards.push(billboard);
      glyph.billboard = void 0;
    }
  }
  function addGlyphToTextureAtlas(textureAtlas, id, canvas, glyphTextureInfo) {
    glyphTextureInfo.index = textureAtlas.addImageSync(id, canvas);
  }
  var splitter = new import_grapheme_splitter.default();
  function rebindAllGlyphs(labelCollection, label, mapboxGlyphs) {
    const text = label._renderedText;
    if (text.length == 0) {
      return;
    }
    const graphemes = splitter.splitGraphemes(text);
    const textLength = graphemes.length;
    const glyphs = label._glyphs;
    const glyphsLength = glyphs.length;
    let glyph;
    let glyphIndex;
    let textIndex;
    label._relativeSize = label._fontSize / 24;
    if (textLength < glyphsLength) {
      for (glyphIndex = textLength; glyphIndex < glyphsLength; ++glyphIndex) {
        unbindGlyph(labelCollection, glyphs[glyphIndex]);
      }
    }
    glyphs.length = textLength;
    const showBackground = label._showBackground && text.split("\n").join("").length > 0;
    let backgroundBillboard = label._backgroundBillboard;
    const backgroundBillboardCollection = labelCollection._backgroundBillboardCollection;
    if (!showBackground) {
      if (defined4(backgroundBillboard)) {
        backgroundBillboardCollection.remove(backgroundBillboard);
        label._backgroundBillboard = backgroundBillboard = void 0;
      }
    } else {
      if (!defined4(backgroundBillboard)) {
        backgroundBillboard = backgroundBillboardCollection.add({
          collection: labelCollection,
          image: whitePixelCanvasId,
          imageSubRegion: whitePixelBoundingRegion
        });
        label._backgroundBillboard = backgroundBillboard;
      }
      backgroundBillboard.color = label._backgroundColor;
      backgroundBillboard.show = label._show;
      backgroundBillboard.position = label._position;
      backgroundBillboard.eyeOffset = label._eyeOffset;
      backgroundBillboard.pixelOffset = label._pixelOffset;
      backgroundBillboard.horizontalOrigin = HorizontalOrigin2.LEFT;
      backgroundBillboard.verticalOrigin = label._verticalOrigin;
      backgroundBillboard.heightReference = label._heightReference;
      backgroundBillboard.scale = label.totalScale;
      backgroundBillboard.pickPrimitive = label;
      backgroundBillboard.id = label._id;
      backgroundBillboard.translucencyByDistance = label._translucencyByDistance;
      backgroundBillboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;
      backgroundBillboard.scaleByDistance = label._scaleByDistance;
      backgroundBillboard.distanceDisplayCondition = label._distanceDisplayCondition;
      backgroundBillboard.disableDepthTestDistance = label._disableDepthTestDistance;
    }
    const glyphTextureCache = labelCollection._glyphTextureCache;
    for (textIndex = 0; textIndex < textLength; ++textIndex) {
      const character = graphemes[textIndex];
      const verticalOrigin = label._verticalOrigin;
      const id = JSON.stringify([
        character,
        label._fontFamily,
        label._fontStyle,
        label._fontWeight,
        +verticalOrigin
      ]);
      let glyphTextureInfo = glyphTextureCache[id];
      if (!defined4(glyphTextureInfo)) {
        var chartCode = character.charCodeAt(0);
        var fontName = "\u5FAE\u8F6F\u96C5\u9ED1";
        var mapboxGlyph = mapboxGlyphs[fontName][chartCode];
        if (!mapboxGlyph) {
          mapboxGlyph = mapboxGlyphs[fontName][63];
        }
        if (!mapboxGlyph.hasOwnProperty("dimensions")) {
          mapboxGlyph.dimensions = {
            width: mapboxGlyph.width - 3,
            height: 24,
            descent: 0,
            minx: 0,
            miny: 0,
            maxx: 0,
            maxy: 0
          };
        }
        glyphTextureInfo = new GlyphTextureInfo(labelCollection, -1, mapboxGlyph.dimensions);
        glyphTextureCache[id] = glyphTextureInfo;
        if (mapboxGlyph.width > 0 && mapboxGlyph.height > 0) {
          if (character !== " ") {
            addGlyphToTextureAtlas(labelCollection._textureAtlas, id, mapboxGlyph, glyphTextureInfo);
          }
        }
      }
      glyph = glyphs[textIndex];
      if (defined4(glyph)) {
        if (glyphTextureInfo.index === -1) {
          unbindGlyph(labelCollection, glyph);
        } else if (defined4(glyph.textureInfo)) {
          glyph.textureInfo = void 0;
        }
      } else {
        glyph = new Glyph();
        glyphs[textIndex] = glyph;
      }
      glyph.textureInfo = glyphTextureInfo;
      glyph.dimensions = glyphTextureInfo.dimensions;
      if (glyphTextureInfo.index !== -1) {
        let billboard = glyph.billboard;
        const spareBillboards = labelCollection._spareBillboards;
        if (!defined4(billboard)) {
          if (spareBillboards.length > 0) {
            billboard = spareBillboards.pop();
          } else {
            billboard = labelCollection._billboardCollection.add({
              collection: labelCollection
            });
            billboard._labelDimensions = new Cartesian22();
            billboard._labelTranslate = new Cartesian22();
          }
          glyph.billboard = billboard;
        }
        billboard.show = label._show;
        billboard.position = label._position;
        billboard.eyeOffset = label._eyeOffset;
        billboard.pixelOffset = label._pixelOffset;
        billboard.horizontalOrigin = HorizontalOrigin2.LEFT;
        billboard.verticalOrigin = label._verticalOrigin;
        billboard.heightReference = label._heightReference;
        billboard.scale = label.totalScale;
        billboard.pickPrimitive = label;
        billboard.id = label._id;
        billboard.image = id;
        billboard.translucencyByDistance = label._translucencyByDistance;
        billboard.pixelOffsetScaleByDistance = label._pixelOffsetScaleByDistance;
        billboard.scaleByDistance = label._scaleByDistance;
        billboard.distanceDisplayCondition = label._distanceDisplayCondition;
        billboard.disableDepthTestDistance = label._disableDepthTestDistance;
        billboard._batchIndex = label._batchIndex;
        billboard.outlineColor = label.outlineColor;
        if (label.style === LabelStyle.FILL_AND_OUTLINE) {
          billboard.color = label._fillColor;
          billboard.outlineWidth = label.outlineWidth;
        } else if (label.style === LabelStyle.FILL) {
          billboard.color = label._fillColor;
          billboard.outlineWidth = 0;
        } else if (label.style === LabelStyle.OUTLINE) {
          billboard.color = Color3.TRANSPARENT;
          billboard.outlineWidth = label.outlineWidth;
        }
        billboard.rotation = label._rotation;
      }
    }
    label._repositionAllGlyphs = true;
  }
  function calculateWidthOffset(lineWidth, horizontalOrigin, backgroundPadding) {
    if (horizontalOrigin === HorizontalOrigin2.CENTER) {
      return -lineWidth / 2;
    } else if (horizontalOrigin === HorizontalOrigin2.RIGHT) {
      return -(lineWidth + backgroundPadding.x);
    }
    return backgroundPadding.x;
  }
  var glyphPixelOffset = new Cartesian22();
  var scratchBackgroundPadding = new Cartesian22();
  function repositionAllGlyphs(label) {
    const glyphs = label._glyphs;
    const text = label._renderedText;
    let glyph;
    let dimensions;
    let lastLineWidth = 0;
    let maxLineWidth = 0;
    const lineWidths = [];
    let maxGlyphDescent = Number.NEGATIVE_INFINITY;
    let maxGlyphY = 0;
    let numberOfLines = 1;
    let glyphIndex;
    const glyphLength = glyphs.length;
    const backgroundBillboard = label._backgroundBillboard;
    const backgroundPadding = Cartesian22.clone(
      defined4(backgroundBillboard) ? label._backgroundPadding : Cartesian22.ZERO,
      scratchBackgroundPadding
    );
    backgroundPadding.x /= label._relativeSize;
    backgroundPadding.y /= label._relativeSize;
    for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
      if (text.charAt(glyphIndex) === "\n") {
        lineWidths.push(lastLineWidth);
        ++numberOfLines;
        lastLineWidth = 0;
      } else {
        glyph = glyphs[glyphIndex];
        dimensions = glyph.dimensions;
        maxGlyphY = Math.max(maxGlyphY, dimensions.height - dimensions.descent);
        maxGlyphDescent = Math.max(maxGlyphDescent, dimensions.descent);
        lastLineWidth += dimensions.width - dimensions.minx;
        if (glyphIndex < glyphLength - 1) {
          lastLineWidth += glyphs[glyphIndex + 1].dimensions.minx;
        }
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      }
    }
    lineWidths.push(lastLineWidth);
    const maxLineHeight = maxGlyphY + maxGlyphDescent;
    const scale = label.totalScale;
    const horizontalOrigin = label._horizontalOrigin;
    const verticalOrigin = label._verticalOrigin;
    let lineIndex = 0;
    let lineWidth = lineWidths[lineIndex];
    let widthOffset = calculateWidthOffset(
      lineWidth,
      horizontalOrigin,
      backgroundPadding
    );
    const lineSpacing = (defined4(label._lineHeight) ? label._lineHeight : defaultLineSpacingPercent * label._fontSize) / label._relativeSize;
    const otherLinesHeight = lineSpacing * (numberOfLines - 1);
    let totalLineWidth = maxLineWidth;
    let totalLineHeight = maxLineHeight + otherLinesHeight;
    glyphPixelOffset.x = widthOffset * scale;
    glyphPixelOffset.y = 0;
    let firstCharOfLine = true;
    let lineOffsetY = 0;
    for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
      if (text.charAt(glyphIndex) === " ") {
        ++lineIndex;
        lineOffsetY += lineSpacing;
        lineWidth = lineWidths[lineIndex];
        widthOffset = calculateWidthOffset(
          lineWidth,
          horizontalOrigin,
          backgroundPadding
        );
        glyphPixelOffset.x = widthOffset * scale;
        firstCharOfLine = true;
      } else {
        glyph = glyphs[glyphIndex];
        dimensions = glyph.dimensions;
        if (verticalOrigin === VerticalOrigin2.TOP) {
          glyphPixelOffset.y = dimensions.height - maxGlyphY - backgroundPadding.y;
          glyphPixelOffset.y += SDFSettings2.PADDING;
        } else if (verticalOrigin === VerticalOrigin2.CENTER) {
          glyphPixelOffset.y = (otherLinesHeight + dimensions.height - maxGlyphY) / 2;
        } else if (verticalOrigin === VerticalOrigin2.BASELINE) {
          glyphPixelOffset.y = otherLinesHeight;
          glyphPixelOffset.y -= SDFSettings2.PADDING;
        } else {
          glyphPixelOffset.y = otherLinesHeight + maxGlyphDescent + backgroundPadding.y;
          glyphPixelOffset.y -= SDFSettings2.PADDING;
        }
        glyphPixelOffset.y = (glyphPixelOffset.y - dimensions.descent - lineOffsetY) * scale;
        if (firstCharOfLine) {
          glyphPixelOffset.x -= SDFSettings2.PADDING * scale;
          firstCharOfLine = false;
        }
        if (defined4(glyph.billboard)) {
          glyph.billboard._setTranslate(glyphPixelOffset);
          glyph.billboard._labelDimensions.x = totalLineWidth;
          glyph.billboard._labelDimensions.y = totalLineHeight;
          glyph.billboard._labelHorizontalOrigin = horizontalOrigin;
        }
        if (glyphIndex < glyphLength - 1) {
          const nextGlyph = glyphs[glyphIndex + 1];
          glyphPixelOffset.x += (dimensions.width - dimensions.minx + nextGlyph.dimensions.minx) * scale;
        }
      }
    }
    if (defined4(backgroundBillboard) && text.split(" ").join("").length > 0) {
      if (horizontalOrigin === HorizontalOrigin2.CENTER) {
        widthOffset = -maxLineWidth / 2 - backgroundPadding.x;
      } else if (horizontalOrigin === HorizontalOrigin2.RIGHT) {
        widthOffset = -(maxLineWidth + backgroundPadding.x * 2);
      } else {
        widthOffset = 0;
      }
      glyphPixelOffset.x = widthOffset * scale;
      if (verticalOrigin === VerticalOrigin2.TOP) {
        glyphPixelOffset.y = maxLineHeight - maxGlyphY - maxGlyphDescent;
      } else if (verticalOrigin === VerticalOrigin2.CENTER) {
        glyphPixelOffset.y = (maxLineHeight - maxGlyphY) / 2 - maxGlyphDescent;
      } else if (verticalOrigin === VerticalOrigin2.BASELINE) {
        glyphPixelOffset.y = -backgroundPadding.y - maxGlyphDescent;
      } else {
        glyphPixelOffset.y = 0;
      }
      glyphPixelOffset.y = glyphPixelOffset.y * scale;
      backgroundBillboard.width = totalLineWidth;
      backgroundBillboard.height = totalLineHeight;
      backgroundBillboard._setTranslate(glyphPixelOffset);
      backgroundBillboard._labelTranslate = Cartesian22.clone(
        glyphPixelOffset,
        backgroundBillboard._labelTranslate
      );
    }
    label.totalWidth = totalLineWidth * scale;
    label.totalHeight = totalLineHeight * scale;
    if (label.heightReference === HeightReference2.CLAMP_TO_GROUND) {
      for (glyphIndex = 0; glyphIndex < glyphLength; ++glyphIndex) {
        glyph = glyphs[glyphIndex];
        const billboard = glyph.billboard;
        if (defined4(billboard)) {
          billboard._labelTranslate = Cartesian22.clone(
            glyphPixelOffset,
            billboard._labelTranslate
          );
        }
      }
    }
  }
  var LabelCollectionExt = class extends LabelCollection {
    constructor(options) {
      super(options);
      this._backgroundBillboardCollection = new BillboardCollection_default({
        scene: this._scene
      });
      this._backgroundBillboardCollection.destroyTextureAtlas = false;
      this._billboardCollection = new BillboardCollection_default({
        scene: this._scene,
        batchTable: this._batchTable,
        enuEnabled: options.enuEnabled
      });
      this._billboardCollection.destroyTextureAtlas = false;
      this._billboardCollection._sdf = true;
    }
    setGlyphs(mapboxGlyphs) {
      this.mapboxGlyphs = mapboxGlyphs;
    }
    update(frameState) {
      if (!this.mapboxGlyphs) {
        return;
      }
      if (!this.show) {
        return;
      }
      const billboardCollection = this._billboardCollection;
      const backgroundBillboardCollection = this._backgroundBillboardCollection;
      billboardCollection.modelMatrix = this.modelMatrix;
      billboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;
      backgroundBillboardCollection.modelMatrix = this.modelMatrix;
      backgroundBillboardCollection.debugShowBoundingVolume = this.debugShowBoundingVolume;
      const context = frameState.context;
      if (!defined4(this._textureAtlas)) {
        this._textureAtlas = new TextureAtlas2({
          context
        });
        billboardCollection.textureAtlas = this._textureAtlas;
      }
      if (!defined4(this._backgroundTextureAtlas)) {
        this._backgroundTextureAtlas = new TextureAtlas2({
          context,
          initialSize: whitePixelSize
        });
        backgroundBillboardCollection.textureAtlas = this._backgroundTextureAtlas;
        addWhitePixelCanvas(this._backgroundTextureAtlas);
      }
      const len = this._labelsToUpdate.length;
      for (let i = 0; i < len; ++i) {
        const label = this._labelsToUpdate[i];
        if (label.isDestroyed()) {
          continue;
        }
        const preUpdateGlyphCount = label._glyphs.length;
        if (label._rebindAllGlyphs) {
          rebindAllGlyphs(this, label, this.mapboxGlyphs);
          label._rebindAllGlyphs = false;
        }
        if (label._repositionAllGlyphs) {
          repositionAllGlyphs(label);
          label._repositionAllGlyphs = false;
        }
        const glyphCountDifference = label._glyphs.length - preUpdateGlyphCount;
        this._totalGlyphCount += glyphCountDifference;
      }
      const blendOption = backgroundBillboardCollection.length > 0 ? BlendOption2.TRANSLUCENT : this.blendOption;
      billboardCollection.blendOption = blendOption;
      backgroundBillboardCollection.blendOption = blendOption;
      billboardCollection._highlightColor = this._highlightColor;
      backgroundBillboardCollection._highlightColor = this._highlightColor;
      this._labelsToUpdate.length = 0;
      backgroundBillboardCollection.update(frameState);
      billboardCollection.update(frameState);
    }
  };
  var LabelCollectionExt_default = LabelCollectionExt;

  // Source/custom/ext/MapPosition.js
  function mapPosition() {
    let camera = Cesium.camera;
    let cartographic = camera.positionCartographic;
    let lon = Cesium.Math.toDegrees(cartographic.longitude);
    let lat = Cesium.Math.toDegrees(cartographic.latitude);
    console.log("\u7ECF\u7EAC\u5EA6 : [" + lon + "," + lat + "]");
    console.log("\u5730\u56FE\u9AD8\u5EA6 : " + cartographic.height);
    console.log("heading :" + Cesium.Math.toDegrees(camera.heading));
    console.log("pitch :" + Cesium.Math.toDegrees(camera.pitch));
    console.log("roll :" + Cesium.Math.toDegrees(camera.roll));
  }
  var MapPosition_default = mapPosition;

  // Source/custom/ext/Version.js
  var versionStr = "version=3.1.3 base cesium1.97";
  Cesium.setShowLevel = function(levelArray) {
    Cesium.showLevelMap = {};
    Cesium.showLevelLength = levelArray.length;
    for (let i = 0; i < Cesium.showLevelLength; i++) {
      let level = levelArray[i];
      Cesium.showLevelMap[level] = i;
    }
  };
  Cesium.tileSize = 256;
  Cesium.processorMap = {};
  console.log(versionStr);
  var Version_default = versionStr;

  // Source/custom/filter/Filter.js
  var Filter = class {
    constructor() {
      this.otherDisplay = true;
      this.layers = [];
      this.order = [];
    }
    addFilterLayer(filterLayer) {
      this.layers.push(filterLayer);
    }
    removeFilterLayerById(filterLayerId) {
      for (var i = 0; i < this.layers.length; i++) {
        if (this.layers[i].id == filterLayerId) {
          this.layers.splice(i, 1);
        }
      }
    }
  };
  var Filter_default = Filter;

  // Source/custom/filter/FilterLayer.js
  var FilterLayer = class {
    constructor() {
      this.id = null;
      this.filters = {};
      this.idFilter = null;
      this.filterStr = null;
      this.display = true;
      this.color = null;
    }
    addFilterField(key2, value) {
      this.filters[key2] = value;
    }
    removeFilterField(key2) {
      delete this.filters[key2];
    }
  };
  var FilterLayer_default = FilterLayer;

  // Source/custom/gloweffect/LineGlow.js
  var LineGlow = class {
    static createLines(geometryInstances, materialOption, PrimitiveType2, asynchronous, modelMatrix, classificationType) {
      let img = new Image();
      img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcsAAAAjCAYAAAD7YiEcAAAACXBIWXMAABRNAAAUTQGUyo0vAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAyDSURBVHja7J3bbiO5EYb/Yks7h8wkQJAgizxD7vL+7xAgT5DDxW6wCXaR2Z0Zj9WVCzdjulwnyrLGlqsAQn3uVlPix79YJImZUVY2Y/03Q0R3tinrxMxgZrTW1OOsbUcYneCr0SO9MvoK2UQnOI4e4d70gHvRmd4xK8vjJyvHLQB2AP5bJcRl2q5eQdljFMQj/Doo5fZ+nVlQBnClx/5uTwiIx9yXTnC9xz7mGKCe6v3zcK2+rH2WyihYlpX5BZIGKg2Cx4Dw2Pt/JbA8ZYieGpDneB8PuT6f4Pn4AcfQE8nrsoJl2RMtbOlM9znHNehMz/gUFOZjgpKOhBoH15ndfwpoRu7X8fu0KioKlmUFyHPChM587nOE5Nd4z6cCKz3hfNHcsNp+ua+VsixYlr1MSJJTKJ27TenchTo9wnd4KvA8V5sknXHfKfIlE9Qj03hMw02QT1nBsuyFqEjC3fYXEtsjcB6rSB9L0dIDjn3od3lKqnL2O/MD38ex59KJ83AGklBAyADWbX0d1vtn37ffUlnBsuyCQTmmhluXkpckQCNlegz0aOJ8mlDBmWemI57hHHk1E8gyCywS0GjK/eiIvKaJ56Ij8nVWjbKxbQSlBsbDAMjD8MmbqixlWbAsu1BrQ1qM5abAtH9qhVF7IPhm3b9kwH/mGeQ5bQKqUoVx8N1YWT6FuiQHBDPvcAaMmW10xD2887LHcxKWEo5sQPIA4HpbvxZpRbVXFizLLlZNti3/e1pw40ZahvUm4NgUaEbuWksNZWAZgdC7b3QOi33NUNoZ0EcFcxPqhUSh7gHUu3d0X0ooQOsdslLxoURFA8nzrH3W+jHHIaEqLUCygGT/vALwRXwehuPLCpZlF6Qm9yJ9s6W9gKdUmB2QiwEaWVg2p+Ae4cABdDPwjApQCp6jKcdnVbKmLmFUFKwIy0idknMPaesEjKBUEvrzLIGypgDILaEwKZGfFNyrJSpVXj5JZSndrdcbGD8D+Ajg07bc05ftuKsqXgqWZZdjewDvAbza0jdieTdA0wJmUwADR5l5CpcDADLs/muRurAKWTYK3Nn2WU2pIICa115GgbrUwMvK++IAbhaMm3jGBXejPSPlaFU2MnDV3vlMnrREhcCqGIzbVyV1RfkRwI9b+rBBc7cB8xo1qk/Bsuyi8vs9gG8BvN0A+RbA6y11aI4Kswlo7nDfJcvCdWcBylJXqwEGOMpGc6dZCtc6npQCWRb2niJdnWft+717A3o3BTjqkROwhgHMyC0r83MJFCgUKDYHmBoYm6LuZbAZnOM0z0BzvBjyuloFgEXerpt6/ADgXwD+jvvt91cbMMsKlmUXYK8A/AHAnwD8GsCvhvRGqEvNHbtTVKWnYuCAAAp0VgVGTYGL1s/NgoF2bzIga7n35Lig4/VWRymvuD+OKONupKlsL9OgygFMo6AhS2lrIBmfcQ+7872n+DR4NgVUWtAYJe9DgSfDC0Dz2mWtSscK4BcAv92OuxLqU3NblxUsy54xLL8F8GcAv9tU5tstdXes1WapuV2zQTuWQiIFflJdetC1QL3Cb1e0rhsBV8KShHokAU92IDsezw5UtXVPqVpKnQxPgNZ22wNWdspxzVGaFKhKmjhXQjwKJoORX3LfCr2NkxG3Rff/yxWAfwP4eVCUh4JlwbLs8vL8DYB325+/L78WsOzAJNgBMFFBMxNOP0KlBUrUK+TWhMLVruMVupzYz8n7zW7jQCVrlQBO5gEb8OpRoFJZznTd8QKJvOhoVs4ft604rguPlS9Rl5/xnfb/xB8B/B7A97gbOV7dRwqWZRdin7c/+F8BfIcbV2xP73Drjn2N2wjZEZxae2XD3bbK0W2aDcyJCjevMIvgrE23FIHECgTSrqEVvpGCnTFOqPaoXTQDFFZg+Y3z3RBUkryApawS1O7REvkX/Z404FpRylqZ+ZvNM/MKcwFtZQXLsmcEy+8A/GUD5PstdWD29sse9NPbMXvQz5gWkdqgRBfcd91qAxtIuI6FIQVqxSuUNYVqRYwCdpRog9/dJIK0BEULAKgVzs0AGxwFrUHU2k+GelvEd2gOYKN7ZSs50TNGnoxIBWvAzVS0xvVl+z+83yoTKFgWLMsuz64B/ATgH7gb3PMOt22XHZDdLdv7X3alOUbLjuBsuNvWuSjbG+yI2jH4IxpBCLBHFrKCTSTEsmrLUkCzKpES6vKY4fyy18ooQBhgstqqLVf8qcbUfUoD3Y95vxv+J5RU0GUFy7JnqC5/wm2/sV+29AZ3u49IN+wIxxGKu6HGvTjgHEE4dkmBUKR9JCFNqWpJPoccOMEKUmoOaFvgXvMgkXHVAvfb346FSGZ4uyhCduY+Dxk4/bnb+HvY4W5ATynLgmXZhdmKm87UvaP11QDO10JRSljKKNlFgGUxYOapR7ldO3eBPo4tKWC2+oVKNSuPtdY9yEZdGoC4f6PnwrVUYARZDsDtwcCLyJ1RcjwJ2+cMT0apyoJl2UVa7xowDud1tanOT0Jd7hVY7gwYWkPiRTObQAGSHLB9cZSfVKZj7b8JEMJRudpADIuinMd7Nud7WePpyqAo2S0jM/KNd0wWzNHIQBbkZLefBnvMVeu8GRX7lEDL4r9TVrAsewEKU/7x+/iXo7LcK8CUQJHK0pqdxBqUnQUQNRU3wkQuz8BLfkoX8YJ4FhZrGjNNSS8K9GFUKlrivUlXs3ctKM8LxJ37++9hgd1VwxqBKKtUOfhtjhWCcfvXdnf2sWM/bRXMzPcpK1iWPXNj3I5p2cfA3G/QlKAcZyTZK7C0xo7VRnDRVJYHS02JRWrVui8MQEml7AUaWapOG3xdU85a+ygCsFvvk+C7ra1ly/U95seVAUlvphZL1UJRoDIK2lKiK+IAqVl3s3YtLYhLU9xXuBn67gr2oBJlBcuyC7TDUHMfXbM7Jy0OXGRBDEM5ybFXLcXUksDxImwtuHrJUotWB3Stb2k0C0fD/RGErHZQBKBqAQyjNuDRVY2tUkQTKrolIG9FNkP5PRDiiF042zKVRUDvfmS5n69xExD34+aFidR1WcGy7KIkJvOBmdfWGuPubAuyK8jecFVmYam5aJGAntfe2ZIuV1Kg3Iz1pqhmT1lmgJltV8zMdmJdtzngbYkKxjJca688j+futtzUVrCUFSAm3dhQns2aoUSreHDyfWrj864ClD/jZjD1H3A7NddqnFtWsCy7UGAyMx+IaAzcGIHZtgJCg+OSgJ2lPCxYwnBTRtf22gLJcRsvCfBHqk9OdeWNewoBOCCeo5MnVKt2D6/tUlYEFkXlaWrQyjdPZZKj4uU1PNjKa0L5bSHIO6970OgK/rRB8p8A/gN9MPWygmXZC2LmgZm5tdaGguJaceVZCs6bVQKGe84qYBEoJK9bR1MUrvW8lksZSmENRxlbqlNTpBH0ELh1AX/uTs99qwFE7l8QT9BsKe6GeO7JTGXE8xp4wVSe10KrfLHh8u0A/LK5X78H8LfBDftlS30w9bKCZdlLMiJa13VlANRaW4dCpS9fB4UlIZ7T0JpLshkKIQqKgaJMrG4szXEByva4xSlkYcDQg1AGjt6wexEkNTWJhLIcp5liBZbZKbKa81wZWNNERcl779YsKDCACNyfOaaPk9tdsD9swPywwfIzbvsqFywLlmUvVWUOBUkH5f8LK2amG66SVsg3R1nBAagGkOxEwlYQjtVH02vD8/p8NkNxtYTSs1Sapz69sUc9JUvwJ0n2wDKCszmQz+QDHGXqubU1N3AE5KhNWLNVfPZ+yCMov+Bm4I4PGzQ/4sYt+2kDZj+mrGBZ9sJtDHQgZu6QHGeqiNqAZka1iY6dmVMxE4Hpta1Zx826QT0QclCB8N6nBU1KrjfjmksijzIw9qDfkup4BrJe+6NVGWTcH6xDwvILbvtXjory83ZOwbJgWVZ2W8Cs68qHw4H2+z0Qz8SRnakjMw1TNJi3BZiWAEakTltwrQzYo4rBDCiRfI6WqIBY92xJxWbBEpMVCGuy5+iZAX8weAhYyknHeagQjrAcu1FJaI6p91W+ruKhYFlWBqVWLmvrxMwYFKdawA/H3Nm3uXVBRIckYDEBFsJcVw1KACYD8Jl9SKik6PgIgJSobERKOFM5oCAPtMpM9A4ylQSvMmbBEgKWY/cpqTI7NMd07ID4ZQXLshcO0HsQHddJkLLvGzYfM8lzBMpjlGpGDWZgNquss9NrZZZnQJepXGDy/Tyk8jCTn7NTmGkVvvFzFdAc2zBXsdxd6K2KgMs1Yq6uQWVlZWVlZZ79bwBtXmHBXMcSpQAAAABJRU5ErkJggg==";
      materialOption.glowImage = img;
      let m = createDynamicLineAppearance(materialOption);
      return new Cesium[PrimitiveType2]({
        geometryInstances,
        appearance: m,
        asynchronous,
        modelMatrix,
        classificationType: classificationType || 0
      });
    }
  };
  var LineShader = {};
  function createDynamicLineAppearance(options) {
    return new Cesium.PolylineMaterialAppearance({
      material: new Cesium.Material({
        translucent: options.translucent || false,
        fabric: {
          uniforms: {
            odColor: options.odColor || Cesium.Color.YELLOW,
            rate: options.rate || 0.05,
            t_rate: options.t_rate || 120,
            glint: options.glint || false,
            glowImage: options.glowImage
          },
          source: LineShader[options.type]()
        }
      })
    });
  }
  LineShader.TwinkleLineShader = function() {
    return "czm_material czm_getMaterial(czm_materialInput m){\n   czm_material dm = czm_getDefaultMaterial(m);\n   vec2 st = m.st;\n   vec4 color = odColor;\n   float f = fract(czm_frameNumber / t_rate);\n   color.a = (0.5 - abs(0.5 - st.t)) / 0.5;\n   if(glint){\n     color.rgb += color.rgb * sin( f * 3.1415926 * 2.) * rate;\n   }\n   dm.diffuse = color.rgb;\n   dm.alpha = color.a ;\n   return dm;\n}";
  };
  LineShader.RunLineShader = function() {
    return "czm_material czm_getMaterial(czm_materialInput m){\n   float length = v_czm_batchTable_length;\n   czm_material dm = czm_getDefaultMaterial(m);\n   vec2 repeat= vec2(length * 0.001, 1.0);\n   vec2 st = repeat* m.st;\n   vec4 color = vec4(odColor.rgb,0.);\n   float time = fract(czm_frameNumber / t_rate) ;\n   vec4 tColor = texture2D(glowImage, vec2(fract(st.s -time),st.t));\n   dm.diffuse = tColor.a == 0.0 ?color.rgb : tColor.rgb * color.rgb;\n   dm.alpha = tColor.a == 0.0 ? odColor.a : tColor.a;\n   return dm;\n}";
  };
  LineShader.RunLineShader2 = function() {
    return "czm_material czm_getMaterial(czm_materialInput m){\n   float length = v_czm_batchTable_length;\n   czm_material dm = czm_getDefaultMaterial(m);\n   vec2 repeat= vec2(1.0, 1.0);\n   vec2 st = repeat* m.st;\n   vec4 color = vec4(odColor.rgb,0.);\n   float time = fract(czm_frameNumber / t_rate) ;\n   vec4 tColor = texture2D(glowImage, vec2(fract(st.s -time),st.t));\n   dm.diffuse = tColor.a == 0.0 ?color.rgb : tColor.rgb * color.rgb;\n   dm.alpha = tColor.a == 0.0 ? odColor.a : tColor.a;\n   return dm;\n}";
  };
  LineShader.RunLineShader1 = function() {
    return "czm_material czm_getMaterial(czm_materialInput m){\n   czm_material dm = czm_getDefaultMaterial(m);\n   vec2 st = m.st;\n   vec4 color = vec4(odColor.rgb,0.);\n   float time = fract(czm_frameNumber / t_rate) + rate;\n   float time1 = time + rate;\n   if(st.s > time && st.s < time1){\n     float ff = st.s - time;     color.a =  ff / rate ;\n     color.a *= ( .5 - abs(0.5 - st.t))/0.5;\n   }\n   if(time1 > 1.&& st.s < (time1 - 1.)){\n     color.a =  (st.s + 1. - time) / rate ;\n     color.a *= ( .5 - abs(0.5 - st.t))/0.5;\n   }\n   dm.diffuse = color.rgb;\n   dm.alpha = color.a ;\n   return dm;\n}";
  };
  var LineGlow_default = LineGlow;

  // Source/custom/gloweffect/PolygonDiffuseGlow.js
  var PolygonDiffuseGlow = class {
    static createPolygonDiffuse(options) {
      let polygonDiffuseGlow = new PolygonDiffuseGlow(options);
      options.viewer.scene.primitives.add(polygonDiffuseGlow);
      return polygonDiffuseGlow;
    }
    constructor(options) {
      this.viewer = options.viewer || window.viewer;
      if (!options.positions) {
        console.log("\u8F93\u5165\u63A7\u5236\u70B9\u4E3A\u7A7A");
      }
      this.controlPoints = options.positions;
      this.radius = options.radius || 1e3;
      this.center = options.center || this.computeCenter(this.controlPoints);
      if (this.radius > 0 && !this.controlPoints) {
        this.controlPoints = this.computeEllipsePosition_pd(this.center, this.radius, 270, -90);
      }
      this.translucent = options.translucent || false;
      this.height = options.extrudedHeight || 500;
      this.direction = options.direction || -1;
      this.color = options.color || new Cesium.Color(0.5, 0.8, 1, 1.3);
      this.startTime = 2;
      this.angle_delta = Math.PI / 180;
      this.stepCount = options.speed || 1;
      this.xyScale = 2;
      this.zScale = 0.01;
      this.mScale = Cesium.Matrix4.fromUniformScale(1);
      this.modelMatrix = Cesium.Matrix4.fromUniformScale(1);
      this.polyline = null;
      this.drawPolygon();
    }
    drawPolygon() {
      this.destroyPrimitive();
      this.draw();
    }
    destroyPrimitive() {
      if (this.polyline) {
        this.viewer.scene.primitives.remove(this.polyline);
      }
    }
    destroy() {
      this.destroyPrimitive();
      this.viewer.scene.primitives.remove(this);
      for (let i in this) {
        delete this[i];
      }
    }
    createGeometry(pos, n, st, indice) {
      let positions = new Float64Array(pos);
      let normals = new Float32Array(n);
      let sts = new Float32Array(st);
      let indices = new Uint16Array(indice);
      return new Cesium.Geometry({
        attributes: {
          position: new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.DOUBLE,
            componentsPerAttribute: 3,
            values: positions
          }),
          normal: new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: normals
          }),
          st: new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: sts
          })
        },
        indices,
        primitiveType: Cesium.PrimitiveType.TRIANGLES,
        boundingSphere: Cesium.BoundingSphere.fromVertices(positions)
      });
    }
    draw() {
      let op = this.computePositions_pd(this.controlPoints, this.height);
      this.positions = op.pos;
      this.normals = op.normals;
      this.sts = op.sts;
      this.indices = op.indices;
      let gi = new Cesium.GeometryInstance({
        geometry: this.createGeometry(this.positions, this.normals, this.sts, this.indices)
      });
      this.polyline = new Cesium.Primitive({
        geometryInstances: gi,
        appearance: new Cesium.MaterialAppearance({
          material: new Cesium.Material({
            translucent: this.translucent,
            fabric: {
              uniforms: {
                u_color: this.color
              },
              source: this.getFS(this.translucent)
            }
          }),
          vertexShaderSource: this.getVertexShaderSource1(),
          fragmentShaderSource: this.getFragmentShaderSource1()
        }),
        asynchronous: false
      });
      this.viewer.scene.primitives.add(this.polyline);
    }
    update(fs) {
      let time = fs.frameNumber / this.stepCount;
      let tt = time - Math.floor(time);
      if (this.polyline) {
        tt = tt < 0.01 ? 0.01 : tt;
        this.mScale[0] = this.mScale[5] = tt * this.xyScale;
        this.mScale[10] = 1.1 - tt;
        this.polyline.modelMatrix = this.scaleXYZ(this.center, this.mScale);
      }
    }
    addHeight_pd(point2, height) {
      let tPoint = Cesium.Cartographic.fromCartesian(point2);
      tPoint.height += height;
      return Cesium.Cartographic.toCartesian(tPoint);
    }
    computeCenter(points) {
      let minX = Number.MAX_VALUE;
      let minY = Number.MAX_VALUE;
      let maxX = Number.MIN_VALUE;
      let maxY = Number.MIN_VALUE;
      let p = null;
      let x3 = null;
      let y3 = null;
      for (let i in points) {
        p = Cesium.Cartographic.fromCartesian(points[i]);
        x3 = p.longitude;
        y3 = p.latitude;
        if (x3 < minX) {
          minX = x3;
        }
        if (x3 > maxX) {
          maxX = x3;
        }
        if (y3 < minY) {
          minY = y3;
        }
        if (y3 > maxY) {
          maxY = y3;
        }
      }
      return Cesium.Cartesian3.fromRadians(minX + (maxX - minX) / 2, minY + (maxY - minY) / 2);
    }
    computeEllipsePosition_pd(center2, radius, fromA, toA, inlength) {
      let res = [];
      let length2 = inlength || 360;
      let interval = (toA - fromA) * Math.PI / 180 / length2;
      let startA = fromA * Math.PI / 180;
      let mm = Cesium.Transforms.eastNorthUpToFixedFrame(center2);
      for (let i = 0; i < length2; i++) {
        let a2 = startA + interval * i;
        let p = new Cesium.Cartesian3(Math.sin(a2) * radius, Math.cos(a2) * radius, 0);
        res.push(Cesium.Matrix4.multiplyByPoint(mm, p, new Cesium.Cartesian3()));
      }
      return res;
    }
    computePositions_pd(cps, height) {
      let count = cps.length;
      let up = [];
      for (let i in cps) {
        up.push(this.addHeight_pd(cps[i], height));
      }
      let pos = [];
      let sts = [];
      let indices = [];
      let normal = [];
      for (let i = 0; i < count; i++) {
        let ni = (i + 1) % count;
        pos.push(...[cps[i].x, cps[i].y, cps[i].z]);
        pos.push(...[cps[ni].x, cps[ni].y, cps[ni].z]);
        pos.push(...[up[ni].x, up[ni].y, up[ni].z]);
        pos.push(...[up[i].x, up[i].y, up[i].z]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        sts.push(...[0, 0, 1, 0, 1, 1, 0, 1]);
        let ii = i * 4;
        let i1 = ii + 1;
        let i2 = ii + 2;
        let i3 = ii + 3;
        indices.push(...[i2, i3, ii, ii, i1, i2]);
      }
      return {
        pos,
        normals: normal,
        sts,
        indices
      };
    }
    scaleXYZ(point2, mScale) {
      let m = Cesium.Transforms.eastNorthUpToFixedFrame(point2);
      let inverse32 = Cesium.Matrix4.inverse(m, new Cesium.Matrix4());
      let tt = Cesium.Matrix4.multiply(mScale, inverse32, new Cesium.Matrix4());
      return Cesium.Matrix4.multiply(m, tt, new Cesium.Matrix4());
    }
    getVertexShaderSource1() {
      return "attribute vec3 position3DHigh;       attribute vec3 position3DLow;       attribute vec3 normal;       attribute vec2 st;       attribute float batchId;       varying vec2 v_st;       varying vec3 v_positionEC;       void main()       {          vec4 p = czm_translateRelativeToEye(position3DHigh,position3DLow);          v_positionEC = (czm_modelViewRelativeToEye * p).xyz;          v_st=st;          gl_Position = czm_modelViewProjectionRelativeToEye * p;       }       ";
    }
    getFragmentShaderSource1() {
      return `
      varying vec3 v_positionEC;
      varying vec2 v_st;
      void main(){
        gl_FragColor = xh_getMaterial(v_st);
      }
      `;
    }
    getFS(t) {
      let fs = "";
      fs += "uniform vec4 u_color;\nvec4 xh_getMaterial(vec2 st){    float alpha = pow(1. - st.t, 4.);\n";
      if (t) {
        fs += "    vec4 color = vec4(u_color.rgb * u_color.a, alpha);";
      } else {
        fs += "    vec4 color = vec4(u_color.rgb * u_color.a, 1.);";
      }
      fs += "    return color;\n}\n";
      return fs;
    }
  };
  var PolygonDiffuseGlow_default = PolygonDiffuseGlow;

  // Source/custom/gloweffect/RidingLanternGlow.js
  var RidingLanternGlow = class {
    static createRidingLantern(options) {
      return new RidingLanternGlow(options);
    }
    constructor(options) {
      this.viewer = options.viewer || window.viewer;
      this.positions = null;
      this.normals = null;
      this.sts = null;
      this.indices = null;
      this.controlPoints = options.positions;
      this.color = options.color;
      this.u_tcolor = options.u_tcolor || Cesium.Color.YELLOW;
      this.height = options.height || 500;
      this.speed = options.speed || 600;
      this.direction = options.direction || -1;
      this.translucent = options.translucent || false;
      this.type = options.type || 1;
      this.draw();
    }
    draw() {
      let op = this.computePositions_dws(this.controlPoints, this.height);
      this.positions = op.pos;
      this.normals = op.normals;
      this.sts = op.sts;
      this.indices = op.indices;
      let geometry = this.createGeometry(this.positions, this.normals, this.sts, this.indices);
      let gi = new Cesium.GeometryInstance({
        geometry
      });
      this.polyline = new Cesium.Primitive({
        geometryInstances: gi,
        appearance: new Cesium.MaterialAppearance({
          material: new Cesium.Material({
            translucent: this.translucent,
            fabric: {
              uniforms: {
                u_color: this.color,
                speed: this.speed,
                direction: this.direction,
                u_tcolor: this.u_tcolor
              },
              source: this.createFS(this.translucent)
            }
          }),
          vertexShaderSource: this.getVertexShaderSource1(),
          fragmentShaderSource: this.getFragmentShaderSource1()
        }),
        asynchronous: false
      });
      this.viewer.scene.primitives.add(this.polyline);
    }
    createGeometry(pos, n, st, indice) {
      let positions = new Float64Array(pos);
      let normals = new Float32Array(n);
      let sts = new Float32Array(st);
      let indices = new Uint16Array(indice);
      return new Cesium.Geometry({
        attributes: {
          position: new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.DOUBLE,
            componentsPerAttribute: 3,
            values: positions
          }),
          normal: new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: normals
          }),
          st: new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: sts
          })
        },
        indices,
        primitiveType: Cesium.PrimitiveType.TRIANGLES,
        boundingSphere: Cesium.BoundingSphere.fromVertices(positions)
      });
    }
    computePositions_dws(cps, height) {
      let count = cps.length;
      let up = [];
      for (let i in cps) {
        up.push(this.addHeight(cps[i], height));
      }
      let pos = [];
      let sts = [];
      let indices = [];
      let normal = [];
      for (let i = 0; i < count - 1; i++) {
        let ni = i + 1;
        pos.push(...[cps[i].x, cps[i].y, cps[i].z]);
        pos.push(...[cps[ni].x, cps[ni].y, cps[ni].z]);
        pos.push(...[up[ni].x, up[ni].y, up[ni].z]);
        pos.push(...[up[i].x, up[i].y, up[i].z]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        sts.push(...[0, 0, 1, 0, 1, 1, 0, 1]);
        let ii = i * 4;
        let i1 = ii + 1;
        let i2 = ii + 2;
        let i3 = ii + 3;
        indices.push(...[ii, i1, i2, i2, i3, ii]);
      }
      return {
        pos,
        normals: normal,
        sts,
        indices
      };
    }
    addHeight(point2, height) {
      let tHeight = height || 0;
      if (!point2.hasOwnProperty("height")) {
        let cartographic = Cesium.Cartographic.fromCartesian(point2);
        cartographic.height += tHeight;
        return Cesium.Cartographic.toCartesian(cartographic);
      } else {
        point2.height += tHeight;
        return point2;
      }
    }
    createFS(t) {
      let fs = "";
      if (this.type === 1) {
        fs += "czm_material czm_getMaterial( czm_materialInput cmi )\n{\n   czm_material material = czm_getDefaultMaterial(cmi);\n   vec2 st = cmi.st;    float t = fract(czm_frameNumber/speed) * direction;\n    vec2 st1 = vec2(st.s,fract(st.t - t));\n    vec4 color = vec4(0.,0.,0.,0.);\n    float tt = 0.5 - abs(0.5 - st1.t);\n    float ss = st1.s ;\n";
        if (t) {
          fs += "    float alpha = tt * 2.;\n    color = vec4(u_color.rgb * u_color.a, alpha * 1.2);\n   material.diffuse = color.rgb;\n   material.alpha = color.a;\n    return material;\n}\n";
        } else {
          fs += "    color = vec4(u_color.rgb * u_color.a * pow(tt,0.25),1.);   material.diffuse = color.rgb;\n   material.alpha = color.a;\n    return material;\n}\n";
        }
      } else {
        fs += "czm_material czm_getMaterial( czm_materialInput cmi )\n{\n   czm_material material = czm_getDefaultMaterial(cmi);\n   vec2 st = cmi.st;\n    float t = fract(czm_frameNumber/speed) * direction;\n    vec2 st1 = vec2(fract(st.s - t),st.t);\n    vec4 color = vec4(0.,0.,0.,0.);\n    float alpha = 1.-st.t;\n    float value = fract(st1.s/0.25);\n    alpha *= sin(value * 3.1415926);\n";
        if (t) {
          fs += "    color = vec4(u_color.rgb * u_color.a, alpha * 1.2);   material.diffuse = color.rgb;\n   material.alpha = color.a;\n    return material;\n}\n";
        } else {
          fs += "    color = vec4(u_color.rgb * u_color.a,alpha);\n   material.diffuse = color.rgb;\n   material.alpha = color.a;\n    return material;\n}\n";
        }
      }
      return fs;
    }
    getVertexShaderSource1() {
      return "attribute vec3 position3DHigh;          attribute vec3 position3DLow;          attribute vec3 normal;          attribute vec2 st;          attribute float batchId;          varying vec2 v_st;          varying vec3 v_normalEC;          varying vec3 v_positionEC;          void main()          {              vec4 p = czm_translateRelativeToEye(position3DHigh,position3DLow);              v_positionEC = (czm_modelViewRelativeToEye * p).xyz;              v_normalEC = czm_normal * normal;              v_st=st;              gl_Position = czm_modelViewProjectionRelativeToEye * p;          }          ";
    }
    getFragmentShaderSource1() {
      return "varying vec3 v_positionEC;\n    varying vec3 v_normalEC;\n    varying vec2 v_st;\n    void main()\n    {\n        vec3 positionToEyeEC = -v_positionEC;\n        vec3 normalEC = normalize(v_normalEC);\n    #ifdef FACE_FORWARD\n        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n        czm_materialInput materialInput;\n        materialInput.normalEC = normalEC;\n        materialInput.positionToEyeEC = positionToEyeEC;\n        materialInput.st = v_st;\n        czm_material material = czm_getMaterial(materialInput);\n        gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n    }";
    }
  };
  var RidingLanternGlow_default = RidingLanternGlow;

  // Source/custom/gloweffect/RidingLanternGlowPrimitive.js
  var RidingLanternGlowPrimitive = class {
    static createRidingLantern(options) {
      return new RidingLanternGlowPrimitive(options).polyline;
    }
    constructor(options) {
      this.viewer = options.viewer || window.viewer;
      this.positions = null;
      this.normals = null;
      this.sts = null;
      this.indices = null;
      this.geometrys = options.positions;
      this.color = options.color;
      this.u_tcolor = options.u_tcolor || Cesium.Color.YELLOW;
      this.height = options.height || 500;
      this.speed = options.speed || 600;
      this.direction = options.direction || -1;
      this.translucent = options.translucent || false;
      this.type = options.type || 1;
      this.createPrimitive();
    }
    createPrimitive() {
      this.polyline = new Cesium.Primitive({
        geometryInstances: this.createGeometryInstances(),
        appearance: new Cesium.MaterialAppearance({
          material: new Cesium.Material({
            translucent: this.translucent,
            fabric: {
              uniforms: {
                u_color: this.color,
                speed: this.speed,
                direction: this.direction,
                u_tcolor: this.u_tcolor
              },
              source: this.createFS(this.translucent)
            }
          }),
          vertexShaderSource: this.getVertexShaderSource1(),
          fragmentShaderSource: this.getFragmentShaderSource1()
        }),
        asynchronous: false
      });
    }
    createGeometryInstances() {
      let geometryInstances = [];
      for (let i = 0; i < this.geometrys.length; i++) {
        let item = this.geometrys[i];
        let op = this.computePositions_dws(item, this.height);
        this.positions = op.pos;
        this.normals = op.normals;
        this.sts = op.sts;
        this.indices = op.indices;
        let geometry = this.createGeometry(this.positions, this.normals, this.sts, this.indices);
        let gi = new Cesium.GeometryInstance({
          geometry
        });
        geometryInstances.push(gi);
      }
      return geometryInstances;
    }
    createGeometry(pos, n, st, indice) {
      let positions = new Float64Array(pos);
      let normals = new Float32Array(n);
      let sts = new Float32Array(st);
      let indices = new Uint16Array(indice);
      return new Cesium.Geometry({
        attributes: {
          position: new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.DOUBLE,
            componentsPerAttribute: 3,
            values: positions
          }),
          normal: new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.FLOAT,
            componentsPerAttribute: 3,
            values: normals
          }),
          st: new Cesium.GeometryAttribute({
            componentDatatype: Cesium.ComponentDatatype.FLOAT,
            componentsPerAttribute: 2,
            values: sts
          })
        },
        indices,
        primitiveType: Cesium.PrimitiveType.TRIANGLES,
        boundingSphere: Cesium.BoundingSphere.fromVertices(positions)
      });
    }
    computePositions_dws(cps, height) {
      let count = cps.length;
      let up = [];
      for (let i in cps) {
        up.push(this.addHeight(cps[i], height));
      }
      let pos = [];
      let sts = [];
      let indices = [];
      let normal = [];
      for (let i = 0; i < count - 1; i++) {
        let ni = i + 1;
        pos.push(...[cps[i].x, cps[i].y, cps[i].z]);
        pos.push(...[cps[ni].x, cps[ni].y, cps[ni].z]);
        pos.push(...[up[ni].x, up[ni].y, up[ni].z]);
        pos.push(...[up[i].x, up[i].y, up[i].z]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        normal.push(...[0, 0, 1]);
        sts.push(...[0, 0, 1, 0, 1, 1, 0, 1]);
        let ii = i * 4;
        let i1 = ii + 1;
        let i2 = ii + 2;
        let i3 = ii + 3;
        indices.push(...[ii, i1, i2, i2, i3, ii]);
      }
      return {
        pos,
        normals: normal,
        sts,
        indices
      };
    }
    addHeight(point2, height) {
      let tHeight = height || 0;
      if (!point2.hasOwnProperty("height")) {
        let cartographic = Cesium.Cartographic.fromCartesian(point2);
        cartographic.height += tHeight;
        return Cesium.Cartographic.toCartesian(cartographic);
      } else {
        point2.height += tHeight;
        return point2;
      }
    }
    createFS(t) {
      let fs = "";
      if (this.type === 1) {
        fs += "czm_material czm_getMaterial( czm_materialInput cmi )\n{\n   czm_material material = czm_getDefaultMaterial(cmi);\n   vec2 st = cmi.st;    float t = fract(czm_frameNumber/speed) * direction;\n    vec2 st1 = vec2(st.s,fract(st.t - t));\n    vec4 color = vec4(0.,0.,0.,0.);\n    float tt = 0.5 - abs(0.5 - st1.t);\n    float ss = st1.s ;\n";
        if (t) {
          fs += "    float alpha = tt * 2.;\n    color = vec4(u_color.rgb * u_color.a, alpha * 1.2);\n   material.diffuse = color.rgb;\n   material.alpha = color.a;\n    return material;\n}\n";
        } else {
          fs += "    color = vec4(u_color.rgb * u_color.a * pow(tt,0.25),1.);   material.diffuse = color.rgb;\n   material.alpha = color.a;\n    return material;\n}\n";
        }
      } else {
        fs += "czm_material czm_getMaterial( czm_materialInput cmi )\n{\n   czm_material material = czm_getDefaultMaterial(cmi);\n   vec2 st = cmi.st;\n    float t = fract(czm_frameNumber/speed) * direction;\n    vec2 st1 = vec2(fract(st.s - t),st.t);\n    vec4 color = vec4(0.,0.,0.,0.);\n    float alpha = 1.-st.t;\n    float value = fract(st1.s/0.25);\n    alpha *= sin(value * 3.1415926);\n";
        if (t) {
          fs += "    color = vec4(u_color.rgb * u_color.a, alpha * 1.2);   material.diffuse = color.rgb;\n   material.alpha = color.a;\n    return material;\n}\n";
        } else {
          fs += "    color = vec4(u_color.rgb * u_color.a,alpha);\n   material.diffuse = color.rgb;\n   material.alpha = color.a;\n    return material;\n}\n";
        }
      }
      return fs;
    }
    getVertexShaderSource1() {
      return "attribute vec3 position3DHigh;          attribute vec3 position3DLow;          attribute vec3 normal;          attribute vec2 st;          attribute float batchId;          varying vec2 v_st;          varying vec3 v_normalEC;          varying vec3 v_positionEC;          void main()          {              vec4 p = czm_translateRelativeToEye(position3DHigh,position3DLow);              v_positionEC = (czm_modelViewRelativeToEye * p).xyz;              v_normalEC = czm_normal * normal;              v_st=st;              gl_Position = czm_modelViewProjectionRelativeToEye * p;          }          ";
    }
    getFragmentShaderSource1() {
      return "varying vec3 v_positionEC;\n    varying vec3 v_normalEC;\n    varying vec2 v_st;\n    void main()\n    {\n        vec3 positionToEyeEC = -v_positionEC;\n        vec3 normalEC = normalize(v_normalEC);\n    #ifdef FACE_FORWARD\n        normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n    #endif\n        czm_materialInput materialInput;\n        materialInput.normalEC = normalEC;\n        materialInput.positionToEyeEC = positionToEyeEC;\n        materialInput.st = v_st;\n        czm_material material = czm_getMaterial(materialInput);\n        gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n    }";
    }
  };
  var RidingLanternGlowPrimitive_default = RidingLanternGlowPrimitive;

  // Source/custom/gloweffect/TargetBloom.js
  var GaussianBlur1DFS = "#ifndef SAMPLES\n#define SAMPLES 8\n#endif\nuniform float delta;\nuniform float sigma;\nuniform float direction;\nuniform sampler2D colorTexture;\n#ifdef USE_STEP_SIZE\nuniform float stepSize;\n#else\nuniform vec2 step;\n#endif\nvarying vec2 v_textureCoordinates;\nvoid main()\n{\nvec2 st = v_textureCoordinates;\nvec2 dir = vec2(1.0 - direction, direction);\n#ifdef USE_STEP_SIZE\nvec2 step = vec2(stepSize * (czm_pixelRatio / czm_viewport.zw));\n#else\nvec2 step = step;\n#endif\nvec3 g;\ng.x = 1.0 / (sqrt(czm_twoPi) * sigma);\ng.y = exp((-0.5 * delta * delta) / (sigma * sigma));\ng.z = g.y * g.y;\nvec4 result = texture2D(colorTexture, st) * g.x;\nfor (int i = 1; i < SAMPLES; ++i)\n{\ng.xy *= g.yz;\nvec2 offset = float(i) * dir * step;\nresult += texture2D(colorTexture, st - offset) * g.x;\nresult += texture2D(colorTexture, st + offset) * g.x;\n}\ngl_FragColor = result;\n}\n";
  var ContrastBiasFS = `
    uniform sampler2D colorTexture;
    uniform float contrast;
    uniform float brightness;
    
    varying vec2 v_textureCoordinates;
    
    void main(void)
    {
        vec3 sceneColor = texture2D(colorTexture, v_textureCoordinates).xyz;
        sceneColor = czm_RGBToHSB(sceneColor);
        sceneColor.z += brightness;
        sceneColor = czm_HSBToRGB(sceneColor);
    
        float factor = (259.0 * (contrast + 255.0)) / (255.0 * (259.0 - contrast));
        sceneColor = factor * (sceneColor - vec3(0.5)) + vec3(0.5);
        gl_FragColor = vec4(sceneColor, 1.0);
    }
    `;
  var BloomCompositeFS = "uniform sampler2D colorTexture;\n  uniform sampler2D bloomTexture;\n  uniform bool glowOnly;\n  uniform float selectedBloom;\n  uniform vec4 bloomColor;\n  varying vec2 v_textureCoordinates;\n  void main(void)\n  {\n  vec4 color = texture2D(colorTexture, v_textureCoordinates);\n  vec4 bloom = texture2D(bloomTexture, v_textureCoordinates);\n  bloom *= bloomColor ;\n  #ifdef CZM_SELECTED_FEATURE\n  if (czm_selected()) {\n  bloom *= selectedBloom;\n  }\n  #endif\n  gl_FragColor = glowOnly ? bloom : bloom + color;\n  }\n  ";
  function createLuminosityHighPass(name2) {
    var highPass = new Cesium.PostProcessStage({
      name: name2 + "_bright",
      fragmentShader: "\n        uniform sampler2D colorTexture;\n        uniform vec3 defaultColor;\n        uniform float defaultOpacity;\n        uniform float luminosityThreshold;\n        uniform float smoothWidth;\n        \n        varying vec2 v_textureCoordinates;\n        void main() {\n            vec4 texel = texture2D( colorTexture, v_textureCoordinates );\n            \n           #ifdef CZM_SELECTED_FEATURE\n               if (!czm_selected()) {\n                   texel = vec4(0.);\n               }\n           #endif\n           \n            vec3 luma = vec3( 0.299, 0.587, 0.114 );\n            float v = dot( texel.xyz, luma );\n            vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n            float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n            gl_FragColor = mix( outputColor, texel, alpha );\n        }\n        ",
      uniforms: {
        luminosityThreshold: 0,
        smoothWidth: 0.01,
        defaultColor: new Cesium.Color.fromRgba(0),
        defaultOpacity: 1
      }
    });
    return highPass;
  }
  Cesium.PostProcessStageLibrary.blurSamples = 32;
  function createBlur(name2) {
    var delta = 1;
    var sigma = 2;
    var stepSize = 1;
    var blurShader = "#define USE_STEP_SIZE\n";
    if (Cesium.defined(Cesium.PostProcessStageLibrary.blurSamples))
      blurShader += "#define SAMPLES " + Cesium.PostProcessStageLibrary.blurSamples + "\n";
    blurShader += GaussianBlur1DFS;
    var blurX = new Cesium.PostProcessStage({
      name: name2 + "_x_direction",
      fragmentShader: blurShader,
      uniforms: {
        delta,
        sigma,
        stepSize,
        direction: 0
      },
      sampleMode: Cesium.PostProcessStageSampleMode.LINEAR
    });
    var blurY = new Cesium.PostProcessStage({
      name: name2 + "_y_direction",
      fragmentShader: blurShader,
      uniforms: {
        delta,
        sigma,
        stepSize,
        direction: 1
      },
      sampleMode: Cesium.PostProcessStageSampleMode.LINEAR
    });
    var uniforms = {};
    Object.defineProperties(uniforms, {
      delta: {
        get: function() {
          return blurX.uniforms.delta;
        },
        set: function(value) {
          var blurXUniforms = blurX.uniforms;
          var blurYUniforms = blurY.uniforms;
          blurXUniforms.delta = blurYUniforms.delta = value;
        }
      },
      sigma: {
        get: function() {
          return blurX.uniforms.sigma;
        },
        set: function(value) {
          var blurXUniforms = blurX.uniforms;
          var blurYUniforms = blurY.uniforms;
          blurXUniforms.sigma = blurYUniforms.sigma = value;
        }
      },
      stepSize: {
        get: function() {
          return blurX.uniforms.stepSize;
        },
        set: function(value) {
          var blurXUniforms = blurX.uniforms;
          var blurYUniforms = blurY.uniforms;
          blurXUniforms.stepSize = blurYUniforms.stepSize = value;
        }
      }
    });
    return new Cesium.PostProcessStageComposite({
      name: name2,
      stages: [blurX, blurY],
      uniforms
    });
  }
  Cesium.PostProcessStageLibrary.createTargetBloomStage = function() {
    var contrastBias = new Cesium.PostProcessStage({
      name: "czm_localbloom_contrast_bias",
      fragmentShader: ContrastBiasFS,
      uniforms: {
        contrast: 128,
        brightness: -0.3
      }
    });
    let highPass = createLuminosityHighPass("localbloom");
    let blurPass = createBlur("czm_localbloom_blur");
    let separableBlurStages = [highPass, blurPass];
    let blurComposite = new Cesium.PostProcessStageComposite({
      name: name + "_blur_composite",
      stages: separableBlurStages,
      inputPreviousStageTexture: true
    });
    var generateComposite = new Cesium.PostProcessStageComposite({
      name: "czm_localbloom_contrast_bias_blur",
      stages: [contrastBias, blurComposite]
    });
    var bloomComposite = new Cesium.PostProcessStage({
      name: "czm_localbloom_generate_composite",
      fragmentShader: BloomCompositeFS,
      uniforms: {
        glowOnly: false,
        bloomTexture: generateComposite.name,
        selectedBloom: 1,
        bloomColor: Cesium.Color.WHITE
      }
    });
    var uniforms = {};
    Object.defineProperties(uniforms, {
      glowOnly: {
        get: function() {
          return bloomComposite.uniforms.glowOnly;
        },
        set: function(value) {
          bloomComposite.uniforms.glowOnly = value;
        }
      },
      selectedBloom: {
        get: function() {
          return bloomComposite.uniforms.selectedBloom;
        },
        set: function(value) {
          bloomComposite.uniforms.selectedBloom = value;
        }
      },
      contrast: {
        get: function() {
          return contrastBias.uniforms.contrast;
        },
        set: function(value) {
          contrastBias.uniforms.contrast = value;
        }
      },
      brightness: {
        get: function() {
          return contrastBias.uniforms.brightness;
        },
        set: function(value) {
          contrastBias.uniforms.brightness = value;
        }
      },
      delta: {
        get: function() {
          return blurPass.uniforms.delta;
        },
        set: function(value) {
          blurPass.uniforms.delta = value;
        }
      },
      sigma: {
        get: function() {
          return blurPass.uniforms.sigma;
        },
        set: function(value) {
          blurPass.uniforms.sigma = value;
        }
      },
      stepSize: {
        get: function() {
          return blurPass.uniforms.stepSize;
        },
        set: function(value) {
          blurPass.uniforms.stepSize = value;
        }
      },
      smoothWidth: {
        get: function() {
          return highPass.uniforms.smoothWidth;
        },
        set: function(value) {
          highPass.uniforms.smoothWidth = value;
        }
      },
      luminosityThreshold: {
        get: function() {
          return highPass.uniforms.luminosityThreshold;
        },
        set: function(value) {
          highPass.uniforms.luminosityThreshold = value;
        }
      },
      bloomColor: {
        get: function() {
          return bloomComposite.uniforms.bloomColor;
        },
        set: function(value) {
          bloomComposite.uniforms.bloomColor = value;
        }
      }
    });
    return new Cesium.PostProcessStageComposite({
      name: "czm_localbloom",
      stages: [generateComposite, bloomComposite],
      inputPreviousStageTexture: false,
      uniforms
    });
  };
  var TargetBloom_default = {};

  // Source/custom/gloweffect/TowerGlow.js
  var TowerGlow = class {
    static createTower(viewer3, center2, radius, height, color) {
      return new TowerGlow(viewer3, center2, radius, height, color);
    }
    constructor(viewer3, center2, radius, height, color) {
      this.viewer = viewer3;
      this.center = center2;
      this.extrudedHeight = height || 100;
      this.topRadius = radius / 100;
      this.topRadius = this.topRadius > 1 ? 1 : this.topRadius;
      this.u_color = color || new Cesium.Color(1, 1, 0, 1);
      this.inner_controlPoints = this.computeEllipsePosition(center2, radius * 0.7, 120);
      this.outer_controlPoints = this.computeEllipsePosition(center2, radius, 120);
      this.circular_clone_topPoints = this.computeEllipsePosition(center2, this.topRadius, 120);
      this.circlePoints_2 = this.computeEllipsePosition(center2, radius * 2, 120);
      this.polyline = null;
      this.polyline1 = null;
      this.polyline2 = null;
      this.polyline3 = null;
      this.ringCanvas = this.drawRingCanvas();
      this.gradientCircle = this.drawGradientCircle();
      let image = new Image();
      image.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAEACAYAAADSoXR2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjExQTg0NDEyMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjExQTg0NDEzMDEzQjExRUFBNDhBRjhGMUMzOUUyNTU0Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTFBODQ0MTAwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MTFBODQ0MTEwMTNCMTFFQUE0OEFGOEYxQzM5RTI1NTQiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz41vRwAAAAE90lEQVR42uydyW4UMRCG3T2dgYSAEGs4sp44cCJBcGUJbwCvALwWPAI8ABwAiUVwgLBdkEikJEiAGMhkZqhfU1aa1sy0g+yaJPyWSupOpPjz0uVyucrJer2eG2fJ3ZgLAQhAgC0PgN8XIlkqgGLE75oih0WmRVZEvop0rHog18rnRe6IzInsthyCXFt+TuSKyGmRXZZDgK5eFrkv8l7kiUhrxN/JSo3pigSvcNmI1bCh3b5LK2+NqHyvyEF9x3z5HgqRRViOAXhW5JrCoNdei/y20gMYxhmRSyIXRY6JTMT4DENLW+SdyD19x/NajDmwmYIW79Hnn+MA4GJEAAIQgABJbMJB+n5Sl9zWZvR9DABUfkJkVt8fi3zUldAEoKl24Y2S1fPZEmBdZFHkkb4vxTLRQ5djbyUf0ncYrD/UADUB8MZno2Q19yx7gIqIAAQgAAEIQIAtYZT+85LvRnjQCoPKR3rQUgN4Y3ZeK30g8qps0qeeAzDn4TWD9+ySG+BBS90DaGnVg9a2tgnR4il9/jkOACoiAhCAAASIZpAAFl6yulO0JACo/IDrn6CedP1zxOciv6wAYNnAP3RVBeWtJQCWzG8iL/X9g4vkqNzMctzUXtintt2KM/aS+bmQaY90rb8CF6tSKiICEIAABCAAAQiwbfcFIWVCbUcc9bZDLKiYAKj4uOv7Bb+ILLj+8W7PCgC7Jhzv44Qdh9yrru8V61jPgd645gD2io+15RiC5ZA5ENNPmGmDmtrta9YAVEQE2FlrQUM/J6efU8cSAD87ojodBaccS6kgiiErGiq/qe93XT+3oGU5BJnbyKrIUs6BQZoQUEcrQ7CYagiGqeKiMgnXLXsg5uJUm/RQJKy8fGS7PMw6SgVQPrJFGZr0kCfUL/7IFjIzrLGpemBQ0kPbehL6I9vMjUh6oEVEAAIQgAAEIAABdpyj0qcK71YrqGUJANNrv+sHOcAiRpDDM1cTY1BEHk7kqyP/2Ac5vLEEQEG8aDnIoTb5ObZRWg5ywG5o1dX4ClNYxT7IISgJPsXGpLut9MCWU0S5bqkmdAa3LQEwcZDAfkZ3tthQfkwNkVeeD6kiuaUabcp6DpS9YyalrAdQ8bT1EFQVUabarND9fNuyB2gREYAABCAAAQhAAAIQoM770UgBXARCIr/koDogVlzgrWuxemBKd0m4JnBed0+5ZQ9gn3BK5LK+P4y5ewoB8DFiKO91COLFfwVuTCZV1hSoYw1APZCsFIkbN1Haaa87wwiKQe6eT27AEX6esPVVd8/kOOdAz/oz9FE0p+uGIKUeqE5C8xgSKiICEIAABCAAAQhAAAIQgAAEIAABCECA6AA+sbkREyDUUYlKD6ggZwzRkr8tewBhusisv+0in5qE/hFchoZTE0TL4p8sTbtIpyahQ4Ag5fKpSVBmfdDECvQTZjoM0U9N6KgkwH9xY7PXpPiCmq5yuaLVldHIO7jgNi5XfOEhCqNh9udHV/RnC5YAUDTftdV4/ivvwEoRVS9XXPWa1FIT5ird8jpSB+BDN3rO8AaGMnGy0I0QRYTvdk6NkOsucuhGCMAgI8Q0isaHbmAevNMhiD4P6iZhstANGiQE2PEGCRo2NcgAsQDwKnxWFdlT17/duWU1BJmuHz6A5bwbEsCScgh+qAHit3Jr1oooOPExdRBLbeJjSpuwuy30AAH+CDAAPH5ltESNYl4AAAAASUVORK5CYII=";
      image.onload = function() {
        this.image = this.drawCanvas(image);
        this.draw();
      }.bind(this);
    }
    draw() {
      this.addOuter();
      this.addInner();
      this.addCircle();
      this.addRing();
    }
    destroy() {
      if (this.polyline) {
        this.viewer.scene.primitives.remove(this.polyline);
      }
      if (this.polyline1) {
        this.viewer.scene.primitives.remove(this.polyline1);
      }
      if (this.polyline2) {
        this.viewer.scene.primitives.remove(this.polyline2);
      }
      if (this.polyline3) {
        this.viewer.scene.primitives.remove(this.polyline3);
      }
      for (let i in this) {
        delete this[i];
      }
    }
    addOuter() {
      let side_instances = this.createParticles_efa_cylinder(this.outer_controlPoints, this.extrudedHeight, this.circular_clone_topPoints);
      this.polyline = new Cesium.Primitive({
        geometryInstances: side_instances,
        appearance: new Cesium.EllipsoidSurfaceAppearance({
          material: new Cesium.Material({
            fabric: {
              uniforms: {
                u_color: this.u_color,
                image: this.image
              },
              source: this.getSource()
            }
          })
        }),
        asynchronous: false
      });
      this.viewer.scene.primitives.add(this.polyline);
    }
    addInner() {
      let side_instances = this.createParticles_efa_cylinder(this.inner_controlPoints, this.extrudedHeight, this.circular_clone_topPoints, this.v_color);
      let a2 = new Cesium.EllipsoidSurfaceAppearance({
        material: new Cesium.Material({
          fabric: {
            uniforms: {
              u_color: this.u_color
            },
            source: this.cylinderGauss1_vtxf()
          }
        })
      });
      this.polyline1 = new Cesium.Primitive({
        geometryInstances: side_instances,
        appearance: a2,
        asynchronous: false
      });
      this.viewer.scene.primitives.add(this.polyline1);
    }
    addCircle() {
      let carto = Cesium.Cartographic.fromCartesian(this.center);
      if (carto.height < 1) {
        let instance = this.createCircleInstance(this.circlePoints_2, false);
        this.polyline2 = new Cesium.GroundPrimitive({
          geometryInstances: instance,
          appearance: new Cesium.EllipsoidSurfaceAppearance({
            material: new Cesium.Material({
              fabric: {
                uniforms: {
                  u_color: this.u_color,
                  image: this.gradientCircle
                },
                source: this.particlesGradient()
              }
            })
          }),
          asynchronous: false
        });
      } else {
        let instance = this.createCircleInstance(this.circlePoints_2, true);
        this.polyline2 = new Cesium.Primitive({
          geometryInstances: instance,
          appearance: new Cesium.EllipsoidSurfaceAppearance({
            material: new Cesium.Material({
              fabric: {
                uniforms: {
                  u_color: this.u_color,
                  image: this.gradientCircle
                },
                source: this.particlesGradient()
              }
            })
          }),
          asynchronous: false
        });
      }
      this.viewer.scene.primitives.add(this.polyline2);
    }
    addRing() {
      let carto = Cesium.Cartographic.fromCartesian(this.center);
      if (carto.height < 1) {
        let instance = this.createCircleInstance(this.circlePoints_2, false);
        this.polyline3 = new Cesium.GroundPrimitive({
          geometryInstances: instance,
          appearance: new Cesium.EllipsoidSurfaceAppearance({
            material: new Cesium.Material({
              fabric: {
                uniforms: {
                  u_color: this.u_color,
                  image: this.ringCanvas
                },
                source: this.particlesRingScan()
              }
            })
          }),
          asynchronous: false
        });
      } else {
        let instance = this.createCircleInstance(this.circlePoints_2, true);
        this.polyline3 = new Cesium.Primitive({
          geometryInstances: instance,
          appearance: new Cesium.EllipsoidSurfaceAppearance({
            material: new Cesium.Material({
              fabric: {
                uniforms: {
                  u_color: this.u_color,
                  image: this.ringCanvas
                },
                source: this.particlesRingScan()
              }
            })
          }),
          asynchronous: false
        });
      }
      this.viewer.scene.primitives.add(this.polyline3);
    }
    drawCanvas(image) {
      let canvas = document.createElement("canvas");
      canvas.width = 64;
      canvas.height = 256;
      let ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, 64, 256);
      ctx.drawImage(image, 0, 0);
      ctx.drawImage(image, 33, 0);
      return canvas;
    }
    drawRingCanvas() {
      let canvas = document.createElement("canvas");
      canvas.width = 512;
      canvas.height = 512;
      let ctx = canvas.getContext("2d");
      ctx.fillStyle = "rgba(255,255,255,0)";
      ctx.strokeStyle = "rgba(255, 255, 255,255)";
      ctx.setLineDash([50, 50]);
      ctx.lineWidth = 30;
      ctx.beginPath();
      ctx.arc(256, 256, 150, 0, Math.PI * 2, true);
      ctx.stroke();
      ctx.restore();
      return canvas;
    }
    drawGradientCircle() {
      let canvas = document.createElement("canvas");
      canvas.width = 512;
      canvas.height = 512;
      let ctx = canvas.getContext("2d");
      let gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
      gradient.addColorStop(0.1, "rgba(255, 255, 255, 1.0)");
      gradient.addColorStop(0.2, "rgba(255, 255, 255, 0.0)");
      gradient.addColorStop(0.3, "rgba(255, 255, 255, 0.9)");
      gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.0)");
      gradient.addColorStop(0.9, "rgba(255, 255, 255, 0.2)");
      gradient.addColorStop(1, "rgba(255, 255, 255, 1.0)");
      ctx.clearRect(0, 0, 512, 512);
      ctx.beginPath();
      ctx.arc(256, 256, 256, 0, Math.PI * 2, true);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.restore();
      return canvas;
    }
    cylinderGauss1_vtxf() {
      return "uniform vec4 u_color;\nczm_material czm_getMaterial(czm_materialInput materialInput){    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float powerRatio = 1./(fract(czm_frameNumber / 30.0) +  1.) ;\n    float alpha = pow(1. - st.t,powerRatio);\n    vec4 color = vec4(u_color.rgb, alpha*u_color.a);    material.diffuse = color.rgb;\n    material.alpha = color.a;\n    return material;\n}\n";
    }
    particlesRingScan() {
      return "czm_material czm_getMaterial(czm_materialInput materialInput){    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    vec2 center = st - vec2(0.5,0.5);\n    float time = -czm_frameNumber * 3.1415926 / 180.;\n    float sin_t = sin(time);\n    float cos_t = cos(time);\n    vec2 center_rotate = vec2(center.s*cos_t-center.t*sin_t+0.5,center.s*sin_t+center.t*cos_t+0.5);\n    vec4 color = texture2D(image,center_rotate);\n    vec3 tColor = color.rgb * u_color.rgb;\n    tColor *= u_color.a;\n    material.diffuse = tColor;\n    float length = 2. - length(center)/0.5;\n    material.alpha = color.a * pow(length, 0.5);\n    return material;\n}\n";
    }
    particlesGradient() {
      return "czm_material czm_getMaterial(czm_materialInput materialInput){    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec4 tColor = u_color;\n    vec2 st = materialInput.st;\n    vec2 center = st - vec2(0.5,0.5);\n    float length = length(center)/0.5;\n    float time = 1. - abs(czm_frameNumber / 360. - 0.5);\n    float param = 1. - step(length, 0.6);\n    float scale = param * length;\n    float alpha = param * (1.0 - abs(scale - 0.8) / 0.2);\n    float param1 = step(length, 0.7);\n    float scale1 = param1 * length;\n    alpha += param1 * (1.0 - abs(scale1 - 0.35) / 0.35);\n    material.diffuse = u_color.rgb * vec3(u_color.a);\n    material.alpha = pow(alpha, 4.0);\n    return material;\n}\n";
    }
    getSource() {
      return "uniform vec4 u_color;\nczm_material czm_getMaterial(czm_materialInput materialInput){    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    float time = fract(czm_frameNumber / 90.) ;\n    vec2 new_st = fract(st-vec2(time,time));\n    vec4 color = texture2D(image,new_st);\n    vec3 diffuse = color.rgb;\n    float alpha = color.a;\n    diffuse *= u_color.rgb;\n    alpha *= u_color.a;\n    alpha *= u_color.a;\n    material.diffuse = diffuse;\n    material.alpha = alpha * pow(1. - st.t,u_color.a);\n    return material;\n}\n";
    }
    computeEllipsePosition(center2, radius, length2) {
      let res = [];
      let interval = 2 * Math.PI / length2;
      let mm = Cesium.Transforms.eastNorthUpToFixedFrame(center2);
      let startPos = 2 * Math.PI * 270 / 360;
      for (let i = 0; i < length2; i++) {
        let a2 = startPos - interval * i;
        let p = new Cesium.Cartesian3(Math.sin(a2) * radius, Math.cos(a2) * radius, 0);
        res.push(Cesium.Matrix4.multiplyByPoint(mm, p, new Cesium.Cartesian3()));
      }
      res.push(res[0]);
      return res;
    }
    createCircleInstance(pos, perPositionHeight) {
      let polygon2 = new Cesium.PolygonGeometry({
        polygonHierarchy: new Cesium.PolygonHierarchy(pos),
        perPositionHeight
      });
      return new Cesium.GeometryInstance({
        geometry: polygon2
      });
    }
    createParticles_efa_cylinder(pts, height, topPts, incolor) {
      let color = incolor || new Cesium.Color(0.5, 0.8, 1, 2);
      let newpts = pts.slice();
      let length2 = pts.length;
      let len_2 = 2 * length2;
      let sts = [];
      let st_interval = 1 / (length2 - 1);
      let define_indices = [];
      let ep = [];
      for (let i = 0; i < length2; i++) {
        ep.push(this.addHeight(topPts[i], height));
        sts.push(i * st_interval);
        sts.push(0);
        let i_1 = i + 1;
        let i_11 = (i + 1) % length2;
        let len_2_i_1 = len_2 - i_1;
        define_indices.push(...[len_2_i_1 - 1, len_2_i_1, i]);
        define_indices.push(...[i, i_11, len_2_i_1 - 1]);
      }
      for (let i in ep) {
        newpts.push(ep[length2 - i - 1]);
        sts.push(1 - i * st_interval);
        sts.push(1);
      }
      let polygon2 = new Cesium.PolygonGeometry({
        polygonHierarchy: new Cesium.PolygonHierarchy(newpts),
        perPositionHeight: true
      });
      polygon2 = Cesium.PolygonGeometry.createGeometry(polygon2);
      polygon2.indices = define_indices;
      polygon2.attributes.st.values = sts;
      return new Cesium.GeometryInstance({
        geometry: polygon2,
        attributes: {
          color: Cesium.ColorGeometryInstanceAttribute.fromColor(color)
        }
      });
    }
    addHeight(p, ih) {
      let h = ih || 0;
      let cp = Cesium.Cartographic.fromCartesian(p);
      cp.height += h;
      return Cesium.Cartographic.toCartesian(cp);
    }
  };
  var TowerGlow_default = TowerGlow;

  // Source/custom/layer/ElevationImageryProvider.js
  var import_md5_node = __toESM(require_md5_node(), 1);
  var ElevationImageryProvider = class {
    constructor(viewer3, options) {
      this.viewer = viewer3;
      this.indexDbName = (0, import_md5_node.default)(options.url);
      this.viewer.imageryLayers.layerAdded.addEventListener(this.onLayerAdded, this);
      this.viewer.imageryLayers.layerRemoved.addEventListener(this.onLayerRemoved, this);
      this.viewer.imageryLayers.layerMoved.addEventListener(this.onLayerMoved, this);
      this.isElevation = true;
    }
    onLayerAdded(layer, index) {
    }
    onLayerRemoved(layer, index) {
    }
    onLayerMoved(layer, newIndex, oldIndex) {
    }
    getTopProviders() {
      let elevationProviders = this.viewer.imageryLayers.elevationProviders;
      let index = 0;
      for (let i = 0; i < elevationProviders.length; i++) {
        let imageryProvider = elevationProviders[i];
        if (imageryProvider == this) {
          index = i;
          break;
        }
      }
      if (index == elevationProviders.length - 1) {
        return [];
      }
      return elevationProviders.slice(index - 1);
    }
    getBottomProviderIndexDbNames() {
      let elevationProviders = this.viewer.imageryLayers.elevationProviders;
      let names34 = [];
      if (this.viewer.terrainProvider.name == "RGBWorldTerrainProvider") {
        names34.push(this.viewer.terrainProvider.indexDbName);
      }
      for (let i = 0; i < elevationProviders.length; i++) {
        let imageryProvider = elevationProviders[i];
        names34.push(imageryProvider.indexDbName);
        if (imageryProvider == this) {
          break;
        }
      }
      return names34;
    }
    getTopProvidersByIndex(index) {
      return this.viewer.imageryLayers.elevationProviders.slice(index);
    }
    updateOtherProviderElevation(xyz) {
      let providers = this.getTopProviders();
      for (let i = 0; i < providers.length; i++) {
        let provider = providers[i];
        if (!provider.updateTileElevation(xyz)) {
          break;
        }
      }
    }
    updateTileElevation(xyz, tileSize) {
    }
    updateAllTileElevation(tileSize) {
    }
  };
  var ElevationImageryProvider_default = ElevationImageryProvider;

  // Source/custom/utils/jx.js
  function set(request, header, value) {
    request.setRequestHeader(header, value);
  }
  function noop2() {
  }
  var isRequested = false;
  var isIE9 = false;
  function req(url, type, json, data) {
    var methods = {
      success: noop2,
      error: noop2
    };
    var request;
    if (!isRequested) {
      var b_version = navigator.appVersion;
      var version = b_version.split(";");
      if (version[1]) {
        var trim_Version = version[1].replace(/[ ]/g, "");
        isIE9 = trim_Version == "MSIE9.0";
      }
      isRequested = true;
    }
    if (isIE9) {
      request = new XDomainRequest();
    } else {
      request = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
    }
    var hasPayload = type === "POST" || type === "PATCH" || type === "DELETE";
    request.open(type, url, true);
    if (!isIE9) {
      if (json) {
        set(request, "Content-Type", "application/json");
        set(request, "Accept", "application/json");
      } else {
        set(request, "Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
      }
    }
    if (hasPayload) {
      if (json)
        data = JSON.stringify(data);
    }
    request.onreadystatechange = function() {
      if (request.readyState === 4) {
        if (request.status >= 200 && request.status < 300) {
          methods.success.call(request, request.responseText, request);
        } else {
          methods.error.call(request, request.responseText, request);
        }
      }
    };
    request.onerror = function() {
      methods.error.call(request, request.responseText, request);
    };
    request.onload = function() {
      methods.success.call(request, request.responseText, request);
    };
    hasPayload ? request.send(data) : request.send();
    var returned = {
      success: function(callback) {
        methods.success = callback;
        return returned;
      },
      error: function(callback) {
        methods.error = callback;
        return returned;
      },
      request
    };
    return returned;
  }
  var jx_default = {
    get: function(url) {
      return req(url, "GET", false, null);
    },
    post: function(url, data) {
      return req(url, "POST", false, data);
    },
    patch: function(url, data) {
      return req(url, "PATCH", false, data);
    },
    "delete": function(url) {
      return req(url, "DELETE", false, null);
    },
    json: {
      get: function(url) {
        return req(url, "GET", true, null);
      },
      post: function(url, data) {
        return req(url, "POST", true, data);
      },
      patch: function(url, data) {
        return req(url, "PATCH", true, data);
      }
    }
  };

  // Source/custom/utils/es6-promise.js
  var Deferred = function() {
    this.promise = new Promise(function(resolve, reject) {
      this.resolve = resolve;
      this.reject = reject;
    }.bind(this));
    this.then = this.promise.then.bind(this.promise);
    this.catch = this.promise.catch.bind(this.promise);
  };
  var getJSON = function(param) {
    if (!param.type) {
      param.type = "GET";
    }
    if (!param.dataType) {
      param.dataType = "json";
    }
    return new Promise(function(resolve, reject) {
      sendAjax(resolve, reject, param);
    });
  };
  var sendAjax = function(resolve, reject, param, returnParam) {
    var UType = param.type.toUpperCase();
    var rq;
    if (UType == "GET") {
      rq = jx_default.get(param.url);
    }
    if (UType == "POST") {
      rq = jx_default.post(param.url, param.data);
    }
    var timeout = 3e4;
    var time = false;
    var timer = setTimeout(function() {
      if (rq.request.status >= 300 || rq.request.status < 200) {
        time = true;
        rq.request.abort();
        console.warn("timeout: " + param.url);
        reject({ param, data: "getParamJSON: " + param.url + " timeout " });
      }
    }, timeout);
    rq.success(function(results, request) {
      if (time) {
        return;
      }
      if (param.dataType == "json" && typeof results == "string") {
        results = JSON.parse(results);
      }
      if (returnParam) {
        resolve({ param, data: results });
      } else {
        resolve(results);
      }
    });
    rq.error(function(results, request) {
      if (time) {
        return;
      }
      reject({ param, data: "getParamJSON: " + param.url + " failed with status: " + request.status });
    });
    return rq.request;
  };
  var getParamJSON = function(param) {
    if (!param.type) {
      param.type = "GET";
    }
    if (!param.dataType) {
      param.dataType = "json";
    }
    var xhr;
    var promise = new Promise(function(resolve, reject) {
      xhr = sendAjax(resolve, reject, param, true);
    });
    promise.xhr = xhr;
    return promise;
  };
  var es6_promise_default = {
    Deferred,
    getJSON,
    getParamJSON
  };

  // Source/custom/layer/GXYZUtil.js
  var getJSON2 = es6_promise_default.getJSON;
  var GXYZUtil = class {
    constructor() {
      this.tileSize = 256;
    }
    setFilter(filter, callback) {
      for (var i = 0; i < filter.layers.length; i++) {
        var filterLayer = filter.layers[i];
        if (!filterLayer.id) {
          filter.layers.splice(i, 1);
        }
      }
      var control = JSON.stringify(filter);
      if (this.isIE()) {
        getJSON2({
          type: "post",
          url: this.host + "/mapserver/vmap/" + this.servername + "/setControl",
          data: "control= " + control,
          dataType: "json"
        }).then(function(result2) {
          result2.isIE = true;
          callback(result2);
        }.bind(this));
      } else {
        var result = { isIE: false, id: encodeURIComponent(control) };
        callback(result);
      }
    }
    parseUrl(url) {
      var urlParts = url.split("?");
      var urlPartOne = urlParts[0].split("/mapserver/");
      if (urlPartOne.length != 2) {
        return;
      }
      this.host = urlPartOne[0];
      if (!urlParts[1]) {
        return;
      }
      this.servername = urlPartOne[1].split("/")[1];
      var params2 = urlParts[1].split("&");
      for (var i = 0; i < params2.length; i++) {
        var param = params2[i];
        var keyValue = param.split("=");
        if (keyValue[0] == "styleId") {
          this.styleId = keyValue[1];
          return;
        }
      }
    }
    pickupFeatures(row, col, level, x3, y3, control, controlId, callback) {
      var url = this.host + "/mapserver/pickup/" + this.servername + "/getData?x=" + col + "&y=" + row + "&l=" + level + "&pixelX=" + x3 + "&pixelY=" + y3 + "&styleId=" + this.styleId + "&tilesize=" + this.tileSize + "&clientVersion=" + Version_default;
      if (control) {
        url = url + "&control=" + control;
      }
      if (controlId) {
        url = url + "&controlId=" + controlId;
      }
      getJSON2({
        url,
        dataType: "json"
      }).then(function(features) {
        callback(features);
      }, function() {
        callback([]);
      });
    }
    CreateHighlightFilter(layerFeatures, style) {
      var filter = new Filter_default();
      filter.otherDisplay = false;
      for (var layerId in layerFeatures) {
        var fs = layerFeatures[layerId];
        var filterLayer = new FilterLayer_default();
        filterLayer.id = layerId;
        filterLayer.color = style;
        var idFilter = "";
        for (var fid in fs) {
          idFilter = idFilter + fid + ",";
        }
        if (idFilter.length > 0) {
          idFilter = idFilter.substr(0, idFilter.length - 1);
          filterLayer.idFilter = idFilter;
        }
        filter.addFilterLayer(filterLayer);
      }
      return filter;
    }
    CreateEveryHighlightFilter(layerFeatures) {
      var filter = new Filter_default();
      filter.otherDisplay = false;
      for (var layerId in layerFeatures) {
        var fs = layerFeatures[layerId];
        var layerStyle = fs.style;
        var hasFid = false;
        for (var fid in fs) {
          var style = fs[fid].style;
          var filterLayer = new FilterLayer_default();
          filterLayer.id = layerId;
          filterLayer.idFilter = fid;
          filterLayer.color = style;
          filter.addFilterLayer(filterLayer);
          hasFid = true;
        }
        if (!hasFid && layerStyle) {
          var filterLayer = new FilterLayer_default();
          filterLayer.id = layerId;
          filterLayer.color = layerStyle;
          filter.addFilterLayer(filterLayer);
        }
      }
      return filter;
    }
    isIE() {
      if (!!window.ActiveXObject || "ActiveXObject" in window) {
        var b_version = navigator.appVersion;
        var version = b_version.split(";");
        if (version[1]) {
          var trim_Version = version[1].replace(/[ ]/g, "");
          if (trim_Version == "MSIE9.0") {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    }
  };
  var GXYZUtil_default = GXYZUtil;

  // Source/custom/lighteffect/Light.js
  var Light = class {
    constructor() {
      this.type = "";
      this.positionArray = [];
      this.colorArray = [];
      this.lightCount = 0;
      this.lightMap = {};
      this.films = [];
    }
    addFilm(film) {
      this.films.push(film);
      if (this.positionArray.length > 0) {
        film.updateLightShader(this);
      }
    }
    removeFilm(film) {
      let index = this.films.indexOf(film);
      this.films.splice(index, 1);
      if (this.positionArray.length > 0) {
        film.removeLightShader(this.type);
      }
    }
    addLight(id, params2) {
      if (!this.lightMap[id]) {
        this.lightCount++;
      }
      this.lightMap[id] = params2;
      this.updateLightArray();
      for (let index in this.films) {
        let film = this.films[index];
        film.updateLightShader(this);
      }
    }
    removeLight(id) {
      if (this.lightMap[id]) {
        let item = this.lightMap[id];
        this.lightCount--;
        delete this.lightMap[id];
        this.updateLightArray();
        if (this.lightCount == 0) {
          for (let index in this.films) {
            let film = this.films[index];
            film.removeLightShader(this.type);
          }
        } else {
          for (let index in this.films) {
            let film = this.films[index];
            film.updateLightShader(this);
          }
        }
      }
    }
    removeAllLight() {
      this.lightCount = 0;
      this.lightMap = {};
      for (let index in this.films) {
        let film = this.films[index];
        film.removeLightShader(this.type);
      }
    }
    updateLightArray() {
    }
    getGlobeSurfaceShader() {
    }
    getPolygonColorPrimitiveShader() {
    }
    getLineColorPrimitiveShader() {
    }
  };
  var Light_default = Light;

  // Source/custom/lighteffect/ModelCollectionShaderFactory.js
  function isContainPoint(v) {
    let str = v.toString();
    let ii = str.indexOf(".");
    if (ii < 0) {
      str += ".";
    }
    return str;
  }
  var ModelCollectionShaderFactory = class {
    static createLightOptions(options) {
      let vs = this.createVertexShader(options);
      let fs = this.createFragmentShader(options);
      let pp = [];
      let plo = options.pointLightOptions;
      if (plo) {
        for (let i in plo) {
          pp.push(plo[i].pointLightPosition);
        }
      }
      return {
        vertexShader: vs,
        fragmentShader: fs,
        plp: pp
      };
    }
    static createVertexShader(options) {
      let header = "void main(){\n xh_vertexShader();\n";
      let b2tShader = "";
      if (options.b2tScanOptions) {
        b2tShader += this.createTop2BottomVertexShader(options.b2tScanOptions);
        header += "  xh_b2tScanShader();\n";
      }
      let plShader = "";
      if (options.pointLightOptions) {
        plShader += this.createPointLightVertexShader();
        header += "  xh_pointLightShader();\n";
      }
      let end = "}\n";
      return b2tShader + plShader + header + end;
    }
    static createFragmentShader(options) {
      let header = "void main(){\n xh_fragmentShader();\n";
      let b2tShader = "";
      if (options.b2tScanOptions) {
        b2tShader += this.createTop2BottomFragmentShader(options.b2tScanOptions);
        header += "  xh_b2tScanShader();\n";
      }
      let plShader = "";
      if (options.pointLightOptions) {
        plShader += this.createPointLightFragmentShader(options.pointLightOptions);
        header += "  xh_pointLightShader();\n";
      }
      let end = "}\n";
      return b2tShader + plShader + header + end;
    }
    static createTop2BottomVertexShader(options) {
      let axis = options.axisName || "z";
      let a_height = options.correctHeight || 0;
      return "varying float v_height_b2t;\nvarying vec3 v_positionEC_b2t;\nvoid xh_b2tScanShader(){\n   v_height_b2t = a_position." + axis + " + " + a_height.toFixed(2) + ";\n   vec4 tp = czm_instanced_modelView * vec4(a_position,1.);\n   //tp = czm_inverseView * tp;\n   v_positionEC_b2t = tp.xyz/tp.w;\n}\n";
    }
    static createTop2BottomFragmentShader(b2t) {
      let mHeight = b2t.maxHeight || 1e3;
      let sHeight = b2t.scanHeight || 2500;
      let sRate = (b2t.scanWidth || 50) / sHeight;
      let speed = b2t.speed || 600;
      let scanColor = b2t.color || Cesium.Color.YELLOW;
      let a_height = b2t.correctHeight || 0;
      let header = "varying float v_height_b2t;\nvarying vec3 v_positionEC_b2t;\nuniform mat4 u_ienu_view;\n";
      let b2TShader = "void b2tScan(float ch,float mh,float sh,float speed,float sRate,vec3 color,float minl,float maxl,float baw){\n   float a11 = fract(czm_frameNumber / speed) * 3.14159265 * 2.;\n   float f = ch /mh;\n   \n   float ff = clamp(f,minl,maxl);\n   float a12 = ff + sin(a11) * baw;\n   gl_FragColor.rgb *= a12;\n   float a13 = fract(czm_frameNumber / speed);\n   float ah = clamp(ch / sh, 0.0, 1.0);\n   a13 = abs(a13 - 0.5) * 2.0;\n   float a_diff = step(sRate, abs(ah - a13));\n   if(a_diff < 0.5)\n     gl_FragColor.rgb = color.rgb;\n}\n";
      let minl = b2t.minimumlight || 0.8;
      let maxl = b2t.maximumlight || 1;
      let baw = b2t.blackAndWhite || 0.1;
      console.log(minl, maxl, baw);
      let scanShader = "void xh_b2tScanShader(){\n";
      scanShader += "  float minl = " + isContainPoint(minl) + ";\n";
      scanShader += "  float maxl = " + isContainPoint(maxl) + ";\n";
      scanShader += "  float baw = " + isContainPoint(baw) + ";\n";
      scanShader += "  float speed = " + isContainPoint(speed) + ";\n";
      scanShader += "  float rate = " + isContainPoint(sRate) + ";\n";
      scanShader += "  float mHeight = " + isContainPoint(mHeight) + ";\n";
      scanShader += "  float sHeight =  " + isContainPoint(sHeight) + ";\n";
      scanShader += "  vec3 color =  vec3(" + isContainPoint(scanColor.red) + "," + isContainPoint(scanColor.green) + "," + isContainPoint(scanColor.blue) + ");\n";
      scanShader += "   float ch = v_height_b2t;\n   vec4 tp = u_ienu_view * vec4(v_positionEC_b2t , 1.);\n   tp /= tp.w;\n   b2tScan(tp.z + " + a_height.toFixed(4) + ",mHeight,sHeight,speed,rate,color,minl,maxl,baw);}\n";
      return header + b2TShader + scanShader;
    }
    static createPointLightVertexShader() {
      return "varying vec3 xh_pointLightCoord;\nvoid xh_pointLightShader(){\n   vec4 tp = czm_instanced_modelView * vec4(a_position ,1.);\n   xh_pointLightCoord = tp.xyz;\n}\n";
    }
    static createPointLightFragmentShader(options) {
      let header = "varying vec3 xh_pointLightCoord;\n";
      for (let i in options) {
        header += "uniform vec3 xh_pointLightPosition" + i + ";\n";
      }
      let body = "void xh_pointLightShader(){\n";
      let r, x3, y3, z2, red, green, blue, alpha, st;
      for (let i in options) {
        let param = options[i];
        let plp = param.pointLightPosition;
        let plc = param.pointLightColor || Cesium.Color.WHITE;
        let plr = param.pointLightRadius || 100;
        st = param.pointLightStrength || 1;
        r = isContainPoint(plr);
        x3 = isContainPoint(plp.x);
        y3 = isContainPoint(plp.y);
        z2 = isContainPoint(plp.z);
        red = isContainPoint(plc.red);
        green = isContainPoint(plc.green);
        blue = isContainPoint(plc.blue);
        alpha = isContainPoint(plc.alpha);
        body += "float xh_pointLightRadius" + i + " = " + isContainPoint(r) + ";\nfloat xh_pointLightStrength" + i + " = " + isContainPoint(st) + ";\nvec3 xh_pointLightCoord" + i + " = vec3(" + isContainPoint(x3) + "," + isContainPoint(y3) + "," + isContainPoint(z2) + ");\nvec4 xh_pointLightColor" + i + " = vec4(" + isContainPoint(red) + "," + isContainPoint(green) + "," + isContainPoint(blue) + "," + isContainPoint(alpha) + ");\n";
        body += this.pointLightShader(i, "xh_pointLightCoord");
      }
      let end = "}\n";
      return header + body + end;
    }
    static pointLightShader(i, v_positionEC) {
      return "vec4 xh_pl" + i + " =  czm_inverseView3D * vec4(xh_pointLightPosition" + i + ".xyz ,1.);\n xh_pl" + i + " /=  xh_pl" + i + ".w ;\n float xh_dis" + i + " = length( " + v_positionEC + " - xh_pointLightPosition" + i + ".xyz);\n if(xh_dis" + i + " <= xh_pointLightRadius" + i + "){\n   float f = (1. - xh_dis" + i + "/ xh_pointLightRadius" + i + ");\n   gl_FragColor.rgb += xh_pointLightStrength" + i + "* xh_pointLightColor" + i + ".rgb * f ;\n }\n";
    }
  };
  var ModelCollectionShaderFactory_default = ModelCollectionShaderFactory;

  // Source/custom/lighteffect/ModelShaderFactory.js
  function isContainPoint2(v) {
    let str = v.toString();
    let ii = str.indexOf(".");
    if (ii < 0) {
      str += ".";
    }
    return str;
  }
  var ModelShaderFactory = class {
    static createLightOptions(options) {
      let vs = ModelShaderFactory.createVertexShader(options);
      let fs = ModelShaderFactory.createFragmentShader(options);
      let pp = [];
      let plo = options.pointLightOptions;
      if (plo) {
        for (let i in plo) {
          pp.push(plo[i].pointLightPosition);
        }
      }
      return {
        vertexShader: vs,
        fragmentShader: fs,
        plp: pp
      };
    }
    static createVertexShader(options) {
      let header = "void main(){\n xh_vertexShader();\n";
      let b2tShader = "";
      if (options.b2tScanOptions) {
        b2tShader += ModelShaderFactory.createTop2BottomVertexShader(options.b2tScanOptions);
        header += "  xh_b2tScanShader();\n";
      }
      let plShader = "";
      if (options.pointLightOptions) {
        plShader += ModelShaderFactory.createPointLightVertexShader();
        header += "  xh_pointLightShader();\n";
      }
      let end = "}\n";
      return b2tShader + plShader + header + end;
    }
    static createFragmentShader(options) {
      let header = "void main(){\n xh_fragmentShader();\n";
      let b2tShader = "";
      if (options.b2tScanOptions) {
        b2tShader += ModelShaderFactory.createTop2BottomFragmentShader(options.b2tScanOptions);
        header += "  xh_b2tScanShader();\n";
      }
      let plShader = "";
      if (options.pointLightOptions) {
        plShader += ModelShaderFactory.createPointLightFragmentShader(options.pointLightOptions);
        header += "  xh_pointLightShader();\n";
      }
      let end = "}\n";
      return b2tShader + plShader + header + end;
    }
    static createTop2BottomVertexShader(options) {
      let axis = options.axisName || "z";
      let a_height = options.correctHeight || 0;
      return "varying float v_height_b2t;\nvarying vec3 v_positionEC_b2t;\nvoid xh_b2tScanShader(){\n   v_height_b2t = a_position." + axis + " + " + a_height.toFixed(2) + ";\n   vec4 tp = u_modelViewMatrix * vec4(a_position,1.);\n   //tp = czm_inverseView * tp;\n   v_positionEC_b2t = tp.xyz/tp.w;\n}\n";
    }
    static createTop2BottomFragmentShader(b2t) {
      let mHeight = b2t.maxHeight || 1e3;
      let sHeight = b2t.scanHeight || 2500;
      let sRate = (b2t.scanWidth || 50) / sHeight;
      let speed = b2t.speed || 600;
      let scanColor = b2t.color || Cesium.Color.YELLOW;
      let a_height = b2t.correctHeight || 0;
      let header = "varying float v_height_b2t;\nvarying vec3 v_positionEC_b2t;\nuniform mat4 u_ienu_view;\n";
      let b2TShader = "void b2tScan(float ch,float mh,float sh,float speed,float sRate,vec3 color,float minl,float maxl,float baw){\n   float a11 = fract(czm_frameNumber / speed) * 3.14159265 * 2.;\n   float f = ch /mh;\n   \n   float ff = clamp(f,minl,maxl);\n   float a12 = ff + sin(a11) * baw;\n   gl_FragColor.rgb *= a12;\n   float a13 = fract(czm_frameNumber / speed);\n   float ah = clamp(ch / sh, 0.0, 1.0);\n   a13 = abs(a13 - 0.5) * 2.0;\n   float a_diff = step(sRate, abs(ah - a13));\n   if(a_diff < 0.5)\n     gl_FragColor.rgb = color.rgb;\n}\n";
      let minl = b2t.minimumlight || 0.8;
      let maxl = b2t.maximumlight || 1;
      let baw = b2t.blackAndWhite || 0.1;
      console.log(minl, maxl, baw);
      let scanShader = "void xh_b2tScanShader(){\n";
      scanShader += "  float minl = " + isContainPoint2(minl) + ";\n";
      scanShader += "  float maxl = " + isContainPoint2(maxl) + ";\n";
      scanShader += "  float baw = " + isContainPoint2(baw) + ";\n";
      scanShader += "  float speed = " + isContainPoint2(speed) + ";\n";
      scanShader += "  float rate = " + isContainPoint2(sRate) + ";\n";
      scanShader += "  float mHeight = " + isContainPoint2(mHeight) + ";\n";
      scanShader += "  float sHeight =  " + isContainPoint2(sHeight) + ";\n";
      scanShader += "  vec3 color =  vec3(" + isContainPoint2(scanColor.red) + "," + isContainPoint2(scanColor.green) + "," + isContainPoint2(scanColor.blue) + ");\n";
      scanShader += "   float ch = v_height_b2t;\n   vec4 tp = u_ienu_view * vec4(v_positionEC_b2t , 1.);\n   tp /= tp.w;\n   b2tScan(tp.z + " + a_height.toFixed(4) + ",mHeight,sHeight,speed,rate,color,minl,maxl,baw);}\n";
      return header + b2TShader + scanShader;
    }
    static createPointLightVertexShader() {
      return "varying vec3 xh_pointLightCoord;\nvoid xh_pointLightShader(){\n   vec4 tp = u_modelViewMatrix * vec4(a_position ,1.);\n   xh_pointLightCoord = tp.xyz;\n}\n";
    }
    static createPointLightFragmentShader(options) {
      let header = "varying vec3 xh_pointLightCoord;\n";
      for (let i in options) {
        header += "uniform vec3 xh_pointLightPosition" + i + ";\n";
      }
      let body = "void xh_pointLightShader(){\n";
      let r, x3, y3, z2, red, green, blue, alpha, st;
      for (let i in options) {
        let param = options[i];
        let plp = param.pointLightPosition;
        let plc = param.pointLightColor || Cesium.Color.WHITE;
        let plr = param.pointLightRadius || 100;
        st = param.pointLightStrength || 1;
        r = isContainPoint2(plr);
        x3 = isContainPoint2(plp.x);
        y3 = isContainPoint2(plp.y);
        z2 = isContainPoint2(plp.z);
        red = isContainPoint2(plc.red);
        green = isContainPoint2(plc.green);
        blue = isContainPoint2(plc.blue);
        alpha = isContainPoint2(plc.alpha);
        body += "float xh_pointLightRadius" + i + " = " + isContainPoint2(r) + ";\nfloat xh_pointLightStrength" + i + " = " + isContainPoint2(st) + ";\nvec3 xh_pointLightCoord" + i + " = vec3(" + isContainPoint2(x3) + "," + isContainPoint2(y3) + "," + isContainPoint2(z2) + ");\nvec4 xh_pointLightColor" + i + " = vec4(" + isContainPoint2(red) + "," + isContainPoint2(green) + "," + isContainPoint2(blue) + "," + isContainPoint2(alpha) + ");\n";
        body += ModelShaderFactory.pointLightShader(i, "xh_pointLightCoord");
      }
      let end = "}\n";
      return header + body + end;
    }
    static pointLightShader(i, v_positionEC) {
      return "vec4 xh_pl" + i + " =  czm_inverseView3D * vec4(xh_pointLightPosition" + i + ".xyz ,1.);\n xh_pl" + i + " /=  xh_pl" + i + ".w ;\n float xh_dis" + i + " = length( " + v_positionEC + " - xh_pointLightPosition" + i + ".xyz);\n if(xh_dis" + i + " <= xh_pointLightRadius" + i + "){\n   float f = (1. - xh_dis" + i + "/ xh_pointLightRadius" + i + ");\n   gl_FragColor.rgb += xh_pointLightStrength" + i + "* xh_pointLightColor" + i + ".rgb * f ;\n }\n";
    }
  };
  var ModelShaderFactory_default = ModelShaderFactory;

  // Source/custom/lighteffect/PointLight.js
  var PointLight = class extends Light_default {
    constructor() {
      super();
      this.type = "PointLight";
      this.radiusArray = [];
    }
    updateLightArray() {
      this.positionArray = [];
      this.colorArray = [];
      this.radiusArray = [];
      for (let key2 in this.lightMap) {
        let item = this.lightMap[key2];
        this.positionArray.push(item.position);
        this.colorArray.push(item.color);
        this.radiusArray.push(item.radius);
      }
    }
    getGlobeSurfaceShader() {
      return {
        vertexShaderSource: Cesium.ShaderSource.replaceMain(this.getGlobeSurfaceVS(), this.type),
        fragmentShaderSource: Cesium.ShaderSource.replaceMain(this.getFS(), this.type)
      };
    }
    getPolygonColorPrimitiveShader() {
      return {
        vertexShaderSource: Cesium.ShaderSource.replaceMain(this.getPolygonColorPrimitiveVs(), this.type),
        fragmentShaderSource: Cesium.ShaderSource.replaceMain(this.getFS(), this.type)
      };
    }
    getGlobeSurfaceVS() {
      return `
          varying vec3 v_xh_position;
          void main(){
            #ifdef QUANTIZATION_BITS12
                vec2 xy = czm_decompressTextureCoordinates(compressed0.x);
                vec2 zh = czm_decompressTextureCoordinates(compressed0.y);
                vec3 position = vec3(xy, zh.x);
                float height = zh.y;
                vec2 textureCoordinates = czm_decompressTextureCoordinates(compressed0.z);
            
                height = height * (u_minMaxHeight.y - u_minMaxHeight.x) + u_minMaxHeight.x;
                position = (u_scaleAndBias * vec4(position, 1.0)).xyz;
            #else
                // A single float per element
                vec3 position = position3DAndHeight.xyz;
            #endif
                v_xh_position = position + u_center3D;
          }
          `;
    }
    getPolygonColorPrimitiveVs() {
      return "varying vec3 v_xh_position;\nvoid main(){\n v_xh_position = position3DHigh + position3DLow;\n}\n";
    }
    getFS() {
      let header = "varying vec3 v_xh_position;\n";
      let lightFunc = "vec3 calPointLightColor(vec3 wp,vec3 pos,vec4 color,float radius){\n   vec3 color1 = vec3(0.,0.,0.);\n   float dis = length(wp - pos);\n   if(dis < radius){\n     color1 = color.rgb * (1. - dis / radius);\n   }\n   return color1;\n}\n";
      let main = lightFunc + "void main(){\n";
      for (let i in this.positionArray) {
        main += "vec3 lightPos" + i + " = vec3(" + this.positionArray[i].x.toFixed(5) + "," + this.positionArray[i].y.toFixed(5) + "," + this.positionArray[i].z.toFixed(5) + ");\nvec4 lightColor" + i + " = vec4(" + this.colorArray[i].red.toFixed(5) + "," + this.colorArray[i].green.toFixed(5) + "," + this.colorArray[i].blue.toFixed(5) + "," + this.colorArray[i].alpha.toFixed(5) + ");\nfloat lightRadius" + i + " = " + this.radiusArray[i].toFixed(5) + ";\ngl_FragColor.rgb += calPointLightColor( v_xh_position, lightPos" + i + ", lightColor" + i + ", lightRadius" + i + ");\n";
      }
      main += "}\n";
      return header + main;
    }
  };
  var PointLight_default = PointLight;

  // Source/custom/lighteffect/Radar3dTileLight.js
  var Radar3dTileLight = class {
    static createRadar3dTileLigh(options) {
      let radar3dTileLight = new Radar3dTileLight(options);
      ;
      return radar3dTileLight;
    }
    constructor(options) {
      this.viewer = options.viewer || window.viewer;
      this.positions = options.positions;
      this.center = options.center;
      this.radius = options.radius || 0;
      if (this.center && this.radius > 0) {
        this.positions = this.computeEllipsePosition_pls(this.center, this.radius, 270, -90);
      }
      this.color = options.color || Cesium.Color.YELLOW;
      this.direction = options.direction || -1;
      this.speed = options.speed || 600;
      this.scale = options.scale || 0.5;
      this.showLine = options.showLine || false;
      this.lineWidth = options.lineWidth || 4;
      this.lineColor = options.lineColor || new Cesium.Color(1, 1, 0, 0.5);
      this.scanCenter = options.scanCenter;
      if (!Cesium.defined(options.scanCenter)) {
        this.scanCenter = new Cesium.Cartesian2(0.5, 0.5);
      } else {
        this.scanCenter = this.computeScanTextureCoordAndRate(options.scanCenter, this.positions).tc;
      }
      this.update();
    }
    draw() {
      let ppxxx = new Cesium.PolygonGeometry({
        polygonHierarchy: new Cesium.PolygonHierarchy(this.positions)
      });
      let gi = new Cesium.GeometryInstance({
        geometry: ppxxx
      });
      this.primitive = new Cesium.GroundPrimitive({
        geometryInstances: [gi],
        appearance: new Cesium.EllipsoidSurfaceAppearance({
          material: new Cesium.Material({
            fabric: {
              uniforms: {
                speed: this.speed,
                color: this.color,
                direction: this.direction
              },
              source: this.createPolygonScanShader1()
            }
          })
        }),
        asynchronous: true
      });
      this.viewer.scene.primitives.add(this.primitive);
    }
    drawLine() {
      let ppxxx = new Cesium.GroundPolylineGeometry({
        positions: this.positions,
        width: this.lineWidth,
        loop: true
      });
      let gi = new Cesium.GeometryInstance({
        geometry: ppxxx
      });
      this.primitive1 = new Cesium.GroundPolylinePrimitive({
        geometryInstances: [gi],
        appearance: new Cesium.EllipsoidSurfaceAppearance({
          material: new Cesium.Material({
            fabric: {
              type: "Color",
              uniforms: {
                color: this.lineColor
              }
            }
          })
        }),
        asynchronous: true
      });
      this.viewer.scene.primitives.add(this.primitive1);
    }
    update() {
      this.destroyPrimitive();
      this.draw();
      if (this.showLine)
        this.drawLine();
    }
    destroyPrimitive() {
      if (this.primitive)
        this.viewer.scene.primitives.remove(this.primitive);
      if (this.primitive1)
        this.viewer.scene.primitives.remove(this.primitive1);
    }
    destroy() {
      this.destroyPrimitive();
      for (let i in this) {
        delete this[i];
      }
    }
    createPolygonScanShader1() {
      return "czm_material czm_getMaterial(czm_materialInput materialInput){   czm_material material = czm_getDefaultMaterial(materialInput);\n   vec2 st = normalize(materialInput.st -vec2(0.5,0.5));\n   vec4 color1 = vec4(color.rgb,0.);\n   float time = fract(czm_frameNumber / speed) * direction;\n   float angle = 3.1415926535898 * 2.0 * time;\n   vec2 normal = vec2(sin(angle),cos(angle));\n   float ff = normal.x * st.t - normal.y * st.s;\n   if(ff < 0.0 ){\n     float fff = dot(normal,st);\n     if(fff > 0.70710678){\n         color1.a =  pow(fff,4.);\n     }\n   }\n    material.diffuse = color.rgb;\n    material.alpha = color1.a ;\n    return material;\n}\n";
    }
    createPolygonScanShader() {
      return "czm_material czm_getMaterial(czm_materialInput materialInput){    czm_material material = czm_getDefaultMaterial(materialInput);\n    vec2 st = materialInput.st;\n    vec2 center = (st - scanCenter)*scale;\n    float time = direction * czm_frameNumber * 3.1415926 / 180.;\n    float sin_t = sin(time);\n    float cos_t = cos(time);\n    vec2 center_rotate = vec2(center.s*cos_t-center.t*sin_t+0.5,center.s*sin_t+center.t*cos_t+0.5);\n    vec4 color = texture2D(image,center_rotate);\n    vec3 tColor = czm_gammaCorrect(color.rgb * highlightColor.rgb);\n    tColor *= vec3(1.2,1.2,1.2);\n    if(length(center)>0.48){\n      tColor = highlightColor.rgb * 1.2;\n    }\n    material.diffuse = tColor;\n    material.alpha = color.a * 2.;\n    return material;\n}\n";
    }
    computeScanTextureCoordAndRate(scanCenter, points) {
      let mm = this.computeMinMaxCoords(points);
      let sc = this.carte2carto(scanCenter);
      let tc = new Cesium.Cartesian2();
      tc.x = (sc.longitude - mm[0]) / (mm[2] - mm[0]);
      tc.y = (sc.latitude - mm[1]) / (mm[3] - mm[1]);
      let rate = (mm[2] - mm[0]) / (mm[3] - mm[1]);
      return {
        tc,
        rate
      };
    }
    computeMinMaxCoords(points) {
      let minX = Number.MAX_VALUE;
      let minY = Number.MAX_VALUE;
      let maxX = Number.MIN_VALUE;
      let maxY = Number.MIN_VALUE;
      let p = null;
      let x3 = null;
      let y3 = null;
      for (let i in points) {
        p = this.carte2carto(points[i]);
        x3 = p.longitude;
        y3 = p.latitude;
        if (x3 < minX) {
          minX = x3;
        }
        if (x3 > maxX) {
          maxX = x3;
        }
        if (y3 < minY) {
          minY = y3;
        }
        if (y3 > maxY) {
          maxY = y3;
        }
      }
      return [minX, minY, maxX, maxY];
    }
    carte2carto(p) {
      return Cesium.Cartographic.fromCartesian(p);
    }
    computeEllipsePosition_pls(center2, radius, fromA, toA, inlength) {
      let res = [];
      let length2 = inlength || 360;
      let interval = (toA - fromA) * Math.PI / 180 / length2;
      let startA = fromA * Math.PI / 180;
      let mm = Cesium.Transforms.eastNorthUpToFixedFrame(center2);
      for (let i = 0; i < length2; i++) {
        let a2 = startA + interval * i;
        let p = new Cesium.Cartesian3(Math.sin(a2) * radius, Math.cos(a2) * radius, 0);
        res.push(Cesium.Matrix4.multiplyByPoint(mm, p, new Cesium.Cartesian3()));
      }
      return res;
    }
  };
  var Radar3dTileLight_default = Radar3dTileLight;

  // Source/custom/lighteffect/RadarLight.js
  var RadarLight = class extends Light_default {
    constructor() {
      super();
      this.type = "RadarLight";
    }
    updateLightArray() {
    }
    getGlobeSurfaceShader() {
      return {
        vertexShaderSource: Cesium.ShaderSource.replaceMain(this.getGlobeSurfaceVS(), this.type),
        fragmentShaderSource: Cesium.ShaderSource.replaceMain(this.getFS(), this.type)
      };
    }
    getPolygonColorPrimitiveShader() {
      return {
        vertexShaderSource: Cesium.ShaderSource.replaceMain(this.getPolygonColorPrimitiveVs(), this.type),
        fragmentShaderSource: Cesium.ShaderSource.replaceMain(this.getFS(), this.type)
      };
    }
    getGlobeSurfaceVS() {
      return `
          varying vec3 v_xh_position2;
          void main(){
            #ifdef QUANTIZATION_BITS12
                vec2 xy = czm_decompressTextureCoordinates(compressed0.x);
                vec2 zh = czm_decompressTextureCoordinates(compressed0.y);
                vec3 position = vec3(xy, zh.x);
                float height = zh.y;
                vec2 textureCoordinates = czm_decompressTextureCoordinates(compressed0.z);
            
                height = height * (u_minMaxHeight.y - u_minMaxHeight.x) + u_minMaxHeight.x;
                position = (u_scaleAndBias * vec4(position, 1.0)).xyz;
            #else
                // A single float per element
                vec3 position = position3DAndHeight.xyz;
            #endif
                v_xh_position2 = position + u_center3D;
          }
          `;
    }
    getPolygonColorPrimitiveVs() {
      return "varying vec3 v_xh_position2;\nvoid main(){\n v_xh_position2 = position3DHigh + position3DLow;\n}\n";
    }
    getFS() {
      let header = "varying vec3 v_xh_position2;\n";
      let scanShader = "";
      for (let i in this.lightMap) {
        let polygon2 = this.lightMap[i].polygon || [new Cesium.Cartesian3()];
        let center2 = this.lightMap[i].position;
        let speed = this.lightMap[i].speed || 600;
        let ringCount = this.lightMap[i].count || 3;
        let scanDirection = this.lightMap[i].direction || -1;
        let scanColor = this.lightMap[i].color || new Cesium.Color(0.3, 0.5, 0.8, 1);
        let isCircle = this.lightMap[i].isCircle || 1;
        let maxRadius = this.lightMap[i].radius || 0;
        if (this.lightMap[i].polygon)
          isCircle = -1;
        scanShader += "int isInPolygon" + i + "(vec2 checkPoint, vec2 polygonPoints[" + polygon2.length + "]) {\n    int counter = 0;\n    float xinters;\n    vec2 p1;\n    vec2 p2;\n    const int pointCount = " + polygon2.length + ";\n    p1 = polygonPoints[0];\n	\n    for (int i = 1; i < pointCount; i++) {\n        p2 = polygonPoints[i ];\n        if (checkPoint.x > min(p1.x, p2.x) && checkPoint.x <= max(p1.x, p2.x)) {\n            if (checkPoint.y <= max(p1.y, p2.y)) {\n                if (p1.x != p2.x) {\n                    xinters = (checkPoint.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y;\n                    if (p1.y == p2.y || checkPoint.y <= xinters) {\n                        counter++;\n                    }\n                }\n            }\n        }\n        p1 = p2;\n    }\n    float f = float(counter) / 2.;\n    float ff = f - floor(f);\n    if(ff > 0.000001)\n       return 1;\n    else\n       return 0;\n}\n";
        scanShader += "void lidarScan" + i + "(){\n";
        let enu_mat = Cesium.Transforms.eastNorthUpToFixedFrame(center2);
        let ienu_mat = Cesium.Matrix4.inverse(enu_mat, new Cesium.Matrix4());
        let ienu_Shader = "mat4 ienu_mat1 = mat4(" + ienu_mat[0].toFixed(15) + "," + ienu_mat[1].toFixed(15) + "," + ienu_mat[2].toFixed(15) + "," + ienu_mat[3].toFixed(15) + "," + ienu_mat[4].toFixed(15) + "," + ienu_mat[5].toFixed(15) + "," + ienu_mat[6].toFixed(15) + "," + ienu_mat[7].toFixed(15) + "," + ienu_mat[8].toFixed(15) + "," + ienu_mat[9].toFixed(15) + "," + ienu_mat[10].toFixed(15) + "," + ienu_mat[11].toFixed(15) + "," + ienu_mat[12].toFixed(15) + "," + ienu_mat[13].toFixed(15) + "," + ienu_mat[14].toFixed(15) + "," + ienu_mat[15].toFixed(15) + ");\n";
        scanShader += ienu_Shader;
        scanShader += "vec2 scan_polygon[" + polygon2.length + "];\n";
        for (let i2 in polygon2) {
          let p = Cesium.Matrix4.multiplyByPoint(ienu_mat, polygon2[i2], new Cesium.Cartesian3());
          scanShader += "scan_polygon[" + i2 + "] = vec2(" + p.x.toFixed(5) + "," + p.y.toFixed(5) + ");\n";
        }
        scanShader += "int isCircle = " + isCircle + ";\n";
        scanShader += "float speed = " + speed.toFixed(5) + ";\n";
        scanShader += "float rate = 1. / " + ringCount.toFixed(5) + ";\n";
        scanShader += "float radius = " + maxRadius.toFixed(5) + ";\n";
        scanShader += "float direction =  " + scanDirection.toFixed(5) + ";\n";
        scanShader += "vec3 color =  vec3(" + scanColor.red.toFixed(5) + "," + scanColor.green.toFixed(5) + "," + scanColor.blue.toFixed(5) + ");\n";
        scanShader += " vec4 tpoint = ienu_mat1 * vec4(v_xh_position2 ,1.);\n tpoint /= tpoint.w;\n vec2 txy = tpoint.xy;\n int f = 0;\n if(isCircle == 1)\n   f = 1;\n else\n   f = isInPolygon" + i + "( txy, scan_polygon );\n if(f == 1){\n   vec2 st = normalize(txy / radius);\n   float time = fract(czm_frameNumber / speed) * direction;\n   float angle = 3.1415926535898 * 2.0 * time;\n   vec2 normal = vec2(sin(angle),cos(angle));\n   float ff = normal.x * st.t - normal.y * st.s;\n   float distance = length(txy);\n   if(ff < 0.0 && distance < radius){\n     float fff = dot(normal,st);\n     if(fff > 0.70710678){\n         gl_FragColor.rgb = mix(gl_FragColor.rgb, color.rgb, pow(fff,4.));\n     }\n   }\n }\n}\n";
      }
      let endShader = "void main(){\n";
      for (let i in this.lightMap) {
        endShader += "  lidarScan" + i + "();\n";
      }
      endShader += "}\n";
      return header + scanShader + endShader;
    }
  };
  var RadarLight_default = RadarLight;

  // Source/custom/lighteffect/UpDownScanLight.js
  var UpDownScanLight = class extends Light_default {
    constructor() {
      super();
      this.type = "UpDownScanLight";
    }
    updateLightArray() {
    }
    getGlobeSurfaceShader() {
    }
    getPolygonColorPrimitiveShader() {
      return {
        vertexShaderSource: Cesium.ShaderSource.replaceMain(this.getPolygonColorPrimitiveVs(), this.type),
        fragmentShaderSource: Cesium.ShaderSource.replaceMain(this.getFs(), this.type)
      };
    }
    getPolygonColorPrimitiveVs() {
      return "varying vec3 v_xh_position3;\n void main(){\n   vec4 p = czm_computePosition();\n   v_xh_position3 = (czm_modelViewRelativeToEye * p).xyz;\n}\n";
    }
    getFs() {
      let b2t = null;
      for (let i in this.lightMap) {
        b2t = this.lightMap[i];
      }
      let center2 = b2t.position;
      let mHeight = b2t.maxHeight || 10;
      let sHeight = b2t.scanHeight || 50;
      let sRate = (b2t.scanWidth || 2) / sHeight;
      let speed = b2t.speed || 600;
      let scanColor = b2t.color || new Cesium.Color(0.1, 0.3, 0.5, 1);
      let header = "varying vec3 v_xh_position3;\n";
      let p1 = center2;
      let tp = Cesium.Cartographic.fromCartesian(p1);
      let p2 = Cesium.Cartesian3.fromRadians(tp.longitude, tp.latitude, tp.height + 2e5);
      let origin1High = new window.Cesium.Cartesian3(Math.floor(p1.x), Math.floor(p1.y), Math.floor(p1.z));
      let origin1Low = new window.Cesium.Cartesian3(p1.x - Math.floor(p1.x), p1.y - Math.floor(p1.y), p1.z - Math.floor(p1.z));
      let origin2High = new window.Cesium.Cartesian3(Math.floor(p2.x), Math.floor(p2.y), Math.floor(p2.z));
      let origin2Low = new window.Cesium.Cartesian3(p2.x - Math.floor(p2.x), p2.y - Math.floor(p2.y), p2.z - Math.floor(p2.z));
      let computeHeightShader = "vec3 calPoint(vec3 high,vec3 low){\n     vec4 tPoint = czm_translateRelativeToEye(high,low);\n     return (czm_modelViewRelativeToEye *tPoint).xyz;\n}\nvec3 pointProjectOnPlane(vec3 planeNormal,vec3 planeOrigin,vec3 point)\n{\n   vec3 dd = point - planeOrigin;\n   float d = dot(planeNormal,dd);\n   return (point - planeNormal * d);\n}\nfloat calHeight(vec3 o,vec3 up,vec3 p)\n{\n   vec3 normal = up - o;\n   normal = normalize(normal);\n   vec3 op = p - o;\n   return dot(normal,op);\n}\n";
      let b2TShader = "void b2tScan(float ch,float mh,float sh,float speed,float sRate,vec3 color){\n   float a11 = fract(czm_frameNumber / speed) * 3.14159265 * 2.;\n   float a12 = ch / mh + sin(a11) * 0.2 + 0.5;\n   gl_FragColor.rgb *= a12;\n   float a13 = fract(czm_frameNumber / speed);\n   float ah = clamp(ch / sh, 0.0, 1.0);\n   a13 = abs(a13 - 0.5) * 2.0;\n   float a_diff = step(sRate, abs(ah - a13));\n   if(a_diff < 0.5)\n     gl_FragColor.rgb = color.rgb;\n}\n";
      let scanShader = "void main(){\n";
      scanShader += "float speed = " + this.isContainPoint(speed) + ";\n";
      scanShader += "float rate = " + this.isContainPoint(sRate) + ";\n";
      scanShader += "float mHeight = " + this.isContainPoint(mHeight) + ";\n";
      scanShader += "float sHeight =  " + this.isContainPoint(sHeight) + ";\n";
      scanShader += "vec3 color =  vec3(" + this.isContainPoint(scanColor.red) + "," + this.isContainPoint(scanColor.green) + "," + this.isContainPoint(scanColor.blue) + ");\n";
      scanShader += "vec3 high1 =  vec3(" + this.isContainPoint(origin1High.x) + "," + this.isContainPoint(origin1High.y) + "," + this.isContainPoint(origin1High.z) + ");\n";
      scanShader += "vec3 low1 =  vec3(" + this.isContainPoint(origin1Low.x) + "," + this.isContainPoint(origin1Low.y) + "," + this.isContainPoint(origin1Low.z) + ");\n";
      scanShader += "vec3 high2 =  vec3(" + this.isContainPoint(origin2High.x) + "," + this.isContainPoint(origin2High.y) + "," + this.isContainPoint(origin2High.z) + ");\n";
      scanShader += "vec3 low2 =  vec3(" + this.isContainPoint(origin2Low.x) + "," + this.isContainPoint(origin2Low.y) + "," + this.isContainPoint(origin2Low.z) + ");\n";
      scanShader += "   vec3 origin = calPoint(high1,low1);\n   vec3 originAbove = calPoint(high2,low2);\n   float ch = calHeight(origin, originAbove, v_xh_position3);\n   b2tScan(ch,mHeight,sHeight,speed,rate,color);\n}\n";
      return header + computeHeightShader + b2TShader + scanShader;
    }
    isContainPoint(v) {
      let str = v.toString();
      let ii = str.indexOf(".");
      if (ii < 0) {
        str += ".";
      }
      return str;
    }
  };
  var UpDownScanLight_default = UpDownScanLight;

  // Source/custom/lighteffect/Wave3dTileLight.js
  var Wave3dTileLight = class {
    static createWave3dTileLight(options) {
      let wave3dTileLight = new Wave3dTileLight(options);
      ;
      return wave3dTileLight;
    }
    constructor(options) {
      this.viewer = options.viewer || window.viewer;
      this.positions = options.positions;
      this.center = options.center;
      this.radius = options.radius;
      if (this.center && this.radius > 0) {
        this.positions = this.computeEllipsePosition_prs(this.center, this.radius, 270, -90);
      }
      this.color = options.color || Cesium.Color.RED;
      this.direction = options.direction || -1;
      this.speed = options.speed || 1e3;
      this.repeat = options.count || 3;
      this.scanCenter = options.scanCenter;
      if (!Cesium.defined(options.scanCenter)) {
        this.scanCenter = new Cesium.Cartesian2(0.5, 0.5);
      } else {
        this.scanCenter = computeScanTextureCoordAndRate(options.scanCenter, this.positions).tc;
      }
      this.showLine = options.showLine || false;
      this.lineWidth = options.lineWidth || 4;
      this.lineColor = options.lineColor || new Cesium.Color(1, 1, 0, 0.5);
      this.offset = 0;
      this.update();
    }
    draw() {
      let ppxxx = new Cesium.PolygonGeometry({
        polygonHierarchy: new Cesium.PolygonHierarchy(this.positions)
      });
      let gi = new Cesium.GeometryInstance({
        geometry: ppxxx
      });
      this.primitive = new Cesium.GroundPrimitive({
        geometryInstances: [gi],
        appearance: new Cesium.EllipsoidSurfaceAppearance({
          material: new Cesium.Material({
            fabric: {
              uniforms: {
                color: this.color,
                repeat: this.repeat * 2,
                u_radius: this.radius,
                speed: this.speed,
                scanCenter: this.scanCenter,
                direction: this.direction
              },
              source: this.createPolygonScanShader()
            }
          })
        }),
        asynchronous: false
      });
      this.viewer.scene.primitives.add(this.primitive);
    }
    drawLine() {
      let ppxxx = new Cesium.GroundPolylineGeometry({
        positions: this.positions,
        width: this.lineWidth,
        loop: true
      });
      let gi = new Cesium.GeometryInstance({
        geometry: ppxxx
      });
      this.primitive1 = new Cesium.GroundPolylinePrimitive({
        geometryInstances: [gi],
        appearance: new Cesium.EllipsoidSurfaceAppearance({
          material: new Cesium.Material({
            fabric: {
              type: "Color",
              uniforms: {
                color: this.lineColor
              }
            }
          })
        }),
        asynchronous: false
      });
      this.viewer.scene.primitives.add(this.primitive1);
    }
    update() {
      this.destroyPrimitive();
      this.draw();
      if (this.showLine)
        this.drawLine();
    }
    destroyPrimitive() {
      if (this.primitive)
        this.viewer.scene.primitives.remove(this.primitive);
      if (this.primitive1)
        this.viewer.scene.primitives.remove(this.primitive1);
    }
    destroy() {
      this.destroyPrimitive();
      for (let i in this) {
        delete this[i];
      }
    }
    createPolygonScanShader() {
      return `
              uniform vec4 color;
              uniform float repeat;
              //uniform float offset;
              uniform float u_radius;
              //uniform float thickness;
              uniform float speed;
              uniform vec2 scanCenter;
               uniform float direction;
              czm_material czm_getMaterial(czm_materialInput materialInput)
              {
                  czm_material material = czm_getDefaultMaterial(materialInput);
                  vec4 color1 = vec4(color.rgb,0.);
                  vec2 st = materialInput.st - vec2(0.5,0.5);
                  float tf = sqrt(2.);
                  float radius = u_radius;
                  float rate = 1. * tf / repeat;
                  float time = fract(czm_frameNumber / speed) * direction;
                  
                  float rr =   radius * time  ;
                  float ring = rate * radius;
                  float dis = length(st) * radius * tf;
                  float f = (dis - rr /tf ) / ring;//\u7531\u4E8Edis\u53EA\u67090-0.5\uFF0C\u800C\u767D\u819Cdis\u4E3A0-1\uFF0C\u6240\u4EE5time\u5FC5\u987B\u9664\u4EE52.
                  float ff = fract(f);
                  if( ff < rate ){
                    color1.a = 1. - ff / rate;
                  }
                  material.diffuse = color1.rgb;
                  material.alpha = color1.a;
                  return material;
              }
          `;
    }
    computeScanTextureCoordAndRate(scanCenter, points) {
      let mm = this.computeMinMaxCoords(points);
      let sc = this.carte2carto_prs(scanCenter);
      let tc = new Cesium.Cartesian2();
      tc.x = (sc.longitude - mm[0]) / (mm[2] - mm[0]);
      tc.y = (sc.latitude - mm[1]) / (mm[3] - mm[1]);
      let rate = (mm[2] - mm[0]) / (mm[3] - mm[1]);
      return {
        tc,
        rate
      };
    }
    computeEllipsePosition_prs(center2, radius, fromA, toA, inlength) {
      let res = [];
      let length2 = inlength || 360;
      let interval = (toA - fromA) * Math.PI / 180 / length2;
      let startA = fromA * Math.PI / 180;
      let mm = Cesium.Transforms.eastNorthUpToFixedFrame(center2);
      for (let i = 0; i < length2; i++) {
        let a2 = startA + interval * i;
        let p = new Cesium.Cartesian3(Math.sin(a2) * radius, Math.cos(a2) * radius, 0);
        res.push(Cesium.Matrix4.multiplyByPoint(mm, p, new Cesium.Cartesian3()));
      }
      return res;
    }
    computeMinMaxCoords(points) {
      let minX = Number.MAX_VALUE;
      let minY = Number.MAX_VALUE;
      let maxX = Number.MIN_VALUE;
      let maxY = Number.MIN_VALUE;
      let p = null;
      let x3 = null;
      let y3 = null;
      for (let i in points) {
        p = this.carte2carto_prs(points[i]);
        x3 = p.longitude;
        y3 = p.latitude;
        if (x3 < minX) {
          minX = x3;
        }
        if (x3 > maxX) {
          maxX = x3;
        }
        if (y3 < minY) {
          minY = y3;
        }
        if (y3 > maxY) {
          maxY = y3;
        }
      }
      return [minX, minY, maxX, maxY];
    }
    carte2carto_prs(p) {
      return Cesium.Cartographic.fromCartesian(p);
    }
  };
  var Wave3dTileLight_default = Wave3dTileLight;

  // Source/custom/lighteffect/WaveLight.js
  var WaveLight = class extends Light_default {
    constructor() {
      super();
      this.type = "WaveLight";
    }
    updateLightArray() {
    }
    getGlobeSurfaceShader() {
      return {
        vertexShaderSource: Cesium.ShaderSource.replaceMain(this.getGlobeSurfaceVS(), this.type),
        fragmentShaderSource: Cesium.ShaderSource.replaceMain(this.getFs(), this.type)
      };
    }
    getPolygonColorPrimitiveShader() {
      return {
        vertexShaderSource: Cesium.ShaderSource.replaceMain(this.getPolygonColorPrimitiveVs(), this.type),
        fragmentShaderSource: Cesium.ShaderSource.replaceMain(this.getFs(), this.type)
      };
    }
    getGlobeSurfaceVS() {
      return `
          varying vec3 v_xh_position1;
          void main(){
            #ifdef QUANTIZATION_BITS12
                vec2 xy = czm_decompressTextureCoordinates(compressed0.x);
                vec2 zh = czm_decompressTextureCoordinates(compressed0.y);
                vec3 position = vec3(xy, zh.x);
                float height = zh.y;
                vec2 textureCoordinates = czm_decompressTextureCoordinates(compressed0.z);
            
                height = height * (u_minMaxHeight.y - u_minMaxHeight.x) + u_minMaxHeight.x;
                position = (u_scaleAndBias * vec4(position, 1.0)).xyz;
            #else
                // A single float per element
                vec3 position = position3DAndHeight.xyz;
            #endif
                v_xh_position1 = position + u_center3D;
          }
          `;
    }
    getPolygonColorPrimitiveVs() {
      return "varying vec3 v_xh_position1;\nvoid main(){\n v_xh_position1 = position3DHigh + position3DLow;\n}\n";
    }
    getFs() {
      let header = "varying vec3 v_xh_position1;\n";
      let scanShader = "";
      for (let i in this.lightMap) {
        let polygon2 = this.lightMap[i].polygon || [new Cesium.Cartesian3()];
        let center2 = this.lightMap[i].position;
        let speed = this.lightMap[i].speed || 600;
        let ringCount = this.lightMap[i].count || 3;
        let scanDirection = this.lightMap[i].direction || -1;
        let scanColor = this.lightMap[i].color || new Cesium.Color(0.3, 0.5, 0.8, 1);
        let isCircle = this.lightMap[i].isCircle || 1;
        let maxRadius = this.lightMap[i].radius || 0;
        if (this.lightMap[i].polygon)
          isCircle = -1;
        let enu_mat = Cesium.Transforms.eastNorthUpToFixedFrame(center2);
        let ienu_mat = Cesium.Matrix4.inverse(enu_mat, new Cesium.Matrix4());
        let ienu_Shader = "mat4 ienu_mat = mat4(" + ienu_mat[0].toFixed(15) + "," + ienu_mat[1].toFixed(15) + "," + ienu_mat[2].toFixed(15) + "," + ienu_mat[3].toFixed(15) + "," + ienu_mat[4].toFixed(15) + "," + ienu_mat[5].toFixed(15) + "," + ienu_mat[6].toFixed(15) + "," + ienu_mat[7].toFixed(15) + "," + ienu_mat[8].toFixed(15) + "," + ienu_mat[9].toFixed(15) + "," + ienu_mat[10].toFixed(15) + "," + ienu_mat[11].toFixed(15) + "," + ienu_mat[12].toFixed(15) + "," + ienu_mat[13].toFixed(15) + "," + ienu_mat[14].toFixed(15) + "," + ienu_mat[15].toFixed(15) + ");\n";
        scanShader += "int isInPolygonCircle" + i + "(vec2 checkPoint, vec2 polygonPoints[" + polygon2.length + "]) {\n    int counter = 0;\n    float xinters;\n    vec2 p1;\n    vec2 p2;\n    const int pointCount = " + polygon2.length + ";\n    p1 = polygonPoints[0];\n	\n    for (int i = 1; i < pointCount; i++) {\n        p2 = polygonPoints[i ];\n        if (checkPoint.x > min(p1.x, p2.x) && checkPoint.x <= max(p1.x, p2.x)) {\n            if (checkPoint.y <= max(p1.y, p2.y)) {\n                if (p1.x != p2.x) {\n                    xinters = (checkPoint.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y;\n                    if (p1.y == p2.y || checkPoint.y <= xinters) {\n                        counter++;\n                    }\n                }\n            }\n        }\n        p1 = p2;\n    }\n    float f = float(counter) / 2.;\n    float ff = f - floor(f);\n    if(ff > 0.000001)\n       return 1;\n    else\n       return 0;\n}\n";
        scanShader += "void circleScan" + i + "(){\n";
        scanShader += ienu_Shader;
        scanShader += "vec2 scan_polygon[" + polygon2.length + "];\n";
        for (let i2 in polygon2) {
          let p = Cesium.Matrix4.multiplyByPoint(ienu_mat, polygon2[i2], new Cesium.Cartesian3());
          scanShader += "scan_polygon[" + i2 + "] = vec2(" + p.x.toFixed(5) + "," + p.y.toFixed(5) + ");\n";
        }
        scanShader += "int isCircle = " + isCircle + ";\n";
        scanShader += "float speed = " + speed.toFixed(5) + ";\n";
        scanShader += "float rate = 1. / " + ringCount.toFixed(5) + ";\n";
        scanShader += "float radius = " + maxRadius.toFixed(5) + ";\n";
        scanShader += "float direction =  " + scanDirection.toFixed(5) + ";\n";
        scanShader += "vec3 color =  vec3(" + scanColor.red.toFixed(5) + "," + scanColor.green.toFixed(5) + "," + scanColor.blue.toFixed(5) + ");\n";
        scanShader += " vec4 tpoint = ienu_mat * vec4(v_xh_position1 ,1.);\n tpoint /= tpoint.w;\n vec2 txy = tpoint.xy;\n int f = 0;\n if(isCircle == 1)\n   f = 1;\n else   f = isInPolygonCircle" + i + "( txy, scan_polygon );\n if(f == 1){\n   float time = fract(czm_frameNumber / speed) * direction;\n   float rr = radius * time;\n   float ring = rate * radius;\n   float dis = length(txy);\n   float f = abs(dis - rr) /ring;\n   float ff = fract(f);\n   if(dis < radius  &&ff < rate){\n     float ta = ff / rate ;\n     gl_FragColor.rgb = mix(color,gl_FragColor.rgb,ta);\n   }\n }\n}\n";
      }
      let endShader = "void main(){\n";
      for (let i in this.lightMap) {
        endShader += "  circleScan" + i + "();\n";
      }
      endShader += "}\n";
      return header + scanShader + endShader;
    }
  };
  var WaveLight_default = WaveLight;

  // Source/custom/mapbox/Browser.js
  var now = function() {
    if (window.performance && window.performance.now) {
      return window.performance.now.bind(window.performance);
    } else {
      return Date.now.bind(Date);
    }
  }();
  var frameFn = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
  var frame = function(fn) {
    return frameFn(fn);
  };
  var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
  var cancelFrame = function(id) {
    cancel(id);
  };
  var timed = function(fn, dur, ctx) {
    if (!dur) {
      fn.call(ctx, 1);
      return null;
    }
    let abort = false;
    const start2 = now();
    function tick(now1) {
      if (abort)
        return;
      now1 = now();
      if (now1 >= start2 + dur) {
        fn.call(ctx, 1);
      } else {
        fn.call(ctx, (now1 - start2) / dur);
        frame(tick);
      }
    }
    frame(tick);
    return function() {
      abort = true;
    };
  };
  var getImageData = function(img) {
    const canvas = window.document.createElement("canvas");
    const context = canvas.getContext("2d");
    canvas.width = img.width;
    canvas.height = img.height;
    context.drawImage(img, 0, 0, img.width, img.height);
    return context.getImageData(0, 0, img.width, img.height);
  };
  var createPowerOfTwoImageFromImage = function(image) {
    if (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height)) {
      var canvas = window.document.createElement("canvas");
      canvas.width = nextHighestPowerOfTwo(image.width);
      canvas.height = nextHighestPowerOfTwo(image.height);
      var ctx = canvas.getContext("2d");
      ctx.drawImage(image, 0, 0, image.width, image.height);
      image = canvas;
    }
    return image;
  };
  function isPowerOfTwo(x3) {
    return (x3 & x3 - 1) == 0;
  }
  function nextHighestPowerOfTwo(x3) {
    --x3;
    for (var i = 1; i < 32; i <<= 1) {
      x3 = x3 | x3 >> i;
    }
    return x3 + 1;
  }
  var hardwareConcurrency = window.navigator.hardwareConcurrency || 4;
  var devicePixelRatio = window.devicePixelRatio;
  var supportsWebp = false;
  var webpImgTest = window.document.createElement("img");
  webpImgTest.onload = function() {
    supportsWebp = true;
  };
  webpImgTest.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=";
  var Browser_default = {
    now,
    frame,
    cancelFrame,
    timed,
    getImageData,
    createPowerOfTwoImageFromImage,
    hardwareConcurrency,
    supportsWebp,
    devicePixelRatio
  };

  // Source/custom/mapbox/gl-matrix.js
  function create() {
    var out = new Float32Array(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  function transformMat3(out, a2, m) {
    var x3 = a2[0], y3 = a2[1], z2 = a2[2];
    out[0] = x3 * m[0] + y3 * m[3] + z2 * m[6];
    out[1] = x3 * m[1] + y3 * m[4] + z2 * m[7];
    out[2] = x3 * m[2] + y3 * m[5] + z2 * m[8];
    return out;
  }
  var vec = create();
  function create$1() {
    var out = new Float32Array(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
  }
  function transformMat4$1(out, a2, m) {
    var x3 = a2[0], y3 = a2[1], z2 = a2[2], w = a2[3];
    out[0] = m[0] * x3 + m[4] * y3 + m[8] * z2 + m[12] * w;
    out[1] = m[1] * x3 + m[5] * y3 + m[9] * z2 + m[13] * w;
    out[2] = m[2] * x3 + m[6] * y3 + m[10] * z2 + m[14] * w;
    out[3] = m[3] * x3 + m[7] * y3 + m[11] * z2 + m[15] * w;
    return out;
  }
  var vec$1 = create$1();
  function create$2() {
    var out = new Float32Array(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function rotate(out, a2, rad) {
    var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3], s = Math.sin(rad), c = Math.cos(rad);
    out[0] = a0 * c + a22 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a22 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
  }
  function scale$2(out, a2, v) {
    var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3], v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a22 * v1;
    out[3] = a3 * v1;
    return out;
  }
  function create$3() {
    var out = new Float32Array(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromRotation$1(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function create$4() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function identity$2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function invert$2(out, a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3], a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7], a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11], a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function multiply$4(out, a2, b) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3], a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7], a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11], a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate$1(out, a2, v) {
    var x3 = v[0], y3 = v[1], z2 = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
    if (a2 === out) {
      out[12] = a2[0] * x3 + a2[4] * y3 + a2[8] * z2 + a2[12];
      out[13] = a2[1] * x3 + a2[5] * y3 + a2[9] * z2 + a2[13];
      out[14] = a2[2] * x3 + a2[6] * y3 + a2[10] * z2 + a2[14];
      out[15] = a2[3] * x3 + a2[7] * y3 + a2[11] * z2 + a2[15];
    } else {
      a00 = a2[0];
      a01 = a2[1];
      a02 = a2[2];
      a03 = a2[3];
      a10 = a2[4];
      a11 = a2[5];
      a12 = a2[6];
      a13 = a2[7];
      a20 = a2[8];
      a21 = a2[9];
      a22 = a2[10];
      a23 = a2[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x3 + a10 * y3 + a20 * z2 + a2[12];
      out[13] = a01 * x3 + a11 * y3 + a21 * z2 + a2[13];
      out[14] = a02 * x3 + a12 * y3 + a22 * z2 + a2[14];
      out[15] = a03 * x3 + a13 * y3 + a23 * z2 + a2[15];
    }
    return out;
  }
  function scale$4(out, a2, v) {
    var x3 = v[0], y3 = v[1], z2 = v[2];
    out[0] = a2[0] * x3;
    out[1] = a2[1] * x3;
    out[2] = a2[2] * x3;
    out[3] = a2[3] * x3;
    out[4] = a2[4] * y3;
    out[5] = a2[5] * y3;
    out[6] = a2[6] * y3;
    out[7] = a2[7] * y3;
    out[8] = a2[8] * z2;
    out[9] = a2[9] * z2;
    out[10] = a2[10] * z2;
    out[11] = a2[11] * z2;
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
    return out;
  }
  function rotateX$1(out, a2, rad) {
    var s = Math.sin(rad), c = Math.cos(rad), a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7], a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    if (a2 !== out) {
      out[0] = a2[0];
      out[1] = a2[1];
      out[2] = a2[2];
      out[3] = a2[3];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  function rotateY$1(out, a2, rad) {
    var s = Math.sin(rad), c = Math.cos(rad), a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3], a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    if (a2 !== out) {
      out[4] = a2[4];
      out[5] = a2[5];
      out[6] = a2[6];
      out[7] = a2[7];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  function rotateZ$1(out, a2, rad) {
    var s = Math.sin(rad), c = Math.cos(rad), a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3], a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    if (a2 !== out) {
      out[8] = a2[8];
      out[9] = a2[9];
      out[10] = a2[10];
      out[11] = a2[11];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  function perspective(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = 2 * far * near * nf;
    out[15] = 0;
    return out;
  }
  function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  function lookAt(out, eye, center2, up) {
    var x02, x12, x22, y02, y12, y22, z0, z1, z2, len, eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center2[0], centery = center2[1], centerz = center2[2];
    if (Math.abs(eyex - centerx) === 0 && Math.abs(eyey - centery) === 0 && Math.abs(eyez - centerz) === 0) {
      return identity(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x02 = upy * z2 - upz * z1;
    x12 = upz * z0 - upx * z2;
    x22 = upx * z1 - upy * z0;
    len = Math.sqrt(x02 * x02 + x12 * x12 + x22 * x22);
    if (!len) {
      x02 = 0;
      x12 = 0;
      x22 = 0;
    } else {
      len = 1 / len;
      x02 *= len;
      x12 *= len;
      x22 *= len;
    }
    y02 = z1 * x22 - z2 * x12;
    y12 = z2 * x02 - z0 * x22;
    y22 = z0 * x12 - z1 * x02;
    len = Math.sqrt(y02 * y02 + y12 * y12 + y22 * y22);
    if (!len) {
      y02 = 0;
      y12 = 0;
      y22 = 0;
    } else {
      len = 1 / len;
      y02 *= len;
      y12 *= len;
      y22 *= len;
    }
    out[0] = x02;
    out[1] = y02;
    out[2] = z0;
    out[3] = 0;
    out[4] = x12;
    out[5] = y12;
    out[6] = z1;
    out[7] = 0;
    out[8] = x22;
    out[9] = y22;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x02 * eyex + x12 * eyey + x22 * eyez);
    out[13] = -(y02 * eyex + y12 * eyey + y22 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  function fromRotationTranslationScale(out, q, v, s) {
    var x3 = q[0], y3 = q[1], z2 = q[2], w = q[3], x22 = x3 + x3, y22 = y3 + y3, z22 = z2 + z2, xx = x3 * x22, xy = x3 * y22, xz = x3 * z22, yy = y3 * y22, yz = y3 * z22, zz = z2 * z22, wx = w * x22, wy = w * y22, wz = w * z22, sx = s[0], sy = s[1], sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromMat4(out, a2) {
    out[0] = a2[0];
    out[1] = a2[1];
    out[2] = a2[2];
    out[3] = a2[4];
    out[4] = a2[5];
    out[5] = a2[6];
    out[6] = a2[8];
    out[7] = a2[9];
    out[8] = a2[10];
    return out;
  }
  function transpose(out, a2) {
    if (out === a2) {
      var a01 = a2[1], a02 = a2[2], a12 = a2[5];
      out[1] = a2[3];
      out[2] = a2[6];
      out[3] = a01;
      out[5] = a2[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a2[0];
      out[1] = a2[3];
      out[2] = a2[6];
      out[3] = a2[1];
      out[4] = a2[4];
      out[5] = a2[7];
      out[6] = a2[2];
      out[7] = a2[5];
      out[8] = a2[8];
    }
    return out;
  }
  function invert(out, a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], b01 = a22 * a11 - a12 * a21, b11 = -a22 * a10 + a12 * a20, b21 = a21 * a10 - a11 * a20, det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function clone(a2) {
    var out = new Float32Array(16);
    out[0] = a2[0];
    out[1] = a2[1];
    out[2] = a2[2];
    out[3] = a2[3];
    out[4] = a2[4];
    out[5] = a2[5];
    out[6] = a2[6];
    out[7] = a2[7];
    out[8] = a2[8];
    out[9] = a2[9];
    out[10] = a2[10];
    out[11] = a2[11];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
    return out;
  }
  var glMatrix = {
    vec3: {
      transformMat3
    },
    vec4: {
      transformMat4: transformMat4$1
    },
    mat2: {
      create: create$2,
      rotate,
      scale: scale$2
    },
    mat3: {
      create: create$3,
      fromRotation: fromRotation$1,
      fromMat4,
      transpose,
      invert
    },
    mat4: {
      create: create$4,
      identity: identity$2,
      translate: translate$1,
      scale: scale$4,
      multiply: multiply$4,
      perspective,
      rotateX: rotateX$1,
      rotateY: rotateY$1,
      rotateZ: rotateZ$1,
      invert: invert$2,
      ortho,
      lookAt,
      fromRotationTranslationScale,
      clone
    }
  };
  var gl_matrix_default = glMatrix;

  // Source/custom/mapbox/MapboxTexture.js
  var { HTMLImageElement, HTMLCanvasElement, HTMLVideoElement: HTMLVideoElement2, ImageData } = window;
  var MapboxTexture = class {
    constructor(gl, image, format, options) {
      this.gl = gl;
      this.format = format;
      this.texture = gl.createTexture();
      this.update(image, options);
    }
    update(image, options, position) {
      const { width, height } = image;
      const resize = (!this.size || this.size[0] !== width || this.size[1] !== height) && !position;
      const gl = this.gl;
      this.useMipmap = Boolean(options && options.useMipmap);
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.format === gl.RGBA && (!options || options.premultiply !== false));
      if (resize) {
        this.size = [width, height];
        if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement2 || image instanceof ImageData) {
          gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, gl.UNSIGNED_BYTE, image);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, gl.UNSIGNED_BYTE, image.data);
        }
      } else {
        const { x: x3, y: y3 } = position || { x: 0, y: 0 };
        if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement2 || image instanceof ImageData) {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, x3, y3, gl.RGBA, gl.UNSIGNED_BYTE, image);
        } else {
          gl.texSubImage2D(gl.TEXTURE_2D, 0, x3, y3, width, height, gl.RGBA, gl.UNSIGNED_BYTE, image.data);
        }
      }
      if (this.useMipmap && this.isSizePowerOfTwo()) {
        gl.generateMipmap(gl.TEXTURE_2D);
      }
    }
    bind(filter, wrap, minFilter) {
      const gl = this.gl;
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      if (minFilter === gl.LINEAR_MIPMAP_NEAREST && !this.isSizePowerOfTwo()) {
        minFilter = gl.LINEAR;
      }
      if (filter !== this.filter) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter || filter);
        this.filter = filter;
      }
      if (wrap !== this.wrap) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);
        this.wrap = wrap;
      }
    }
    isSizePowerOfTwo() {
      return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 === 0;
    }
    destroy() {
      this.gl.deleteTexture(this.texture);
      this.texture = null;
    }
  };
  var MapboxTexture_default = MapboxTexture;

  // Source/custom/mapbox/RasterBoundsArray.js
  var createStructArrayType = Cesium.StructArray;
  var RasterBoundsArray = createStructArrayType({
    members: [
      { name: "a_pos", type: "Float32", components: 2 },
      { name: "a_texture_pos", type: "Int16", components: 2 },
      { name: "a_data", components: 2, type: "Int16" }
    ]
  });
  var RasterBoundsArray_default = RasterBoundsArray;

  // Source/custom/mapbox/RGBAImage.js
  function createImage(image, { width, height }, channels, data) {
    if (!data) {
      data = new Uint8Array(width * height * channels);
    } else if (data.length !== width * height * channels) {
      throw new RangeError("mismatched image size");
    }
    image.width = width;
    image.height = height;
    image.data = data;
    return image;
  }
  function resizeImage(image, { width, height }, channels) {
    if (width === image.width && height === image.height) {
      return;
    }
    const newImage = createImage({}, { width, height }, channels);
    copyImage(image, newImage, { x: 0, y: 0 }, { x: 0, y: 0 }, {
      width: Math.min(image.width, width),
      height: Math.min(image.height, height)
    }, channels);
    image.width = width;
    image.height = height;
    image.data = newImage.data;
  }
  function copyImage(srcImg, dstImg, srcPt, dstPt, size, channels) {
    if (size.width === 0 || size.height === 0) {
      return dstImg;
    }
    if (size.width > srcImg.width || size.height > srcImg.height || srcPt.x > srcImg.width - size.width || srcPt.y > srcImg.height - size.height) {
      throw new RangeError("out of range source coordinates for image copy");
    }
    if (size.width > dstImg.width || size.height > dstImg.height || dstPt.x > dstImg.width - size.width || dstPt.y > dstImg.height - size.height) {
      throw new RangeError("out of range destination coordinates for image copy");
    }
    const srcData = srcImg.data;
    const dstData = dstImg.data;
    for (let y3 = 0; y3 < size.height; y3++) {
      const srcOffset = ((srcPt.y + y3) * srcImg.width + srcPt.x) * channels;
      const dstOffset = ((dstPt.y + y3) * dstImg.width + dstPt.x) * channels;
      for (let i = 0; i < size.width * channels; i++) {
        dstData[dstOffset + i] = srcData[srcOffset + i];
      }
    }
    return dstImg;
  }
  var RGBAImage = class {
    constructor(size, data) {
      createImage(this, size, 4, data);
    }
    resize(size) {
      resizeImage(this, size, 4);
    }
    clone() {
      return new RGBAImage({ width: this.width, height: this.height }, new Uint8Array(this.data));
    }
    static copy(srcImg, dstImg, srcPt, dstPt, size) {
      copyImage(srcImg, dstImg, srcPt, dstPt, size, 4);
    }
    serialize(transferables) {
      if (this.data) {
        transferables.push(this.data.buffer);
        return {
          data: this.data,
          width: this.width,
          height: this.height
        };
      }
    }
  };
  var RGBAImage_default = RGBAImage;

  // Source/custom/mapbox/VertexArrayObject.js
  var VertexArrayObject = class {
    constructor() {
      this.boundProgram = null;
      this.boundVertexBuffer = null;
      this.boundVertexBuffer2 = null;
      this.boundElementBuffer = null;
      this.boundVertexOffset = null;
      this.vao = null;
    }
    bind(gl, program, layoutVertexBuffer, elementBuffer, vertexBuffer2, vertexOffset) {
      if (gl.extVertexArrayObject === void 0) {
        gl.extVertexArrayObject = gl.getExtension("OES_vertex_array_object");
      }
      const isFreshBindRequired = !this.vao || this.boundProgram !== program || this.boundVertexBuffer !== layoutVertexBuffer || this.boundVertexBuffer2 !== vertexBuffer2 || this.boundElementBuffer !== elementBuffer || this.boundVertexOffset !== vertexOffset;
      if (!gl.extVertexArrayObject || isFreshBindRequired) {
        this.freshBind(gl, program, layoutVertexBuffer, elementBuffer, vertexBuffer2, vertexOffset);
        this.gl = gl;
      } else {
        gl.extVertexArrayObject.bindVertexArrayOES(this.vao);
      }
    }
    freshBind(gl, program, layoutVertexBuffer, elementBuffer, vertexBuffer2, vertexOffset) {
      let numPrevAttributes;
      const numNextAttributes = program.numAttributes;
      if (gl.extVertexArrayObject) {
        if (this.vao)
          this.destroy();
        this.vao = gl.extVertexArrayObject.createVertexArrayOES();
        gl.extVertexArrayObject.bindVertexArrayOES(this.vao);
        numPrevAttributes = 0;
        this.boundProgram = program;
        this.boundVertexBuffer = layoutVertexBuffer;
        this.boundVertexBuffer2 = vertexBuffer2;
        this.boundElementBuffer = elementBuffer;
        this.boundVertexOffset = vertexOffset;
      } else {
        numPrevAttributes = gl.currentNumAttributes || 0;
        for (let i = numNextAttributes; i < numPrevAttributes; i++) {
          gl.disableVertexAttribArray(i);
        }
      }
      layoutVertexBuffer.enableAttributes(gl, program);
      if (vertexBuffer2) {
        vertexBuffer2.enableAttributes(gl, program);
      }
      layoutVertexBuffer.bind(gl);
      layoutVertexBuffer.setVertexAttribPointers(gl, program, vertexOffset);
      if (vertexBuffer2) {
        vertexBuffer2.bind(gl);
        vertexBuffer2.setVertexAttribPointers(gl, program, vertexOffset);
      }
      if (elementBuffer) {
        elementBuffer.bind(gl);
      }
      layoutVertexBuffer.isenableAttributes = true;
      gl.currentNumAttributes = numNextAttributes;
    }
    destroy() {
      if (this.vao) {
        this.gl.extVertexArrayObject.deleteVertexArrayOES(this.vao);
        this.vao = null;
      }
    }
  };
  var VertexArrayObject_default = VertexArrayObject;

  // Source/custom/overlay/Overlay.js
  window.Cesium.Viewer.prototype.addOverlay = function(overlay) {
    overlay.setViewer(this);
    this._container.appendChild(overlay.element);
  };
  var Overlay = function(opt) {
    opt = opt || {};
    var _self = this;
    this.id = opt.id;
    this.element = opt.element;
    this.position = opt.position;
    this.offset = opt.offset;
    this.scratch = new Cesium.Cartesian2();
    this._viewer = null;
    this.setViewer = function(viewer3) {
      this._viewer = viewer3;
      _self._viewer.scene.preRender.addEventListener(_self.update);
    };
    this.getViewer = function() {
      return _self._viewer;
    };
    this.updatePosition = function() {
      if (!_self.position) {
        _self.close();
        return;
      }
      if (!_self.getViewer()) {
        return;
      }
      var canvasPosition = Cesium.SceneTransforms.wgs84ToWindowCoordinates(_self.getViewer().scene, _self.position);
      if (Cesium.defined(canvasPosition)) {
        if (_self.offset) {
          _self.element.style.top = canvasPosition.y + _self.offset.y + "px";
          _self.element.style.left = canvasPosition.x + _self.offset.x + "px";
        } else {
          _self.element.style.top = canvasPosition.y + "px";
          _self.element.style.left = canvasPosition.x + "px";
        }
        _self.show();
      }
    };
    this.update = function() {
      if (_self.element.style.display !== "none") {
        _self.updatePosition();
      }
    };
    this.getPosition = function() {
    };
    this.close = function() {
      _self.element.style.display = "none";
    };
    this.show = function() {
      _self.element.style.display = "block";
    };
    this.destroy = function() {
      _self._viewer.scene.preRender.removeEventListener(_self.update);
      if (_self.element.parentNode) {
        _self._viewer._container.removeChild(_self.element);
        _self.close();
      }
    };
    this.setPosition = function(position) {
      _self.position = position;
    };
  };
  var Overlay_default = Overlay;

  // Source/custom/reflectWater/ReflectWater.js
  var WaterMaterialSource = `
uniform sampler2D texture;
uniform sampler2D normalTexture;
uniform float time;
uniform mat4 fixedFrameToEastNorthUpTransform;

varying vec4 v_worldPosition;
varying vec4 v_uv;

// \u53EF\u914D\u7F6E\u7684\u53C2\u6570
uniform float size; // \u6CE2\u7EB9\u5927\u5C0F\uFF08\u6570\u503C\u8D8A\u5927\u6CE2\u7EB9\u8D8A\u5BC6\u96C6\uFF09
uniform vec4 waterColor; // \u6C34\u9762\u989C\u8272
uniform float waterAlpha; // \u6C34\u9762\u900F\u660E\u5EA6
uniform float rf0; // \u6C34\u9762\u53CD\u5C04\u7387
uniform vec3 lightDirection; // \u5149\u7167\u65B9\u5411
uniform float sunShiny; // \u5149\u7167\u5F3A\u5EA6
uniform float distortionScale; // \u5012\u5F71\u7684\u626D\u66F2\u7A0B\u5EA6

vec3 sunDirection = normalize( lightDirection );
vec3 sunColor = vec3( 1.0 );


// \u83B7\u53D6\u566A\u58F0
vec4 getNoise( sampler2D normalMap, vec2 uv ) {
    vec2 uv0 = ( uv / 103.0 ) + vec2( time / 17.0, time / 29.0 );
    vec2 uv1 = uv / 107.0 - vec2( time / -19.0, time / 31.0 );
    vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
    vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
    vec4 noise = texture2D( normalMap, uv0 ) +
        texture2D( normalMap, uv1 ) +
        texture2D( normalMap, uv2 ) +
        texture2D( normalMap, uv3 );
    return noise * 0.5 - 1.0;
}

void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {
    vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) ); 
    float direction = max( 0.0, dot( eyeDirection, reflection ) ); 
    specularColor += pow( direction, shiny ) * sunColor * spec;
    diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
}

czm_material czm_getMaterial(czm_materialInput materialInput) {
    czm_material material = czm_getDefaultMaterial(materialInput);

    vec2 transformedSt = materialInput.st * 2.0 - 1.0;  // [0, 1] => [-1, 1]
    vec4 noise = getNoise( normalTexture, transformedSt * size );
    vec3 surfaceNormal = normalize( noise.xzy );  // [0, +1]\uFF0CY up

    vec3 diffuseLight = vec3( 0.0 );
    vec3 specularLight = vec3( 0.0 );

    vec3 eye = ( czm_inverseView * vec4( vec3(0.0), 1.0 ) ).xyz;
    eye = ( fixedFrameToEastNorthUpTransform * vec4( eye, 1.0) ).xyz;
    vec3 world = ( fixedFrameToEastNorthUpTransform * vec4( v_worldPosition.xyz, 1.0) ).xyz;

    vec3 worldToEye = eye - world;  // east, north, up
    worldToEye = vec3( worldToEye.x, worldToEye.z, -worldToEye.y );  // Y up
    vec3 eyeDirection = normalize( worldToEye );

    float shiny = sunShiny;
    float spec = 2.0;
    float diffuse = 0.5;
    sunLight( surfaceNormal, eyeDirection, shiny, spec, diffuse, diffuseLight, specularLight );

    float distance = length( worldToEye );
    float distortionScale = distortionScale;
    vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
    vec3 reflectionSample = vec3( texture2D( texture, (v_uv.xy / v_uv.w) * 0.5 + 0.5 + distortion ) );

    float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
    float rf0 = rf0;
    float reflectance = mix( rf0, 1.0, pow( 1.0 - theta, 5.0 ) );

    vec3 waterColor = waterColor.rgb;

    vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;
    vec3 albedo = mix(
        sunColor * diffuseLight * 0.3 + scatter,
        vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight,
        reflectance
    );
    material.diffuse = albedo.rgb;
    material.alpha = waterAlpha;

    return material;
}
`;
  var WaterAppearanceVS = `
attribute vec3 position3DHigh;
attribute vec3 position3DLow;
attribute vec3 normal;
attribute vec2 st;
attribute float batchId;

varying vec3 v_positionEC;
varying vec3 v_normalEC;
varying vec2 v_st;

uniform mat4 reflectorProjectionMatrix;
uniform mat4 reflectorViewMatrix;
uniform mat4 reflectMatrix;
varying vec4 v_worldPosition;  // \u4E16\u754C\u5750\u6807
varying vec4 v_uv;             // \u7EB9\u7406\u5750\u6807



void main()
{
    vec4 p = czm_computePosition();

    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates
    v_normalEC = czm_normal * normal;                         // normal in eye coordinates
    v_st = st;


    mat4 modelView = reflectorViewMatrix * reflectMatrix * czm_model;
    modelView[3][0] = 0.0;
    modelView[3][1] = 0.0;
    modelView[3][2] = 0.0;
    v_uv = reflectorProjectionMatrix * modelView * p;
    vec4 positionMC = vec4( position3DHigh + position3DLow, 1.0 );
    v_worldPosition = czm_model * positionMC;

    gl_Position = czm_modelViewProjectionRelativeToEye * p;
}

`;
  function createPlaceHolderTexture(context) {
    const placeholderTexture = new Cesium.Texture({
      context,
      source: {
        width: 1,
        height: 1,
        arrayBufferView: new Uint8Array([255, 0, 0, 255])
      },
      sampler: new Cesium.Sampler({
        wrapS: Cesium.TextureWrap.REPEAT,
        wrapT: Cesium.TextureWrap.REPEAT,
        minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
        magnificationFilter: Cesium.TextureMinificationFilter.LINEAR
      })
    });
    placeholderTexture.type = "sampler2D";
    return placeholderTexture;
  }
  function reflect(view, normal) {
    const scaledNormal = normal.clone();
    const reflect2 = view.clone();
    const scalar = 2 * Cesium.Cartesian3.dot(view, normal);
    Cesium.Cartesian3.multiplyByScalar(normal, scalar, scaledNormal);
    return Cesium.Cartesian3.subtract(view, scaledNormal, reflect2);
  }
  function isPowerOfTwo2(value) {
    return (value & value - 1) === 0 && value !== 0;
  }
  function addTextureUniform(options) {
    const { context, material, uniformName, imgSrc } = options;
    const wrapS = options.wrapS || Cesium.TextureWrap.REPEAT;
    const wrapT = options.wrapT || Cesium.TextureWrap.REPEAT;
    const minificationFilter = options.minificationFilter || Cesium.TextureMinificationFilter.LINEAR;
    const magnificationFilter = options.magnificationFilter || Cesium.TextureMagnificationFilter.LINEAR;
    const img = new Image();
    img.src = imgSrc;
    img.addEventListener("load", () => {
      const texture = new Cesium.Texture({
        context,
        source: img,
        sampler: new Cesium.Sampler({
          wrapS,
          wrapT,
          minificationFilter,
          magnificationFilter
        })
      });
      texture.type = "sampler2D";
      if (isPowerOfTwo2(img.width) && isPowerOfTwo2(img.height)) {
        texture.generateMipmap(Cesium.MipmapHint.NICEST);
      }
      material.uniforms[uniformName] = texture;
    });
  }
  var renderTilesetPassState = new Cesium.Cesium3DTilePassState({
    pass: Cesium.Cesium3DTilePass.RENDER
  });
  var scratchBackgroundColor = new Cesium.Color();
  function render(scene, passStateFramebuffer) {
    const frameState = scene._frameState;
    const context = scene.context;
    const us = context.uniformState;
    const view = scene._defaultView;
    scene._view = view;
    scene.updateFrameState();
    frameState.passes.render = true;
    frameState.passes.postProcess = scene.postProcessStages.hasSelected;
    frameState.tilesetPassState = renderTilesetPassState;
    let backgroundColor = Cesium.defaultValue(scene.backgroundColor, Cesium.Color.BLACK);
    if (scene._hdr) {
      backgroundColor = Cesium.Color.clone(backgroundColor, scratchBackgroundColor);
      backgroundColor.red = Math.pow(backgroundColor.red, scene.gamma);
      backgroundColor.green = Math.pow(backgroundColor.green, scene.gamma);
      backgroundColor.blue = Math.pow(backgroundColor.blue, scene.gamma);
    }
    frameState.backgroundColor = backgroundColor;
    scene.fog.update(frameState);
    us.update(frameState);
    const shadowMap = scene.shadowMap;
    if (Cesium.defined(shadowMap) && shadowMap.enabled) {
      if (!Cesium.defined(scene.light) || scene.light instanceof Cesium.SunLight) {
        Cesium.Cartesian3.negate(us.sunDirectionWC, scene._shadowMapCamera.direction);
      } else {
        Cesium.Cartesian3.clone(scene.light.direction, scene._shadowMapCamera.direction);
      }
      frameState.shadowMaps.push(shadowMap);
    }
    scene._computeCommandList.length = 0;
    scene._overlayCommandList.length = 0;
    const viewport = view.viewport;
    viewport.x = 0;
    viewport.y = 0;
    viewport.width = context.drawingBufferWidth;
    viewport.height = context.drawingBufferHeight;
    const passState = view.passState;
    passState.framebuffer = passStateFramebuffer;
    passState.blendingEnabled = void 0;
    passState.scissorTest = void 0;
    passState.viewport = Cesium.BoundingRectangle.clone(viewport, passState.viewport);
    if (Cesium.defined(scene.globe)) {
      scene.globe.beginFrame(frameState);
    }
    scene.updateEnvironment();
    scene.updateAndExecuteCommands(passState, backgroundColor);
    scene.resolveFramebuffers(passState);
    if (Cesium.defined(scene.globe)) {
      scene.globe.endFrame(frameState);
      if (!scene.globe.tilesLoaded) {
        scene._renderRequested = true;
      }
    }
    context.endFrame();
  }
  var clipBias = 0;
  var ReflectWater = class {
    constructor(viewer3, options = {}) {
      this._scene = viewer3.scene;
      if (!options.normalMapUrl) {
        return;
      }
      this._height = options.height;
      this._normalMapUrl = options.normalMapUrl;
      this._rippleSize = Cesium.defaultValue(options.rippleSize, 50);
      this._waterColor = Cesium.Color.fromCssColorString(Cesium.defaultValue(options.waterColor, "#001e0f"));
      this._waterAlpha = Cesium.defaultValue(options.waterAlpha, 0.9);
      this._reflectivity = Cesium.defaultValue(options.reflectivity, 0.3);
      this._lightDirection = Cesium.defaultValue(
        options.lightDirection,
        new Cesium.Cartesian3(0, 0, 1)
      );
      this._sunShiny = Cesium.defaultValue(options.sunShiny, 100);
      this._distortionScale = Cesium.defaultValue(options.distortionScale, 3.7);
      const flowDegrees = Cesium.defaultValue(options.flowDegrees, 0);
      const positions = options.positions;
      const total = positions.length;
      let x3 = 0;
      let y3 = 0;
      let z2 = 0;
      this._positions = [];
      positions.forEach((p) => {
        const lat = Cesium.Math.toRadians(p.y);
        const lon = Cesium.Math.toRadians(p.x);
        x3 += Math.cos(lat) * Math.cos(lon);
        y3 += Math.cos(lat) * Math.sin(lon);
        z2 += Math.sin(lat);
        this._positions.push(
          Cesium.Cartesian3.fromDegrees(p.x, p.y, this._height)
        );
      });
      x3 /= total;
      y3 /= total;
      z2 /= total;
      const centerLon = Math.atan2(y3, x3);
      const hyp = Math.sqrt(x3 * x3 + y3 * y3);
      const centerLat = Math.atan2(z2, hyp);
      this._reflectorWorldPosition = Cesium.Cartesian3.fromRadians(centerLon, centerLat, this._height);
      this._normal = Cesium.Ellipsoid.WGS84.geodeticSurfaceNormal(this._reflectorWorldPosition);
      this._waterPlane = Cesium.Plane.fromPointNormal(
        this._reflectorWorldPosition,
        this._normal
      );
      this._reflectMatrix = new Cesium.Matrix4(
        -2 * this._waterPlane.normal.x * this._waterPlane.normal.x + 1,
        -2 * this._waterPlane.normal.x * this._waterPlane.normal.y,
        -2 * this._waterPlane.normal.x * this._waterPlane.normal.z,
        -2 * this._waterPlane.normal.x * this._waterPlane.distance,
        -2 * this._waterPlane.normal.y * this._waterPlane.normal.x,
        -2 * this._waterPlane.normal.y * this._waterPlane.normal.y + 1,
        -2 * this._waterPlane.normal.y * this._waterPlane.normal.z,
        -2 * this._waterPlane.normal.y * this._waterPlane.distance,
        -2 * this._waterPlane.normal.z * this._waterPlane.normal.x,
        -2 * this._waterPlane.normal.z * this._waterPlane.normal.y,
        -2 * this._waterPlane.normal.z * this._waterPlane.normal.z + 1,
        -2 * this._waterPlane.normal.z * this._waterPlane.distance,
        0,
        0,
        0,
        1
      );
      this._reflectorViewMatrix = Cesium.Matrix4.IDENTITY.clone();
      this._reflectorProjectionMatrix = Cesium.Matrix4.IDENTITY.clone();
      this._initUniforms = {
        normalMapUrl: this._normalMapUrl,
        size: this._rippleSize,
        waterColor: this._waterColor,
        waterAlpha: this._waterAlpha,
        rf0: this._reflectivity,
        lightDirection: this._lightDirection,
        sunShiny: this._sunShiny,
        distortionScale: this._distortionScale
      };
      const context = this._scene.context;
      this._createFramebuffer(
        context,
        context.drawingBufferWidth,
        context.drawingBufferHeight,
        this._scene.highDynamicRange
      );
      this._primitive = this._createPrimitive(
        this._positions,
        this._height,
        flowDegrees
      );
      this._scene.primitives.add(this._primitive);
      this.preRender = this.preRender.bind(this);
      this._scene.preRender.addEventListener(this.preRender);
      this._scene.logarithmicDepthBuffer = false;
      Cesium.UniformState.prototype.updateFrustum = function(frustum) {
        Cesium.Matrix4.clone(
          Cesium.defaultValue(
            frustum.customProjectionMatrix,
            frustum.projectionMatrix
          ),
          this._projection
        );
        this._inverseProjectionDirty = true;
        this._viewProjectionDirty = true;
        this._inverseViewProjectionDirty = true;
        this._modelViewProjectionDirty = true;
        this._modelViewProjectionRelativeToEyeDirty = true;
        if (Cesium.defined(frustum.infiniteProjectionMatrix)) {
          Cesium.Matrix4.clone(
            frustum.infiniteProjectionMatrix,
            this._infiniteProjection
          );
          this._modelViewInfiniteProjectionDirty = true;
        }
        this._currentFrustum.x = frustum.near;
        this._currentFrustum.y = frustum.far;
        this._farDepthFromNearPlusOne = frustum.far - frustum.near + 1;
        this._log2FarDepthFromNearPlusOne = Cesium.Math.log2(
          this._farDepthFromNearPlusOne
        );
        this._oneOverLog2FarDepthFromNearPlusOne = 1 / this._log2FarDepthFromNearPlusOne;
        if (Cesium.defined(frustum._offCenterFrustum)) {
          frustum = frustum._offCenterFrustum;
        }
        this._frustumPlanes.x = frustum.top;
        this._frustumPlanes.y = frustum.bottom;
        this._frustumPlanes.z = frustum.left;
        this._frustumPlanes.w = frustum.right;
      };
      Cesium.PerspectiveFrustum.prototype.clone = function(result) {
        if (!Cesium.defined(result)) {
          result = new Cesium.PerspectiveFrustum();
        }
        result.aspectRatio = this.aspectRatio;
        result.fov = this.fov;
        result.near = this.near;
        result.far = this.far;
        result._aspectRatio = void 0;
        result._fov = void 0;
        result._near = void 0;
        result._far = void 0;
        this._offCenterFrustum.clone(result._offCenterFrustum);
        result.customProjectionMatrix = this.customProjectionMatrix;
        return result;
      };
    }
    get rippleSize() {
      return this._material.uniforms.size;
    }
    set rippleSize(value) {
      this._material.uniforms.size = value;
    }
    get waterAlpha() {
      return this._material.uniforms.waterAlpha;
    }
    set waterAlpha(value) {
      this._material.uniforms.waterAlpha = value;
    }
    get reflectivity() {
      return this._material.uniforms.rf0;
    }
    set reflectivity(value) {
      this._material.uniforms.rf0 = value;
    }
    get distortionScale() {
      return this._material.uniforms.distortionScale;
    }
    set distortionScale(value) {
      this._material.uniforms.distortionScale = value;
    }
    _createReflectionWaterMaterial() {
      const context = this._scene.context;
      const placeholderTexture = createPlaceHolderTexture(context);
      const {
        normalMapUrl,
        size,
        waterColor,
        waterAlpha,
        rf0,
        lightDirection,
        sunShiny,
        distortionScale
      } = this._initUniforms;
      const texture = Cesium.Texture.fromFramebuffer({
        context,
        framebuffer: this._colorFramebuffer
      });
      texture.type = "sampler2D";
      const initUniforms = {
        size,
        waterColor,
        waterAlpha,
        rf0,
        lightDirection,
        sunShiny,
        distortionScale,
        normalTexture: placeholderTexture,
        texture,
        time: 0,
        fixedFrameToEastNorthUpTransform: Cesium.Matrix4.toArray(
          this._getFixedFrameToEastNorthUpTransformFromWorldMatrix()
        )
      };
      const material = new Cesium.Material({
        fabric: {
          type: "ReflectionWater",
          uniforms: initUniforms,
          source: WaterMaterialSource
        },
        translucent: false,
        minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
        magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
      });
      addTextureUniform({
        context,
        material,
        uniformName: "normalTexture",
        imgSrc: normalMapUrl
      });
      return material;
    }
    _updateVirtualCamera(camera) {
      let lookAtPosition = new Cesium.Cartesian3(0, 0, -1);
      let target = new Cesium.Cartesian3();
      this._virtualCamera = Cesium.Camera.clone(
        camera,
        this._virtualCamera
      );
      const cameraWorldPosition = camera.positionWC.clone();
      let view = Cesium.Cartesian3.subtract(
        this._reflectorWorldPosition,
        cameraWorldPosition,
        new Cesium.Cartesian3()
      );
      if (Cesium.Cartesian3.dot(view, this._normal) > 0) {
        return false;
      }
      view = reflect(view, this._normal);
      Cesium.Cartesian3.negate(view, view);
      Cesium.Cartesian3.add(view, this._reflectorWorldPosition, view);
      this._virtualCamera.position = view.clone();
      Cesium.Cartesian3.add(
        camera.directionWC,
        cameraWorldPosition,
        lookAtPosition
      );
      Cesium.Cartesian3.subtract(
        this._reflectorWorldPosition,
        lookAtPosition,
        target
      );
      target = reflect(target, this._normal);
      Cesium.Cartesian3.negate(target, target);
      Cesium.Cartesian3.add(target, this._reflectorWorldPosition, target);
      this._virtualCamera.direction = Cesium.Cartesian3.subtract(
        target,
        this._virtualCamera.position,
        new Cesium.Cartesian3()
      );
      Cesium.Cartesian3.normalize(
        this._virtualCamera.direction,
        this._virtualCamera.direction
      );
      Cesium.Cartesian3.add(camera.upWC, cameraWorldPosition, lookAtPosition);
      Cesium.Cartesian3.subtract(
        this._reflectorWorldPosition,
        lookAtPosition,
        target
      );
      target = reflect(target, this._normal);
      Cesium.Cartesian3.negate(target, target);
      Cesium.Cartesian3.add(target, this._reflectorWorldPosition, target);
      this._virtualCamera.up = Cesium.Cartesian3.subtract(
        target,
        this._virtualCamera.position,
        new Cesium.Cartesian3()
      );
      Cesium.Cartesian3.normalize(this._virtualCamera.up, this._virtualCamera.up);
      this._reflectorProjectionMatrix = this._virtualCamera.frustum.projectionMatrix;
      this._reflectorViewMatrix = this._virtualCamera.viewMatrix;
      const reflectorPlane = Cesium.Plane.fromPointNormal(
        this._reflectorWorldPosition,
        this._normal
      );
      Cesium.Plane.transform(
        reflectorPlane,
        this._virtualCamera.viewMatrix,
        reflectorPlane
      );
      const clipPlane = new Cesium.Cartesian4(
        reflectorPlane.normal.x,
        reflectorPlane.normal.y,
        reflectorPlane.normal.z,
        reflectorPlane.distance
      );
      const projectionMatrix = Cesium.Matrix4.clone(
        this._virtualCamera.frustum.projectionMatrix
      );
      const q = new Cesium.Cartesian4(
        (Math.sign(clipPlane.x) + projectionMatrix[8]) / projectionMatrix[0],
        (Math.sign(clipPlane.y) + projectionMatrix[9]) / projectionMatrix[5],
        -1,
        (1 + projectionMatrix[10]) / projectionMatrix[14]
      );
      Cesium.Cartesian4.multiplyByScalar(
        clipPlane,
        2 / Cesium.Cartesian4.dot(clipPlane, q),
        clipPlane
      );
      projectionMatrix[2] = clipPlane.x;
      projectionMatrix[6] = clipPlane.y;
      projectionMatrix[10] = clipPlane.z + 1 - clipBias;
      projectionMatrix[14] = clipPlane.w;
      this._virtualCamera.frustum.customProjectionMatrix = Cesium.Matrix4.clone(projectionMatrix);
      return true;
    }
    preRender(scene) {
      const currnetDefaultViewCamera = scene._defaultView.camera;
      const currentShadowMap = scene.shadowMap;
      const currentGlobe = scene.globe.show;
      const currentShowSkirts = scene.globe.showSkirts;
      if (!this._updateVirtualCamera(scene._defaultView.camera)) {
        this._primitive.show = false;
        return;
      }
      this._primitive.show = false;
      scene._defaultView.camera = this._virtualCamera;
      scene.shadowMap = void 0;
      scene.globe.show = false;
      scene.globe.showSkirts = false;
      const context = scene.context;
      const width = context.drawingBufferWidth;
      const height = context.drawingBufferHeight;
      const hdr = scene.highDynamicRange;
      this._createFramebuffer(context, width, height, hdr);
      render(scene, this._colorFramebuffer);
      const appearance = this._primitive.appearance;
      const texture = Cesium.Texture.fromFramebuffer({
        context,
        framebuffer: this._colorFramebuffer
      });
      texture.type = "sampler2D";
      this._material.uniforms.texture = texture;
      this._material.uniforms.time = performance.now() / 1e3;
      this._material.uniforms.fixedFrameToEastNorthUpTransform = Cesium.Matrix4.toArray(
        this._getFixedFrameToEastNorthUpTransformFromWorldMatrix()
      );
      appearance.uniforms.reflectMatrix = Cesium.Matrix4.toArray(
        this._reflectMatrix
      );
      appearance.uniforms.reflectorProjectionMatrix = Cesium.Matrix4.toArray(
        this._reflectorProjectionMatrix
      );
      appearance.uniforms.reflectorViewMatrix = Cesium.Matrix4.toArray(
        this._reflectorViewMatrix
      );
      this._primitive.show = true;
      scene._defaultView.camera = currnetDefaultViewCamera;
      scene.shadowMap = currentShadowMap;
      scene.globe.show = currentGlobe;
      scene.globe.showSkirts = currentShowSkirts;
    }
    _createPrimitive(positions, extrudedHeight, flowDegrees) {
      const material = this._createReflectionWaterMaterial();
      this._material = material;
      const appearance = new Cesium.MaterialAppearance({
        material,
        vertexShaderSource: WaterAppearanceVS,
        translucent: true
      });
      appearance.uniforms = {};
      appearance.uniforms.reflectMatrix = Cesium.Matrix4.toArray(
        this._reflectMatrix
      );
      appearance.uniforms.reflectorProjectionMatrix = Cesium.Matrix4.toArray(
        this._reflectorProjectionMatrix
      );
      appearance.uniforms.reflectorViewMatrix = Cesium.Matrix4.toArray(
        this._reflectorViewMatrix
      );
      const primitive = new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry: new Cesium.PolygonGeometry({
            polygonHierarchy: new Cesium.PolygonHierarchy(positions),
            perPositionHeight: true,
            extrudedHeight,
            stRotation: Cesium.Math.toRadians(flowDegrees),
            closeTop: true,
            closeBottom: false,
            vertexFormat: Cesium.VertexFormat.POSITION_NORMAL_AND_ST
          })
        }),
        appearance,
        asynchronous: true
      });
      return primitive;
    }
    _getFixedFrameToEastNorthUpTransformFromWorldMatrix() {
      const eastNorthUpToFixedFrameTransform = Cesium.Transforms.eastNorthUpToFixedFrame(this._reflectorWorldPosition);
      const fixedFrameToEastNorthUpTransform = Cesium.Matrix4.inverse(
        eastNorthUpToFixedFrameTransform,
        new Cesium.Matrix4()
      );
      return fixedFrameToEastNorthUpTransform;
    }
    _createFramebuffer(context, width, height, hdr) {
      const colorTexture = this._colorTexture;
      if (Cesium.defined(colorTexture) && colorTexture.width === width && colorTexture.height === height && this._hdr === hdr) {
        return;
      }
      this._destroyResource();
      this._hdr = hdr;
      const pixelDatatype = hdr ? context.halfFloatingPointTexture ? Cesium.PixelDatatype.HALF_FLOAT : Cesium.PixelDatatype.FLOAT : Cesium.PixelDatatype.UNSIGNED_BYTE;
      this._colorTexture = new Cesium.Texture({
        context,
        width,
        height,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype,
        sampler: new Cesium.Sampler({
          wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
          wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
          minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
          magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
        })
      });
      this._depthStencilTexture = new Cesium.Texture({
        context,
        width,
        height,
        pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
      });
      this._colorFramebuffer = new Cesium.Framebuffer({
        context,
        colorTextures: [this._colorTexture],
        depthStencilTexture: this._depthStencilTexture,
        destroyAttachments: false
      });
    }
    _destroyResource() {
      this._colorTexture && this._colorTexture.destroy();
      this._depthStencilTexture && this._depthStencilTexture.destroy();
      this._colorFramebuffer && this._colorFramebuffer.destroy();
      this._colorTexture = void 0;
      this._depthStencilTexture = void 0;
      this._colorFramebuffer = void 0;
    }
    destroy() {
      if (this.preRender) {
        this._scene.preRender.removeEventListener(this.preRender);
      }
      if (this._primitive) {
        this._scene.primitives.remove(this._primitive);
        this._primitive = null;
      }
    }
  };
  var ReflectWater_default = ReflectWater;

  // Source/custom/shaders/hillshadeFragment.js
  var HillShadeFragment = class {
    static getShade() {
      return `
        uniform sampler2D u_image;
        varying vec2 v_pos;
        
        uniform vec2 u_latrange;
        uniform vec2 u_light;
        uniform vec4 u_shadow;
        uniform vec4 u_highlight;
        uniform vec4 u_accent;
        
        #define PI 3.141592653589793
        
        void main() {
            vec4 pixel = texture2D(u_image, v_pos);
        
            vec2 deriv = ((pixel.rg * 2.0) - 1.0);
        
            // We divide the slope by a scale factor based on the cosin of the pixel's approximate latitude
            // to account for mercator projection distortion. see #4807 for details
            float scaleFactor = cos(radians((u_latrange[0] - u_latrange[1]) * (1.0 - v_pos.y) + u_latrange[1]));
            // We also multiply the slope by an arbitrary z-factor of 1.25
            float slope = atan(1.25 * length(deriv) / scaleFactor);
            float aspect = deriv.x != 0.0 ? atan(deriv.y, -deriv.x) : PI / 2.0 * (deriv.y > 0.0 ? 1.0 : -1.0);
        
            float intensity = u_light.x;
            // We add PI to make this property match the global light object, which adds PI/2 to the light's azimuthal
            // position property to account for 0deg corresponding to north/the top of the viewport in the style spec
            // and the original shader was written to accept (-illuminationDirection - 90) as the azimuthal.
            float azimuth = u_light.y + PI;
        
            // We scale the slope exponentially based on intensity, using a calculation similar to
            // the exponential interpolation function in the style spec:
            // https://github.com/mapbox/mapbox-gl-js/blob/master/src/style-spec/expression/definitions/interpolate.js#L217-L228
            // so that higher intensity values create more opaque hillshading.
            float base = 1.875 - intensity * 1.75;
            float maxValue = 0.5 * PI;
            float scaledSlope = intensity != 0.5 ? ((pow(base, slope) - 1.0) / (pow(base, maxValue) - 1.0)) * maxValue : slope;
        
            // The accent color is calculated with the cosine of the slope while the shade color is calculated with the sine
            // so that the accent color's rate of change eases in while the shade color's eases out.
            float accent = cos(scaledSlope);
            // We multiply both the accent and shade color by a clamped intensity value
            // so that intensities >= 0.5 do not additionally affect the color values
            // while intensity values < 0.5 make the overall color more transparent.
            vec4 accent_color = (1.0 - accent) * u_accent * clamp(intensity * 2.0, 0.0, 1.0);
            float shade = abs(mod((aspect + azimuth) / PI + 0.5, 2.0) - 1.0);
            vec4 shade_color = mix(u_shadow, u_highlight, shade) * sin(scaledSlope) * clamp(intensity * 2.0, 0.0, 1.0);
            gl_FragColor = accent_color * (1.0 - shade_color.a) + shade_color;
        
        #ifdef OVERDRAW_INSPECTOR
            gl_FragColor = vec4(1.0);
        #endif
        }
        `;
    }
  };
  var hillshadeFragment_default = HillShadeFragment;

  // Source/custom/shaders/hillshadePrepareFragment.js
  var HillShadePrepareFragment = class {
    static getShade() {
      return `
        #ifdef GL_ES
        precision highp float;
        #endif
        
        uniform sampler2D u_image;
        varying vec2 v_pos;
        uniform vec2 u_dimension;
        uniform float u_zoom;
        uniform float u_maxzoom;
        
        float getElevation(vec2 coord, float bias) {
            // Convert encoded elevation value to meters
            vec4 data = texture2D(u_image, coord) * 255.0;
            return (data.r + data.g * 256.0 + data.b * 256.0 * 256.0) / 4.0;
        }
        
        void main() {
            vec2 epsilon = 1.0 / u_dimension;
        
            // queried pixels:
            // +-----------+
            // |   |   |   |
            // | a | b | c |
            // |   |   |   |
            // +-----------+
            // |   |   |   |
            // | d | e | f |
            // |   |   |   |
            // +-----------+
            // |   |   |   |
            // | g | h | i |
            // |   |   |   |
            // +-----------+
        
            float a = getElevation(v_pos + vec2(-epsilon.x, -epsilon.y), 0.0);
            float b = getElevation(v_pos + vec2(0, -epsilon.y), 0.0);
            float c = getElevation(v_pos + vec2(epsilon.x, -epsilon.y), 0.0);
            float d = getElevation(v_pos + vec2(-epsilon.x, 0), 0.0);
            float e = getElevation(v_pos, 0.0);
            float f = getElevation(v_pos + vec2(epsilon.x, 0), 0.0);
            float g = getElevation(v_pos + vec2(-epsilon.x, epsilon.y), 0.0);
            float h = getElevation(v_pos + vec2(0, epsilon.y), 0.0);
            float i = getElevation(v_pos + vec2(epsilon.x, epsilon.y), 0.0);
        
            // here we divide the x and y slopes by 8 * pixel size
            // where pixel size (aka meters/pixel) is:
            // circumference of the world / (pixels per tile * number of tiles)
            // which is equivalent to: 8 * 40075016.6855785 / (512 * pow(2, u_zoom))
            // which can be reduced to: pow(2, 19.25619978527 - u_zoom)
            // we want to vertically exaggerate the hillshading though, because otherwise
            // it is barely noticeable at low zooms. to do this, we multiply this by some
            // scale factor pow(2, (u_zoom - u_maxzoom) * a) where a is an arbitrary value
            // Here we use a=0.3 which works out to the expression below. see 
            // nickidlugash's awesome breakdown for more info
            // https://github.com/mapbox/mapbox-gl-js/pull/5286#discussion_r148419556
            float exaggeration = u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;
        
            vec2 deriv = vec2(
                (c + f + f + i) - (a + d + d + g),
                (g + h + h + i) - (a + b + b + c)
            ) /  pow(2.0, (u_zoom - u_maxzoom) * exaggeration + 19.2562 - u_zoom);
        
            gl_FragColor = clamp(vec4(
                deriv.x / 2.0 + 0.5,
                deriv.y / 2.0 + 0.5,
                1.0,
                1.0), 0.0, 1.0);
        
        #ifdef OVERDRAW_INSPECTOR
            gl_FragColor = vec4(1.0);
        #endif
        }

        `;
    }
  };
  var hillshadePrepareFragment_default = HillShadePrepareFragment;

  // Source/custom/shaders/hillshadePrepareVertex.js
  var HillShadePrepareVertex = class {
    static getShade() {
      return `
        uniform mat4 u_matrix;
        uniform vec2 u_dimension;
        
        attribute vec2 a_pos;
        attribute vec2 a_texture_pos;
        
        varying vec2 v_pos;
        
        void main() {
            gl_Position = u_matrix * vec4(a_pos, 0, 1);
        
            highp vec2 epsilon = 1.0 / u_dimension;
            float scale = (u_dimension.x - 2.0) / u_dimension.x;
            v_pos = (a_texture_pos / 32768.0) * scale + epsilon;
        }
        `;
    }
  };
  var hillshadePrepareVertex_default = HillShadePrepareVertex;

  // Source/custom/shaders/hillshadeVertex.js
  var HillShadeVertex = class {
    static getShade() {
      return `
        uniform mat4 u_matrix;
        
        attribute vec2 a_pos;
        attribute vec2 a_texture_pos;
        
        varying vec2 v_pos;
        
        void main() {
            gl_Position = u_matrix * vec4(a_pos, 0, 1);
            v_pos = a_texture_pos / 32768.0;
        }
        `;
    }
  };
  var hillshadeVertex_default = HillShadeVertex;

  // Source/custom/terrain/Pit.js
  var getSurfaceHeight3 = PointUtil_default.getSurfaceHeight;
  var Pit = class {
    constructor(_map, options = {}) {
      this._map = _map;
      this.style = options.style;
      this.style.diffHeight = Cesium.defaultValue(this.style.diffHeight, 10);
      this.style.splitNum = Cesium.defaultValue(this.style.splitNum, 50);
      if (options.positions) {
        this.positions = options.positions;
      }
      let wellData = this._getWellData();
      this.wellData = wellData;
      this._createPit(wellData);
    }
    get czmObjectEx() {
      let arr2 = [];
      if (this._bottomPrimitive) {
        arr2.push(this._bottomPrimitive);
      }
      if (this._primitive_label) {
        arr2.push(this._primitive_label);
      }
      return arr2;
    }
    get center() {
      return this.centerOfMass;
    }
    get diffHeight() {
      return this.style.diffHeight;
    }
    set diffHeight(val) {
      this.style.diffHeight = val;
      let bottomPositions = [];
      let bottomHeight = this._minHeight - val;
      let cartoList = this.wellData.cartoList;
      for (let i = 0, len = cartoList.length; i < len; i++) {
        let carto = cartoList[i];
        bottomPositions.push(Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, bottomHeight));
      }
      this.wellData.bottomPositions = bottomPositions;
      this._removePit();
      this._createPit(this.wellData);
    }
    _getWellData() {
      if (this.positions.length == 0) {
        return;
      }
      let wallTopPositions = [];
      let bottomPositions = [];
      let cartoList = [];
      let positionsNew = this.interPolyline({
        scene: this._map.scene,
        positions: this.positions.concat(this.positions[0]),
        splitNum: this.style.splitNum
      });
      let minMaxHeight = this.getHeight(positionsNew);
      this._minHeight = minMaxHeight.min;
      this._maxHeight = minMaxHeight.max;
      let bottomHeight = this._minHeight - this.diffHeight;
      for (let i = 0, len = positionsNew.length; i < len; i++) {
        let point2 = Cesium.Cartographic.fromCartesian(positionsNew[i]);
        cartoList.push(new Cesium.Cartographic(point2.longitude, point2.latitude));
        bottomPositions.push(Cesium.Cartesian3.fromRadians(point2.longitude, point2.latitude, bottomHeight));
        wallTopPositions.push(Cesium.Cartesian3.fromRadians(point2.longitude, point2.latitude, 0));
      }
      return {
        cartoList,
        bottomPositions,
        wallTopPositions
      };
    }
    _removePit() {
      if (this._primitive) {
        this._map.scene.primitives.remove(this._primitive);
        delete this._primitive;
      }
      if (this._bottomPrimitive) {
        this._map.scene.primitives.remove(this._bottomPrimitive);
        delete this._bottomPrimitive;
      }
      if (this._upliftPrimitive) {
        this._map.scene.primitives.remove(this._upliftPrimitive);
        delete this._upliftPrimitive;
      }
      if (this._upliftBottomPrimitive) {
        this._map.scene.primitives.remove(this._upliftBottomPrimitive);
        delete this._upliftBottomPrimitive;
      }
    }
    addCartesianAddHeight(c3, height) {
      let cartographic = Cesium.Cartographic.fromCartesian(c3);
      let h = cartographic.height + height;
      return Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, h);
    }
    _createPit(wellData) {
      this._createBottomSurface(wellData.bottomPositions);
      let hasTerrain = Boolean(this._map.terrainProvider._layers);
      if (hasTerrain) {
        let promise = Cesium.sampleTerrainMostDetailed(this._map.terrainProvider, wellData.cartoList);
        promise.then((updatedPositions) => {
          let _maxHeight = -9999;
          let wallTopPositions = [];
          for (let k = 0, len = updatedPositions.length; k < len; k++) {
            let carto = updatedPositions[k];
            _maxHeight = Math.max(carto.height, _maxHeight);
            wallTopPositions.push(Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, carto.height));
          }
          this._maxHeight = _maxHeight;
          this._createWellWall(wallTopPositions);
        });
      } else {
        this._createBottomtranslucentSurface(wellData.bottomPositions);
        this._createWellWall(wellData.wallTopPositions);
      }
    }
    _createWellWall(top) {
      let bottomHeight = this._minHeight - this.diffHeight;
      let g = new Cesium.GeometryInstance({
        geometry: new Cesium.WallGeometry({
          positions: top,
          minimumHeights: Array(top.length).fill(bottomHeight)
        })
      });
      this._primitive = new Cesium.Primitive({
        asynchronous: false,
        geometryInstances: [g],
        appearance: new Cesium.MaterialAppearance({
          translucent: true,
          flat: true,
          material: Cesium.Material.fromType(Cesium.Material.ImageType, {
            image: this.style.image,
            color: Cesium.Color.WHITE.withAlpha(this.style.opacity || 1)
          })
        })
      });
      this._map.scene.primitives.add(this._primitive);
      if (this.style.openUplift) {
        let upliftTop = [];
        for (let j = 0; j < top.length; j++) {
          upliftTop.push(this.addCartesianAddHeight(top[j], this.style.upHeight));
        }
        let g1 = new Cesium.GeometryInstance({
          geometry: new Cesium.WallGeometry({
            positions: upliftTop,
            minimumHeights: Array(upliftTop.length).fill(bottomHeight + this.style.upHeight)
          })
        });
        this._upliftPrimitive = new Cesium.Primitive({
          asynchronous: false,
          geometryInstances: [g1],
          appearance: new Cesium.MaterialAppearance({
            translucent: true,
            flat: true,
            material: Cesium.Material.fromType(Cesium.Material.ImageType, {
              image: this.style.upliftImage ? this.style.upliftImage : this.style.image,
              color: Cesium.Color.WHITE.withAlpha(this.style.opacity || 1)
            })
          })
        });
        this._map.scene.primitives.add(this._upliftPrimitive);
      }
    }
    _createBottomtranslucentSurface(bottomPositions) {
      if (this.style.openUplift) {
        let upliftBottomPositions = [];
        for (let i = 0; i < bottomPositions.length; i++) {
          upliftBottomPositions.push(this.addCartesianAddHeight(bottomPositions[i], this.style.upHeight));
        }
        let g1 = new Cesium.GeometryInstance({
          geometry: Cesium.PolygonGeometry.fromPositions({
            positions: upliftBottomPositions,
            perPositionHeight: true
          })
        });
        this._upliftBottomPrimitive = new Cesium.Primitive({
          asynchronous: false,
          geometryInstances: [g1],
          appearance: new Cesium.MaterialAppearance({
            translucent: true,
            flat: true,
            material: Cesium.Material.fromType(Cesium.Material.ImageType, {
              image: this.style.upliftImageBottom ? this.style.upliftImageBottom : this.style.imageBottom,
              color: Cesium.Color.WHITE.withAlpha(this.style.opacity || 1)
            })
          })
        });
        this._map.scene.primitives.add(this._upliftBottomPrimitive);
      }
    }
    _createBottomSurface(bottomPositions) {
      if (!bottomPositions.length) {
        return;
      }
      let g = new Cesium.GeometryInstance({
        geometry: Cesium.PolygonGeometry.fromPositions({
          positions: bottomPositions,
          perPositionHeight: true
        })
      });
      this._bottomPrimitive = new Cesium.Primitive({
        asynchronous: false,
        geometryInstances: [g],
        appearance: new Cesium.MaterialAppearance({
          translucent: true,
          flat: true,
          material: Cesium.Material.fromType(Cesium.Material.ImageType, {
            image: this.style.imageBottom,
            color: Cesium.Color.WHITE.withAlpha(this.style.opacity || 1)
          })
        })
      });
      this._map.scene.primitives.add(this._bottomPrimitive);
    }
    getHeight(positions, defaultVal = 0) {
      if (positions == null || positions.length == 0) {
        return {
          min: defaultVal,
          max: defaultVal
        };
      }
      let minHeight = defaultVal;
      let maxHeight = defaultVal;
      for (let i = 0; i < positions.length; i++) {
        let tempCarto = Cesium.Cartographic.fromCartesian(positions[i]);
        if (i == 0) {
          minHeight = tempCarto.height;
          maxHeight = tempCarto.height;
        }
        if (tempCarto.height < minHeight) {
          minHeight = tempCarto.height;
        }
        if (tempCarto.height > maxHeight) {
          maxHeight = tempCarto.height;
        }
      }
      return {
        min: minHeight.toFixed(3) * 1,
        max: maxHeight.toFixed(3) * 1
      };
    }
    interPolyline(options) {
      let positions = options.positions;
      let scene = options.scene;
      let granularity = this.getGranularity(positions, options.splitNum || 100);
      if (granularity <= 0) {
        granularity = null;
      }
      let flatPositions = Cesium.PolylinePipeline.generateArc({
        positions,
        height: options.height,
        minDistance: options.minDistance,
        granularity
      });
      let arr2 = [];
      for (let i = 0; i < flatPositions.length; i += 3) {
        let position = Cesium.Cartesian3.unpack(flatPositions, i);
        if (scene && Cesium.defaultValue(options.surfaceHeight, true)) {
          delete options.callback;
          let height = getSurfaceHeight3(scene, position, options);
          let car = Cesium.Cartographic.fromCartesian(position);
          position = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
        }
        arr2.push(position);
      }
      return arr2;
    }
    getGranularity(positions, splitNum = 10) {
      let recta = Cesium.Rectangle.fromCartesianArray(positions);
      let granularity = Math.max(recta.height, recta.width);
      granularity /= splitNum;
      return granularity;
    }
  };
  var Pit_default = Pit;

  // Source/custom/terrain/TerrainClip.js
  var TerrainClip = class extends TerrainEditBase_default {
    constructor(viewer3, options = {}) {
      super(viewer3, options);
      this._clipOutSide = Cesium.defaultValue(options.clipOutSide, false);
      this.openUplift = false;
      if (options.hasOwnProperty("upHeight")) {
        this.upHeight = options.upHeight;
        this.openUplift = true;
      }
    }
    get terrainEditCtl() {
      return this._map.scene.globe._surface.tileProvider._excavateAnalysis;
    }
    get clipOutSide() {
      return this.terrainEditCtl.showTailorOnly;
    }
    set clipOutSide(val) {
      this.terrainEditCtl.showTailorOnly = val;
    }
    get diffHeight() {
      return this.options.diffHeight;
    }
    set diffHeight(val) {
      this.options.diffHeight = val;
    }
    clear() {
      for (let i = 0; i < this._areaList.length; i++) {
        let polygonObj = this._areaList[i];
        polygonObj.pitPrimitive._removePit();
      }
      super.clear();
      this.yanmoFbo = null;
      this._map.scene.globe._surface.tileProvider.applyTailor = false;
      this.terrainEditCtl.enableTailor = false;
      this.terrainEditCtl.inverTailorCenterMat = Cesium.Matrix4.IDENTITY;
      this.terrainEditCtl.tailorArea = void 0;
      this.terrainEditCtl.openUplift = false;
      if (this._hasChangeHighDynamicRange) {
        this._map.scene.highDynamicRange = false;
        this._hasChangeHighDynamicRange = false;
      }
      if (this._hasChangeDepthTestAgainstTerrain) {
        this._map.scene.globe.depthTestAgainstTerrain = false;
        this._hasChangeDepthTestAgainstTerrain = false;
      }
    }
    addPolygon(positions, options) {
      if (options.hasOwnProperty("upHeight")) {
        options.openUplift = true;
        this.openUplift = true;
        this.upHeight = options.upHeight;
      }
      let polygonObj = super.addPolygon(positions, options);
      if (positions && this.options.image) {
        polygonObj.pitPrimitive = new Pit_default(this._map, {
          style: {
            ...this.options,
            ...options
          },
          positions: polygonObj.positions_original
        });
      }
      if (!this._map.scene.highDynamicRange) {
        this._map.scene.highDynamicRange = true;
        this._hasChangeHighDynamicRange = true;
      }
      if (!this._map.scene.globe.depthTestAgainstTerrain) {
        this._map.scene.globe.depthTestAgainstTerrain = true;
        this._hasChangeDepthTestAgainstTerrain = true;
      }
      return polygonObj;
    }
    removePolygon(item) {
      super.removePolygon(item);
      item.pitPrimitive._removePit();
    }
    beginTailor() {
      this._map.scene.globe._surface.tileProvider.applyTailor = true;
      this.terrainEditCtl.inverTailorCenterMat = this.inverTrans;
      this.terrainEditCtl.tailorArea = this.yanmoFbo;
      this.terrainEditCtl.enableTailor = true;
      this.terrainEditCtl.tailorRect = this.floodRect;
      this.terrainEditCtl.openUplift = this.openUplift;
      this.terrainEditCtl.upHeight = this.upHeight;
    }
  };
  var TerrainClip_default = TerrainClip;

  // Source/custom/tileset/TilesetEditBase.js
  var TilesetEditVS = `uniform mat4 myPorjection;
attribute vec3 position;
varying vec2 depth;
void main()
{
    vec4 pos = vec4(position.xyz,1.0);
    depth = pos.zw;
    pos.z = 0.0;
    gl_Position = czm_projection*pos;
}`;
  var TilesetEditFS = `#ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
#else
    precision mediump float;
#endif

#define OES_texture_float_linear

varying vec2 depth;

vec4 packDepth(float depth)
{
    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;
    enc = fract(enc);
    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);
    return enc;
}

void main()
{
    float fDepth = (depth.x / 5000.0)/2.0 + 0.5;
    // gl_FragColor = packDepth(fDepth);
    gl_FragColor = vec4(1.0,0.0,0.0,1.0);
}`;
  var TilesetEditBase = class {
    constructor(viewer3, options = {}) {
      this.options = options;
      this._map = viewer3;
      this._areaList = [];
      this._cache_id = 0;
      if (this.options.hasOwnProperty("tileset")) {
        this.tileset = this.options.tileset;
      }
    }
    get list() {
      return this._areaList;
    }
    get tileset() {
      return this._tileset;
    }
    set tileset(val) {
      this._tileset = val;
      this._inverseTransform = null;
    }
    get matrix() {
      if (!this._tileset) {
        return null;
      }
      this.upZ = this._tileset.asset.gltfUpAxis == "Z" || this._tileset.asset.gltfUpAxis == "z";
      if (!this._inverseTransform) {
        let transform2;
        let tmp = this._tileset.root.transform;
        if (!tmp || tmp.equals(Cesium.Matrix4.IDENTITY)) {
          transform2 = Cesium.Transforms.eastNorthUpToFixedFrame(this._tileset.boundingSphere.center);
        } else {
          transform2 = Cesium.Transforms.eastNorthUpToFixedFrame(this._tileset.boundingSphere.center);
        }
        this._inverseTransform = Cesium.Matrix4.inverseTransformation(transform2, new Cesium.Matrix4());
      }
      return this._inverseTransform;
    }
    get positions() {
      if (this.length > 0) {
        return this._areaList[0].positions;
      } else {
        return null;
      }
    }
    set positions(val) {
      this.clear();
      this.addPolygon(val);
    }
    get length() {
      if (this._areaList) {
        return this._areaList.length;
      } else {
        return 0;
      }
    }
    clear() {
      this._areaList = [];
      this._cache_id = 0;
      this._disable();
    }
    getPolygonById(id) {
      for (let i = 0; i < this._areaList.length; i++) {
        let item = this._areaList[i];
        if (item.id == id) {
          return item;
        }
      }
      return null;
    }
    hidePolygon(id) {
      let item = this.getPolygonById(id);
      if (item) {
        item.show = false;
        this.drawed = false;
      }
    }
    showPolygon(id) {
      let item = this.getPolygonById(id);
      if (item) {
        item.show = true;
        this.drawed = false;
      }
    }
    removePolygon(item) {
      if (item) {
        this.removeArrayItem(this._areaList, item);
        this._disable();
        this._activete();
      }
    }
    addPolygon(positions) {
      if (!positions || positions.length === 0) {
        return;
      }
      let areaObj = {
        show: true,
        id: ++this._cache_id,
        positions
      };
      this._areaList.push(areaObj);
      this._disable();
      this._activete();
      return areaObj;
    }
    _activete() {
      if (!this._tileset) {
        return;
      }
      this._preparePos();
      this._createTexture();
      if (!this._map.scene.primitives.contains(this)) {
        this._map.scene.primitives.add(this);
      }
    }
    _disable() {
      if (this.tileset.modelEditor) {
        if (this.fbo && this.fbo.destroy) {
          this.fbo.destroy();
          this.fbo = null;
        }
        this.tileset.modelEditor.IsYaPing = [false, false, false, false];
        this.tileset.modelEditor.editVar = [false, false, false, false];
        this.tileset.modelEditor.floodColor = [0, 0, 0, 0.5];
        this.tileset.modelEditor.floodVar = [0, 0, 0, 0];
        this.tileset.modelEditor.heightVar = [0, 0];
        this.tileset.modelEditor.enable = false;
      }
      this.drawed = false;
    }
    update(frameState) {
      if (this.drawed || !this._areaList || this._areaList.length == 0) {
        return;
      }
      this._createCommand();
      this._activeModelEditor();
      this.drawed = true;
      let context = frameState.context;
      let width = 4096;
      let height = 4096;
      if (!this._passState) {
        this._passState = new Cesium.PassState(context);
      }
      this._passState.framebuffer = this.fbo;
      this._passState.viewport = new Cesium.BoundingRectangle(0, 0, width, height);
      let us = context.uniformState;
      us.updateCamera(this._camera);
      this._fboClearCommand.execute(frameState.context);
      this._areaList.forEach((areaObj) => {
        const command = areaObj.drawCommand;
        if (command && areaObj.show) {
          us.updatePass(command.pass);
          command.framebuffer = this.fbo;
          command.execute(context, this._passState);
        }
      });
    }
    _activeModelEditor() {
    }
    deActiveEdit() {
      this.tileset.modelEditor.IsYaPing[0] = false;
    }
    _preparePos() {
      let _minLocalZ;
      let _minHeight = 99999;
      let inverMAT = this.matrix;
      this._areaList.forEach((areaObj) => {
        if (!areaObj.show) {
          return;
        }
        let localPos = [];
        const positions = areaObj.positions;
        if (positions && positions.length > 2) {
          for (let i = 0; i < positions.length; i++) {
            let cart = Cesium.Cartographic.fromCartesian(positions[i]);
            let height = cart.height;
            let currLocalPos = Cesium.Matrix4.multiplyByPoint(inverMAT, positions[i], new Cesium.Cartesian3());
            localPos.push(currLocalPos);
            if (height < _minHeight) {
              _minHeight = height;
              _minLocalZ = currLocalPos.z;
            }
          }
          areaObj.localPos = localPos;
        }
      });
      this._minLocalZ = _minLocalZ;
    }
    _createTexture() {
      let context = this._map.scene.context;
      let tt = new Cesium.Texture({
        context,
        width: 4096,
        height: 4096,
        pixelFormat: Cesium.PixelFormat.RGBA,
        pixelDatatype: Cesium.PixelDatatype.FLOAT,
        sampler: new Cesium.Sampler({
          wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
          wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
          minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
          magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
        })
      });
      let depthStencilTexture = new Cesium.Texture({
        context,
        width: 4096,
        height: 4096,
        pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
        pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
      });
      this.fbo = new Cesium.Framebuffer({
        context,
        colorTextures: [tt],
        depthStencilTexture,
        destroyAttachments: false
      });
      this._fboClearCommand = new Cesium.ClearCommand({
        color: new Cesium.Color(0, 0, 0, 0),
        framebuffer: this.fbo
      });
    }
    _createCommand() {
      let context = this._map.scene.context;
      let minX = 99999999;
      let minY = 99999999;
      let maxX = -99999999;
      let maxY = -99999999;
      this._areaList.forEach((areaObj) => {
        const localPos = areaObj.localPos;
        if (localPos) {
          let flattenPolygon = new Cesium.PolygonGeometry({
            polygonHierarchy: new Cesium.PolygonHierarchy(localPos),
            perPositionHeight: true
          });
          let ppp = Cesium.PolygonGeometry.createGeometry(flattenPolygon);
          let sp = Cesium.ShaderProgram.fromCache({
            context,
            vertexShaderSource: TilesetEditVS,
            fragmentShaderSource: TilesetEditFS,
            attributeLocations: {
              position: 0
            }
          });
          let vao = Cesium.VertexArray.fromGeometry({
            context,
            geometry: ppp,
            attributeLocations: sp._attributeLocations,
            bufferUsage: Cesium.BufferUsage.STATIC_DRAW,
            interleave: true
          });
          let rs = new Cesium.RenderState();
          rs.depthTest.enabled = false;
          rs.depthRange.near = -1e6;
          rs.depthRange.far = 1e6;
          let bg = Cesium.BoundingRectangle.fromPoints(areaObj.localPos, new Cesium.BoundingRectangle());
          if (minX > bg.x) {
            minX = bg.x;
          }
          if (minY > bg.y) {
            minY = bg.y;
          }
          if (maxX < bg.x + bg.width) {
            maxX = bg.x + bg.width;
          }
          if (maxY < bg.y + bg.height) {
            maxY = bg.y + bg.height;
          }
          let myPorjection = Cesium.Matrix4.computeOrthographicOffCenter(
            bg.x,
            bg.x + bg.width,
            bg.y,
            bg.y + bg.height,
            1,
            5e8,
            new Cesium.Matrix4()
          );
          areaObj.polygonBounds = new Cesium.Cartesian4(bg.x, bg.y, bg.x + bg.width, bg.y + bg.height);
          areaObj.drawCommand = new Cesium.DrawCommand({
            boundingVolume: ppp.boundingVolume,
            primitiveType: Cesium.PrimitiveType.TRIANGLES,
            vertexArray: vao,
            shaderProgram: sp,
            renderState: rs,
            pass: Cesium.Pass.CESIUM_3D_TILE,
            uniformMap: {
              myPorjection: function() {
                return myPorjection;
              }
            }
          });
        }
      });
      let _camera = {
        viewMatrix: Cesium.Matrix4.IDENTITY,
        inverseViewMatrix: Cesium.Matrix4.IDENTITY,
        frustum: new Cesium.OrthographicOffCenterFrustum(),
        positionCartographic: new Cesium.Cartographic(),
        positionWC: new Cesium.Cartesian3(),
        directionWC: Cesium.Cartesian3.UNIT_Z,
        upWC: Cesium.Cartesian3.UNIT_Y,
        rightWC: Cesium.Cartesian3.UNIT_X,
        viewProjectionMatrix: Cesium.Matrix4.IDENTITY
      };
      _camera.frustum.left = minX;
      _camera.frustum.top = maxY;
      _camera.frustum.right = maxX;
      _camera.frustum.bottom = minY;
      this.polygonBounds = new Cesium.Cartesian4(minX, minY, maxX, maxY);
      this._camera = _camera;
    }
    removeArrayItem(arr2, val) {
      let index = arr2.indexOf(val);
      if (index > -1) {
        arr2.splice(index, 1);
        return true;
      }
      return false;
    }
  };
  var TilesetEditBase_default = TilesetEditBase;

  // Source/custom/tileset/TilesetClip.js
  var TilesetClip = class extends TilesetEditBase_default {
    constructor(viewer3, options = {}) {
      super(viewer3, options);
      if (options.hasOwnProperty("clipOutSide")) {
        this.clipOutSide = options.clipOutSide;
      }
    }
    get clipOutSide() {
      return this.options.clipOutSide;
    }
    set clipOutSide(val) {
      this.options.clipOutSide = val;
      if (this.tileset.modelEditor) {
        this.tileset.modelEditor.editVar[0] = val;
      }
    }
    _activeModelEditor() {
      this.tileset.modelEditor.fbo = this.fbo;
      this.tileset.modelEditor.polygonBounds = this.polygonBounds;
      this.tileset.modelEditor.IsYaPing[0] = true;
      this.tileset.modelEditor.IsYaPing[2] = true;
      this.tileset.modelEditor.editVar[0] = this.clipOutSide;
      this.tileset.modelEditor.enable = this.enabled;
      this.tileset.modelEditor._inverseTransform = this.matrix;
      this.tileset.modelEditor.upZ = this.upZ;
    }
  };
  var TilesetClip_default = TilesetClip;

  // Source/custom/tileset/TilesetFlat.js
  var TilesetFlat = class extends TilesetEditBase_default {
    constructor(viewer3, options = {}) {
      super(viewer3, options);
      if (options.hasOwnProperty("height")) {
        this.height = options.height;
      }
    }
    get height() {
      return this.options.height;
    }
    set height(val) {
      this.options.height = val;
      if (this.tileset.modelEditor) {
        this.tileset.modelEditor.heightVar[1] = val;
      }
    }
    _activeModelEditor() {
      this.tileset.modelEditor.fbo = this.fbo;
      this.tileset.modelEditor.polygonBounds = this.polygonBounds;
      this.tileset.modelEditor.IsYaPing[0] = true;
      this.tileset.modelEditor.IsYaPing[1] = true;
      this.tileset.modelEditor.heightVar[0] = this._minLocalZ;
      this.tileset.modelEditor.heightVar[1] = this.height || 0;
      this.tileset.modelEditor.enable = this.enabled;
      this.tileset.modelEditor._inverseTransform = this.matrix;
      this.tileset.modelEditor.upZ = this.upZ;
    }
  };
  var TilesetFlat_default = TilesetFlat;

  // Source/custom/tooltip/ToolTip.js
  var ToolTip = class {
    constructor(viewer3, options = {}) {
      this._map = viewer3;
      this.options = options;
      this.parentContainerId = this._map?.container?.id;
      let el = document.createElement("div");
      el.className = "custom-popup";
      this._container = el;
      this._container.id = "custom-tooltip-view";
      this._container.style.display = "none";
      this.options.cacheTime = Cesium.defaultValue(this.options.cacheTime, 20);
    }
    get show() {
      return this._show;
    }
    set show(show) {
      if (this._show == show) {
        return;
      }
      this._show = show;
      if (this._container) {
        this._container.style.display = show ? "block" : "none";
      }
      this._showHook && this._showHook(show);
    }
    _bindMourseEvent() {
      this.handler = new Cesium.ScreenSpaceEventHandler(this._map.canvas);
      this.handler.setInputAction(this._mouseDownHandler.bind(this), Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.handler.setInputAction(this._mouseUpHandler.bind(this), Cesium.ScreenSpaceEventType.LEFT_UP);
      this.handler.setInputAction(this._mouseMoveHandler.bind(this), Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
    _unbindMourseEvent() {
      if (this.handler) {
        this.handler.destroy();
        delete this.handler;
      }
    }
    start() {
      if (this._container) {
        this._map?.container.appendChild(this._container);
      }
      this._bindMourseEvent();
    }
    destroy() {
      if (this._container) {
        this._map?.container.removeChild(this._container);
        this._container = null;
      }
      this._unbindMourseEvent();
    }
    _mouseDownHandler(event) {
      this._isMouseUpdownPressed = true;
      this.close();
    }
    _mouseUpHandler(event) {
      this._isMouseUpdownPressed = false;
    }
    _mouseMoveHandler(event) {
      if (this.moveTimer) {
        clearTimeout(this.moveTimer);
        delete this.moveTimer;
      }
      if (this._isMouseUpdownPressed || this._map.scene.screenSpaceCameraController.enableRotate == false || this._map.scene.screenSpaceCameraController.enableTilt == false || this._map.scene.screenSpaceCameraController.enableTranslate == false) {
        this.close();
        return;
      }
      this.moveTimer = setTimeout(() => {
        delete this.moveTimer;
        let pickedFeature = this._map.scene.pick(event.endPosition);
        if (Cesium.defined(pickedFeature)) {
          event.target = pickedFeature;
          this._mouseMoveWork(event);
        } else {
          this.close();
        }
      }, this.options.cacheTime);
    }
    _mouseMoveWork(event) {
      if (this._openByMove(event.target, event)) {
        return;
      }
      this.close();
    }
    _openByMove(target, event) {
      if (target.primitive) {
        target = target.primitive;
      } else {
        target = null;
      }
      if (!target || !Cesium.defined(target.tooltip)) {
        return false;
      }
      if (target.tooltip == false) {
        return true;
      }
      this.open(target, {
        windowPosition: event.endPosition,
        event
      });
      return true;
    }
    _showHook() {
      if (!this._show) {
        if (this.moveTimer) {
          clearTimeout(this.moveTimer);
          delete this.moveTimer;
        }
        if (this.onRemove) {
          this.onRemove(this._last_eventResult);
          delete this.onRemove;
        }
      }
    }
    close() {
      this.show = false;
    }
    open(target, options = {}) {
      let eventResult = options.event || {};
      delete options.event;
      eventResult.target = target;
      this._last_eventResult = eventResult;
      let inhtml;
      let onAdd;
      if (typeof target.tooltip == "object") {
        inhtml = target.tooltip.html;
        onAdd = target.tooltip.onAdd;
        this.onRemove = target.tooltip.onRemove;
        if (typeof target.tooltip.show == "function") {
          if (!target.tooltip.show(eventResult)) {
            this.close();
            return;
          }
        }
      } else {
        inhtml = target.tooltip;
      }
      if (typeof inhtml == "function") {
        inhtml = inhtml(eventResult);
      }
      if (!inhtml) {
        this.close();
        return;
      }
      this.show = true;
      if (Cesium.defaultValue(target.tooltip?.template, true)) {
        this._container.innerHTML = `
            <div class="custom-popup-content-wrapper  custom-popup-background">
                <div id="${this.parentContainerId}-custom-tooltip-content" class="custom-popup-content custom-popup-color">${inhtml}</div>
            </div>
            <div class="custom-popup-tip-container"><div class="custom-popup-tip  custom-popup-background"></div></div>
            `;
      } else {
        this._container.innerHTML = inhtml;
      }
      if (onAdd) {
        onAdd(eventResult);
      }
      let x3 = options.windowPosition.x - this._container.offsetWidth / 2;
      let y3 = options.windowPosition.y - this._container.offsetHeight;
      let tooltip = target.tooltip;
      if (tooltip && typeof tooltip == "object" && tooltip.anchor) {
        x3 += tooltip.anchor[0];
        y3 += tooltip.anchor[1];
      } else {
        y3 -= 3;
      }
      this._container.style.left = x3 + "px";
      this._container.style.top = y3 + "px";
    }
  };
  var ToolTip_default = ToolTip;

  // Source/custom/utils/ieee754.js
  var read = function(buffer4, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer4[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer4[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer4[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  var write = function(buffer4, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer4[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer4[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer4[offset + i - d] |= s * 128;
  };
  var ieee754_default = { read, write };

  // Source/custom/utils/isArray.js
  var toString = {}.toString;
  var isArray_default = Array.isArray || function(arr2) {
    return toString.call(arr2) == "[object Array]";
  };

  // Source/custom/utils/Buffer.js
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  var INSPECT_MAX_BYTES = 50;
  Buffer4.TYPED_ARRAY_SUPPORT = true;
  var _kMaxLength = kMaxLength();
  function kMaxLength() {
    return Buffer4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer(that, length2) {
    if (kMaxLength() < length2) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length2);
      that.__proto__ = Buffer4.prototype;
    } else {
      if (that === null) {
        that = new Buffer4(length2);
      }
      that.length = length2;
    }
    return that;
  }
  function Buffer4(arg, encodingOrOffset, length2) {
    if (!Buffer4.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer4)) {
      return new Buffer4(arg, encodingOrOffset, length2);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error(
          "If encoding is specified then the first argument must be a string"
        );
      }
      return allocUnsafe(this, arg);
    }
    return from(this, arg, encodingOrOffset, length2);
  }
  Buffer4.poolSize = 8192;
  Buffer4._augment = function(arr2) {
    arr2.__proto__ = Buffer4.prototype;
    return arr2;
  };
  function from(that, value, encodingOrOffset, length2) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length2);
    }
    if (typeof value === "string") {
      return fromString(that, value, encodingOrOffset);
    }
    return fromObject(that, value);
  }
  Buffer4.from = function(value, encodingOrOffset, length2) {
    return from(null, value, encodingOrOffset, length2);
  };
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    Buffer4.prototype.__proto__ = Uint8Array.prototype;
    Buffer4.__proto__ = Uint8Array;
    if (typeof Symbol !== "undefined" && Symbol.species && Buffer4[Symbol.species] === Buffer4) {
    }
  }
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc(that, size, fill2, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size);
    }
    if (fill2 !== void 0) {
      return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
    }
    return createBuffer(that, size);
  }
  Buffer4.alloc = function(size, fill2, encoding) {
    return alloc(null, size, fill2, encoding);
  };
  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer4.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that;
  }
  Buffer4.allocUnsafe = function(size) {
    return allocUnsafe(null, size);
  };
  Buffer4.allocUnsafeSlow = function(size) {
    return allocUnsafe(null, size);
  };
  function fromString(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer4.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length2 = byteLength(string, encoding) | 0;
    that = createBuffer(that, length2);
    var actual = that.write(string, encoding);
    if (actual !== length2) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike(that, array2) {
    var length2 = array2.length < 0 ? 0 : checked(array2.length) | 0;
    that = createBuffer(that, length2);
    for (var i = 0; i < length2; i += 1) {
      that[i] = array2[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array2, byteOffset, length2) {
    array2.byteLength;
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array2.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length2 === void 0) {
      array2 = new Uint8Array(array2);
    } else if (length2 === void 0) {
      array2 = new Uint8Array(array2, byteOffset);
    } else {
      array2 = new Uint8Array(array2, byteOffset, length2);
    }
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      that = array2;
      that.__proto__ = Buffer4.prototype;
    } else {
      that = fromArrayLike(that, array2);
    }
    return that;
  }
  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }
      if (obj.type === "Buffer" && isArray_default(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  function checked(length2) {
    if (length2 >= kMaxLength()) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
    }
    return length2 | 0;
  }
  Buffer4.isBuffer = isBuffer;
  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }
  Buffer4.compare = function compare(a2, b) {
    if (!internalIsBuffer(a2) || !internalIsBuffer(b)) {
      throw new TypeError("Arguments must be Buffers");
    }
    if (a2 === b)
      return 0;
    var x3 = a2.length;
    var y3 = b.length;
    for (var i = 0, len = Math.min(x3, y3); i < len; ++i) {
      if (a2[i] !== b[i]) {
        x3 = a2[i];
        y3 = b[i];
        break;
      }
    }
    if (x3 < y3)
      return -1;
    if (y3 < x3)
      return 1;
    return 0;
  };
  Buffer4.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer4.concat = function concat(list, length2) {
    if (!isArray_default(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer4.alloc(0);
    }
    var i;
    if (length2 === void 0) {
      length2 = 0;
      for (i = 0; i < list.length; ++i) {
        length2 += list[i].length;
      }
    }
    var buffer4 = Buffer4.allocUnsafe(length2);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      buf.copy(buffer4, pos);
      pos += buf.length;
    }
    return buffer4;
  };
  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      string = "" + string;
    }
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer4.byteLength = byteLength;
  function slowToString(encoding, start2, end) {
    var loweredCase = false;
    if (start2 === void 0 || start2 < 0) {
      start2 = 0;
    }
    if (start2 > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start2 >>>= 0;
    if (end <= start2) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start2, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start2, end);
        case "ascii":
          return asciiSlice(this, start2, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start2, end);
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start2, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer4.prototype._isBuffer = true;
  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer4.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer4.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer4.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer4.prototype.toString = function toString2() {
    var length2 = this.length | 0;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer4.prototype.equals = function equals(b) {
    if (!internalIsBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer4.compare(this, b) === 0;
  };
  Buffer4.prototype.inspect = function inspect() {
    var str = "";
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
      if (this.length > max)
        str += " ... ";
    }
    return "<Buffer " + str + ">";
  };
  Buffer4.prototype.compare = function compare2(target, start2, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError("Argument must be a Buffer");
    }
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start2 < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start2 >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start2 >= end) {
      return 1;
    }
    start2 >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x3 = thisEnd - thisStart;
    var y3 = end - start2;
    var len = Math.min(x3, y3);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start2, end);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x3 = thisCopy[i];
        y3 = targetCopy[i];
        break;
      }
    }
    if (x3 < y3)
      return -1;
    if (y3 < x3)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer4, val, byteOffset, encoding, dir) {
    if (buffer4.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer4.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer4.length + byteOffset;
    if (byteOffset >= buffer4.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer4.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer4.from(val, encoding);
    }
    if (internalIsBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer4, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer4.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer4, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer4, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer4, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr2.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr2.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read2(arr2, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read2(arr2, i + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length2) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new TypeError("Invalid hex string");
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    for (var i = 0; i < length2; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length2) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length2);
  }
  function asciiWrite(buf, string, offset, length2) {
    return blitBuffer(asciiToBytes(string), buf, offset, length2);
  }
  function latin1Write(buf, string, offset, length2) {
    return asciiWrite(buf, string, offset, length2);
  }
  function base64Write(buf, string, offset, length2) {
    return blitBuffer(base64ToBytes(string), buf, offset, length2);
  }
  function ucs2Write(buf, string, offset, length2) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length2);
  }
  Buffer4.prototype.write = function write2(string, offset, length2, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset = 0;
    } else if (length2 === void 0 && typeof offset === "string") {
      encoding = offset;
      length2 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length2)) {
        length2 = length2 | 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    var remaining = this.length - offset;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length2);
        case "ascii":
          return asciiWrite(this, string, offset, length2);
        case "latin1":
        case "binary":
          return latin1Write(this, string, offset, length2);
        case "base64":
          return base64Write(this, string, offset, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer4.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function utf8Slice(buf, start2, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start2;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start2, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start2; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start2, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start2; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start2, end) {
    var len = buf.length;
    if (!start2 || start2 < 0)
      start2 = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i = start2; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start2, end) {
    var bytes = buf.slice(start2, end);
    var res = "";
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer4.prototype.slice = function slice2(start2, end) {
    var len = this.length;
    start2 = ~~start2;
    end = end === void 0 ? len : ~~end;
    if (start2 < 0) {
      start2 += len;
      if (start2 < 0)
        start2 = 0;
    } else if (start2 > len) {
      start2 = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start2)
      end = start2;
    var newBuf;
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start2, end);
      newBuf.__proto__ = Buffer4.prototype;
    } else {
      var sliceLen = end - start2;
      newBuf = new Buffer4(sliceLen, void 0);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start2];
      }
    }
    return newBuf;
  };
  function checkOffset(offset, ext, length2) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer4.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength2 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer4.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    var val = this[offset + --byteLength2];
    var mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer4.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer4.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer4.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer4.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer4.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer4.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength2 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer4.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var i = byteLength2;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer4.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer4.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer4.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer4.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer4.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer4.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754_default.read(this, offset, true, 23, 4);
  };
  Buffer4.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754_default.read(this, offset, false, 23, 4);
  };
  Buffer4.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754_default.read(this, offset, true, 52, 8);
  };
  Buffer4.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754_default.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while (++i < byteLength2 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength2 = byteLength2 | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    var i = byteLength2 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    if (!Buffer4.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = value & 255;
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 65535 + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 4294967295 + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
    }
  }
  Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer4.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer4.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i = byteLength2 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer4.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (!Buffer4.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    if (Buffer4.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
    }
    ieee754_default.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
    }
    ieee754_default.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer4.prototype.copy = function copy(target, targetStart, start2, end) {
    if (!start2)
      start2 = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start2)
      end = start2;
    if (end === start2)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start2 < 0 || start2 >= this.length)
      throw new RangeError("sourceStart out of bounds");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start2) {
      end = target.length - targetStart + start2;
    }
    var len = end - start2;
    var i;
    if (this === target && start2 < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start2];
      }
    } else if (len < 1e3 || !Buffer4.TYPED_ARRAY_SUPPORT) {
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start2];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start2, start2 + len),
        targetStart
      );
    }
    return len;
  };
  Buffer4.prototype.fill = function fill(val, start2, end, encoding) {
    if (typeof val === "string") {
      if (typeof start2 === "string") {
        encoding = start2;
        start2 = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
    } else if (typeof val === "number") {
      val = val & 255;
    }
    if (start2 < 0 || this.length < start2 || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start2) {
      return this;
    }
    start2 = start2 >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    var i;
    if (typeof val === "number") {
      for (i = start2; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer4(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start2; ++i) {
        this[i + start2] = bytes[i % len];
      }
    }
    return this;
  };
  function toHex(n) {
    if (n < 16)
      return "0" + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length2 = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length2; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length2) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function blitBuffer(src, dst, offset, length2) {
    for (var i = 0; i < length2; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isnan(val) {
    return val !== val;
  }
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }
  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
  }

  // Source/custom/utils/Cache.js
  var Cache = class {
    constructor(limit) {
      this.init(limit);
    }
    init(limit) {
      this.limit = limit || 10;
      this.map = {};
      this.keys = [];
    }
    set(key2, value) {
      let map2 = this.map;
      let keys = this.keys;
      let deleteItem = null;
      if (!Object.prototype.hasOwnProperty.call(map2, key2)) {
        if (keys.length === this.limit) {
          let name2 = keys.shift();
          deleteItem = map2[name2];
          delete map2[name2];
        }
        keys.push(key2);
      }
      map2[key2] = value;
      return deleteItem;
    }
    get(key2) {
      return this.map[key2];
    }
  };
  var Cache_default = Cache;

  // Source/custom/utils/CodeTool.js
  var CodeTool = class {
    constructor() {
    }
    static getHeaderArray(headerLength) {
      let harr = [];
      for (let i = 0; i < headerLength; i++) {
        harr[i] = this._getRandomNum();
      }
      return harr;
    }
    static _getRandomNum() {
      let Range = 80;
      let Rand = Math.random();
      return 50 + Math.round(Rand * Range);
    }
    static stringToByte(str, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      let bytes = [];
      let buffer4 = Buffer.from(str, encoding);
      for (let i = 0; i < buffer4.length; i++) {
        bytes.push(buffer4[i]);
      }
      return bytes;
    }
    static byteToString(bytes, encoding) {
      if (encoding === void 0) {
        encoding = "utf8";
      }
      return Buffer.from(bytes).toString(encoding);
    }
    static intToBytes(num) {
      return [num >> 24 & 255, num >> 16 & 255, num >> 8 & 255, num & 255];
    }
    static bytesToInt(bytes) {
      return bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3];
    }
    static varintToInt(buffer4) {
      let intBuffer = [];
      let highBuffer = [];
      let j = 3;
      let offset = 0;
      for (let i = buffer4.length - 1; i >= 0; i--) {
        if (i - 1 >= 0) {
          highBuffer[0] = buffer4[i - 1] << 7 - offset;
        } else {
          highBuffer[0] = 0;
        }
        if (j === -1) {
          break;
        }
        intBuffer[j] = (buffer4[i] & 127) >> offset | highBuffer[0];
        j--;
        offset++;
      }
      let t = intBuffer[0] << 24 & 4278190080 | intBuffer[1] << 16 & 16711680 | intBuffer[2] << 8 & 65280 | intBuffer[3] & 255;
      t = t >> 1 ^ -(t & 1);
      return t;
    }
    static intToVarint(num) {
      if (num === 0) {
        return [0];
      }
      num = this._zigZagEncoding(num);
      let buffer4 = [];
      let now2;
      let high = 0;
      for (let i = 5; i > 0; i--) {
        now2 = num >> (i - 1) * 7 & 127;
        if (high !== 0) {
          now2 = now2 | 128;
        }
        if (now2 !== 0) {
          buffer4.push(now2);
        }
        high = now2;
      }
      return buffer4;
    }
    static varintToIntArray(buffer4) {
      let varintCode = [];
      let high;
      let bf_index = 0;
      let nums = [];
      for (let i = 0; i < buffer4.length; i++) {
        high = 0 | buffer4[i] >> 7 & 1;
        if (high === 0) {
          if (bf_index > 0 && bf_index <= 5) {
            nums.push(this.varintToInt(varintCode));
            varintCode = [];
            bf_index = 0;
          }
        }
        varintCode.push(buffer4[i]);
        bf_index++;
      }
      nums.push(this.varintToInt(varintCode));
      return nums;
    }
    static intArrayToVarintBuffer(numArray) {
      let bytea = [];
      let numBytes;
      for (let i = 0; i < numArray.length; i++) {
        numBytes = this.intToVarint(numArray[i]);
        bytea.push(...numBytes);
      }
      return Buffer.from(bytea);
    }
    static _zigZagEncoding(num) {
      return num >> 31 ^ num << 1;
    }
  };
  var CodeTool_default = CodeTool;

  // Source/custom/utils/Drag.js
  var Drag = class {
    constructor(viewer3) {
      this._viewer = viewer3;
      this.entity = null;
      this.handler = null;
      this.moving = false;
      this._leftDown = this._leftDownHandler.bind(this);
      this._leftUp = this._leftUpHandler.bind(this);
      this._move = this._moveHandler.bind(this);
      this.handler = new Cesium.ScreenSpaceEventHandler(this._viewer.canvas);
    }
    enable() {
      this.handler.setInputAction(this._leftDown, Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.handler.setInputAction(this._leftUp, Cesium.ScreenSpaceEventType.LEFT_UP);
      this.handler.setInputAction(this._move, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
    disable() {
      this._viewer.scene.screenSpaceCameraController.enableRotate = true;
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.moving = false;
      this.entity = null;
    }
    _leftDownHandler(e) {
      this.entity = this._viewer.scene.pick(e.position);
      this.moving = true;
      if (this.entity) {
        this._viewer.scene.screenSpaceCameraController.enableRotate = false;
      }
    }
    _leftUpHandler() {
      this.moving = false;
      this.entity = null;
      this._viewer.scene.screenSpaceCameraController.enableRotate = true;
    }
    _moveHandler(e) {
      if (this.moving && this.entity && this.entity.id) {
        const ray = this._viewer.camera.getPickRay(e.endPosition);
        const cartesian2 = this._viewer.scene.globe.pick(ray, this._viewer.scene);
        const ellipsoid = viewer.scene.globe.ellipsoid;
        const c = ellipsoid.cartesianToCartographic(cartesian2);
        const origin = this.entity.id.position.getValue();
        const cc = ellipsoid.cartesianToCartographic(origin);
        this.entity.id.position = new Cesium.CallbackProperty(function() {
          return new Cesium.Cartesian3.fromRadians(c.longitude, c.latitude, cc.height);
        }, false);
      }
    }
  };
  var Drag_default = Drag;

  // Source/custom/utils/DragModel.js
  var DragModel = class {
    constructor(viewer3) {
      this._viewer = viewer3;
      this.entity = null;
      this.handler = null;
      this.moving = false;
      this._leftDown = this._leftDownHandler.bind(this);
      this._leftUp = this._leftUpHandler.bind(this);
      this._move = this._moveHandler.bind(this);
      this.handler = new Cesium.ScreenSpaceEventHandler(this._viewer.canvas);
    }
    enable() {
      this.handler.setInputAction(this._leftDown, Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.handler.setInputAction(this._leftUp, Cesium.ScreenSpaceEventType.LEFT_UP);
      this.handler.setInputAction(this._move, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }
    disable() {
      this._viewer.scene.screenSpaceCameraController.enableRotate = true;
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
      this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      this.moving = false;
      this.entity = null;
    }
    _leftDownHandler(e) {
      this.entity = this._viewer.scene.pick(e.position);
      this.moving = true;
      if (this.entity) {
        this._viewer.scene.screenSpaceCameraController.enableRotate = false;
      }
    }
    _leftUpHandler() {
      this.moving = false;
      this.entity = null;
      this._viewer.scene.screenSpaceCameraController.enableRotate = true;
    }
    _moveHandler(e) {
      if (this.moving && this.entity && this.entity.primitive) {
        const ray = this._viewer.camera.getPickRay(e.endPosition);
        const cartesian2 = this._viewer.scene.globe.pick(ray, this._viewer.scene);
        this.entity.primitive.modelMatrix = Cesium.Matrix4.setTranslation(
          this.entity.primitive.modelMatrix,
          cartesian2,
          new Cesium.Matrix4()
        );
        if (this.entity.primitive.resetDrawCommands) {
          this.entity.primitive.resetDrawCommands();
        }
      }
    }
  };
  var DragModel_default = DragModel;

  // Source/custom/utils/ElevationTool.js
  var defer2 = Cesium.defer;
  var ElevationTool = class {
    static getDBMap(indexDbNames, dbMap) {
      let deferred = defer2();
      let promises = [];
      for (let i = 0; i < indexDbNames.length; i++) {
        let indexDbname = indexDbNames[i];
        let defer1 = defer2();
        let request = indexedDB.open(indexDbname, 1);
        request.onerror = function() {
          console.log(indexDbname + "\u6570\u636E\u5E93\u521B\u5EFA\u5931\u8D25\u6216\u8005\u5F02\u5E38~");
          defer1.reject();
        };
        request.onsuccess = function(e) {
          console.log(indexDbname + "\u6570\u636E\u5E93\u8FDE\u63A5\u6210\u529F~");
          dbMap[indexDbname] = e.target.result;
          defer1.resolve(true);
        };
        request.onupgradeneeded = function(e) {
          let db = e.target.result;
          dbMap[indexDbname] = db;
          let objectStore = db.createObjectStore(indexDbname, { keyPath: "key", autoIncrement: false });
          objectStore.createIndex("key", "key", { unique: true });
          defer1.resolve(true);
        };
        promises.push(defer1.promise);
      }
      Promise.all(promises).then(function() {
        deferred.resolve(true);
      });
      return deferred.promise;
    }
    static getElevation(dbMap, indexDbNames, key2) {
      let deferred = defer2();
      let promises = [];
      let elevationDataMap = [];
      for (let i = 0; i < indexDbNames.length; i++) {
        let indexDbname = indexDbNames[i];
        let db = dbMap[indexDbname];
        let transaction = db.transaction([indexDbname]);
        let objectStore = transaction.objectStore(indexDbname);
        let defer1 = defer2();
        let request = objectStore.get(key2);
        request.onerror = function(event) {
          elevationDataMap[indexDbname] = null;
          defer1.resolve(null);
        };
        request.onsuccess = function(event) {
          if (request.result) {
            elevationDataMap[indexDbname] = request.result;
            defer1.resolve(request.result);
          } else {
            elevationDataMap[indexDbname] = null;
            defer1.resolve(null);
          }
        };
        promises.push(defer1.promise);
      }
      Promise.all(promises).then(function() {
        deferred.resolve(elevationDataMap);
      });
      return deferred.promise;
    }
    static updateElevation(db, indexDbName, key2, data) {
      let deferred = defer2();
      let request = db.transaction([indexDbName], "readwrite").objectStore(indexDbName).put({ key: key2, data });
      request.onsuccess = function(event) {
        deferred.resolve(true);
      };
      request.onerror = function(event) {
        deferred.reject();
      };
      return deferred.promise;
    }
  };
  var ElevationTool_default = ElevationTool;

  // Source/custom/utils/Geojson.js
  var Geojson = class {
    constructor() {
      this.ingest = {
        FeatureCollection: function(json) {
          let features = json.features;
          for (let i = 0, len = features.length; i < len; i++) {
            let feature3 = features[i];
            if (!feature3.geometry) {
              return;
            }
            var geometryType = feature3.geometry.type;
            if (this.ingest[geometryType]) {
              let components = this.ingest[geometryType].apply(this, [feature3]);
              this.pushComponents(components, feature3.properties, geometryType);
            } else {
              throw new RuntimeError("Unknown geometry type: " + geometryType);
            }
          }
        },
        Feature: function(json) {
          let feature3 = json;
          if (!feature3.geometry) {
            return;
          }
          var geometryType = feature3.geometry.type;
          if (this.ingest[geometryType]) {
            let components = this.ingest[geometryType].apply(this, [feature3]);
            this.pushComponents(components, feature3.properties, geometryType);
          } else {
            throw new RuntimeError("Unknown geometry type: " + geometryType);
          }
        },
        GeometryCollection: function(geometryCollection2) {
          var geometries = geometryCollection2.geometries;
          for (var i = 0, len = geometries.length; i < len; i++) {
            var geometry = geometries[i];
            var geometryType = geometry.type;
            if (this.ingest[geometryType]) {
              let components = this.ingest[geometryType].apply(this, [feature]);
              this.pushComponents(components, geometry.properties, geometryType);
            } else {
              throw new RuntimeError("Unknown geometry type: " + geometryType);
            }
          }
        },
        Point: function(feature3) {
          var coordinate = feature3.geometry.coordinates;
          return [{
            x: parseFloat(coordinate[0]),
            y: parseFloat(coordinate[1])
          }];
        },
        MultiPoint: function(feature3) {
          var coordinates = feature3.geometry.coordinates;
          var components = [];
          for (var i = 0; i < coordinates.length; i += 1) {
            components.push(this.ingest.Point.apply(this, [{ geometry: { coordinates: coordinates[i] } }]));
          }
          return components;
        },
        LineString: function(feature3) {
          var i, multipoints, components;
          multipoints = this.ingest.MultiPoint.apply(this, [feature3]);
          components = [];
          for (i = 0; i < multipoints.length; i += 1) {
            components = components.concat(multipoints[i]);
          }
          return components;
        },
        MultiLineString: function(feature3) {
          var components = [];
          var coordinates = feature3.geometry.coordinates;
          for (var i = 0; i < coordinates.length; i += 1) {
            components.push(this.ingest.LineString.apply(this, [{ geometry: { coordinates: coordinates[i] } }]));
          }
          return components;
        },
        Polygon: function(feature3) {
          var i, j, components;
          var coordinates = feature3.geometry.coordinates;
          components = [];
          for (i = 0; i < coordinates.length; i += 1) {
            var coordinate = coordinates[i];
            var subcomponents = [];
            for (j = 0; j < coordinate.length; j += 1) {
              var pt = coordinate[j];
              var x_cord = pt[0];
              var y_cord = pt[1];
              subcomponents.push({
                x: parseFloat(x_cord),
                y: parseFloat(y_cord)
              });
            }
            components.push(subcomponents);
          }
          return components;
        },
        MultiPolygon: function(feature3) {
          var i, components, polygon2;
          components = [];
          var coordinates = feature3.geometry.coordinates;
          for (i = 0; i < coordinates.length; i += 1) {
            var coordinate = coordinates[i];
            components.push(this.ingest.Polygon.apply(this, [{ geometry: { coordinates: coordinate } }]));
          }
          return components;
        }
      };
    }
    read(geojson) {
      this.pointArray = [];
      this.lineArray = [];
      this.polygonArray = [];
      this.propertieArray = [];
      this.ingest[geojson.type].apply(this, [geojson]);
      return this;
    }
    readToPrimitives(geojson, option) {
      this.read(geojson);
      return this.componentsToPrimitives(option);
    }
    pushComponents(components, properties, geometryType) {
      this.propertieArray.push(properties);
      if (geometryType == "Point" || geometryType == "MultiPoint") {
        this.pointArray.push(components);
        return;
      }
      if (geometryType == "LineString") {
        let line = { properties, geometry: this.createLine(components) };
        this.lineArray.push(line);
        return;
      }
      if (geometryType == "MultiLineString") {
        for (let i = 0; i < components.length; i++) {
          let line = { properties, geometry: this.createLine(components[i]) };
          this.lineArray.push(line);
        }
        return;
      }
      if (geometryType == "Polygon") {
        let polygon2 = { properties, geometry: this.createPolygon(components) };
        this.polygonArray.push(polygon2);
        return;
      }
      if (geometryType == "MultiPolygon") {
        for (let i = 0; i < components.length; i++) {
          let polygon2 = { properties, geometry: this.createPolygon(components[i]) };
          this.polygonArray.push(polygon2);
        }
        return;
      }
    }
    componentsToPrimitives(option) {
      option = option ? option : {};
      option.asynchronous = option.asynchronous ? option.asynchronous : false;
      option.clampToGround = option.clampToGround ? option.clampToGround : false;
      option.fillColor = option.fillColor ? option.fillColor : "#ff0000";
      option.fillOpacity = option.hasOwnProperty("fillOpacity") ? option.fillOpacity : 1;
      option.pixelSize = option.pixelSize ? option.pixelSize : 10;
      option.strokeColor = option.strokeColor ? option.strokeColor : "#ff0000";
      option.strokeOpacity = option.hasOwnProperty("strokeOpacity") ? option.strokeOpacity : 1;
      option.lineWidth = option.hasOwnProperty("lineWidth") ? option.lineWidth : 2;
      option.outlineWidth = option.hasOwnProperty("outlineWidth") ? option.outlineWidth : 0;
      option.translucent = false;
      if (option.fillOpacity != 1 || option.strokeOpacity != 1) {
        option.translucent = true;
      }
      let pointInstances = [];
      let lineInstances = [];
      let polygonInstances = [];
      for (let i = 0; i < this.pointArray.length; i++) {
        let item = this.pointArray[i].geometry;
        pointInstances.push(this.getPointInstance(item, option));
      }
      for (let i = 0; i < this.lineArray.length; i++) {
        let item = this.lineArray[i].geometry;
        lineInstances.push(this.getLineInstance(item, option));
      }
      for (let i = 0; i < this.polygonArray.length; i++) {
        let item = this.polygonArray[i].geometry;
        polygonInstances.push(this.getPolygonInstance(item, option));
      }
      let pointPrimitive = this.getPointPrimitive(pointInstances, option);
      let linePrimitive = this.getLinePrimitive(lineInstances, option);
      let polygonPrimitive = this.getPolygonPrimitive(polygonInstances, option);
      let primitives = [];
      if (pointPrimitive) {
        primitives.push(pointPrimitive);
      }
      if (linePrimitive) {
        primitives.push(linePrimitive);
      }
      if (polygonPrimitive) {
        primitives.push(polygonPrimitive);
      }
      return primitives;
    }
    getPointInstance(components, option, geometryType) {
      return components;
    }
    getPointPrimitive(instances, option) {
      if (instances.length == 0) {
        return null;
      }
      let pointPrimitives = new Cesium.PointPrimitiveCollection();
      for (let i = 0; i < instances.length; i++) {
        pointPrimitives.add({
          pixelSize: option.pixelSize,
          color: Cesium.Color.fromCssColorString(option.fillColor).withAlpha(option.fillOpacity),
          outlineColor: Cesium.Color.fromCssColorString(option.strokeColor).withAlpha(option.strokeOpacity),
          outlineWidth: option.outlineWidth,
          position: Cesium.Cartesian3.fromDegrees(instances[i].x, instances[i].y, 0)
        });
      }
      return pointPrimitives;
    }
    getLineInstance(data, option) {
      let geometryInstance = null;
      if (option.clampToGround) {
        geometryInstance = new Cesium.GeometryInstance({
          geometry: new Cesium.GroundPolylineGeometry({
            positions: Cesium.Cartesian3.fromDegreesArray(data),
            width: option.lineWidth
          }),
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString(option.strokeColor).withAlpha(option.strokeOpacity))
          }
        });
      } else {
        geometryInstance = new Cesium.GeometryInstance({
          geometry: new Cesium.PolylineGeometry({
            positions: Cesium.Cartesian3.fromDegreesArray(data),
            width: option.lineWidth
          }),
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString(option.strokeColor).withAlpha(option.strokeOpacity))
          }
        });
      }
      return geometryInstance;
    }
    getLinePrimitive(geometryInstances, option) {
      if (geometryInstances.length == 0) {
        return null;
      }
      let primitive = null;
      if (option.clampToGround) {
        primitive = new Cesium.GroundPolylinePrimitive({
          asynchronous: option.asynchronous,
          geometryInstances,
          appearance: new Cesium.PolylineColorAppearance({
            flat: true,
            translucent: option.translucent
          })
        });
      } else {
        primitive = new Cesium.Primitive({
          asynchronous: option.asynchronous,
          geometryInstances,
          appearance: new Cesium.PolylineColorAppearance({
            flat: true,
            translucent: option.translucent
          })
        });
      }
      return primitive;
    }
    createLine(components) {
      let lpts = [];
      for (let i = 0; i < components.length; i++) {
        let pt = components[i];
        lpts.push(pt.x);
        lpts.push(pt.y);
      }
      return lpts;
    }
    getPolygonInstance(py, option) {
      let positions = Cesium.Cartesian3.fromDegreesArray(py.pts);
      let holes = [];
      for (let m = 0; m < py.holes.length; m++) {
        holes.push({ positions: Cesium.Cartesian3.fromDegreesArray(py.holes[m]) });
      }
      let polygonInstance = new Cesium.GeometryInstance({
        geometry: new Cesium.PolygonGeometry({
          polygonHierarchy: {
            positions,
            holes
          },
          vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,
          height: 0
        }),
        attributes: {
          color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString(option.fillColor).withAlpha(option.fillOpacity))
        }
      });
      return polygonInstance;
    }
    getPolygonPrimitive(geometryInstances, option) {
      if (geometryInstances.length == 0) {
        return null;
      }
      let primitive = null;
      if (option.clampToGround) {
        primitive = new Cesium.GroundPrimitive({
          asynchronous: option.asynchronous,
          geometryInstances,
          appearance: new Cesium.PerInstanceColorAppearance({
            translucent: option.translucent,
            closed: true
          })
        });
      } else {
        primitive = new Cesium.Primitive({
          asynchronous: option.asynchronous,
          geometryInstances,
          appearance: new Cesium.PerInstanceColorAppearance({
            translucent: option.translucent,
            closed: true
          })
        });
      }
      return primitive;
    }
    createPolygon(components) {
      let pts = [];
      let holes = [];
      let polygon2 = { pts, holes };
      for (let i = 0; i < components.length; i++) {
        let component = components[i];
        if (i == 0) {
          for (let j = 0; j < component.length; j++) {
            let item = component[j];
            pts.push(item.x);
            pts.push(item.y);
          }
        } else {
          let hpts = [];
          for (let m = 0; m < component.length; m++) {
            let pt = component[m];
            hpts.push(pt.x);
            hpts.push(pt.y);
          }
          holes.push(hpts);
        }
      }
      return polygon2;
    }
    beginsWith(str, sub) {
      return str.substring(0, sub.length) === sub;
    }
    endsWith(str, sub) {
      return str.substring(str.length - sub.length) === sub;
    }
    trim(str, sub) {
      sub = sub || " ";
      while (this.beginsWith(str, sub)) {
        str = str.substring(1);
      }
      while (this.endsWith(str, sub)) {
        str = str.substring(0, str.length - 1);
      }
      return str;
    }
  };
  var Geojson_default = Geojson;

  // Source/custom/utils/IndexDBTool.js
  var defer3 = Cesium.defer;
  var IndexDBTool = class {
    static createDB(dbName) {
      let deferred = defer3();
      let request = indexedDB.open(dbName, 1);
      request.onerror = function() {
        console.log(dbName + "\u6570\u636E\u5E93\u521B\u5EFA\u5931\u8D25\u6216\u8005\u5F02\u5E38~");
        deferred.reject();
      };
      request.onsuccess = function(e) {
        console.log(dbName + "\u6570\u636E\u5E93\u8FDE\u63A5\u6210\u529F~");
        let db = e.target.result;
        deferred.resolve(db);
      };
      request.onupgradeneeded = function(e) {
        let db = e.target.result;
        deferred.resolve(db);
      };
      return deferred.promise;
    }
    static createTable(db, tName, pKey, autoIncrement, indexName, indexFiled) {
      let objectStore = db.createObjectStore(tName, { keyPath: pKey, autoIncrement });
      objectStore.createIndex(indexName, indexFiled, { unique: true });
    }
    static getObjectStore(db, tName) {
      let transaction = db.transaction([tName], "readwrite");
      let objectStore = transaction.objectStore(tName);
      return objectStore;
    }
    static getByPkey(objectStore, key2) {
      let deferred = defer3();
      let request = objectStore.get(key2);
      request.onerror = function(event) {
        deferred.resolve(null);
      };
      request.onsuccess = function(event) {
        if (request.result) {
          deferred.resolve(request.result);
        } else {
          deferred.resolve(null);
        }
      };
      return deferred.promise;
    }
    static setByKey(objectStore, key2, data) {
      let deferred = defer3();
      let request = objectStore.put({ key: key2, data });
      request.onsuccess = function(event) {
        deferred.resolve(true);
      };
      request.onerror = function(event) {
        deferred.reject();
      };
      return deferred.promise;
    }
  };
  var IndexDBTool_default = IndexDBTool;

  // Source/custom/utils/LayerContentModel.js
  var LayerContentModel = class {
    constructor() {
      this.layerHeaderProBuffer = Buffer.alloc(0);
      this.coordinateBufferArray = [];
      this.featureArray = [];
    }
    getLayerHeaderProBuffer() {
      return this.layerHeaderProBuffer;
    }
    setLayerHeaderProBuffer(layerHeaderProBuffer) {
      this.layerHeaderProBuffer = layerHeaderProBuffer;
    }
    getFeatureArray() {
      return this.featureArray;
    }
    setFeatureArray(featureArray) {
      this.featureArray = featureArray;
    }
    getCoordinateBufferArray() {
      return this.coordinateBufferArray;
    }
    setCoordinateBufferArray(coordinateBufferArray) {
      this.coordinateBufferArray = coordinateBufferArray;
    }
  };
  var LayerContentModel_default = LayerContentModel;

  // Source/custom/utils/LightTool.js
  var LightTool = class {
    static composeShader(shaderArray) {
      let main = "void main(){\n";
      let body = "";
      let fs = "";
      for (let i in shaderArray) {
        let item = shaderArray[i];
        body = body + item.name + "();";
        fs = fs + item.shader;
      }
      main = main + body + "}";
      return fs + main;
    }
    static composeMainShader(sourceShader, shaderArray) {
      let regex = /void\s+main\s*\(\s*(?:void)?\s*\)/g;
      let array2 = sourceShader.split(regex);
      let sourceHead = array2[0];
      let sourceTail = array2[1];
      let index = sourceTail.lastIndexOf("}");
      sourceTail = sourceTail.substring(0, index);
      let main = "void main()\n";
      let body = "";
      let fs = "";
      for (let i in shaderArray) {
        let item = shaderArray[i];
        body = body + item.name + "();";
        fs = fs + item.shader;
      }
      main = sourceHead + fs + main + sourceTail + body + "}";
      console.log(main);
      return main;
    }
  };
  var LightTool_default = LightTool;

  // Source/custom/utils/QueryToJs.js
  var patt1 = new RegExp("[\\w]+_[0-9a-zA-Z\u0391-\uFFE5]+_[\\w]+_[\\w]+[ ]{0,}=[ ]{0,}(([A-Za-z0-9\u4E00-\u9FA5]+([,|\\-|\\_][A-Za-z0-9\u4E00-\u9FA5]{0,})+)|([\\w]+\\(['|[A-Za-z0-9\u4E00-\u9FA5]{0,}|']+\\))|(\\d+)\\.(\\d+)|('|[A-Za-z0-9\u4E00-\u9FA5]{0,}|')+)", "g");
  var QueryToJs = class {
    _dealWithString(value) {
      return '"' + value + '"';
    }
    _dealWithNumber(value) {
      if (value.toLowerCase() == "null") {
        return null;
      }
      return value;
    }
    _dealWithDate(value) {
      let date = new Date(value);
      value = date.getTime();
      return value;
    }
    _dealWithDateFloat(value) {
      return value;
    }
    _convertType(type, value, defaultTyle) {
      switch (type) {
        case "S":
          value = this._dealWithString(value);
          break;
        case "N":
          value = this._dealWithNumber(value);
          break;
        case "L":
          value = this._dealWithNumber(value);
          break;
        case "FT":
          value = this._dealWithDateFloat(value);
          break;
        case "D":
          value = this._dealWithDate(value);
          break;
      }
      return value;
    }
    _convertTypeIn(type, value) {
      let typeStr;
      switch (type) {
        case "S":
          typeStr = "S";
          break;
        case "N":
          typeStr = "N";
          break;
        case "L":
          typeStr = "N";
          break;
        case "FT":
          typeStr = "N";
          break;
        default:
          typeStr = "S";
          break;
      }
      let values = value.split(",");
      let valueArr = [];
      for (let i = 0; i < values.length; i++) {
        if (typeStr == "S") {
          valueArr.push('"' + values[i] + '"');
        } else {
          valueArr.push(values[i]);
        }
      }
      return "[" + valueArr.join(",") + "]";
    }
    _queryPathToJs(queryPath) {
      let str = "";
      let queryArr = queryPath.split("=");
      let queryfilter = queryArr[0];
      let compareValue = queryArr[1];
      var filterCell = {};
      let info = queryfilter.split("_");
      filterCell["field"] = info[1];
      filterCell["type"] = info[2];
      filterCell["operation"] = info[3];
      switch (filterCell.operation.toUpperCase()) {
        case "LT":
          compareValue = this._convertType(filterCell.type, compareValue);
          str = filterCell["field"] + " < " + compareValue;
          return {
            str,
            field: filterCell["field"]
          };
        case "NE":
          compareValue = this._convertType(filterCell.type, compareValue);
          str = filterCell["field"] + " != " + compareValue;
          return {
            str,
            field: filterCell["field"]
          };
        case "GT":
          compareValue = this._convertType(filterCell.type, compareValue, "N");
          str = filterCell["field"] + " > " + compareValue;
          return {
            str,
            field: filterCell["field"]
          };
        case "LE":
          compareValue = this._convertType(filterCell.type, compareValue, "N");
          str = filterCell["field"] + " <= " + compareValue;
          return {
            str,
            field: filterCell["field"]
          };
        case "GE":
          compareValue = this._convertType(filterCell.type, compareValue, "N");
          str = filterCell["field"] + " >= " + compareValue;
          return {
            str,
            field: filterCell["field"]
          };
        case "NULL":
          str = filterCell["field"] + " == null";
          return {
            str,
            field: filterCell["field"]
          };
        case "NOTNULL":
          str = filterCell["field"] + " != null";
          return {
            str,
            field: filterCell["field"]
          };
        case "LK":
          compareValue = this._convertType(filterCell.type, compareValue, "S");
          str = "(" + filterCell["field"] + " != null && " + filterCell["field"] + ".indexOf(" + compareValue + ") != -1)";
          return {
            str,
            field: filterCell["field"]
          };
        case "LFK":
          compareValue = this._convertType(filterCell.type, compareValue, "S");
          str = "(" + filterCell["field"] + " != null && " + filterCell["field"] + ".startsWith(" + compareValue + "))";
          return {
            str,
            field: filterCell["field"]
          };
        case "RHK":
          compareValue = this._convertType(filterCell.type, compareValue, "S");
          str = "(" + filterCell["field"] + " != null && " + filterCell["field"] + ".endsWith(" + compareValue + "))";
          return {
            str,
            field: filterCell["field"]
          };
        case "IN":
          compareValue = this._convertTypeIn(filterCell["type"], compareValue);
          str = compareValue + ".indexOf(" + filterCell["field"] + ") != -1";
          return {
            str,
            field: filterCell["field"]
          };
        case "NOTIN":
          compareValue = this._convertTypeIn(filterCell["type"], compareValue);
          str = compareValue + ".indexOf(" + filterCell["field"] + ") == -1";
          return {
            str,
            field: filterCell["field"]
          };
        case "EQ":
          compareValue = this._convertType(filterCell["type"], compareValue);
          str = filterCell["field"] + " == " + compareValue;
          return {
            str,
            field: filterCell["field"]
          };
      }
    }
    queryToJs(query) {
      let map2 = {};
      let result = null;
      let fields = {};
      while (true) {
        result = patt1.exec(query);
        if (result != null) {
          let queryPath = result[0];
          var path = this._queryPathToJs(queryPath);
          map2[queryPath] = path.str;
          fields[path.field] = true;
        } else {
          break;
        }
      }
      for (let key2 in map2) {
        query = query.replace(new RegExp(key2, "g"), map2[key2]);
      }
      query = query.replace(new RegExp(/( AND )/g), " && ");
      query = query.replace(new RegExp(/( and )/g), " && ");
      query = query.replace(new RegExp(/( OR )/g), " || ");
      query = query.replace(new RegExp(/( or )/g), " || ");
      query = query.replace(new RegExp(/(not )/g), " ! ");
      query = query.replace(new RegExp(/(NOT )/g), " ! ");
      return {
        js: query,
        fields
      };
    }
  };
  var QueryToJs_default = new QueryToJs();

  // Source/custom/utils/snappyJs.js
  /**
   * Modules in this bundle
   * @license
   *
   * snappyjs:
   *   license: MIT (http://opensource.org/licenses/MIT)
   *   author: Zhipeng Jia
   *   version: 0.6.0
   *
   * This header is generated by licensify (https://github.com/twada/licensify)
   */
  var WORD_MASK = [0, 255, 65535, 16777215, 4294967295];
  function copyBytes(fromArray, fromPos, toArray, toPos, length2) {
    var i;
    for (i = 0; i < length2; i++) {
      toArray[toPos + i] = fromArray[fromPos + i];
    }
  }
  function selfCopyBytes(array2, pos, offset, length2) {
    var i;
    for (i = 0; i < length2; i++) {
      array2[pos + i] = array2[pos - offset + i];
    }
  }
  function SnappyDecompressor(compressed) {
    this.array = compressed;
    this.pos = 0;
  }
  SnappyDecompressor.prototype.readUncompressedLength = function() {
    var result = 0;
    var shift = 0;
    var c, val;
    while (shift < 32 && this.pos < this.array.length) {
      c = this.array[this.pos];
      this.pos += 1;
      val = c & 127;
      if (val << shift >>> shift !== val) {
        return -1;
      }
      result |= val << shift;
      if (c < 128) {
        return result;
      }
      shift += 7;
    }
    return -1;
  };
  SnappyDecompressor.prototype.uncompressToBuffer = function(outBuffer) {
    var array2 = this.array;
    var arrayLength = array2.length;
    var pos = this.pos;
    var outPos = 0;
    var c, len, smallLen;
    var offset;
    while (pos < array2.length) {
      c = array2[pos];
      pos += 1;
      if ((c & 3) === 0) {
        len = (c >>> 2) + 1;
        if (len > 60) {
          if (pos + 3 >= arrayLength) {
            return false;
          }
          smallLen = len - 60;
          len = array2[pos] + (array2[pos + 1] << 8) + (array2[pos + 2] << 16) + (array2[pos + 3] << 24);
          len = (len & WORD_MASK[smallLen]) + 1;
          pos += smallLen;
        }
        if (pos + len > arrayLength) {
          return false;
        }
        copyBytes(array2, pos, outBuffer, outPos, len);
        pos += len;
        outPos += len;
      } else {
        switch (c & 3) {
          case 1:
            len = (c >>> 2 & 7) + 4;
            offset = array2[pos] + (c >>> 5 << 8);
            pos += 1;
            break;
          case 2:
            if (pos + 1 >= arrayLength) {
              return false;
            }
            len = (c >>> 2) + 1;
            offset = array2[pos] + (array2[pos + 1] << 8);
            pos += 2;
            break;
          case 3:
            if (pos + 3 >= arrayLength) {
              return false;
            }
            len = (c >>> 2) + 1;
            offset = array2[pos] + (array2[pos + 1] << 8) + (array2[pos + 2] << 16) + (array2[pos + 3] << 24);
            pos += 4;
            break;
          default:
            break;
        }
        if (offset === 0 || offset > outPos) {
          return false;
        }
        selfCopyBytes(outBuffer, outPos, offset, len);
        outPos += len;
      }
    }
    return true;
  };
  function isNode() {
    if (typeof process === "object") {
      if (typeof process.versions === "object") {
        if (typeof process.versions.node !== "undefined") {
          return true;
        }
      }
    }
    return false;
  }
  function isUint8Array(object2) {
    return object2 instanceof Uint8Array && (!isNode() || !Buffer.isBuffer(object2));
  }
  function isArrayBuffer(object2) {
    return object2 instanceof ArrayBuffer;
  }
  function isBuffer2(object2) {
    if (!isNode()) {
      return false;
    }
    return Buffer.isBuffer(object2);
  }
  var TYPE_ERROR_MSG = "Argument compressed must be type of ArrayBuffer, Buffer, or Uint8Array";
  function uncompress(compressed) {
    if (!isUint8Array(compressed) && !isArrayBuffer(compressed) && !isBuffer2(compressed)) {
      throw new TypeError(TYPE_ERROR_MSG);
    }
    var uint8Mode = false;
    var arrayBufferMode = false;
    if (isUint8Array(compressed)) {
      uint8Mode = true;
    } else if (isArrayBuffer(compressed)) {
      arrayBufferMode = true;
      compressed = new Uint8Array(compressed);
    }
    var decompressor = new SnappyDecompressor(compressed);
    var length2 = decompressor.readUncompressedLength();
    if (length2 === -1) {
      throw new Error("Invalid Snappy bitstream");
    }
    var uncompressed, uncompressedView;
    if (uint8Mode) {
      uncompressed = new Uint8Array(length2);
      if (!decompressor.uncompressToBuffer(uncompressed)) {
        throw new Error("Invalid Snappy bitstream");
      }
    } else if (arrayBufferMode) {
      uncompressed = new ArrayBuffer(length2);
      uncompressedView = new Uint8Array(uncompressed);
      if (!decompressor.uncompressToBuffer(uncompressedView)) {
        throw new Error("Invalid Snappy bitstream");
      }
    } else {
      uncompressed = Buffer.alloc(length2);
      if (!decompressor.uncompressToBuffer(uncompressed)) {
        throw new Error("Invalid Snappy bitstream");
      }
    }
    return uncompressed;
  }
  var snappyJs_default = uncompress;

  // Source/custom/utils/TextureQueue.js
  var TextureQueue = class {
    constructor(gl, size) {
      this.gl = gl;
      this.queue = [];
      this.map = {};
      this.intZoomMap = {};
      this.intZoomCountMap = {};
      this.size = 2e3;
      if (size || size == 0) {
        this.size = size;
      }
    }
    add(key2, zoom, styleZoom, item) {
      let id = zoom + "_" + styleZoom + "_" + key2;
      if (!this.map[id]) {
        if (this.queue.length == this.size) {
          let obj = this.queue.shift();
          delete this.map[obj.id];
          this.gl.deleteTexture(obj.value);
          this.intZoomCountMap[obj.key] = this.intZoomCountMap[obj.key] - 1;
          if (!this.intZoomCountMap[obj.key]) {
            delete this.intZoomMap[obj.key];
          }
        }
        this.queue.push({ id, key: key2, value: item });
        this.map[id] = item;
        this.intZoomMap[key2] = item;
        let count = this.intZoomCountMap[key2];
        if (!count) {
          this.intZoomCountMap[key2] = 1;
        } else {
          this.intZoomCountMap[key2] = count + 1;
        }
      }
    }
    getOne(key2, zoom, styleZoom) {
      let id = zoom + "_" + styleZoom + "_" + key2;
      if (this.map[id]) {
        return this.map[id];
      }
      return null;
    }
    get(key2, zoom, styleZoom) {
      let id = zoom + "_" + styleZoom + "_" + key2;
      if (this.map[id]) {
        return this.map[id];
      } else {
        return this.intZoomMap[key2];
      }
    }
    remove(key2) {
      let removeObjs = [];
      for (let i = 0; i < this.queue.length; i++) {
        let item = this.queue[i];
        if (key2 == item.key) {
          this.queue.splice(i, 1);
          removeObjs.push(item);
        }
      }
      for (let j = 0; j < removeObjs.length; j++) {
        let obj = removeObjs[j];
        delete this.map[obj.id];
        this.gl.deleteTexture(obj.value);
      }
      this.intZoomCountMap[key2] = 0;
      delete this.intZoomMap[key2];
    }
    setSize(size) {
      this.size = size;
      this.empty();
    }
    empty() {
      for (let i = 0; i < this.queue.length; i++) {
        let obj = this.queue[i];
        this.gl.deleteTexture(obj.value);
      }
      for (let key2 in this.intZoomMap) {
        let item = this.intZoomMap[key2];
        this.gl.deleteTexture(item);
      }
      this.queue = [];
      this.map = {};
      this.intZoomMap = {};
      this.intZoomCountMap = {};
    }
  };
  var TextureQueue_default = TextureQueue;

  // Source/custom/utils/uuid.js
  function UUID() {
    this.id = this.createUUID();
  }
  UUID.prototype.valueOf = function() {
    return this.id;
  };
  UUID.prototype.toString = function() {
    return this.id;
  };
  UUID.prototype.createUUID = function() {
    var c = new Date(1582, 10, 15, 0, 0, 0, 0);
    var f = new Date();
    var h = f.getTime() - c.getTime();
    var i = UUID.getIntegerBits(h, 0, 31);
    var g = UUID.getIntegerBits(h, 32, 47);
    var e = UUID.getIntegerBits(h, 48, 59) + "2";
    var b = UUID.getIntegerBits(UUID.rand(4095), 0, 7);
    var d = UUID.getIntegerBits(UUID.rand(4095), 0, 7);
    var a2 = UUID.getIntegerBits(UUID.rand(8191), 0, 7) + UUID.getIntegerBits(UUID.rand(8191), 8, 15) + UUID.getIntegerBits(UUID.rand(8191), 0, 7) + UUID.getIntegerBits(UUID.rand(8191), 8, 15) + UUID.getIntegerBits(UUID.rand(8191), 0, 15);
    return i + g + e + b + d + a2;
  };
  UUID.getIntegerBits = function(f, g, b) {
    var a2 = UUID.returnBase(f, 16);
    var d = new Array();
    var e = "";
    var c = 0;
    for (c = 0; c < a2.length; c++) {
      d.push(a2.substring(c, c + 1));
    }
    for (c = Math.floor(g / 4); c <= Math.floor(b / 4); c++) {
      if (!d[c] || d[c] == "") {
        e += "0";
      } else {
        e += d[c];
      }
    }
    return e;
  };
  UUID.returnBase = function(c, d) {
    var e = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z"
    ];
    if (c < d) {
      var b = e[c];
    } else {
      var f = "" + Math.floor(c / d);
      var a2 = c - f * d;
      if (f >= d) {
        var b = this.returnBase(f, d) + e[a2];
      } else {
        var b = e[f] + e[a2];
      }
    }
    return b;
  };
  UUID.rand = function(a2) {
    return Math.floor(Math.random() * a2);
  };
  var uuid_default = UUID;

  // Source/custom/utils/VarintReader.js
  var VarintReader = class {
    constructor(vectorVarintBuffer, headerLength, proSizeObj) {
      this.headerLength = headerLength;
      this.proSizeObj = proSizeObj;
      this.intLength = 4;
      this.vectorName = "vector";
      this.gTypeKey = "gType";
      this.encoding = "utf8";
      this.featureSpace = "#@";
      this.vectorVarintBuffer = vectorVarintBuffer;
      this.layerMap = new Object();
      this.vectorHeaderProMap = new Object();
      this.layerHeaderProMap = new Object();
      this.layerHeaderProBuffer = new Object();
      this.geometyTypeMap = new Object();
      this.featureMap = new Object();
      this.featureArrayMap = new Object();
      this.offsetBufferMap = new Object();
      this.offsetArrayMap = new Object();
      this.varintMap = new Object();
      this._parseVector(vectorVarintBuffer);
    }
    getVectorHeaderProMap() {
      return this.vectorHeaderProMap;
    }
    getLayerHeaderProMap() {
      return this.layerHeaderProMap;
    }
    getLayerBuffer(layerName) {
      return this.layerMap[layerName];
    }
    getLayerProByFilter(layerName, featureIndexArray) {
      let coordinateBufferArray = [];
      let offsetArray = this.offsetArrayMap[layerName];
      let featureArray = this._lazyParseFeature(layerName);
      let filterArray = [];
      let idx;
      let offset;
      let length2;
      let proSize = this.proSizeObj[layerName];
      for (let i = 0; i < featureIndexArray.length; i++) {
        idx = featureIndexArray[i];
        filterArray.push(...featureArray[idx]);
        offset = offsetArray[idx * 2];
        length2 = offsetArray[idx * 2 + 1];
        coordinateBufferArray.push(this.varintMap[layerName].slice(offset, offset + length2));
      }
      let model = new LayerContentModel_default();
      model.setLayerHeaderProBuffer(this.layerHeaderProBuffer[layerName]);
      model.setFeatureArray(filterArray);
      model.setCoordinateBufferArray(coordinateBufferArray);
      return model;
    }
    getAllLayerNames() {
      let layerNames = [];
      for (let value in this.layerMap) {
        layerNames.push(value);
      }
      return layerNames;
    }
    getGeometryType(layerName) {
      return this.geometyTypeMap[layerName];
    }
    getLayerProByIndex(layerName, featureIndex) {
      let featureArray = this._lazyParseFeature(layerName);
      return featureArray[featureIndex];
    }
    getLayerPro(layerName) {
      return this._lazyParseFeature(layerName);
    }
    getOffsetArray(layerName) {
      return this.offsetArrayMap[layerName];
    }
    getOffsetByIndex(layerName, featureIndex) {
      let all = this.offsetArrayMap[layerName];
      let arr2 = [];
      arr2.push(all[featureIndex * 2]);
      arr2.push(all[featureIndex * 2 + 1]);
      return arr2;
    }
    getLayerCoordinate(layerName) {
      return this.varintMap[layerName];
    }
    getLayerFeature(layerName) {
      return [this.featureMap[layerName], this.offsetArrayMap[layerName], this.varintMap[layerName]];
    }
    getAllCoordinates(layerName, precision) {
      let ofs = this.offsetArrayMap[layerName];
      let buffer4 = this.varintMap[layerName];
      let coorArray = [];
      let offset;
      let length2;
      let bf;
      for (let i = 0; i < ofs.length / 2; i++) {
        offset = ofs[i * 2];
        length2 = ofs[i * 2 + 1];
        bf = buffer4.slice(offset, offset + length2);
        coorArray.push(this._bufferToDoubleArray(bf, precision)[0]);
      }
      return coorArray;
    }
    getCoordinatesByIndex(layerName, proIndex, precision) {
      let ofs = this.getOffsetByIndex(layerName, proIndex);
      let buffer4 = this.varintMap[layerName];
      let offset = ofs[0];
      let length2 = ofs[1];
      let bf = buffer4.slice(offset, offset + length2);
      return this._bufferToDoubleArray(bf, precision)[0];
    }
    _parseVector(vectorVarintBuffer) {
      let offset = this.headerLength;
      let typeLength = vectorVarintBuffer.readInt32BE(offset);
      offset = offset + this.intLength;
      let type = vectorVarintBuffer.slice(offset, offset + typeLength).toString("utf-8");
      offset = offset + typeLength;
      if (type !== this.vectorName) {
        console.error("\u4E0D\u662F\u74E6\u7247\u6570\u636E\uFF01");
        return;
      }
      let array2 = this._parseHeaderPro(vectorVarintBuffer, offset);
      offset = array2[0];
      this.vectorHeaderProMap = array2[1];
      let indexLength = vectorVarintBuffer.readInt32BE(offset);
      offset = offset + this.intLength;
      let indexBuffer = vectorVarintBuffer.slice(offset, offset + indexLength);
      offset = offset + indexLength;
      let dataBuffer = vectorVarintBuffer.slice(offset, this.vectorVarintBuffer.length);
      let layerNameLength = 0;
      let layerName;
      let dataLength;
      let dataBegin = 0;
      let begin = 0;
      let end = 0;
      let layerBuffer;
      for (let i = 0; i < indexBuffer.length; ) {
        begin = i;
        layerNameLength = indexBuffer.readInt32BE(begin);
        begin = begin + this.intLength;
        end = begin + layerNameLength;
        layerName = indexBuffer.toString(this.encoding, begin, end);
        begin = end;
        dataLength = indexBuffer.readInt32BE(begin);
        begin = begin + this.intLength;
        layerBuffer = dataBuffer.slice(dataBegin, dataBegin + dataLength);
        dataBegin = dataBegin + dataLength;
        this.layerMap[layerName] = layerBuffer;
        this._parseLayer(layerName, layerBuffer);
        i = begin;
      }
    }
    _parseLayer(layerName, layerBuffer) {
      if (layerBuffer.length === 0) {
        return;
      }
      let offset = this.headerLength;
      let array2 = this._parseHeaderPro(layerBuffer, offset);
      offset = array2[0];
      this.layerHeaderProMap[layerName] = array2[1];
      this.layerHeaderProBuffer[layerName] = array2[2];
      let geometrytype = this.layerHeaderProMap[layerName][this.gTypeKey];
      this.geometyTypeMap[layerName] = geometrytype;
      let featureLength = layerBuffer.readInt32BE(offset);
      offset = offset + this.intLength;
      let featureBuffer = layerBuffer.slice(offset, offset + featureLength);
      featureBuffer = snappyJs_default(featureBuffer);
      offset = offset + featureLength;
      this.featureMap[layerName] = featureBuffer;
      let indexRes = this._parseIndex(layerBuffer, offset);
      offset = indexRes.offset;
      this.offsetBufferMap[layerName] = indexRes.buffer;
      this.offsetArrayMap[layerName] = indexRes.array;
      let varintBuf = layerBuffer.slice(offset);
      this.varintMap[layerName] = varintBuf;
    }
    _parseHeaderPro(varintBuffer, offset) {
      let proMap = new Object();
      let headerProLength = varintBuffer.readInt32BE(offset);
      offset = offset + this.intLength;
      let headerProBuffer = varintBuffer.slice(offset, offset + headerProLength);
      offset = offset + headerProLength;
      if (headerProLength == 0) {
        return [offset, proMap];
      }
      let headerProArray = GisTools_default.Utf8ArrayToStr(snappyJs_default(headerProBuffer)).split(":");
      for (let i = 0; i < headerProArray.length / 2; i++) {
        proMap[headerProArray[i * 2]] = headerProArray[i * 2 + 1];
      }
      return [offset, proMap, headerProBuffer];
    }
    _parseIndex(layerBuffer, offset) {
      let length2 = layerBuffer.readInt32BE(offset);
      offset = offset + this.intLength;
      let buffer4 = layerBuffer.slice(offset, offset + length2);
      offset = offset + length2;
      let array2 = CodeTool_default.varintToIntArray(buffer4);
      return {
        "offset": offset,
        "buffer": buffer4,
        "array": array2
      };
    }
    _lazyParseFeature(layerName) {
      let featureArray = this.featureArrayMap[layerName];
      let proSize = this.proSizeObj[layerName];
      if (featureArray == void 0) {
        let buffer4 = this.featureMap[layerName];
        let props = [];
        if (buffer4.length > 0) {
          props = GisTools_default.Utf8ArrayToStr(this.featureMap[layerName]).split(this.featureSpace);
        } else {
          this.featureArrayMap[layerName] = [];
          return [];
        }
        let item = [];
        let length2 = (props.length - 1) / proSize;
        featureArray = [];
        let current = 0;
        let next = current;
        for (let i = 0; i < length2; i++) {
          next = current + proSize;
          item = props.slice(current, next);
          featureArray.push(item);
          current = next;
        }
        this.featureArrayMap[layerName] = featureArray;
      }
      return featureArray;
    }
    _bufferToDoubleArray(buffer4, precision) {
      let varintCode = [];
      let path = [];
      let high;
      let bf_index = 0;
      let nums = [];
      let oldX = 0;
      let oldY = 0;
      let x3;
      let y3;
      let isX = true;
      for (let i = 0; i <= buffer4.length; i++) {
        high = 0 | buffer4[i] >> 7 & 1;
        if (high === 0 && bf_index > 0) {
          if (bf_index > 0 && bf_index <= 5) {
            if (isX) {
              x3 = CodeTool_default.varintToInt(varintCode) + oldX;
              path.push(x3 / precision);
              isX = false;
              oldX = x3;
            } else {
              y3 = CodeTool_default.varintToInt(varintCode) + oldY;
              path.push(y3 / precision);
              isX = true;
              oldY = y3;
            }
            bf_index = 0;
            varintCode = [];
          } else if (bf_index > 5) {
            oldX = 0;
            oldY = 0;
            bf_index = 0;
            varintCode = [];
            nums.push(path);
            path = [];
          }
        }
        if (i !== buffer4.length) {
          varintCode.push(buffer4[i]);
          bf_index++;
        } else {
          if (path.length > 0) {
            nums.push(path);
          }
        }
      }
      return nums;
    }
  };
  var VarintReader_default = VarintReader;

  // Source/custom/utils/Wkt.js
  var Wkt = class {
    constructor() {
      this.ingest = {
        point: function(str) {
          var coords = this.trim(str).split(this.regExes.spaces);
          return [{
            x: parseFloat(this.regExes.numeric.exec(coords[0])[0]),
            y: parseFloat(this.regExes.numeric.exec(coords[1])[0])
          }];
        },
        multipoint: function(str) {
          var i, components, points;
          components = [];
          points = this.trim(str).split(this.regExes.comma);
          for (i = 0; i < points.length; i += 1) {
            components.push(this.ingest.point.apply(this, [points[i]]));
          }
          return components;
        },
        linestring: function(str) {
          var i, multipoints, components;
          multipoints = this.ingest.multipoint.apply(this, [str]);
          components = [];
          for (i = 0; i < multipoints.length; i += 1) {
            components = components.concat(multipoints[i]);
          }
          return components;
        },
        multilinestring: function(str) {
          var i, components, line, lines;
          components = [];
          lines = this.trim(str).split(this.regExes.doubleParenComma);
          if (lines.length === 1) {
            lines = this.trim(str).split(this.regExes.parenComma);
          }
          for (i = 0; i < lines.length; i += 1) {
            line = this._stripWhitespaceAndParens(lines[i]);
            components.push(this.ingest.linestring.apply(this, [line]));
          }
          return components;
        },
        polygon: function(str) {
          var i, j, components, subcomponents, ring, rings;
          rings = this.trim(str).split(this.regExes.parenComma);
          components = [];
          for (i = 0; i < rings.length; i += 1) {
            ring = this._stripWhitespaceAndParens(rings[i]).split(this.regExes.comma);
            subcomponents = [];
            for (j = 0; j < ring.length; j += 1) {
              var split = ring[j].split(this.regExes.spaces);
              if (split.length > 2) {
                split = split.filter(function(n) {
                  return n != "";
                });
              }
              if (split.length === 2) {
                var x_cord = split[0];
                var y_cord = split[1];
                subcomponents.push({
                  x: parseFloat(x_cord),
                  y: parseFloat(y_cord)
                });
              }
            }
            components.push(subcomponents);
          }
          return components;
        },
        box: function(str) {
          var i, multipoints, components;
          multipoints = this.ingest.multipoint.apply(this, [str]);
          components = [];
          for (i = 0; i < multipoints.length; i += 1) {
            components = components.concat(multipoints[i]);
          }
          return components;
        },
        multipolygon: function(str) {
          var i, components, polygon2, polygons;
          components = [];
          polygons = this.trim(str).split(this.regExes.doubleParenComma);
          for (i = 0; i < polygons.length; i += 1) {
            polygon2 = this._stripWhitespaceAndParens(polygons[i]);
            components.push(this.ingest.polygon.apply(this, [polygon2]));
          }
          return components;
        }
      };
      this.regExes = {
        "typeStr": /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
        "spaces": /\s+|\+/,
        "numeric": /-*\d+(\.*\d+)?/,
        "comma": /\s*,\s*/,
        "parenComma": /\)\s*,\s*\(/,
        "coord": /-*\d+\.*\d+ -*\d+\.*\d+/,
        "doubleParenComma": /\)\s*\)\s*,\s*\(\s*\(/,
        "ogcTypes": /^(multi)?(point|line|polygon|box)?(string)?$/i,
        "crudeJson": /^{.*"(type|coordinates|geometries|features)":.*}$/,
        "collectionParse": /,(?=[a-zA-Z])/
      };
      this.components = void 0;
    }
    read(str) {
      var matches;
      matches = this.regExes.typeStr.exec(str);
      if (matches) {
        this.type = matches[1].toLowerCase();
        this.base = matches[2];
        if (this.ingest[this.type]) {
          this.components = this.ingest[this.type].apply(this, [this.base]);
        } else {
          this.base = this.base.split(this.regExes.collectionParse);
        }
      }
      return this;
    }
    readToPrimitives(str, option) {
      option = option ? option : {};
      option.asynchronous = option.asynchronous ? option.asynchronous : false;
      option.clampToGround = option.clampToGround ? option.clampToGround : false;
      option.fillColor = option.fillColor ? option.fillColor : "#ff0000";
      option.fillOpacity = option.fillOpacity ? option.fillOpacity : 1;
      option.pixelSize = option.pixelSize ? option.pixelSize : 10;
      option.strokeColor = option.strokeColor ? option.strokeColor : "#ff0000";
      option.strokeOpacity = option.strokeOpacity ? option.strokeOpacity : 1;
      option.lineWidth = option.lineWidth ? option.lineWidth : 2;
      option.outlineWidth = option.outlineWidth ? option.outlineWidth : 0;
      let geometryArray = [str];
      let m = this.regExes.typeStr.exec(str);
      if (m) {
        let geometryType = m[1].toLowerCase();
        if (geometryType == "geometrycollection") {
          geometryArray = m[2].split(this.regExes.collectionParse);
        }
      }
      let pointInstances = [];
      let lineInstances = [];
      let polygonInstances = [];
      for (let i = 0; i < geometryArray.length; i++) {
        var matches = this.regExes.typeStr.exec(geometryArray[i]);
        if (matches) {
          this.type = matches[1].toLowerCase();
          this.base = matches[2];
          if (this.ingest[this.type]) {
            this.components = this.ingest[this.type].apply(this, [this.base]);
          }
        }
        pointInstances = pointInstances.concat(this.getPointInstances(option));
        lineInstances = lineInstances.concat(this.getLineInstances(option));
        polygonInstances = polygonInstances.concat(this.getPolygonInstances(option));
      }
      let pointPrimitive = this.getPointPrimitive(pointInstances, option);
      let linePrimitive = this.getLinePrimitive(lineInstances, option);
      let polygonPrimitive = this.getPolygonPrimitive(polygonInstances, option);
      let primitives = [];
      if (pointPrimitive) {
        primitives.push(pointPrimitive);
      }
      if (linePrimitive) {
        primitives.push(linePrimitive);
      }
      if (polygonPrimitive) {
        primitives.push(polygonPrimitive);
      }
      return primitives;
    }
    getPointInstances(option) {
      if (this.type != "point") {
        return [];
      }
      return this.components;
    }
    getPointPrimitive(instances, option) {
      if (instances.length == 0) {
        return null;
      }
      let pointPrimitives = new Cesium.PointPrimitiveCollection();
      for (let i = 0; i < instances.length; i++) {
        pointPrimitives.add({
          pixelSize: option.pixelSize,
          color: Cesium.Color.fromCssColorString(option.fillColor).withAlpha(option.fillOpacity),
          outlineColor: Cesium.Color.fromCssColorString(option.strokeColor).withAlpha(option.strokeOpacity),
          outlineWidth: option.outlineWidth,
          position: Cesium.Cartesian3.fromDegrees(instances[i].x, instances[i].y, 0)
        });
      }
      return pointPrimitives;
    }
    getLineInstances(option) {
      let ls = [];
      if (this.type == "linestring") {
        ls.push(this.createLine(this.components));
      }
      if (this.type == "multilinestring") {
        for (let i = 0; i < this.components.length; i++) {
          ls.push(this.createLine(this.components[i]));
        }
      }
      let geometryInstances = [];
      for (let j = 0; j < ls.length; j++) {
        let geometryInstance = null;
        if (option.clampToGround) {
          geometryInstance = new Cesium.GeometryInstance({
            geometry: new Cesium.GroundPolylineGeometry({
              positions: Cesium.Cartesian3.fromDegreesArray(ls[j]),
              width: option.lineWidth
            }),
            attributes: {
              color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString(option.strokeColor).withAlpha(option.strokeOpacity))
            }
          });
        } else {
          geometryInstance = new Cesium.GeometryInstance({
            geometry: new Cesium.PolylineGeometry({
              positions: Cesium.Cartesian3.fromDegreesArray(ls[j]),
              width: option.lineWidth
            }),
            attributes: {
              color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString(option.strokeColor).withAlpha(option.strokeOpacity))
            }
          });
        }
        geometryInstances.push(geometryInstance);
      }
      return geometryInstances;
    }
    getLinePrimitive(geometryInstances, option) {
      if (geometryInstances.length == 0) {
        return null;
      }
      let primitive = null;
      if (option.clampToGround) {
        primitive = new Cesium.GroundPolylinePrimitive({
          asynchronous: option.asynchronous,
          geometryInstances,
          appearance: new Cesium.PolylineColorAppearance({
            flat: true,
            translucent: false
          })
        });
      } else {
        primitive = new Cesium.Primitive({
          asynchronous: option.asynchronous,
          geometryInstances,
          appearance: new Cesium.PolylineColorAppearance({
            flat: true,
            translucent: false
          })
        });
      }
      return primitive;
    }
    createLine(components) {
      let lpts = [];
      for (let i = 0; i < components.length; i++) {
        let pt = components[i];
        lpts.push(pt.x);
        lpts.push(pt.y);
      }
      return lpts;
    }
    getPolygonInstances(option) {
      let ps = [];
      if (this.type == "polygon") {
        ps.push(this.createPolygon(this.components));
      }
      if (this.type == "multipolygon") {
        for (let i = 0; i < this.components.length; i++) {
          ps.push(this.createPolygon(this.components[i]));
        }
      }
      let geometryInstances = [];
      for (let j = 0; j < ps.length; j++) {
        let py = ps[j];
        let positions = Cesium.Cartesian3.fromDegreesArray(py.pts);
        let holes = [];
        for (let m = 0; m < py.holes.length; m++) {
          holes.push({ positions: Cesium.Cartesian3.fromDegreesArray(py.holes[m]) });
        }
        let polygonInstance = new Cesium.GeometryInstance({
          geometry: new Cesium.PolygonGeometry({
            polygonHierarchy: {
              positions,
              holes
            },
            vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,
            height: 0
          }),
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString(option.fillColor).withAlpha(option.fillOpacity))
          }
        });
        geometryInstances.push(polygonInstance);
      }
      return geometryInstances;
    }
    getPolygonPrimitive(geometryInstances, option) {
      if (geometryInstances.length == 0) {
        return null;
      }
      let primitive = null;
      if (option.clampToGround) {
        primitive = new Cesium.GroundPrimitive({
          asynchronous: option.asynchronous,
          geometryInstances,
          appearance: new Cesium.PerInstanceColorAppearance({
            translucent: false,
            closed: true
          })
        });
      } else {
        primitive = new Cesium.Primitive({
          asynchronous: option.asynchronous,
          geometryInstances,
          appearance: new Cesium.PerInstanceColorAppearance({
            translucent: false,
            closed: true
          })
        });
      }
      return primitive;
    }
    createPolygon(components) {
      let pts = [];
      let holes = [];
      let polygon2 = { pts, holes };
      for (let i = 0; i < components.length; i++) {
        let component = components[i];
        if (i == 0) {
          for (let j = 0; j < component.length; j++) {
            let item = component[j];
            pts.push(item.x);
            pts.push(item.y);
          }
        } else {
          let hpts = [];
          for (let m = 0; m < component.length; m++) {
            let pt = component[m];
            hpts.push(pt.x);
            hpts.push(pt.y);
          }
          holes.push(hpts);
        }
      }
      return polygon2;
    }
    beginsWith(str, sub) {
      return str.substring(0, sub.length) === sub;
    }
    endsWith(str, sub) {
      return str.substring(str.length - sub.length) === sub;
    }
    trim(str, sub) {
      sub = sub || " ";
      while (this.beginsWith(str, sub)) {
        str = str.substring(1);
      }
      while (this.endsWith(str, sub)) {
        str = str.substring(0, str.length - 1);
      }
      return str;
    }
    _stripWhitespaceAndParens(fullStr) {
      var trimmed = fullStr.trim();
      var noParens = trimmed.replace(/^\(?(.*?)\)?$/, "$1");
      return noParens;
    }
  };
  var Wkt_default = Wkt;

  // Source/custom/video/Shader.js
  var shaderText = `
uniform float mixNum;
uniform sampler2D colorTexture;
uniform sampler2D stcshadow; 
uniform sampler2D videoTexture;
uniform sampler2D maskTexture;
uniform sampler2D depthTexture;
uniform float useMask;
uniform mat4 _shadowMap_matrix; 
uniform vec4 shadowMap_lightPositionEC; 
uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; 
uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; 
varying vec2 v_textureCoordinates;

vec4 toEye(in vec2 uv, in float depth){
  vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));
  vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);
  posInCamera =posInCamera / posInCamera.w;
  return posInCamera;
}
float getDepth(in vec4 depth){
  float z_window = czm_unpackDepth(depth);
  z_window = czm_reverseLogDepth(z_window);
  float n_range = czm_depthRange.near;
  float f_range = czm_depthRange.far;
  return (2.0 * z_window - n_range - f_range) / (f_range - n_range);
}

float _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){
  return texture2D(shadowMap, uv).r;
}
float _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){
  return step(depth, _czm_sampleShadowMap(shadowMap, uv));
}
float _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){
  float depthBias = shadowParameters.depthBias;
  float depth = shadowParameters.depth;
  float nDotL = shadowParameters.nDotL;
  float normalShadingSmooth = shadowParameters.normalShadingSmooth;
  float darkness = shadowParameters.darkness;
  vec2 uv = shadowParameters.texCoords;
  depth -= depthBias;
  vec2 texelStepSize = shadowParameters.texelStepSize;
  float radius = 1.0;
  float dx0 = -texelStepSize.x * radius;
  float dy0 = -texelStepSize.y * radius;
  float dx1 = texelStepSize.x * radius;
  float dy1 = texelStepSize.y * radius;
  float visibility =(
    _czm_shadowDepthCompare(shadowMap, uv, depth)
  +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +
  _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +
  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +
  _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +
    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +
    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +
  _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +
    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth))* (1.0 / 9.0);
  return visibility;
}

void main()
{
  const float PI = 3.141592653589793;
  vec4 color = texture2D(colorTexture, v_textureCoordinates);
  vec4 currD = texture2D(depthTexture, v_textureCoordinates);
  if(currD.r>=1.0){
    gl_FragColor = color;
    return;
  }

  float depth = getDepth(currD);
  vec4 positionEC = toEye(v_textureCoordinates, depth);
  vec3 normalEC = vec3(1.0);
  czm_shadowParameters shadowParameters;
  shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy;
  shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z;
  shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w;
  shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w;
  shadowParameters.depthBias *= max(depth * 0.01, 1.0);
  vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz);
  float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0);
  vec4 shadowPosition = _shadowMap_matrix * positionEC;
  shadowPosition /= shadowPosition.w;
  if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))){
    gl_FragColor = color;
    return;
  }
  shadowParameters.texCoords = shadowPosition.xy;
  shadowParameters.depth = shadowPosition.z;
  shadowParameters.nDotL = nDotL;
  float visibility = _czm_shadowVisibility(stcshadow, shadowParameters);
  vec4 videoColor = texture2D(videoTexture,shadowPosition.xy);
  if (useMask > 0.) {
    vec4 maskColor = texture2D(maskTexture,shadowPosition.xy);            
    videoColor *= maskColor;  
  }
  if(visibility==1.0){
    gl_FragColor = mix(color,vec4(videoColor.xyz,1.0),mixNum*videoColor.a);
  }else{
    if(abs(shadowPosition.z-0.0)<0.01){
      return;
    }
    gl_FragColor = color;
  }
}
`;
  var Shader_default = shaderText;

  // Source/custom/video/Video.js
  var defer4 = Cesium.defer;
  var defaultOptions = {
    position: false,
    near: 0.5,
    far: 1e3,
    fov: 30,
    aspectRatio: 1.5,
    heading: 0,
    pitch: -20,
    alpha: 0.6,
    videoSource: false,
    debug: false,
    useMask: true,
    maskUrl: ""
  };
  function Video(viewer3, option = {}) {
    this.viewer = viewer3;
    this._offsetDis = option.offsetDis ? option.offsetDis : 0;
    this._roll = option.roll ? option.roll : 0;
    option = this._parseOption({
      ...defaultOptions,
      ...option
    });
    this._cameraPosition = option.cameraPosition;
    this._position = option.position;
    this._viewPosition = option.viewPosition;
    this._orientation = null;
    this._alpha = option.alpha;
    this._videoSource = option.videoSource;
    this._videoType = option.videoType;
    this._debug = option.debug;
    this._camerafov = option.fov;
    this._aspectRatio = option.aspectRatio;
    this._videoPlay = option.videoPlay;
    this._show = option.show;
    this._useMask = option.useMask;
    this._maskUrl = option.maskUrl;
    this._heading = option.heading;
    this._pitch = option.pitch;
    this._near = option.near;
    this._far = option.far;
    this._shadowMap = null;
    this._postProcess = null;
    this._videoTexture = null;
    this._maskTexture = null;
    this._cameraFrustum = null;
    this._videoEle = null;
    this._readyPromise = Cesium.defer();
    this._updateOffsetDis(this._offsetDis);
    this._init();
  }
  Object.defineProperties(Video.prototype, {
    readyPromise: {
      get: function() {
        return this._readyPromise.promise;
      }
    },
    alpha: {
      get: function() {
        return this._alpha;
      },
      set: function(value) {
        return this._alpha = value;
      }
    },
    position: {
      get: function() {
        return this._position;
      },
      set: function(value) {
        this._position = value;
        this._onChangeCameraParam();
      }
    },
    positionX: {
      get: function() {
        return this._position.x;
      },
      set: function(value) {
        this.position = {
          ...this.position,
          x: parseFloat(value)
        };
        this._onChangeCameraParam();
      }
    },
    positionY: {
      get: function() {
        return this._position.y;
      },
      set: function(value) {
        this.position = {
          ...this.position,
          y: parseFloat(value)
        };
        this._onChangeCameraParam();
      }
    },
    positionZ: {
      get: function() {
        return this._position.z;
      },
      set: function(value) {
        this.position = {
          ...this.position,
          z: parseFloat(value)
        };
        this._onChangeCameraParam();
      }
    },
    aspectRatio: {
      get: function() {
        return this._aspectRatio;
      },
      set: function(value) {
        if (value !== this._aspectRatio) {
          this._aspectRatio = value;
          this._onChangeVideoAspectRatio();
        }
      }
    },
    debug: {
      get: function() {
        return this._debug;
      },
      set: function(value) {
        this._debug = !!value;
        this._onChangeCameraParam();
      }
    },
    fov: {
      get: function() {
        return this._camerafov;
      },
      set: function(value) {
        if (this._camerafov !== value) {
          this._camerafov = value;
          this._onChangeCameraFov();
        }
      }
    },
    near: {
      get: function() {
        return this._near;
      },
      set: function(value) {
        if (this._near !== value) {
          this._near = value;
          this._onChangeCameraParam();
        }
      }
    },
    far: {
      get: function() {
        return this._far;
      },
      set: function(value) {
        if (this._far !== value) {
          this._far = value;
          this._onChangeCameraParam();
        }
      }
    },
    heading: {
      get: function() {
        return this._heading;
      },
      set: function(value) {
        if (this._heading !== value) {
          this._heading = value;
          this._onChangeCameraParam();
        }
      }
    },
    pitch: {
      get: function() {
        return this._pitch;
      },
      set: function(value) {
        if (this._pitch !== value) {
          this._pitch = value;
          this._onChangeCameraParam();
        }
      }
    },
    offsetDis: {
      get: function() {
        return this._offsetDis;
      },
      set: function(value) {
        if (this._offsetDis !== value) {
          this._offsetDis = value;
          this._onChangeCameraParam();
        }
      }
    },
    roll: {
      get: function() {
        return this._roll;
      },
      set: function(value) {
        if (this._roll !== value) {
          this._roll = value;
          this._onChangeCameraParam();
        }
      }
    },
    cameraPosition: {
      get: function() {
        return this._cameraPosition;
      }
    },
    viewPosition: {
      get: function() {
        return this._viewPosition;
      }
    },
    videoPlay: {
      get: function() {
        return this._videoPlay;
      },
      set: function(value) {
        if (this._videoPlay !== value) {
          this._videoPlay = !!value;
          this._videoEle && (this._videoPlay ? this._videoEle.play() : this._videoEle.pause());
        }
      }
    },
    videoSource: {
      get: function() {
        return this._videoSource;
      },
      set: function(value) {
        if (this._videoSource !== value) {
          this._videoSource = value;
          this._onChangeVideoSource();
        }
      }
    },
    videoType: {
      get: function() {
        return this._videoType;
      },
      set: function(value) {
        if (this._videoType !== value) {
          this._videoType = value;
        }
      }
    },
    show: {
      get: function() {
        return this._show;
      },
      set: function(value) {
        if (this._show !== value) {
          this._show = !!value;
          this._onChangeShow();
        }
      }
    },
    useMask: {
      get: function() {
        return this._useMask;
      },
      set: function(value) {
        if (this._useMask !== value) {
          this._useMask = !!value;
          this._onChangeMask();
        }
      }
    },
    maskUrl: {
      get: function() {
        return this._maskUrl;
      },
      set: function(value) {
        if (this._maskUrl !== value) {
          this._maskUrl = value;
          this._onChangeMask();
        }
      }
    }
  });
  Video.prototype.update = function() {
    if (this._show && this._shadowMap) {
      this.viewer.scene.frameState.shadowMaps.push(this._shadowMap);
    }
  };
  Video.prototype.focus = function(option = {}) {
    if (this._shadowMap && this._viewPosition && this._cameraPosition) {
      let camera = this._shadowMap._lightCamera;
      const distance = Cesium.Cartesian3.distance(this._viewPosition, this._cameraPosition);
      const center2 = this._viewPosition;
      this.viewer.camera.flyToBoundingSphere(new Cesium.BoundingSphere(center2, distance / 2), {
        offset: new Cesium.HeadingPitchRange(camera.heading, camera.pitch),
        duration: option.duration || 1
      });
    }
  };
  Video.prototype._createPoints = function() {
    this.viewPoint = this.viewer.entities.add({
      position: this.viewPosition,
      point: {
        pixelSize: 12,
        color: Cesium.Color.RED,
        disableDepthTestDistance: Infinity
      },
      show: this.show
    });
    this.cameraPoint = this.viewer.entities.add({
      position: this.cameraPosition,
      point: {
        pixelSize: 12,
        color: Cesium.Color.BLUE,
        disableDepthTestDistance: Infinity
      },
      show: this.show
    });
  };
  Video.prototype.destroy = function() {
    if (this._isUnInit) {
      return;
    }
    this._unInit();
  };
  Video.prototype.exportParams = function() {
    const option = {
      position: {
        x: this._position.x,
        y: this._position.y,
        z: this._position.z
      },
      alpha: this._alpha,
      near: this._near,
      far: this._far,
      heading: this._heading,
      pitch: this._pitch,
      offsetDis: this._offsetDis,
      roll: this._roll,
      aspectRatio: this._aspectRatio,
      videoSource: this._videoSource instanceof HTMLVideoElement ? null : this._videoSource,
      videoType: this._videoType,
      useMask: this._useMask,
      maskUrl: this._maskUrl
    };
    console.log(JSON.stringify(option));
    return option;
  };
  Video.prototype._parseOption = function(option) {
    const { position, far, heading, pitch } = option;
    const calculatedPositions = this._calculatePositions(position, far, heading, pitch);
    return {
      ...option,
      ...calculatedPositions,
      fov: option.fov || Cesium.Math.toDegrees(this.viewer.scene.camera.frustum.fov),
      alpha: option.alpha || 1,
      videoPlay: Cesium.defaultValue(option.videoPlay, true),
      show: Cesium.defaultValue(option.show, true),
      aspectRatio: option.aspectRatio,
      maskUrl: option.maskUrl || "./img/map/mask.png"
    };
  };
  Video.prototype._calculatePositions = function(point2, far, heading, pitch) {
    const cameraPosition = Cesium.Cartesian3.fromDegrees(
      point2.x,
      point2.y,
      point2.z
    );
    let c3 = Cesium.Cartesian3.clone(cameraPosition);
    const viewPosition = this._calculateViewPositions(c3, far, heading, pitch);
    return {
      viewPosition,
      cameraPosition
    };
  };
  Video.prototype._calculateViewPositions = function(cameraPosition, far, heading, pitch) {
    let scene = this.viewer.scene;
    let camera = new Cesium.Camera(scene);
    camera.setView({
      destination: cameraPosition,
      orientation: {
        heading: Cesium.Math.toRadians(heading),
        pitch: Cesium.Math.toRadians(pitch),
        roll: 0
      }
    });
    camera.zoomIn(far);
    return camera.positionWC;
  };
  Video.prototype._addPrimitives = function() {
    this._createShadowMap();
    this._getOrientation();
    if (this._debug) {
      this._createCameraFrustum();
      this._createPoints();
    }
    this._createPostPorcessStage();
  };
  Video.prototype._updateOffsetDis = function(offsetDis) {
    let pot = Cesium.Cartesian3.subtract(this._viewPosition, this._cameraPosition, new Cesium.Cartesian3());
    let dir = Cesium.Cartesian3.normalize(pot, new Cesium.Cartesian3());
    let ray = new Cesium.Ray(this._cameraPosition, dir);
    this._cameraPosition = Cesium.Ray.getPoint(ray, offsetDis);
  };
  Video.prototype._init = function() {
    let promiseArr = [];
    let promise1 = this._createVideoTexture();
    let promise2 = this._createMaskTexture();
    if (promise1) {
      promiseArr.push(promise1);
    }
    if (promise2) {
      promiseArr.push(promise2);
    }
    if (promiseArr.length == 0) {
      this._addPrimitives();
      this._readyPromise.resolve(this);
      return;
    }
    Promise.all(promiseArr).then(function() {
      this._addPrimitives();
      this._readyPromise.resolve(this);
    }.bind(this));
  };
  Video.prototype._removePrimitives = function() {
    if (this._cameraFrustum) {
      this.viewer.scene.primitives.remove(this._cameraFrustum);
      if (!this.viewer.scene.primitives.destroyPrimitives) {
        this._cameraFrustum.destroy();
      }
    }
    if (this.viewPoint) {
      this.viewer.entities.remove(this.viewPoint);
    }
    if (this.cameraPoint) {
      this.viewer.entities.remove(this.cameraPoint);
    }
    if (this._postProcess) {
      this.viewer.scene.postProcessStages.remove(this._postProcess);
    }
    this._cameraFrustum = null;
    this._postProcess = null;
    if (this._shadowMap) {
      this._shadowMap.destroy();
      this._shadowMap = null;
    }
  };
  Video.prototype._unInit = function() {
    this.videoPlay = false;
    this._removePrimitives();
    this._destroyVideoTexture();
    this.show = false;
    this._maskTexture = null;
    this._videoTexture = null;
    this._videoEle = null;
    this._isUnInit = true;
  };
  function createVideoElement(url, deferred) {
    const source1 = document.createElement("SOURCE");
    source1.type = "video/mp4";
    source1.src = url;
    const source2 = document.createElement("SOURCE");
    source2.type = "video/quicktime";
    source2.src = url;
    const element = document.createElement("VIDEO");
    element.setAttribute("autoplay", true);
    element.setAttribute("loop", true);
    element.setAttribute("crossorigin", true);
    element.appendChild(source1);
    element.appendChild(source2);
    element.addEventListener("canplaythrough", function() {
      deferred.resolve();
    }, false);
    return element;
  }
  Video.prototype._createVideoTexture = function() {
    let video, that = this;
    let deferred = new defer4();
    deferred.promise.then(function() {
      if (video) {
        var viewer3 = that.viewer;
        if (!that._activeVideoListener) {
          that._activeVideoListener = function() {
            that._videoTexture && that._videoTexture.destroy();
            that._videoTexture = new Cesium.Texture({
              context: viewer3.scene.context,
              source: video,
              width: 1,
              height: 1,
              pixelFormat: Cesium.PixelFormat.RGBA,
              pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE
            });
          };
          viewer3.clock.onTick.addEventListener(that._activeVideoListener);
        }
        that._videoEle = video;
      }
    });
    if (this._videoSource instanceof HTMLVideoElement) {
      video = this._videoSource;
      deferred.resolve();
      return null;
    } else {
      video = createVideoElement(this._videoSource, deferred);
    }
    return deferred.promise;
  };
  Video.prototype._createMaskTexture = function(callback) {
    const that = this;
    let imagePromise = null;
    if (this._useMask) {
      if (this._maskUrl === defaultOptions.maskUrl) {
        imagePromise = this._getDefaultMaskImage();
      } else {
        imagePromise = createImage2(this._maskUrl);
      }
      imagePromise.then((maskImage) => {
        that._maskTexture = new Cesium.Texture({
          context: that.viewer.scene.context,
          source: maskImage
        });
        callback && callback.call(that);
      });
    } else {
      that._maskTexture = new Cesium.Texture({
        context: that.viewer.scene.context,
        source: null
      });
      callback && callback.call(that);
    }
    return imagePromise;
  };
  function createImage2(url) {
    return new Promise((resolve, reject) => {
      const maskImage = new Image();
      maskImage.src = url;
      maskImage.onload = function() {
        resolve(maskImage);
      };
      maskImage.onerror = function(err) {
        reject(err);
      };
    });
  }
  Video.prototype._getDefaultMaskImage = function() {
    return new Promise((resolve, reject) => {
      if (this._defaultMaskImage === null) {
        createImage2(this._maskUrl).then((image) => {
          this._defaultMaskImage = image;
          resolve(this._defaultMaskImage);
        });
      } else {
        resolve(this._defaultMaskImage);
      }
    });
  };
  Video.prototype._destroyVideoTexture = function() {
    if (this._activeVideoListener) {
      this.viewer.clock.onTick.removeEventListener(this._activeVideoListener);
      delete this._activeVideoListener;
    }
    if (this._videoTexture) {
      this._videoTexture.destroy();
    }
    if (this._maskTexture) {
      this._maskTexture.destroy();
    }
    this._videoEle = null;
    this._videoTexture = null;
    this._maskTexture = null;
  };
  Video.prototype._createShadowMap = function() {
    const cameraPosition = this.cameraPosition, position = this.viewPosition;
    const viewDis = Cesium.Cartesian3.distance(position, cameraPosition);
    let scene = this.viewer.scene;
    let camera = new Cesium.Camera(scene);
    camera.frustum = new Cesium.PerspectiveFrustum({
      fov: Cesium.Math.toRadians(this.fov),
      aspectRatio: this._aspectRatio,
      near: this._near,
      far: viewDis
    });
    camera.setView({
      destination: this.cameraPosition,
      orientation: {
        heading: Cesium.Math.toRadians(this._heading),
        pitch: Cesium.Math.toRadians(this._pitch),
        roll: Cesium.Math.toRadians(this._roll)
      }
    });
    this._shadowMap = new Cesium.ShadowMap({
      lightCamera: camera,
      enable: false,
      isPointLight: false,
      isSpotLight: true,
      cascadesEnabled: false,
      context: scene.context,
      pointLightRadius: viewDis,
      darkness: 1,
      size: 512
    });
  };
  Video.prototype._getOrientation = function() {
    let camera = this._shadowMap._lightCamera;
    let direction = camera.directionWC;
    let up = camera.upWC;
    let rightWC = camera.rightWC, cartesian3 = new Cesium.Cartesian3(), matrix3 = new Cesium.Matrix3(), quaternion = new Cesium.Quaternion();
    rightWC = Cesium.Cartesian3.negate(rightWC, cartesian3);
    Cesium.Matrix3.setColumn(matrix3, 0, rightWC, matrix3);
    Cesium.Matrix3.setColumn(matrix3, 1, up, matrix3);
    Cesium.Matrix3.setColumn(matrix3, 2, direction, matrix3);
    this._orientation = Cesium.Quaternion.fromRotationMatrix(matrix3, quaternion);
  };
  Video.prototype._createCameraFrustum = function() {
    this._cameraFrustum = new Cesium.Primitive({
      geometryInstances: new Cesium.GeometryInstance({
        geometry: new Cesium.FrustumOutlineGeometry({
          origin: this.cameraPosition,
          orientation: this._orientation,
          frustum: this._shadowMap._lightCamera.frustum,
          _drawNearPlane: true
        }),
        attributes: {
          color: Cesium.ColorGeometryInstanceAttribute.fromColor(
            new Cesium.Color(1, 0, 0)
          )
        }
      }),
      appearance: new Cesium.PerInstanceColorAppearance({
        translucent: false,
        flat: true
      }),
      asynchronous: true,
      show: this.show
    });
    this.viewer.scene.primitives.add(this._cameraFrustum);
  };
  Video.prototype._createPostPorcessStage = function() {
    const that = this, bias = this._shadowMap._isPointLight ? this._shadowMap._pointBias : this._shadowMap._primitiveBias;
    this._postProcess = new Cesium.PostProcessStage({
      fragmentShader: Shader_default,
      uniforms: {
        mixNum: function() {
          return that.alpha;
        },
        stcshadow: function() {
          return that._shadowMap._shadowMapTexture;
        },
        videoTexture: function() {
          return that._videoTexture;
        },
        useMask: function() {
          return that._useMask;
        },
        maskTexture: function() {
          return that._maskTexture;
        },
        _shadowMap_matrix: function() {
          return that._shadowMap._shadowMapMatrix;
        },
        shadowMap_lightPositionEC: function() {
          return that._shadowMap._lightPositionEC;
        },
        shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function() {
          const t = new Cesium.Cartesian2();
          return t.x = 1 / that._shadowMap._textureSize.x, t.y = 1 / that._shadowMap._textureSize.y, Cesium.Cartesian4.fromElements(
            t.x,
            t.y,
            bias.depthBias,
            bias.normalShadingSmooth,
            this.combinedUniforms1
          );
        },
        shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function() {
          return Cesium.Cartesian4.fromElements(
            bias.normalOffsetScale,
            that._shadowMap._distance,
            that._shadowMap.maximumDistance,
            that._shadowMap._darkness,
            this.combinedUniforms2
          );
        }
      }
    });
    this._postProcess.enabled = this._show;
    this.viewer.scene.postProcessStages.add(this._postProcess);
  };
  Video.prototype._updatePrimitives = function() {
    this._removePrimitives();
    this._addPrimitives();
  };
  Video.prototype._onChangeVideoAspectRatio = function() {
    this._updatePrimitives();
  };
  Video.prototype._onChangeCameraFov = function() {
    this._updatePrimitives();
  };
  Video.prototype._onChangeCameraPos = function() {
    this._updatePrimitives();
  };
  Video.prototype._onChangeViewPos = function() {
    this._updatePrimitives();
  };
  Video.prototype._onChangeShow = function() {
    if (this._cameraFrustum) {
      this._cameraFrustum.show = this._show;
    }
    if (this._postProcess) {
      this._postProcess.enabled = this._show;
    }
  };
  Video.prototype._onChangeMask = function() {
    this._createMaskTexture(function() {
      this._updatePrimitives();
    });
  };
  Video.prototype._onChangeCameraParam = function() {
    const calculatedPositions = this._calculatePositions(this._position, this._far, this.heading, this.pitch);
    this._viewPosition = calculatedPositions.viewPosition;
    this._cameraPosition = calculatedPositions.cameraPosition;
    this._updateOffsetDis(this._offsetDis);
    this._updatePrimitives();
  };
  Video.prototype._onChangeVideoSource = function() {
    this._destroyVideoTexture();
    this._createVideoTexture();
    this._updatePrimitives();
  };
  var Video_default = Video;

  // Source/custom/layer/3dtiles/Quadtree3DTilesProvider.js
  var combine2 = Cesium.combine;
  var Credit2 = Cesium.Credit;
  var defaultValue5 = Cesium.defaultValue;
  var defined5 = Cesium.defined;
  var DeveloperError4 = Cesium.DeveloperError;
  var Event2 = Cesium.Event;
  var isArray = Array.isArray;
  var Rectangle = Cesium.Rectangle;
  var Resource2 = Cesium.Resource;
  var WebMercatorTilingScheme2 = Cesium.WebMercatorTilingScheme;
  var TimeDynamicImagery = Cesium.TimeDynamicImagery;
  var Cesium3DTile = Cesium.Cesium3DTile;
  var Matrix43 = Cesium.Matrix4;
  var defer5 = Cesium.defer;
  var defaultParameters = {
    service: "WMTS",
    version: "1.0.0",
    request: "GetTile"
  };
  var Quadtree3DTilesProvider = class {
    constructor(viewer3, options, shaders) {
      this.viewer = viewer3;
      options = defaultValue5(options, defaultValue5.EMPTY_OBJECT);
      this.id = Math.random();
      if (!defined5(options.url)) {
        throw new DeveloperError4("options.url is required.");
      }
      var resource = Resource2.createIfNeeded(options.url);
      var style = options.style;
      var tileMatrixSetID = options.tileMatrixSetID;
      var url = resource.url;
      if (url.indexOf("{") >= 0) {
        var templateValues = {
          style,
          Style: style,
          TileMatrixSet: tileMatrixSetID
        };
        resource.setTemplateValues(templateValues);
        this._useKvp = false;
      } else {
        resource.setQueryParameters(defaultParameters);
        this._useKvp = true;
      }
      this._resource = resource;
      this._layer = options.layer;
      this._style = style;
      this._tileMatrixSetID = tileMatrixSetID;
      this._tileMatrixLabels = options.tileMatrixLabels;
      this._format = defaultValue5(options.format, "image/jpeg");
      this._tileDiscardPolicy = options.tileDiscardPolicy;
      this._tilingScheme = defined5(options.tilingScheme) ? options.tilingScheme : new WebMercatorTilingScheme2({ ellipsoid: options.ellipsoid });
      this._tileWidth = defaultValue5(options.tileWidth, 256);
      this._tileHeight = defaultValue5(options.tileHeight, 256);
      this._minimumLevel = defaultValue5(options.minimumLevel, 0);
      this._maximumLevel = options.maximumLevel;
      this._rectangle = defaultValue5(options.rectangle, this._tilingScheme.rectangle);
      this._dimensions = options.dimensions;
      var that = this;
      this._reload = void 0;
      if (defined5(options.times)) {
        this._timeDynamicImagery = new TimeDynamicImagery({
          clock: options.clock,
          times: options.times,
          requestImageFunction: function(x3, y3, level, request, interval) {
            return requestImage(that, x3, y3, level, request, interval);
          },
          reloadFunction: function() {
            if (defined5(that._reload)) {
              that._reload();
            }
          }
        });
      }
      this._readyPromise = defer5();
      var swTile = this._tilingScheme.positionToTileXY(Rectangle.southwest(this._rectangle), this._minimumLevel);
      var neTile = this._tilingScheme.positionToTileXY(Rectangle.northeast(this._rectangle), this._minimumLevel);
      var tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);
      if (tileCount > 4) {
        throw new DeveloperError4("The imagery provider's rectangle and minimumLevel indicate that there are " + tileCount + " tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.");
      }
      this._errorEvent = new Event2();
      var credit = options.credit;
      this._credit = typeof credit === "string" ? new Credit2(credit) : credit;
      this._subdomains = options.subdomains;
      if (isArray(this._subdomains)) {
        this._subdomains = this._subdomains.slice();
      } else if (defined5(this._subdomains) && this._subdomains.length > 0) {
        this._subdomains = this._subdomains.split("");
      } else {
        this._subdomains = ["a", "b", "c"];
      }
      let tilesetUrl = options.url.split("{z}")[0] + "tileset.json";
      this.loadRootJson(tilesetUrl).then(function(tilesetJson) {
        this.ready = {
          value: true
        };
        this._readyPromise.resolve(true);
        this.tilesetJson = tilesetJson;
        var gltfUpAxis = defined5(tilesetJson.asset.gltfUpAxis) ? Cesium.Axis.fromName(tilesetJson.asset.gltfUpAxis) : Cesium.Axis.Y;
        this._gltfUpAxis = gltfUpAxis;
      }.bind(this));
      this.cache = {};
      this.options = options;
      this.lightMap = {};
      this.showLevel = options.showLevel || 16;
      this.image = document.createElement("canvas");
      this.clippingPlanes = options.clippingPlanes;
      this._modelMatrix = defined5(options.modelMatrix) ? Matrix43.clone(options.modelMatrix) : Matrix43.clone(Matrix43.IDENTITY);
      this._heatmap = new Cesium.Cesium3DTilesetHeatmap(options.debugHeatmapTilePropertyName);
      this._imageBasedLightingFactor = new Cesium.Cartesian2(1, 1);
      Cesium.Cartesian2.clone(options.imageBasedLightingFactor, this._imageBasedLightingFactor);
      this._gltfUpAxis = void 0;
    }
    get imageBasedLightingFactor() {
      return this._imageBasedLightingFactor;
    }
    set imageBasedLightingFactor(value) {
      Cesium.Cartesian2.clone(value, this._imageBasedLightingFactor);
    }
    loadRootJson(tilesetUrl) {
      var resource = Resource2.createIfNeeded(tilesetUrl);
      return resource.fetchJson();
    }
    draw(tilesToRender) {
      let renderTileMap = this.getRenderTileMap(tilesToRender);
      let passOptions = {
        ignoreCommands: false,
        isRender: true,
        requestTiles: true
      };
      for (let name2 in renderTileMap) {
        let tile = this.cache[name2];
        if (tile) {
          tile.update(this, this.viewer.scene._frameState, passOptions);
        }
      }
    }
    getRenderTileMap(renderTiles) {
      let renderTileMap = {};
      for (let i = 0; i < renderTiles.length; i++) {
        let tileImagerys = renderTiles[i].data.imagery;
        for (let j = 0; j < tileImagerys.length; j++) {
          let tileImagery = tileImagerys[j];
          let imagery = tileImagery.readyImagery;
          if (imagery && imagery.imageryLayer._imageryProvider.id == this.id) {
            let key2 = imagery.x + "_" + imagery.y + "_" + imagery.level;
            renderTileMap[key2] = true;
          }
        }
      }
      return renderTileMap;
    }
    requestImageNow(imageryProvider, col, row, level, request, interval) {
      var labels = imageryProvider._tileMatrixLabels;
      var tileMatrix = defined5(labels) ? labels[level] : level.toString();
      var subdomains = imageryProvider._subdomains;
      var staticDimensions = imageryProvider._dimensions;
      var dynamicIntervalData = defined5(interval) ? interval.data : void 0;
      var resource;
      if (!imageryProvider._useKvp) {
        var templateValues = {
          z: tileMatrix,
          y: row.toString(),
          x: col.toString(),
          s: subdomains[(col + row + level) % subdomains.length]
        };
        resource = imageryProvider._resource.getDerivedResource({
          request
        });
        resource.setTemplateValues(templateValues);
        if (defined5(staticDimensions)) {
          resource.setTemplateValues(staticDimensions);
        }
        if (defined5(dynamicIntervalData)) {
          resource.setTemplateValues(dynamicIntervalData);
        }
      } else {
        var query = {};
        query.tilematrix = tileMatrix;
        query.layer = imageryProvider._layer;
        query.style = imageryProvider._style;
        query.tilerow = row;
        query.tilecol = col;
        query.tilematrixset = imageryProvider._tileMatrixSetID;
        query.format = imageryProvider._format;
        if (defined5(staticDimensions)) {
          query = combine2(query, staticDimensions);
        }
        if (defined5(dynamicIntervalData)) {
          query = combine2(query, dynamicIntervalData);
        }
        resource = imageryProvider._resource.getDerivedResource({
          queryParameters: query,
          request
        });
      }
      var deferred = defer5();
      let xyz = { x: col, y: row, z: level };
      let tileLevel = resource._templateValues.z;
      if (tileLevel < this.showLevel) {
        deferred.reject();
        return deferred.promise;
      }
      let success = this.requestJsonData(deferred, imageryProvider, resource, xyz, request);
      if (!success) {
        return void 0;
      }
      return deferred.promise;
    }
    requestJsonData(deferred, imageryProvider, url, xyz, request) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let z2 = xyz.z;
      let level = url._templateValues.z;
      let name2 = x3 + "_" + y3 + "_" + z2;
      if (this.cache[name2]) {
        deferred.resolve(this.image);
        return deferred;
      }
      this.tilesetJson.root.content = { uri: y3 + ".b3dm" };
      var tile = new Cesium3DTile(this, url, this.tilesetJson.root, null);
      tile._depth = 1;
      var requested = tile.requestContent();
      if (!requested) {
        return void 0;
      }
      tile._contentReadyToProcessPromise.then(function(deferred2, xyz2, level2, request2, content) {
        this.cache[name2] = tile;
        deferred2.resolve(this.image);
      }.bind(this, deferred, xyz, level, request), function(error) {
        deferred.reject();
      });
      return true;
    }
    get url() {
      return this._resource.url;
    }
    get proxy() {
      return this._resource.proxy;
    }
    get tileWidth() {
      return this._tileWidth;
    }
    get tileHeight() {
      return this._tileHeight;
    }
    get maximumLevel() {
      return this._maximumLevel;
    }
    get minimumLevel() {
      return this._minimumLevel;
    }
    get tilingScheme() {
      return this._tilingScheme;
    }
    get rectangle() {
      return this._rectangle;
    }
    get tileDiscardPolicy() {
      return this._tileDiscardPolicy;
    }
    get errorEvent() {
      return this._errorEvent;
    }
    get format() {
      return this._format;
    }
    get readyPromise() {
      return this._readyPromise;
    }
    get credit() {
      return this._credit;
    }
    get hasAlphaChannel() {
      return true;
    }
    get clock() {
      return this._timeDynamicImagery.clock;
    }
    set clock(value) {
      this._timeDynamicImagery.clock = value;
    }
    get times() {
      return this._timeDynamicImagery.times;
    }
    set times(value) {
      this._timeDynamicImagery.times = value;
    }
    get dimensions() {
      return this._dimensions;
    }
    set dimensions(value) {
      if (this._dimensions !== value) {
        this._dimensions = value;
        if (defined5(this._reload)) {
          this._reload();
        }
      }
    }
    getTileCredits(x3, y3, level) {
      return void 0;
    }
    requestImage(x3, y3, level, request) {
      var result;
      var timeDynamicImagery = this._timeDynamicImagery;
      var currentInterval;
      if (defined5(timeDynamicImagery)) {
        currentInterval = timeDynamicImagery.currentInterval;
        result = timeDynamicImagery.getFromCache(x3, y3, level, request);
      }
      if (!defined5(result)) {
        result = this.requestImageNow(this, x3, y3, level, request, currentInterval);
      }
      if (defined5(result) && defined5(timeDynamicImagery)) {
        timeDynamicImagery.checkApproachingInterval(x3, y3, level, request);
      }
      return result;
    }
    pickFeatures(x3, y3, level, longitude, latitude) {
      return void 0;
    }
    destroy() {
      for (let key2 in this.cache) {
        let tile = this.cache[key2];
        tile.destroy();
      }
      this.cache = {};
    }
    removeImageryFromCache(x3, y3, z2) {
      let key2 = x3 + "_" + y3 + "_" + z2;
      let tile = this.cache[key2];
      if (tile) {
        tile.destroy();
        delete this.cache[key2];
      }
    }
    get modelMatrix() {
      return this._modelMatrix;
    }
    set modelMatrix(value) {
      this._modelMatrix = Matrix43.clone(value, this._modelMatrix);
    }
  };
  var Quadtree3DTilesProvider_default = Quadtree3DTilesProvider;

  // Source/custom/layer/datasource/DataSource.js
  var DataSource = class {
    constructor() {
      this.id = new uuid_default().valueOf();
      this.type = "";
      this.textures = {};
    }
  };
  var DataSource_default = DataSource;

  // Source/custom/layer/datasource/LocalDataSource.js
  var Deferred2 = es6_promise_default.Deferred;
  var getJSON3 = es6_promise_default.getJSON;
  var LocalDataSource = class extends DataSource_default {
    constructor() {
      super();
      this.type = "LocalDataSource";
      this.features = [];
      this.textureUrls = {};
    }
    addFeature(feature3) {
      this.features.push(feature3);
    }
    addTextureUrl(name2, url) {
      this.textureUrls[name2] = url;
    }
    removeTextureUrl(name2) {
      delete this.textureUrls[name2];
    }
    loadTexture() {
      let def = new Deferred2();
      let totalCount = 0;
      for (let i in this.textureUrls) {
        totalCount++;
      }
      if (totalCount == 0) {
        def.resolve();
        return;
      }
      let count = 0;
      for (let key2 in this.textureUrls) {
        let img = new Image();
        img.name = key2;
        img.onload = function(data) {
          count++;
          let name2 = data.target.name;
          this.textures[name2] = data.target;
          if (count == totalCount) {
            def.resolve();
          }
        }.bind(this);
        img.src = this.textureUrls[key2];
      }
      return def;
    }
    removeFeatureById(featureId) {
      for (let i = 0; i < this.features.length; i++) {
        let feature3 = this.features[i];
        if (feature3.id == featureId) {
          this.features.splice(i, 1);
        }
      }
    }
  };
  var LocalDataSource_default = LocalDataSource;

  // Source/custom/layer/datasource/URLDataSource.js
  var Deferred3 = es6_promise_default.Deferred;
  var getJSON4 = es6_promise_default.getJSON;
  var URLDataSource = class extends DataSource_default {
    constructor() {
      super();
      this.urlArray = [];
      this.type = "URLDataSource";
      this.url = null;
      this.styleUrl = null;
      this.styleId = "style";
      this.filter = null;
      this.textures = {};
      this.control = null;
      this.controlId = null;
      this.sourceUrl = null;
      this.host = "";
      this.servername = "";
    }
    loadStyle(styleType) {
      let def0 = new Deferred3();
      let def1 = new Deferred3();
      let def2 = new Deferred3();
      this.parseUrl();
      let queryParam = this.url.split("?")[1];
      if (!this.sourceUrl) {
        this.sourceUrl = this.url + "&clientVersion=" + Version_default;
        this.url = this.url + "&clientVersion=" + Version_default;
      }
      if (this.control && this.isIE()) {
        getJSON4({
          type: "post",
          url: this.host + "/mapserver/vmap/" + this.servername + "/setControl",
          data: "control=" + this.control,
          dataType: "json"
        }).then(function(result) {
          this.controlId = result.id;
          this.url = this.sourceUrl + "&controlId=" + result.id;
          def0.resolve();
        }.bind(this));
      } else {
        if (this.control) {
          this.url = this.sourceUrl + "&control=" + encodeURIComponent(this.control);
        } else {
          this.url = this.sourceUrl;
        }
        def0.resolve();
      }
      if (!styleType) {
        styleType = "label";
      }
      if (this.styleId == "_default__") {
        let styleStr = 'var layers = drawer.getAllLayer(); layers.setStyle(function(level , get){ return {"type":"_default__","show":true,"pointFillStyle":"#ff0000","radius":5,"lineFillStyle":"#00ff00","lineWidth":3 }})';
        this.styleFun = new Function("drawer", "level", styleStr);
        return [def0];
      }
      getJSON4({ url: this.host + "/mapserver/styleInfo/" + this.servername + "/" + this.styleId + "/" + styleType + "/style.js?" + Math.random() + "&" + queryParam, dataType: "text" }).then(function(result) {
        this.styleFun = new Function("drawer", "level", result);
        def1.resolve();
      }.bind(this));
      getJSON4({ url: this.host + "/mapserver/styleInfo/" + this.servername + "/" + this.styleId + "/label/texture.js?" + Math.random() + "&" + queryParam, dataType: "text" }).then(function(result) {
        let textures = JSON.parse(result);
        let totalCount = 0;
        for (let i in textures) {
          totalCount++;
        }
        if (totalCount == 0) {
          def2.resolve();
          return;
        }
        let count = 0;
        for (let key2 in textures) {
          let img = new Image();
          img.name = key2;
          img.onload = function(data) {
            count++;
            let name2 = data.target.name;
            this.textures[name2] = data.target;
            if (count == totalCount) {
              def2.resolve();
            }
          }.bind(this);
          img.src = textures[key2];
        }
      }.bind(this));
      return [def0, def1, def2];
    }
    parseUrl() {
      let urlParts = this.url.split("?");
      let urlPartOne = urlParts[0].split("/mapserver/");
      this.host = urlPartOne[0];
      this.servername = urlPartOne[1].split("/")[1];
      let params2 = urlParts[1].split("&");
      for (let i = 0; i < params2.length; i++) {
        let param = params2[i];
        let keyValue = param.split("=");
        if (keyValue[0] == "styleId") {
          this.styleId = keyValue[1];
          return;
        }
      }
    }
    setFilter(filter) {
      this.control = null;
      if (!this.url || !filter || filter.layers.length == 0 && filter.order.length == 0) {
        return;
      }
      for (let i = 0; i < filter.layers.length; i++) {
        let filterLayer = filter.layers[i];
        if (!filterLayer.id) {
          filter.layers.splice(i, 1);
        }
      }
      this.control = JSON.stringify(filter);
    }
    getTexture(key2) {
      return this.textures[key2];
    }
    addTexture(key2, texture) {
      this.textures[key2] = texture;
    }
    isIE() {
      if (!!window.ActiveXObject || "ActiveXObject" in window) {
        var b_version = navigator.appVersion;
        var version = b_version.split(";");
        if (version[1]) {
          var trim_Version = version[1].replace(/[ ]/g, "");
          if (trim_Version == "MSIE9.0") {
            return false;
          }
        }
        return true;
      } else
        return false;
    }
  };
  var URLDataSource_default = URLDataSource;

  // Source/custom/layer/envelope/EnvelopeDataSource.js
  var Cartesian34 = Cesium.Cartesian3;
  var Color4 = Cesium.Color;
  var defined6 = Cesium.defined;
  var CallbackProperty = Cesium.CallbackProperty;
  var CesiumMath4 = Cesium.Math;
  var PrimitivePipeline = Cesium.PrimitivePipeline;
  var Matrix44 = Cesium.Matrix4;
  var PrimitiveState = Cesium.PrimitiveState;
  var BatchTable = Cesium.BatchTable;
  var Cartesian4 = Cesium.Cartesian4;
  var BEGIN = 1;
  var LOADED = 2;
  var ADDED = 3;
  var REMOVED = 4;
  var EnvelopeDataSource = class {
    constructor(name2, results, level, viewer3, options, lightMap) {
      this.name = name2;
      this.level = level;
      this.viewer = viewer3;
      this.options = options;
      this.type = "envelope";
      this.state = BEGIN;
      this.polygonPrimitive = new Cesium.ClassificationPrimitive({
        shadows: Cesium.ShadowMode.ENABLED,
        geometryInstances: [],
        undisplayable: true,
        classificationType: Cesium.ClassificationType.CESIUM_3D_TILE,
        appearance: new Cesium.PerInstanceColorAppearance({
          flat: false,
          translucent: this.translucent,
          closed: true
        })
      });
      this.load(results);
    }
    load(results) {
      let polygon2 = results.polygon;
      if (polygon2) {
        let primitiveOptions = this.polygonPrimitive.getDrawFunctionOptions();
        primitiveOptions.shadows = Cesium.ShadowMode.ENABLED;
        primitiveOptions.appearance = new Cesium.PerInstanceColorAppearance({
          flat: false,
          translucent: this.translucent,
          closed: true
        });
        primitiveOptions.undisplayable = true;
        primitiveOptions.geometryInstances = [];
        let primitive = new Cesium.Primitive(primitiveOptions);
        this.setPrimitive(primitive, polygon2);
        this.state = LOADED;
      }
    }
    setPrimitive(primitive, results) {
      let result = PrimitivePipeline.unpackCombineGeometryResults(results);
      primitive.isExt = true;
      primitive._geometries = result.geometries;
      primitive._attributeLocations = result.attributeLocations;
      primitive.modelMatrix = Matrix44.clone(result.modelMatrix, primitive.modelMatrix);
      primitive._pickOffsets = result.pickOffsets;
      primitive._offsetInstanceExtend = result.offsetInstanceExtend;
      primitive._instanceBoundingSpheres = result.boundingSpheres;
      primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;
      primitive.propertiesMapBuffer = results.propertiesMapBuffer;
      if (defined6(primitive._geometries) && primitive._geometries.length > 0) {
        primitive._recomputeBoundingSpheres = true;
        primitive._state = PrimitiveState.COMBINED;
      } else {
      }
      this.createBatchTable(primitive, results);
      primitive.appearance = this.polygonPrimitive.appearance;
      this.polygonPrimitive._primitive = primitive;
    }
    createBatchTable(primitive, result) {
      let attributes = result.attributes;
      let attributesLength = attributes.length;
      let ids = result.ids;
      let batchValues = result.batchValues;
      let numberOfInstances = ids.length;
      let pickId = result.pickId;
      let context = this.viewer.scene.frameState.context;
      let batchTable = new BatchTable(context, attributes, numberOfInstances);
      batchTable._batchValues = batchValues;
      var scratchGetAttributeCartesian4 = new Cartesian4();
      if (primitive._allowPicking) {
        for (let i = 0; i < numberOfInstances; ++i) {
          var pickObject = {
            primitive
          };
          let id = ids[i];
          if (defined6(id)) {
            pickObject.id = id;
          }
          pickId++;
          context._pickObjects[pickId] = pickObject;
        }
      }
      primitive._instanceIds = ids;
      primitive._batchTable = batchTable;
      primitive._batchTableAttributeIndices = result.attributeIndices;
    }
    remove() {
      if (this.polygonPrimitive) {
        this.viewer.scene.primitives.remove(this.polygonPrimitive);
      }
      this.state = REMOVED;
    }
    destroy() {
      this.remove();
      if (this.polygonPrimitive && !this.polygonPrimitive.isDestroyed()) {
        this.polygonPrimitive.destroy();
      }
      this.destroyed = true;
    }
    addToPrimitives() {
      if (this.polygonPrimitive && this.polygonPrimitive._primitive) {
        this.viewer.scene.primitives.add(this.polygonPrimitive);
      }
      this.state = ADDED;
    }
    showPrimitive(primitive) {
      for (let i = 0; i < primitive._instanceIds.length; i++) {
        primitive._batchTable.setBatchedAttribute(i, 1, 1);
      }
    }
    show(styleFun) {
      if (this.state == REMOVED || this.state == LOADED) {
        this.addToPrimitives();
      }
    }
  };
  var EnvelopeDataSource_default = EnvelopeDataSource;

  // Source/custom/layer/envelope/EnvelopeModelTileServiceImageryProvider.js
  var combine3 = Cesium.combine;
  var Credit3 = Cesium.Credit;
  var defaultValue6 = Cesium.defaultValue;
  var defined7 = Cesium.defined;
  var DeveloperError5 = Cesium.DeveloperError;
  var Event3 = Cesium.Event;
  var freezeObject = Cesium.freezeObject;
  var isArray2 = Array.isArray;
  var Rectangle2 = Cesium.Rectangle;
  var Resource3 = Cesium.Resource;
  var WebMercatorTilingScheme3 = Cesium.WebMercatorTilingScheme;
  var ImageryProvider = Cesium.ImageryProvider;
  var TimeDynamicImagery2 = Cesium.TimeDynamicImagery;
  var RequestState = Cesium.RequestState;
  var defer6 = Cesium.defer;
  var defaultParameters2 = {
    service: "WMTS",
    version: "1.0.0",
    request: "GetTile"
  };
  var EnvelopeModelTileServiceImageryProvider = class {
    constructor(viewer3, options) {
      this.viewer = viewer3;
      options = defaultValue6(options, defaultValue6.EMPTY_OBJECT);
      this.id = Math.random();
      this.needDecode = defaultValue6(options.needDecode, false);
      if (!defined7(options.url)) {
        throw new DeveloperError5("options.url is required.");
      }
      var resource = Resource3.createIfNeeded(options.url);
      var style = options.style;
      var tileMatrixSetID = options.tileMatrixSetID;
      var url = resource.url;
      if (url.indexOf("{") >= 0) {
        var templateValues = {
          style,
          Style: style,
          TileMatrixSet: tileMatrixSetID
        };
        resource.setTemplateValues(templateValues);
        this._useKvp = false;
      } else {
        resource.setQueryParameters(defaultParameters2);
        this._useKvp = true;
      }
      this._resource = resource;
      this._layer = options.layer;
      this._style = style;
      this._tileMatrixSetID = tileMatrixSetID;
      this._tileMatrixLabels = options.tileMatrixLabels;
      this._format = defaultValue6(options.format, "image/jpeg");
      this._tileDiscardPolicy = options.tileDiscardPolicy;
      this._tilingScheme = defined7(options.tilingScheme) ? options.tilingScheme : new WebMercatorTilingScheme3({ ellipsoid: options.ellipsoid });
      this._tileWidth = defaultValue6(options.tileWidth, 256);
      this._tileHeight = defaultValue6(options.tileHeight, 256);
      this._minimumLevel = defaultValue6(options.minimumLevel, 0);
      this._maximumLevel = options.maximumLevel;
      this._rectangle = defaultValue6(options.rectangle, this._tilingScheme.rectangle);
      this._dimensions = options.dimensions;
      var that = this;
      this._reload = void 0;
      if (defined7(options.times)) {
        this._timeDynamicImagery = new TimeDynamicImagery2({
          clock: options.clock,
          times: options.times,
          requestImageFunction: function(x3, y3, level, request, interval) {
            return requestImage(that, x3, y3, level, request, interval);
          },
          reloadFunction: function() {
            if (defined7(that._reload)) {
              that._reload();
            }
          }
        });
      }
      this._readyPromise = defer6();
      var swTile = this._tilingScheme.positionToTileXY(Rectangle2.southwest(this._rectangle), this._minimumLevel);
      var neTile = this._tilingScheme.positionToTileXY(Rectangle2.northeast(this._rectangle), this._minimumLevel);
      var tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);
      if (tileCount > 4) {
        throw new DeveloperError5("The imagery provider's rectangle and minimumLevel indicate that there are " + tileCount + " tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.");
      }
      this._errorEvent = new Event3();
      var credit = options.credit;
      this._credit = typeof credit === "string" ? new Credit3(credit) : credit;
      this._subdomains = options.subdomains;
      if (isArray2(this._subdomains)) {
        this._subdomains = this._subdomains.slice();
      } else if (defined7(this._subdomains) && this._subdomains.length > 0) {
        this._subdomains = this._subdomains.split("");
      } else {
        this._subdomains = ["a", "b", "c"];
      }
      this.dataType = "binary";
      if (options.hasOwnProperty("dataType")) {
        this.dataType = options["dataType"];
      } else {
        this.dataType = "Json";
      }
      if (this.dataType == "binary") {
        this.processor = new Cesium.TaskProcessor("EnvelopeBinaryWorker", Number.POSITIVE_INFINITY);
      } else {
        this.processor = new Cesium.TaskProcessor("EnvelopeWorker", Number.POSITIVE_INFINITY);
      }
      this.parseUrl(options.url);
      this.loadStyle().then(function() {
        this.ready = {
          value: true
        };
        this._readyPromise.resolve(true);
      }.bind(this));
      this.cache = {};
      this.options = options;
      this.lightMap = {};
      this.showLevel = options.showLevel || 16;
      this.image = document.createElement("canvas");
      this.bufferDistance = defaultValue6(this.options.bufferDistance, 0);
    }
    draw(tilesToRender) {
      let renderTileMap = this.getRenderTileMap(tilesToRender);
      for (let key2 in this.cache) {
        if (!renderTileMap[key2]) {
          let tile = this.cache[key2];
          tile.remove();
        }
      }
      for (let name2 in renderTileMap) {
        let ds = this.cache[name2];
        if (ds) {
          ds.show(this.styleFun);
        }
      }
    }
    getRenderTileMap(renderTiles) {
      let renderTileMap = {};
      for (let i = 0; i < renderTiles.length; i++) {
        let tileImagerys = renderTiles[i].data.imagery;
        for (let j = 0; j < tileImagerys.length; j++) {
          let tileImagery = tileImagerys[j];
          let imagery = tileImagery.readyImagery;
          if (imagery && imagery.imageryLayer._imageryProvider.id == this.id) {
            let key2 = imagery.x + "_" + imagery.y + "_" + imagery.level;
            renderTileMap[key2] = true;
          }
        }
      }
      return renderTileMap;
    }
    parseUrl(url) {
      let urlParts = url.split("?");
      let urlPartOne = urlParts[0].split("/mapserver/");
      this.host = urlPartOne[0];
      if (this._subdomains.length > 0) {
        this.host = this.host.replace("{s}", this._subdomains[0]);
      }
      this.servername = urlPartOne[1].split("/")[1];
      this.queryParam = urlParts[1];
      let params2 = this.queryParam.split("&");
      for (let i = 0; i < params2.length; i++) {
        let param = params2[i];
        let keyValue = param.split("=");
        if (keyValue[0] == "styleId") {
          this.styleId = keyValue[1];
        }
        if (keyValue[0] == "return_type") {
          this.return_type = keyValue[1];
        }
      }
    }
    loadStyle() {
      let promises = [];
      let styleUrl = this.host + "/mapserver/styleInfo/" + this.servername + "/" + this.styleId + "/layer/style.js?" + Math.random();
      let resource = Resource3.createIfNeeded(styleUrl);
      let promise1 = resource.fetchText();
      promises.push(promise1);
      let promise2 = null;
      if (this.dataType == "binary") {
        let styleUrl2 = this.host + "/mapserver/serverInfo/" + this.servername + ".json?" + Math.random();
        let resource2 = Resource3.createIfNeeded(styleUrl2);
        promise2 = resource2.fetchJson();
        promises.push(promise2);
      }
      let deferred = defer6();
      Promise.all(promises).then(function(result) {
        let styleStr = result[0];
        let results = result[1];
        let options = {
          init: true,
          styleStr,
          tileSize: this._tileWidth,
          return_type: this.return_type
        };
        if (results && results.layerMap) {
          this.serverInfo = {};
          this.layerFieldMap = {};
          for (let key2 in results.layerMap) {
            this.serverInfo[key2] = {
              geometryType: results.layerMap[key2].geometryType,
              fieldsConfig: results.layerMap[key2].fields
            };
            if (!this.layerFieldMap[key2]) {
              this.layerFieldMap[key2] = results.layerMap[key2].fields.length;
            }
          }
          options.serverInfo = this.serverInfo;
          options.layerFieldMap = this.layerFieldMap;
        }
        if (this.options.hasOwnProperty("fillColor")) {
          options.fillColor = this.options.fillColor;
        }
        if (this.options.hasOwnProperty("opacity")) {
          options.opacity = this.options.opacity;
        }
        if (this.options.hasOwnProperty("heightProperty")) {
          options.heightProperty = this.options.heightProperty;
        }
        if (this.options.hasOwnProperty("heightValue")) {
          options.heightValue = this.options.heightValue;
        }
        let promise = this.processor.scheduleTask(options);
        promise.then(function() {
          deferred.resolve();
        });
      }.bind(this));
      return deferred.promise;
    }
    requestImageNow(imageryProvider, col, row, level, request, interval) {
      var labels = imageryProvider._tileMatrixLabels;
      var tileMatrix = defined7(labels) ? labels[level] : level.toString();
      var subdomains = imageryProvider._subdomains;
      var staticDimensions = imageryProvider._dimensions;
      var dynamicIntervalData = defined7(interval) ? interval.data : void 0;
      var resource;
      if (!imageryProvider._useKvp) {
        var templateValues = {
          z: tileMatrix,
          y: row.toString(),
          x: col.toString(),
          s: subdomains[(col + row + level) % subdomains.length]
        };
        resource = imageryProvider._resource.getDerivedResource({
          request
        });
        resource.setTemplateValues(templateValues);
        if (defined7(staticDimensions)) {
          resource.setTemplateValues(staticDimensions);
        }
        if (defined7(dynamicIntervalData)) {
          resource.setTemplateValues(dynamicIntervalData);
        }
      } else {
        var query = {};
        query.tilematrix = tileMatrix;
        query.layer = imageryProvider._layer;
        query.style = imageryProvider._style;
        query.tilerow = row;
        query.tilecol = col;
        query.tilematrixset = imageryProvider._tileMatrixSetID;
        query.format = imageryProvider._format;
        if (defined7(staticDimensions)) {
          query = combine3(query, staticDimensions);
        }
        if (defined7(dynamicIntervalData)) {
          query = combine3(query, dynamicIntervalData);
        }
        resource = imageryProvider._resource.getDerivedResource({
          queryParameters: query,
          request
        });
      }
      var deferred = defer6();
      let xyz = { x: col, y: row, z: level };
      let tileLevel = resource._templateValues.z;
      if (tileLevel < this.showLevel) {
        deferred.reject();
        return deferred.promise;
      }
      this.requestJsonData(deferred, imageryProvider, resource, xyz, request);
      return deferred.promise;
    }
    requestJsonData(deferred, imageryProvider, url, xyz, request) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let z2 = xyz.z;
      let level = url._templateValues.z;
      let name2 = x3 + "_" + y3 + "_" + z2;
      if (this.cache[name2]) {
        deferred.resolve(this.image);
        return deferred;
      }
      let rectangle = this._tilingScheme.tileXYToRectangle(xyz.x, xyz.y, xyz.z);
      let rectangleObj = { west: rectangle.west, north: rectangle.north, width: rectangle.width, height: rectangle.height };
      let styleLevel = Math.round(this.viewer.camera.getLevel());
      let xyzStr = xyz.x + "_" + xyz.y + "_" + xyz.z;
      let promise = this.processor.scheduleTask({
        url: url.url,
        xyz: xyzStr,
        needDecode: this.options.needDecode,
        level: styleLevel,
        filterLayerId: this.options.filterLayerId,
        bufferDistance: this.bufferDistance,
        rectangle: rectangleObj
      });
      promise.then(function(deferred2, xyz2, level2, request2, results) {
        if (results == true) {
          request2.state = RequestState.CANCELLED;
          deferred2.reject();
          return;
        }
        this.jsonPromiseResult(deferred2, xyz2, level2, results);
      }.bind(this, deferred, xyz, level, request), function(error) {
        deferred.reject();
      });
      return true;
    }
    jsonPromiseResult(deferred, xyz, level, results) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let z2 = xyz.z;
      let name2 = x3 + "_" + y3 + "_" + z2;
      let tile = new EnvelopeDataSource_default(name2, results, level, this.viewer, this.options, this.lightMap);
      this.cache[tile.name] = tile;
      deferred.resolve(this.image);
    }
    updateTileElevation(xyz, tileSize) {
      let name2 = xyz.x + "_" + xyz.y + "_" + xyz.z;
      if (!this.cache[name2]) {
        return false;
      }
      return true;
    }
    get url() {
      return this._resource.url;
    }
    get proxy() {
      return this._resource.proxy;
    }
    get tileWidth() {
      return this._tileWidth;
    }
    get tileHeight() {
      return this._tileHeight;
    }
    get maximumLevel() {
      return this._maximumLevel;
    }
    get minimumLevel() {
      return this._minimumLevel;
    }
    get tilingScheme() {
      return this._tilingScheme;
    }
    get rectangle() {
      return this._rectangle;
    }
    get tileDiscardPolicy() {
      return this._tileDiscardPolicy;
    }
    get errorEvent() {
      return this._errorEvent;
    }
    get format() {
      return this._format;
    }
    get readyPromise() {
      return this._readyPromise;
    }
    get credit() {
      return this._credit;
    }
    get hasAlphaChannel() {
      return true;
    }
    get clock() {
      return this._timeDynamicImagery.clock;
    }
    set clock(value) {
      this._timeDynamicImagery.clock = value;
    }
    get times() {
      return this._timeDynamicImagery.times;
    }
    set times(value) {
      this._timeDynamicImagery.times = value;
    }
    get dimensions() {
      return this._dimensions;
    }
    set dimensions(value) {
      if (this._dimensions !== value) {
        this._dimensions = value;
        if (defined7(this._reload)) {
          this._reload();
        }
      }
    }
    getTileCredits(x3, y3, level) {
      return void 0;
    }
    requestImage(x3, y3, level, request) {
      var result;
      var timeDynamicImagery = this._timeDynamicImagery;
      var currentInterval;
      if (defined7(timeDynamicImagery)) {
        currentInterval = timeDynamicImagery.currentInterval;
        result = timeDynamicImagery.getFromCache(x3, y3, level, request);
      }
      if (!defined7(result)) {
        result = this.requestImageNow(this, x3, y3, level, request, currentInterval);
      }
      if (defined7(result) && defined7(timeDynamicImagery)) {
        timeDynamicImagery.checkApproachingInterval(x3, y3, level, request);
      }
      return result;
    }
    pickFeatures(x3, y3, level, longitude, latitude) {
      return void 0;
    }
    destroy() {
      for (let key2 in this.cache) {
        let tile = this.cache[key2];
        tile.destroy();
      }
      this.cache = {};
    }
    removeImageryFromCache(x3, y3, z2) {
      let key2 = x3 + "_" + y3 + "_" + z2;
      let tile = this.cache[key2];
      if (tile) {
        tile.destroy();
        delete this.cache[key2];
      }
    }
    removeTile(xyzStr) {
      let tile = this.cache[xyzStr];
      if (tile) {
        tile.remove();
      }
    }
    redraw() {
      let layers = this.viewer.imageryLayers._layers;
      let imagerLayer = null;
      let index = -1;
      for (let i = 0; i < layers.length; i++) {
        let layer = layers[i];
        if (layer.imageryProvider == this) {
          imagerLayer = layer;
          index = i;
        }
      }
      if (imagerLayer) {
        this.viewer.imageryLayers.layerShownOrHidden.raiseEvent(
          imagerLayer,
          index,
          false
        );
        this.viewer.imageryLayers.layerShownOrHidden.raiseEvent(
          imagerLayer,
          index,
          true
        );
      }
    }
  };
  var EnvelopeModelTileServiceImageryProvider_default = EnvelopeModelTileServiceImageryProvider;

  // Source/custom/layer/envelope/EnvelopeWmtsDataSource.js
  var defined8 = Cesium.defined;
  var PrimitivePipeline2 = Cesium.PrimitivePipeline;
  var Matrix45 = Cesium.Matrix4;
  var PrimitiveState2 = Cesium.PrimitiveState;
  var BatchTable2 = Cesium.BatchTable;
  var BEGIN2 = 1;
  var LOADED2 = 2;
  var ADDED2 = 3;
  var REMOVED2 = 4;
  var EnvelopeWmtsDataSource = class {
    constructor(name2, results, rectangle, tileSize, level, viewer3, options) {
      this.name = name2;
      this.level = level;
      this.viewer = viewer3;
      this.options = options;
      this.type = "envelopeWmts";
      this.state = BEGIN2;
      var polygonHierarchy = {
        positions: Cesium.Cartesian3.fromDegreesArray(
          this.getWmtsPositions(rectangle, tileSize)
        )
      };
      let geometry = new Cesium.PolygonGeometry({
        height: -9e3,
        extrudedHeight: 1e4,
        polygonHierarchy
      });
      const textureCoordinateRotationPoints = [0, 0, 0, 1, 1, 0];
      const frameState = viewer3.scene.frameState;
      const ellipsoid = frameState.mapProjection.ellipsoid;
      let attributes = Cesium.ShadowVolumeAppearance.getPlanarTextureCoordinateAttributes(
        rectangle,
        textureCoordinateRotationPoints,
        ellipsoid,
        frameState.mapProjection,
        1e4
      );
      this.polygonPrimitive = new Cesium.ClassificationPrimitive({
        asynchronous: false,
        shadows: Cesium.ShadowMode.ENABLED,
        geometryInstances: new Cesium.GeometryInstance({
          geometry,
          attributes
        }),
        classificationType: Cesium.ClassificationType.CESIUM_3D_TILE,
        appearance: new Cesium.MaterialAppearance({
          material: Cesium.Material.fromType("Image", {
            image: results
          })
        })
      });
      this.state = LOADED2;
    }
    getWmtsPositions(rectangle, tileSize) {
      let geometry = [0, 0, tileSize, 0, tileSize, tileSize, 0, tileSize];
      let positions = [];
      for (let i = 0; i < geometry.length; i++) {
        let pt = this.formatToDegrees(geometry[i], geometry[i + 1], rectangle, tileSize);
        positions.push(pt[0]);
        positions.push(pt[1]);
        i++;
      }
      return positions;
    }
    formatToDegrees(x3, y3, rectangle, tileSize) {
      var lon = this.toDegrees(rectangle.west + rectangle.width / tileSize * x3);
      var lat = this.toDegrees(rectangle.north - rectangle.height / tileSize * y3);
      lon = Number(lon.toFixed(6));
      lat = Number(lat.toFixed(6));
      return [lon, lat];
    }
    toDegrees(radians2) {
      return radians2 * 180 / Math.PI;
    }
    load(results) {
      let primitiveData = results.primitiveData;
      let imageData = results.imageData;
      let polygon2 = primitiveData.polygon;
      let primitiveOptions = this.polygonPrimitive.getDrawFunctionOptions();
      primitiveOptions.shadows = Cesium.ShadowMode.ENABLED;
      primitiveOptions.undisplayable = true;
      primitiveOptions.geometryInstances = [];
      let primitive = new Cesium.Primitive(primitiveOptions);
      this.setPrimitive(primitive, polygon2);
      this.state = LOADED2;
    }
    setPrimitive(primitive, results) {
      let result = PrimitivePipeline2.unpackCombineGeometryResults(results);
      primitive.isExt = true;
      primitive._geometries = result.geometries;
      primitive._attributeLocations = result.attributeLocations;
      primitive.modelMatrix = Matrix45.clone(result.modelMatrix, primitive.modelMatrix);
      primitive._pickOffsets = result.pickOffsets;
      primitive._offsetInstanceExtend = result.offsetInstanceExtend;
      primitive._instanceBoundingSpheres = result.boundingSpheres;
      primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;
      primitive.propertiesMapBuffer = results.propertiesMapBuffer;
      if (defined8(primitive._geometries) && primitive._geometries.length > 0) {
        primitive._recomputeBoundingSpheres = true;
        primitive._state = PrimitiveState2.COMBINED;
      } else {
      }
      this.createBatchTable(primitive, results);
      primitive.appearance = this.polygonPrimitive.appearance;
      this.polygonPrimitive._primitive = primitive;
    }
    createBatchTable(primitive, result) {
      let attributes = result.attributes;
      let attributesLength = attributes.length;
      let ids = result.ids;
      let batchValues = result.batchValues;
      let numberOfInstances = ids.length;
      let pickId = result.pickId;
      let context = this.viewer.scene.frameState.context;
      let batchTable = new BatchTable2(context, attributes, numberOfInstances);
      batchTable._batchValues = batchValues;
      if (primitive._allowPicking) {
        for (let i = 0; i < numberOfInstances; ++i) {
          var pickObject = {
            primitive
          };
          let id = ids[i];
          if (defined8(id)) {
            pickObject.id = id;
          }
          pickId++;
          context._pickObjects[pickId] = pickObject;
        }
      }
      primitive._instanceIds = ids;
      primitive._batchTable = batchTable;
      primitive._batchTableAttributeIndices = result.attributeIndices;
    }
    remove() {
      if (this.polygonPrimitive) {
        this.viewer.scene.primitives.remove(this.polygonPrimitive);
      }
      this.state = REMOVED2;
    }
    destroy() {
      this.remove();
      if (this.polygonPrimitive && !this.polygonPrimitive.isDestroyed()) {
        this.polygonPrimitive.destroy();
      }
      this.destroyed = true;
    }
    addToPrimitives() {
      if (this.polygonPrimitive) {
        this.viewer.scene.primitives.add(this.polygonPrimitive);
      }
      this.state = ADDED2;
    }
    showPrimitive(primitive) {
      for (let i = 0; i < primitive._instanceIds.length; i++) {
        primitive._batchTable.setBatchedAttribute(i, 1, 1);
      }
    }
    show(styleFun) {
      if (this.state == REMOVED2 || this.state == LOADED2) {
        this.addToPrimitives();
      }
    }
  };
  var EnvelopeWmtsDataSource_default = EnvelopeWmtsDataSource;

  // Source/custom/layer/envelope/EnvelopeWmtsImageryProvider.js
  var combine4 = Cesium.combine;
  var Credit4 = Cesium.Credit;
  var defaultValue7 = Cesium.defaultValue;
  var defined9 = Cesium.defined;
  var DeveloperError6 = Cesium.DeveloperError;
  var Event4 = Cesium.Event;
  var isArray3 = Array.isArray;
  var Rectangle3 = Cesium.Rectangle;
  var Resource4 = Cesium.Resource;
  var WebMercatorTilingScheme4 = Cesium.WebMercatorTilingScheme;
  var TimeDynamicImagery3 = Cesium.TimeDynamicImagery;
  var RequestState2 = Cesium.RequestState;
  var defer7 = Cesium.defer;
  var defaultParameters3 = {
    service: "WMTS",
    version: "1.0.0",
    request: "GetTile"
  };
  var EnvelopeWmtsImageryProvider = class {
    constructor(viewer3, options) {
      this.viewer = viewer3;
      options = defaultValue7(options, defaultValue7.EMPTY_OBJECT);
      this.id = Math.random();
      this.needDecode = defaultValue7(options.needDecode, false);
      if (!defined9(options.url)) {
        throw new DeveloperError6("options.url is required.");
      }
      var resource = Resource4.createIfNeeded(options.url);
      var style = options.style;
      var tileMatrixSetID = options.tileMatrixSetID;
      var url = resource.url;
      if (url.indexOf("{") >= 0) {
        var templateValues = {
          style,
          Style: style,
          TileMatrixSet: tileMatrixSetID
        };
        resource.setTemplateValues(templateValues);
        this._useKvp = false;
      } else {
        resource.setQueryParameters(defaultParameters3);
        this._useKvp = true;
      }
      this._resource = resource;
      this._layer = options.layer;
      this._style = style;
      this._tileMatrixSetID = tileMatrixSetID;
      this._tileMatrixLabels = options.tileMatrixLabels;
      this._format = defaultValue7(options.format, "image/jpeg");
      this._tileDiscardPolicy = options.tileDiscardPolicy;
      this._tilingScheme = defined9(options.tilingScheme) ? options.tilingScheme : new WebMercatorTilingScheme4({ ellipsoid: options.ellipsoid });
      this._tileWidth = defaultValue7(options.tileWidth, 256);
      this._tileHeight = defaultValue7(options.tileHeight, 256);
      this._minimumLevel = defaultValue7(options.minimumLevel, 0);
      this._maximumLevel = options.maximumLevel;
      this._rectangle = defaultValue7(options.rectangle, this._tilingScheme.rectangle);
      this._dimensions = options.dimensions;
      var that = this;
      this._reload = void 0;
      if (defined9(options.times)) {
        this._timeDynamicImagery = new TimeDynamicImagery3({
          clock: options.clock,
          times: options.times,
          requestImageFunction: function(x3, y3, level, request, interval) {
            return requestImage(that, x3, y3, level, request, interval);
          },
          reloadFunction: function() {
            if (defined9(that._reload)) {
              that._reload();
            }
          }
        });
      }
      var swTile = this._tilingScheme.positionToTileXY(Rectangle3.southwest(this._rectangle), this._minimumLevel);
      var neTile = this._tilingScheme.positionToTileXY(Rectangle3.northeast(this._rectangle), this._minimumLevel);
      var tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);
      if (tileCount > 4) {
        throw new DeveloperError6("The imagery provider's rectangle and minimumLevel indicate that there are " + tileCount + " tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.");
      }
      this._errorEvent = new Event4();
      var credit = options.credit;
      this._credit = typeof credit === "string" ? new Credit4(credit) : credit;
      this._subdomains = options.subdomains;
      if (isArray3(this._subdomains)) {
        this._subdomains = this._subdomains.slice();
      } else if (defined9(this._subdomains) && this._subdomains.length > 0) {
        this._subdomains = this._subdomains.split("");
      } else {
        this._subdomains = ["a", "b", "c"];
      }
      this.processor = new Cesium.TaskProcessor("EnvelopeWmtsWorker", Number.POSITIVE_INFINITY);
      this._readyPromise = Promise.resolve(true);
      this.ready = {
        value: true
      };
      this.cache = {};
      this.options = options;
      this.lightMap = {};
      this.showLevel = options.showLevel || 16;
      this.image = document.createElement("canvas");
      this.bufferDistance = defaultValue7(this.options.bufferDistance, 0);
    }
    get readyPromise() {
      return this._readyPromise;
    }
    draw(tilesToRender) {
      let renderTileMap = this.getRenderTileMap(tilesToRender);
      for (let key2 in this.cache) {
        if (!renderTileMap[key2]) {
          let tile = this.cache[key2];
          tile.remove();
        }
      }
      for (let name2 in renderTileMap) {
        let ds = this.cache[name2];
        if (ds) {
          ds.show(this.styleFun);
        }
      }
    }
    getRenderTileMap(renderTiles) {
      let renderTileMap = {};
      for (let i = 0; i < renderTiles.length; i++) {
        let tileImagerys = renderTiles[i].data.imagery;
        for (let j = 0; j < tileImagerys.length; j++) {
          let tileImagery = tileImagerys[j];
          let imagery = tileImagery.readyImagery;
          if (imagery && imagery.imageryLayer._imageryProvider.id == this.id) {
            let key2 = imagery.x + "_" + imagery.y + "_" + imagery.level;
            renderTileMap[key2] = true;
          }
        }
      }
      return renderTileMap;
    }
    requestImageNow(imageryProvider, col, row, level, request, interval) {
      var labels = imageryProvider._tileMatrixLabels;
      var tileMatrix = defined9(labels) ? labels[level] : level.toString();
      var subdomains = imageryProvider._subdomains;
      var staticDimensions = imageryProvider._dimensions;
      var dynamicIntervalData = defined9(interval) ? interval.data : void 0;
      var resource;
      if (!imageryProvider._useKvp) {
        var templateValues = {
          TileMatrix: tileMatrix,
          TileRow: row.toString(),
          TileCol: col.toString(),
          s: subdomains[(col + row + level) % subdomains.length]
        };
        resource = imageryProvider._resource.getDerivedResource({
          request
        });
        resource.setTemplateValues(templateValues);
        if (defined9(staticDimensions)) {
          resource.setTemplateValues(staticDimensions);
        }
        if (defined9(dynamicIntervalData)) {
          resource.setTemplateValues(dynamicIntervalData);
        }
      } else {
        var query = {};
        query.tilematrix = tileMatrix;
        query.layer = imageryProvider._layer;
        query.style = imageryProvider._style;
        query.tilerow = row;
        query.tilecol = col;
        query.tilematrixset = imageryProvider._tileMatrixSetID;
        query.format = imageryProvider._format;
        if (defined9(staticDimensions)) {
          query = combine4(query, staticDimensions);
        }
        if (defined9(dynamicIntervalData)) {
          query = combine4(query, dynamicIntervalData);
        }
        resource = imageryProvider._resource.getDerivedResource({
          queryParameters: query,
          request
        });
      }
      var deferred = defer7();
      let xyz = { x: col, y: row, z: level };
      let tileLevel = resource._templateValues.z;
      if (tileLevel < this.showLevel) {
        deferred.reject();
        return deferred.promise;
      }
      this.requestJsonData(deferred, imageryProvider, resource, xyz, request);
      return deferred.promise;
    }
    requestJsonData(deferred, imageryProvider, url, xyz, request) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let z2 = xyz.z;
      let level = url._templateValues.z;
      let name2 = x3 + "_" + y3 + "_" + z2;
      if (this.cache[name2]) {
        deferred.resolve(this.image);
        return deferred;
      }
      let rectangle = this._tilingScheme.tileXYToRectangle(xyz.x, xyz.y, xyz.z);
      let rectangleObj = { west: rectangle.west, north: rectangle.north, width: rectangle.width, height: rectangle.height };
      let styleLevel = Math.round(this.viewer.camera.getLevel());
      let xyzStr = xyz.x + "_" + xyz.y + "_" + xyz.z;
      let promise = url.fetchImage({
        preferImageBitmap: false,
        flipY: true
      });
      if (!promise) {
        request.state = RequestState2.CANCELLED;
        deferred.reject();
        return;
      }
      promise.then(function(deferred2, xyz2, level2, request2, results) {
        this.jsonPromiseResult(deferred2, xyz2, level2, results, rectangle);
      }.bind(this, deferred, xyz, level, request), function(error) {
        deferred.reject();
      });
      return true;
    }
    jsonPromiseResult(deferred, xyz, level, results, rectangle) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let z2 = xyz.z;
      let name2 = x3 + "_" + y3 + "_" + z2;
      let tile = new EnvelopeWmtsDataSource_default(name2, results, rectangle, this.tileWidth, level, this.viewer, this.options, this.lightMap);
      this.cache[tile.name] = tile;
      deferred.resolve(this.image);
    }
    get url() {
      return this._resource.url;
    }
    get proxy() {
      return this._resource.proxy;
    }
    get tileWidth() {
      return this._tileWidth;
    }
    get tileHeight() {
      return this._tileHeight;
    }
    get maximumLevel() {
      return this._maximumLevel;
    }
    get minimumLevel() {
      return this._minimumLevel;
    }
    get tilingScheme() {
      return this._tilingScheme;
    }
    get rectangle() {
      return this._rectangle;
    }
    get tileDiscardPolicy() {
      return this._tileDiscardPolicy;
    }
    get errorEvent() {
      return this._errorEvent;
    }
    get format() {
      return this._format;
    }
    get readyPromise() {
      return this._readyPromise;
    }
    get credit() {
      return this._credit;
    }
    get hasAlphaChannel() {
      return true;
    }
    get clock() {
      return this._timeDynamicImagery.clock;
    }
    set clock(value) {
      this._timeDynamicImagery.clock = value;
    }
    get times() {
      return this._timeDynamicImagery.times;
    }
    set times(value) {
      this._timeDynamicImagery.times = value;
    }
    get dimensions() {
      return this._dimensions;
    }
    set dimensions(value) {
      if (this._dimensions !== value) {
        this._dimensions = value;
        if (defined9(this._reload)) {
          this._reload();
        }
      }
    }
    getTileCredits(x3, y3, level) {
      return void 0;
    }
    requestImage(x3, y3, level, request) {
      var result;
      var timeDynamicImagery = this._timeDynamicImagery;
      var currentInterval;
      if (defined9(timeDynamicImagery)) {
        currentInterval = timeDynamicImagery.currentInterval;
        result = timeDynamicImagery.getFromCache(x3, y3, level, request);
      }
      if (!defined9(result)) {
        result = this.requestImageNow(this, x3, y3, level, request, currentInterval);
      }
      if (defined9(result) && defined9(timeDynamicImagery)) {
        timeDynamicImagery.checkApproachingInterval(x3, y3, level, request);
      }
      return result;
    }
    pickFeatures(x3, y3, level, longitude, latitude) {
      return void 0;
    }
    destroy() {
      for (let key2 in this.cache) {
        let tile = this.cache[key2];
        tile.destroy();
      }
      this.cache = {};
    }
    removeImageryFromCache(x3, y3, z2) {
      let key2 = x3 + "_" + y3 + "_" + z2;
      let tile = this.cache[key2];
      if (tile) {
        tile.destroy();
        delete this.cache[key2];
      }
    }
    removeTile(xyzStr) {
      let tile = this.cache[xyzStr];
      if (tile) {
        tile.remove();
      }
    }
    redraw() {
      let layers = this.viewer.imageryLayers._layers;
      let imagerLayer = null;
      let index = -1;
      for (let i = 0; i < layers.length; i++) {
        let layer = layers[i];
        if (layer.imageryProvider == this) {
          imagerLayer = layer;
          index = i;
        }
      }
      if (imagerLayer) {
        this.viewer.imageryLayers.layerShownOrHidden.raiseEvent(
          imagerLayer,
          index,
          false
        );
        this.viewer.imageryLayers.layerShownOrHidden.raiseEvent(
          imagerLayer,
          index,
          true
        );
      }
    }
  };
  var EnvelopeWmtsImageryProvider_default = EnvelopeWmtsImageryProvider;

  // Source/custom/layer/hillshader/HillShaderTile.js
  var HillShaderTile = class {
    constructor(name2, gl, dem, texture, latrange, level) {
      this.name = name2;
      this.gl = gl;
      this.dem = dem;
      this.texture = texture;
      this.latrange = latrange;
      this.level = level;
      this.needsHillshadePrepare = true;
      this.renderTexture = null;
    }
    destroy() {
      if (this.renderTexture) {
        this.gl.deleteTexture(this.renderTexture);
      }
    }
  };
  var HillShaderTile_default = HillShaderTile;

  // Source/custom/layer/shaders/glsl/_prelude.fragment.js
  var prelude_fragment_default = "#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif\n";

  // Source/custom/layer/shaders/glsl/_prelude.vertex.js
  var prelude_vertex_default = "#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif\n\nfloat evaluate_zoom_function_1(const vec4 values, const float t) {\n    if (t < 1.0) {\n        return mix(values[0], values[1], t);\n    } else if (t < 2.0) {\n        return mix(values[1], values[2], t - 1.0);\n    } else {\n        return mix(values[2], values[3], t - 2.0);\n    }\n}\nvec4 evaluate_zoom_function_4(const vec4 value0, const vec4 value1, const vec4 value2, const vec4 value3, const float t) {\n    if (t < 1.0) {\n        return mix(value0, value1, t);\n    } else if (t < 2.0) {\n        return mix(value1, value2, t - 1.0);\n    } else {\n        return mix(value2, value3, t - 2.0);\n    }\n}\n\n// Unpack a pair of values that have been packed into a single float.\n// The packed values are assumed to be 8-bit unsigned integers, and are\n// packed like so:\n// packedValue = floor(input[0]) * 256 + input[1],\nvec2 unpack_float(const float packedValue) {\n    int packedIntValue = int(packedValue);\n    int v0 = packedIntValue / 256;\n    return vec2(v0, packedIntValue - v0 * 256);\n}\n\n\n// To minimize the number of attributes needed in the mapbox-gl-native shaders,\n// we encode a 4-component color into a pair of floats (i.e. a vec2) as follows:\n// [ floor(color.r * 255) * 256 + color.g * 255,\n//   floor(color.b * 255) * 256 + color.g * 255 ]\nvec4 decode_color(const vec2 encodedColor) {\n    return vec4(\n        unpack_float(encodedColor[0]) / 255.0,\n        unpack_float(encodedColor[1]) / 255.0\n    );\n}\n\n// Unpack a pair of paint values and interpolate between them.\nfloat unpack_mix_vec2(const vec2 packedValue, const float t) {\n    return mix(packedValue[0], packedValue[1], t);\n}\n\n// Unpack a pair of paint values and interpolate between them.\nvec4 unpack_mix_vec4(const vec4 packedColors, const float t) {\n    vec4 minColor = decode_color(vec2(packedColors[0], packedColors[1]));\n    vec4 maxColor = decode_color(vec2(packedColors[2], packedColors[3]));\n    return mix(minColor, maxColor, t);\n}\n\n// The offset depends on how many pixels are between the world origin and the edge of the tile:\n// vec2 offset = mod(pixel_coord, size)\n//\n// At high zoom levels there are a ton of pixels between the world origin and the edge of the tile.\n// The glsl spec only guarantees 16 bits of precision for highp floats. We need more than that.\n//\n// The pixel_coord is passed in as two 16 bit values:\n// pixel_coord_upper = floor(pixel_coord / 2^16)\n// pixel_coord_lower = mod(pixel_coord, 2^16)\n//\n// The offset is calculated in a series of steps that should preserve this precision:\nvec2 get_pattern_pos(const vec2 pixel_coord_upper, const vec2 pixel_coord_lower,\n    const vec2 pattern_size, const float tile_units_to_pixels, const vec2 pos) {\n\n    vec2 offset = mod(mod(mod(pixel_coord_upper, pattern_size) * 256.0, pattern_size) * 256.0 + pixel_coord_lower, pattern_size);\n    return (tile_units_to_pixels * pos + offset) / pattern_size;\n}\n";

  // Source/custom/layer/shaders/glsl/circle.fragment.js
  var circle_fragment_default = "\nvarying vec2 v_extrude;\nvarying lowp float v_antialiasblur;\n\nuniform highp vec4 color;\nuniform mediump float radius;\nuniform lowp float blur;\nuniform lowp float opacity;\nuniform vec4 stroke_color;\nuniform mediump float stroke_width;\nuniform lowp float stroke_opacity;\n\nvoid main() {\n\n    float extrude_length = length(v_extrude);\n    float antialiased_blur = -max(blur, v_antialiasblur);\n\n    float opacity_t = smoothstep(0.0, antialiased_blur, extrude_length - 1.0);\n\n    float color_t = stroke_width < 0.01 ? 0.0 : smoothstep(\n        antialiased_blur,\n        0.0,\n        extrude_length - radius / (radius + stroke_width)\n    );\n\n    gl_FragColor = opacity_t * mix(color * opacity, stroke_color * stroke_opacity, color_t);\n\n    //gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n";

  // Source/custom/layer/shaders/glsl/circle.vertex.js
  var circle_vertex_default = "uniform mat4 u_matrix;\nuniform bool u_pitch_with_map;\nuniform vec2 u_extrude_scale;\n\n\nuniform lowp float u_devicepixelratio;\n//uniform highp vec4 color;\nuniform mediump float radius;\n//uniform lowp float blur;\n//uniform lowp float opacity;\n//uniform vec4 stroke_color;\nuniform mediump float stroke_width;\n//uniform lowp float stroke_opacity;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_extrude;\nvarying lowp float v_antialiasblur;\nvoid main(void) {\n\n    // unencode the extrusion vector that we snuck into the a_pos vector\n    v_extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n\n    vec2 extrude = v_extrude * (radius + stroke_width) * u_extrude_scale;\n    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n    // in extrusion data\n    \n\n    if (u_pitch_with_map) {\n        gl_Position = u_matrix * vec4(floor(a_pos * 0.5 + extrude), 0, 1);\n        //gl_Position.xy += extrude;\n    } else {\n        gl_Position = u_matrix * vec4(floor(a_pos * 0.5), 0, 1);\n        gl_Position.xy += extrude * gl_Position.w;\n        gl_Position.z = 0.0;\n    }\n    // This is a minimum blur distance that serves as a faux-antialiasing for\n    // the circle. since blur is a ratio of the circle's size and the intent is\n    // to keep the blur at roughly 1px, the two are inversely related.\n    v_antialiasblur = 1.0 / u_devicepixelratio / (radius + stroke_width);\n}\n\n\n\n\n\n\n\n\n\n";

  // Source/custom/layer/shaders/glsl/fill.fragment.js
  var fill_fragment_default = "uniform highp vec4 u_color;\nuniform lowp float u_opacity;\nvoid main() {\n    gl_FragColor = u_color * u_opacity;\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n";

  // Source/custom/layer/shaders/glsl/fill.vertex.js
  var fill_vertex_default = "attribute vec2 a_pos;\nuniform mat4 u_matrix;\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    gl_Position.y =  - gl_Position.y;\n}\n";

  // Source/custom/layer/shaders/glsl/fill_outline.fragment.js
  var fill_outline_fragment_default = "uniform highp vec4 outline_color;\nuniform lowp float opacity;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = 1.0 - smoothstep(0.0, 1.0, dist);\n    gl_FragColor = outline_color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n";

  // Source/custom/layer/shaders/glsl/fill_outline.vertex.js
  var fill_outline_vertex_default = "attribute vec2 a_pos;\nuniform mat4 u_matrix;\nuniform vec2 u_world;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    gl_Position.y =  - gl_Position.y;\n    v_pos = (gl_Position.xy / gl_Position.w + 1.0) / 2.0 * u_world;\n}\n";

  // Source/custom/layer/shaders/glsl/fill_outline_pattern.fragment.js
  var fill_outline_pattern_fragment_default = "uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    // find distance to outline for alpha interpolation\n\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = 1.0 - smoothstep(0.0, 1.0, dist);\n\n\n    gl_FragColor = mix(color1, color2, u_mix) * alpha * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n";

  // Source/custom/layer/shaders/glsl/fill_outline_pattern.vertex.js
  var fill_outline_pattern_vertex_default = "uniform mat4 u_matrix;\nuniform vec2 u_world;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    gl_Position.y =  - gl_Position.y;\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, a_pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, a_pos);\n\n    v_pos = (gl_Position.xy / gl_Position.w + 1.0) / 2.0 * u_world;\n}\n";

  // Source/custom/layer/shaders/glsl/fill_pattern.fragment.js
  var fill_pattern_fragment_default = "uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    gl_FragColor = mix(color1, color2, u_mix) * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n";

  // Source/custom/layer/shaders/glsl/fill_pattern.vertex.js
  var fill_pattern_vertex_default = "uniform mat4 u_matrix;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    gl_Position.y =  - gl_Position.y;\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, a_pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, a_pos);\n}\n";

  // Source/custom/layer/shaders/glsl/line.fragment.js
  var line_fragment_default = "\n\nvarying vec2 v_width2;\nvarying vec2 v_normal;\nvarying float v_gamma_scale;\nuniform highp vec4 color;\nuniform lowp float blur;\nuniform lowp float opacity;\nvoid main() {\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    gl_FragColor = color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n";

  // Source/custom/layer/shaders/glsl/line.vertex.js
  var line_vertex_default = `

// the distance over which the line edge fades out.
// Retina devices need a smaller distance to avoid aliasing.
#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0

// floor(127 / 2) == 63.0
// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is
// stored in a byte (-128..127). we scale regular normals up to length 63, but
// there are also "special" normals that have a bigger length (of up to 126 in
// this case).
// #define scale 63.0
#define scale 0.015873016

attribute vec2 a_pos;
attribute vec4 a_data;
attribute vec2 a_txy;

uniform mat4 u_matrix;
uniform mediump float u_ratio;
uniform mediump float u_width;
uniform vec2 u_gl_units_to_pixels;

varying vec2 v_normal;
varying vec2 v_width2;
varying float v_gamma_scale;

 uniform mediump float a_gapwidth;
 uniform float a_offset;
mediump  float gapwidth;
lowp float offset;


void main() {

    vec2 a_extrude = a_data.xy - 128.0;
    float a_direction = mod(a_data.z, 4.0) - 1.0;

    // We store the texture normals in the most insignificant bit
    // transform y so that 0 => -1 and 1 => 1
    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap
    // y is 1 if the normal points up, and -1 if it points down
    mediump vec2 normal = a_txy;
    normal.y = sign(normal.y - 0.5);
    v_normal = normal;


    // these transformations used to be applied in the JS and native code bases.
    // moved them into the shader for clarity and simplicity.
    gapwidth = a_gapwidth / 2.0;
    float width = u_width / 2.0;
    offset = -1.0 * a_offset;

    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);
    float outset = gapwidth + width * (gapwidth > 0.0 ? 2.0 : 1.0) + ANTIALIASING;

    // Scale the extrusion vector down to a normal and then up by the line width
    // of this vertex.
    mediump vec2 dist = outset * a_extrude * scale;

    // Calculate the offset when drawing a line that is to the side of the actual line.
    // We do this by creating a vector that points towards the extrude, but rotate
    // it when we're drawing round end points (a_direction = -1 or 1) since their
    // extrude vector points in another direction.
    mediump float u = 0.5 * a_direction;
    mediump float t = 1.0 - abs(u);
    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);

    // Remove the texture normal bit to get the position
//    vec2 pos = a_pos;

    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);

    gl_Position = u_matrix * vec4(a_pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;
    gl_Position.y =  - gl_Position.y;

    // calculate how much the perspective view squishes or stretches the extrude
    float extrude_length_without_perspective = length(dist);
    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);
    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;

    v_width2 = vec2(outset, inset);
}
`;

  // Source/custom/layer/shaders/glsl/line_pattern.fragment.js
  var line_pattern_fragment_default = "uniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform vec2 u_texsize;\nuniform float u_fade;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    float x_a = mod(v_linesofar / u_pattern_size_a.x, 1.0);\n    float x_b = mod(v_linesofar / u_pattern_size_b.x, 1.0);\n    float y_a = 0.5 + (v_normal.y * v_width2.s / u_pattern_size_a.y);\n    float y_b = 0.5 + (v_normal.y * v_width2.s / u_pattern_size_b.y);\n    vec2 pos_a = mix(u_pattern_tl_a / u_texsize, u_pattern_br_a / u_texsize, vec2(x_a, y_a));\n    vec2 pos_b = mix(u_pattern_tl_b / u_texsize, u_pattern_br_b / u_texsize, vec2(x_b, y_b));\n\n    vec4 color = mix(texture2D(u_image, pos_a), texture2D(u_image, pos_b), u_fade);\n\n    gl_FragColor = color * alpha * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n";

  // Source/custom/layer/shaders/glsl/line_pattern.vertex.js
  var line_pattern_vertex_default = `// floor(127 / 2) == 63.0
// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is
// stored in a byte (-128..127). we scale regular normals up to length 63, but
// there are also "special" normals that have a bigger length (of up to 126 in
// this case).
// #define scale 63.0
#define scale 0.015873016

// We scale the distance before adding it to the buffers so that we can store
// long distances for long segments. Use this value to unscale the distance.
#define LINE_DISTANCE_SCALE 2.0

// the distance over which the line edge fades out.
// Retina devices need a smaller distance to avoid aliasing.
#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0

attribute vec2 a_pos;
attribute vec4 a_data;

uniform mat4 u_matrix;
uniform mediump float u_ratio;
uniform mediump float u_width;
uniform vec2 u_gl_units_to_pixels;

varying vec2 v_normal;
varying vec2 v_width2;
varying float v_linesofar;
varying float v_gamma_scale;

#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth

void main() {
    #pragma mapbox: initialize lowp float blur
    #pragma mapbox: initialize lowp float opacity
    #pragma mapbox: initialize lowp float offset
    #pragma mapbox: initialize mediump float gapwidth

    vec2 a_extrude = a_data.xy - 128.0;
    float a_direction = mod(a_data.z, 4.0) - 1.0;
    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;

    // We store the texture normals in the most insignificant bit
    // transform y so that 0 => -1 and 1 => 1
    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap
    // y is 1 if the normal points up, and -1 if it points down
    mediump vec2 normal = mod(a_pos, 2.0);
    normal.y = sign(normal.y - 0.5);
    v_normal = normal;

    // these transformations used to be applied in the JS and native code bases. 
    // moved them into the shader for clarity and simplicity. 
    gapwidth = gapwidth / 2.0;
    float width = u_width / 2.0;
    offset = -1.0 * offset; 

    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);
    float outset = gapwidth + width * (gapwidth > 0.0 ? 2.0 : 1.0) + ANTIALIASING;

    // Scale the extrusion vector down to a normal and then up by the line width
    // of this vertex.
    mediump vec2 dist = outset * a_extrude * scale;

    // Calculate the offset when drawing a line that is to the side of the actual line.
    // We do this by creating a vector that points towards the extrude, but rotate
    // it when we're drawing round end points (a_direction = -1 or 1) since their
    // extrude vector points in another direction.
    mediump float u = 0.5 * a_direction;
    mediump float t = 1.0 - abs(u);
    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);

    // Remove the texture normal bit to get the position
    vec2 pos = floor(a_pos * 0.5);

    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);
    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;
    gl_Position.y =  - gl_Position.y;

    // calculate how much the perspective view squishes or stretches the extrude
    float extrude_length_without_perspective = length(dist);
    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);
    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;

    v_linesofar = a_linesofar;
    v_width2 = vec2(outset, inset);
}
`;

  // Source/custom/layer/shaders/glsl/line_sdf.fragment.js
  var line_sdf_fragment_default = "\nuniform sampler2D u_image;\nuniform float u_sdfgamma;\nuniform float u_mix;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\n\nuniform highp vec4 color;\nuniform lowp float blur;\nuniform lowp float opacity;\n\n\nvoid main() {\n       // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    float sdfdist_a = texture2D(u_image, -v_tex_a).a;\n    float sdfdist_b = texture2D(u_image, -v_tex_b).a;\n    float sdfdist = mix(sdfdist_a, sdfdist_b, u_mix);\n    alpha *= smoothstep(0.5 - u_sdfgamma, 0.5 + u_sdfgamma, sdfdist);\n\n    gl_FragColor = color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n";

  // Source/custom/layer/shaders/glsl/line_sdf.vertex.js
  var line_sdf_vertex_default = `// floor(127 / 2) == 63.0
// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is
// stored in a byte (-128..127). we scale regular normals up to length 63, but
// there are also "special" normals that have a bigger length (of up to 126 in
// this case).
// #define scale 63.0
#define scale 0.015873016

// We scale the distance before adding it to the buffers so that we can store
// long distances for long segments. Use this value to unscale the distance.
#define LINE_DISTANCE_SCALE 2.0

// the distance over which the line edge fades out.
// Retina devices need a smaller distance to avoid aliasing.
#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0

attribute vec2 a_pos;
attribute vec4 a_data;
attribute vec2 a_txy;

uniform mat4 u_matrix;
uniform mediump float u_ratio;
uniform vec2 u_patternscale_a;
uniform float u_tex_y_a;
uniform vec2 u_patternscale_b;
uniform float u_tex_y_b;
uniform vec2 u_gl_units_to_pixels;
uniform mediump float u_width;

varying vec2 v_normal;
varying vec2 v_width2;
varying vec2 v_tex_a;
varying vec2 v_tex_b;
varying float v_gamma_scale;


uniform mediump float a_gapwidth;
uniform lowp float a_offset;
mediump float gapwidth;
lowp float offset;

void main() {
    vec2 a_extrude = a_data.xy - 128.0;
    float a_direction = mod(a_data.z, 4.0) - 1.0;
    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;

    // We store the texture normals in the most insignificant bit
    // transform y so that 0 => -1 and 1 => 1
    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap
    // y is 1 if the normal points up, and -1 if it points down
    mediump vec2 normal = a_txy;
    normal.y = sign(normal.y - 0.5);
    v_normal = normal;

    // these transformations used to be applied in the JS and native code bases. 
    // moved them into the shader for clarity and simplicity. 
    gapwidth = a_gapwidth / 2.0;
    float width = u_width / 2.0;
    offset = -1.0 * a_offset;

    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);
    float outset = gapwidth + width * (gapwidth > 0.0 ? 2.0 : 1.0) + ANTIALIASING;

    // Scale the extrusion vector down to a normal and then up by the line width
    // of this vertex.
    mediump vec2 dist =outset * a_extrude * scale;

    // Calculate the offset when drawing a line that is to the side of the actual line.
    // We do this by creating a vector that points towards the extrude, but rotate
    // it when we're drawing round end points (a_direction = -1 or 1) since their
    // extrude vector points in another direction.
    mediump float u = 0.5 * a_direction;
    mediump float t = 1.0 - abs(u);
    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);

    // Remove the texture normal bit to get the position
    vec2 pos = a_pos;

    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);
    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;
    gl_Position.y =  - gl_Position.y;
    // calculate how much the perspective view squishes or stretches the extrude
    float extrude_length_without_perspective = length(dist);
    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);
    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;

    v_tex_a = vec2(a_linesofar * u_patternscale_a.x, normal.y * u_patternscale_a.y + u_tex_y_a);
    v_tex_b = vec2(a_linesofar * u_patternscale_b.x, normal.y * u_patternscale_b.y + u_tex_y_b);

    v_width2 = vec2(outset, inset);
}
`;

  // Source/custom/layer/shaders/glsl/hillshade.fragment.js
  var hillshade_fragment_default = "uniform sampler2D u_image;\nvarying vec2 v_pos;\n\nuniform vec2 u_latrange;\nuniform vec2 u_light;\nuniform vec4 u_shadow;\nuniform vec4 u_highlight;\nuniform vec4 u_accent;\n\n#define PI 3.141592653589793\n\nvoid main() {\n    vec4 pixel = texture2D(u_image, v_pos);\n\n    vec2 deriv = ((pixel.rg * 2.0) - 1.0);\n\n    // We divide the slope by a scale factor based on the cosin of the pixel's approximate latitude\n    // to account for mercator projection distortion. see #4807 for details\n    float scaleFactor = cos(radians((u_latrange[0] - u_latrange[1]) * (1.0 - v_pos.y) + u_latrange[1]));\n    // We also multiply the slope by an arbitrary z-factor of 1.25\n    float slope = atan(1.25 * length(deriv) / scaleFactor);\n    float aspect = deriv.x != 0.0 ? atan(deriv.y, -deriv.x) : PI / 2.0 * (deriv.y > 0.0 ? 1.0 : -1.0);\n\n    float intensity = u_light.x;\n    // We add PI to make this property match the global light object, which adds PI/2 to the light's azimuthal\n    // position property to account for 0deg corresponding to north/the top of the viewport in the style spec\n    // and the original shader was written to accept (-illuminationDirection - 90) as the azimuthal.\n    float azimuth = u_light.y + PI;\n\n    // We scale the slope exponentially based on intensity, using a calculation similar to\n    // the exponential interpolation function in the style spec:\n    // https://github.com/mapbox/mapbox-gl-js/blob/master/src/style-spec/expression/definitions/interpolate.js#L217-L228\n    // so that higher intensity values create more opaque hillshading.\n    float base = 1.875 - intensity * 1.75;\n    float maxValue = 0.5 * PI;\n    float scaledSlope = intensity != 0.5 ? ((pow(base, slope) - 1.0) / (pow(base, maxValue) - 1.0)) * maxValue : slope;\n\n    // The accent color is calculated with the cosine of the slope while the shade color is calculated with the sine\n    // so that the accent color's rate of change eases in while the shade color's eases out.\n    float accent = cos(scaledSlope);\n    // We multiply both the accent and shade color by a clamped intensity value\n    // so that intensities >= 0.5 do not additionally affect the color values\n    // while intensity values < 0.5 make the overall color more transparent.\n    vec4 accent_color = (1.0 - accent) * u_accent * clamp(intensity * 2.0, 0.0, 1.0);\n    float shade = abs(mod((aspect + azimuth) / PI + 0.5, 2.0) - 1.0);\n    vec4 shade_color = mix(u_shadow, u_highlight, shade) * sin(scaledSlope) * clamp(intensity * 2.0, 0.0, 1.0);\n    gl_FragColor = accent_color * (1.0 - shade_color.a) + shade_color;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n";

  // Source/custom/layer/shaders/glsl/hillshade.vertex.js
  var hillshade_vertex_default = "uniform mat4 u_matrix;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    gl_Position.y =  - gl_Position.y;\n    v_pos = a_texture_pos / 32768.0;\n}\n";

  // Source/custom/layer/shaders/glsl/hillshade_prepare.fragment.js
  var hillshade_prepare_fragment_default = "#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D u_image;\nvarying vec2 v_pos;\nuniform vec2 u_dimension;\nuniform float u_zoom;\nuniform float u_maxzoom;\n\nfloat getElevation(vec2 coord, float bias) {\n    // Convert encoded elevation value to meters\n    vec4 data = texture2D(u_image, coord) * 255.0;\n    return (data.r + data.g * 256.0 + data.b * 256.0 * 256.0) / 4.0;\n}\n\nvoid main() {\n    vec2 epsilon = 1.0 / u_dimension;\n\n    // queried pixels:\n    // +-----------+\n    // |   |   |   |\n    // | a | b | c |\n    // |   |   |   |\n    // +-----------+\n    // |   |   |   |\n    // | d | e | f |\n    // |   |   |   |\n    // +-----------+\n    // |   |   |   |\n    // | g | h | i |\n    // |   |   |   |\n    // +-----------+\n\n    float a = getElevation(v_pos + vec2(-epsilon.x, -epsilon.y), 0.0);\n    float b = getElevation(v_pos + vec2(0, -epsilon.y), 0.0);\n    float c = getElevation(v_pos + vec2(epsilon.x, -epsilon.y), 0.0);\n    float d = getElevation(v_pos + vec2(-epsilon.x, 0), 0.0);\n    float e = getElevation(v_pos, 0.0);\n    float f = getElevation(v_pos + vec2(epsilon.x, 0), 0.0);\n    float g = getElevation(v_pos + vec2(-epsilon.x, epsilon.y), 0.0);\n    float h = getElevation(v_pos + vec2(0, epsilon.y), 0.0);\n    float i = getElevation(v_pos + vec2(epsilon.x, epsilon.y), 0.0);\n\n    // here we divide the x and y slopes by 8 * pixel size\n    // where pixel size (aka meters/pixel) is:\n    // circumference of the world / (pixels per tile * number of tiles)\n    // which is equivalent to: 8 * 40075016.6855785 / (512 * pow(2, u_zoom))\n    // which can be reduced to: pow(2, 19.25619978527 - u_zoom)\n    // we want to vertically exaggerate the hillshading though, because otherwise\n    // it is barely noticeable at low zooms. to do this, we multiply this by some\n    // scale factor pow(2, (u_zoom - u_maxzoom) * a) where a is an arbitrary value\n    // Here we use a=0.3 which works out to the expression below. see \n    // nickidlugash's awesome breakdown for more info\n    // https://github.com/mapbox/mapbox-gl-js/pull/5286#discussion_r148419556\n    float exaggeration = u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;\n\n    vec2 deriv = vec2(\n        (c + f + f + i) - (a + d + d + g),\n        (g + h + h + i) - (a + b + b + c)\n    ) /  pow(2.0, (u_zoom - u_maxzoom) * exaggeration + 19.2562 - u_zoom);\n\n    gl_FragColor = clamp(vec4(\n        deriv.x / 2.0 + 0.5,\n        deriv.y / 2.0 + 0.5,\n        1.0,\n        1.0), 0.0, 1.0);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n";

  // Source/custom/layer/shaders/glsl/hillshade_prepare.vertex.js
  var hillshade_prepare_vertex_default = "uniform mat4 u_matrix;\nuniform vec2 u_dimension;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n\n    highp vec2 epsilon = 1.0 / u_dimension;\n    float scale = (u_dimension.x - 2.0) / u_dimension.x;\n    v_pos = (a_texture_pos / 32768.0) * scale + epsilon;\n}\n";

  // Source/custom/layer/shaders/Shaders.js
  var Shaders_default = {
    prelude: {
      fragmentSource: prelude_fragment_default,
      vertexSource: prelude_vertex_default
    },
    circle: {
      fragmentSource: circle_fragment_default,
      vertexSource: circle_vertex_default
    },
    fill: {
      fragmentSource: fill_fragment_default,
      vertexSource: fill_vertex_default
    },
    fillOutline: {
      fragmentSource: fill_outline_fragment_default,
      vertexSource: fill_outline_vertex_default
    },
    fillOutlinePattern: {
      fragmentSource: fill_outline_pattern_fragment_default,
      vertexSource: fill_outline_pattern_vertex_default
    },
    fillPattern: {
      fragmentSource: fill_pattern_fragment_default,
      vertexSource: fill_pattern_vertex_default
    },
    line: {
      fragmentSource: line_fragment_default,
      vertexSource: line_vertex_default
    },
    linePattern: {
      fragmentSource: line_pattern_fragment_default,
      vertexSource: line_pattern_vertex_default
    },
    lineSDF: {
      fragmentSource: line_sdf_fragment_default,
      vertexSource: line_sdf_vertex_default
    },
    hillshade: {
      fragmentSource: hillshade_fragment_default,
      vertexSource: hillshade_vertex_default
    },
    hillshadePrepare: {
      fragmentSource: hillshade_prepare_fragment_default,
      vertexSource: hillshade_prepare_vertex_default
    }
  };

  // Source/custom/layer/shaders/ProgramFactory.js
  var cache = {};
  var ProgramFactory = class {
    static createProgram(gl, name2) {
      let result = cache[name2];
      if (!result) {
        let shader = Shaders_default[name2];
        let definesSource = `#define MAPBOX_GL_JS
#define DEVICE_PIXEL_RATIO ${window.devicePixelRatio.toFixed(1)}
`;
        if (shader.definePragma)
          definesSource += shader.definePragma;
        let vertexShader = ProgramFactory.makeShader(gl, definesSource + Shaders_default.prelude.fragmentSource + shader.fragmentSource, gl.FRAGMENT_SHADER);
        let fragmentShader = ProgramFactory.makeShader(gl, definesSource + Shaders_default.prelude.vertexSource + shader.vertexSource, gl.VERTEX_SHADER);
        let program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        const numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        result = { program, numAttributes };
        for (let i = 0; i < numAttributes; i++) {
          const attribute = gl.getActiveAttrib(program, i);
          result[attribute.name] = gl.getAttribLocation(program, attribute.name);
        }
        const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < numUniforms; i++) {
          const uniform = gl.getActiveUniform(program, i);
          result[uniform.name] = gl.getUniformLocation(program, uniform.name);
        }
        cache[name2] = result;
      }
      gl.useProgram(result.program);
      return result;
    }
    static compile(fragmentSource, vertexSource) {
      const re = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g;
      const staticAttributes = vertexSource.match(/attribute ([\w]+) ([\w]+)/g);
      const fragmentUniforms = fragmentSource.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g);
      const vertexUniforms = vertexSource.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g);
      const staticUniforms = vertexUniforms ? vertexUniforms.concat(fragmentUniforms) : fragmentUniforms;
      const fragmentPragmas = {};
      fragmentSource = fragmentSource.replace(re, (match2, operation, precision, type, name2) => {
        fragmentPragmas[name2] = true;
        if (operation === "define") {
          return `
#ifndef HAS_UNIFORM_u_${name2}
varying ${precision} ${type} ${name2};
#else
uniform ${precision} ${type} u_${name2};
#endif
`;
        } else {
          return `
#ifdef HAS_UNIFORM_u_${name2}
    ${precision} ${type} ${name2} = u_${name2};
#endif
`;
        }
      });
      vertexSource = vertexSource.replace(re, (match2, operation, precision, type, name2) => {
        const attrType = type === "float" ? "vec2" : "vec4";
        const unpackType = name2.match(/color/) ? "color" : attrType;
        if (fragmentPragmas[name2]) {
          if (operation === "define") {
            return `
#ifndef HAS_UNIFORM_u_${name2}
uniform lowp float u_${name2}_t;
attribute ${precision} ${attrType} a_${name2};
varying ${precision} ${type} ${name2};
#else
uniform ${precision} ${type} u_${name2};
#endif
`;
          } else {
            if (unpackType === "vec4") {
              return `
#ifndef HAS_UNIFORM_u_${name2}
    ${name2} = a_${name2};
#else
    ${precision} ${type} ${name2} = u_${name2};
#endif
`;
            } else {
              return `
#ifndef HAS_UNIFORM_u_${name2}
    ${name2} = unpack_mix_${unpackType}(a_${name2}, u_${name2}_t);
#else
    ${precision} ${type} ${name2} = u_${name2};
#endif
`;
            }
          }
        } else {
          if (operation === "define") {
            return `
#ifndef HAS_UNIFORM_u_${name2}
uniform lowp float u_${name2}_t;
attribute ${precision} ${attrType} a_${name2};
#else
uniform ${precision} ${type} u_${name2};
#endif
`;
          } else {
            if (unpackType === "vec4") {
              return `
#ifndef HAS_UNIFORM_u_${name2}
    ${precision} ${type} ${name2} = a_${name2};
#else
    ${precision} ${type} ${name2} = u_${name2};
#endif
`;
            } else {
              return `
#ifndef HAS_UNIFORM_u_${name2}
    ${precision} ${type} ${name2} = unpack_mix_${unpackType}(a_${name2}, u_${name2}_t);
#else
    ${precision} ${type} ${name2} = u_${name2};
#endif
`;
            }
          }
        }
      });
      return { fragmentSource, vertexSource, staticAttributes, staticUniforms };
    }
    static makeShader(gl, src, type) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
      }
      return shader;
    }
  };
  var ProgramFactory_default = ProgramFactory;

  // Source/custom/layer/hillshader/draw/DrawHillshade.js
  var EXTENT = 8192;
  var mat4 = gl_matrix_default.mat4;
  function drawHillshade(hillProvider, tile) {
    if (tile.needsHillshadePrepare) {
      prepareHillshade(hillProvider, tile);
    }
  }
  function renderHillshade(hillProvider, tile, matrix) {
    const gl = hillProvider.viewer.scene.context._gl;
    const program = hillProvider.useProgram("hillshade");
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, tile.renderTexture);
    hillshadeUniformValues(gl, program, hillProvider, tile, matrix);
    const buffer4 = hillProvider.rasterBoundsBuffer;
    const vao = hillProvider.rasterBoundsVAO;
    vao.bind(gl, program, buffer4);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, buffer4.length);
  }
  function prepareHillshade(hillProvider, tile) {
    const gl = hillProvider.viewer.scene.context._gl;
    if (tile.dem && tile.dem.data) {
      const tileSize = tile.dem.dim;
      const textureStride = tile.dem.stride;
      const pixelData = new RGBAImage_default({ width: tile.dem.stride, height: tile.dem.stride }, new Uint8Array(tile.dem.data.buffer));
      gl.activeTexture(gl.TEXTURE1);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
      if (tile.demTexture) {
        const demTexture = tile.demTexture;
        demTexture.update(pixelData, { premultiply: false });
        tile.frambuffer = gl.createFramebuffer();
        demTexture.bind(gl.NEAREST, gl.CLAMP_TO_EDGE);
      } else {
        tile.demTexture = new MapboxTexture_default(gl, pixelData, gl.RGBA, { premultiply: false });
        tile.demTexture.bind(gl.NEAREST, gl.CLAMP_TO_EDGE);
      }
      gl.activeTexture(gl.TEXTURE2);
      let frambuffer = tile.frambuffer;
      if (!frambuffer) {
        const renderTexture = new MapboxTexture_default(gl, { width: tileSize, height: tileSize, data: null }, gl.RGBA);
        renderTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);
        frambuffer = tile.frambuffer = gl.createFramebuffer();
        tile.renderTexture = renderTexture.texture;
        gl.bindFramebuffer(gl.FRAMEBUFFER, frambuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture.texture, 0);
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, frambuffer);
      gl.viewport(0, 0, tileSize, tileSize);
      const program = hillProvider.useProgram("hillshadePrepare");
      const buffer4 = hillProvider.rasterBoundsBuffer;
      const vao = hillProvider.rasterBoundsVAO;
      hillshadeUniformPrepareValues(gl, program, tile);
      vao.bind(gl, program, buffer4);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, buffer4.length);
      tile.needsHillshadePrepare = false;
    }
  }
  function hillshadeUniformValues(gl, program, hillProvider, tile, matrix) {
    const shadow = hillProvider.options["hillshade-shadow-color"];
    const highlight = hillProvider.options["hillshade-highlight-color"];
    const accent = hillProvider.options["hillshade-accent-color"];
    let azimuthal = hillProvider.options["hillshade-illumination-direction"] * (Math.PI / 180);
    if (hillProvider.options["hillshade-illumination-anchor"] === "viewport") {
      azimuthal -= hillProvider.viewer.camera.heading;
    }
    const align = true;
    gl.uniformMatrix4fv(program.u_matrix, false, matrix);
    gl.uniform1i(program.u_image, 2);
    gl.uniform2fv(program.u_latrange, tile.latrange);
    gl.uniform2f(program.u_light, hillProvider.options["hillshade-exaggeration"], azimuthal);
    gl.uniform4f(program.u_shadow, shadow[0], shadow[1], shadow[2], shadow[3]);
    gl.uniform4f(program.u_highlight, highlight[0], highlight[1], highlight[2], highlight[3]);
    gl.uniform4f(program.u_accent, accent[0], accent[1], accent[2], accent[3]);
  }
  function hillshadeUniformPrepareValues(gl, program, tile) {
    const stride = tile.dem.stride;
    const matrix = mat4.create();
    mat4.ortho(matrix, 0, EXTENT, -EXTENT, 0, 0, 1);
    mat4.translate(matrix, matrix, [0, -EXTENT, 0]);
    gl.uniformMatrix4fv(program.u_matrix, false, matrix);
    gl.uniform1i(program.u_image, 1);
    gl.uniform2fv(program.u_dimension, [stride, stride]);
    gl.uniform1f(program.u_zoom, tile.level);
    gl.uniform1f(program.u_maxzoom, 22);
  }
  var DrawHillshade_default = { drawHillshade, renderHillshade };

  // Source/custom/layer/hillshader/draw/DrawFboHillShade.js
  var mat42 = gl_matrix_default.mat4;
  var DrawFboHillShade = class {
    static drawFboHillShade(hillProvider, tile, key2) {
      const gl = hillProvider.viewer.scene.context._gl;
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      let texture = hillProvider.textureQueue.getOne(key2, hillProvider._zoom);
      if (!texture) {
        DrawHillshade_default.drawHillshade(hillProvider, tile);
        texture = DrawFboHillShade.initFramebufferObject(hillProvider, gl, hillProvider.scale);
        hillProvider.textureQueue.add(key2, hillProvider._zoom, texture);
        DrawFboHillShade.drawRasterTile(hillProvider, tile, gl);
      }
      gl.disable(gl.BLEND);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0, 0, hillProvider.viewer._lastWidth, hillProvider.viewer._lastHeight);
      return texture;
    }
    static drawRasterTile(hillProvider, tile, gl) {
      let m = mat42.identity(new Float32Array(16));
      mat42.translate(m, m, [-1, -1, 0]);
      mat42.scale(m, m, [2 / 8192, 2 / 8192, 1]);
      DrawFboHillShade.cleanViewPort(gl, hillProvider._tileWidth * hillProvider.ratio * hillProvider.scale, hillProvider._tileWidth * hillProvider.ratio * hillProvider.scale);
      gl.clearColor(1, 1, 1, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
      DrawHillshade_default.renderHillshade(hillProvider, tile, m);
    }
    static initFramebufferObject(hillProvider, gl, scale) {
      let fbo = hillProvider.viewportFbo;
      if (!fbo) {
        let fbo2 = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo2);
        hillProvider.viewportFbo = fbo2;
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      }
      gl.activeTexture(gl.TEXTURE0);
      let texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, hillProvider._tileWidth * hillProvider.ratio * scale, hillProvider._tileWidth * hillProvider.ratio * scale, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      return texture;
    }
    static cleanViewPort(gl, width, height) {
      gl.viewport(0, 0, width, height);
    }
  };
  var DrawFboHillShade_default = DrawFboHillShade.drawFboHillShade;

  // Source/custom/layer/hillshader/HillShaderTileServiceImageryProvider.js
  var combine5 = Cesium.combine;
  var Credit5 = Cesium.Credit;
  var defaultValue8 = Cesium.defaultValue;
  var defined10 = Cesium.defined;
  var DeveloperError7 = Cesium.DeveloperError;
  var Event5 = Cesium.Event;
  var freezeObject2 = Cesium.freezeObject;
  var isArray4 = Array.isArray;
  var Rectangle4 = Cesium.Rectangle;
  var Resource5 = Cesium.Resource;
  var WebMercatorTilingScheme5 = Cesium.WebMercatorTilingScheme;
  var ImageryProvider2 = Cesium.ImageryProvider;
  var TimeDynamicImagery4 = Cesium.TimeDynamicImagery;
  var RequestState3 = Cesium.RequestState;
  var defer8 = Cesium.defer;
  var BufferUtil = Cesium.BufferUtil;
  var CesiumMath5 = Cesium.Math;
  var EXTENT2 = 8192;
  var defaultParameters4 = {
    service: "WMTS",
    version: "1.0.0",
    request: "GetTile"
  };
  var HillShaderTileServiceImageryProvider = class {
    constructor(viewer3, options, shaders) {
      options = defaultValue8(options, defaultValue8.EMPTY_OBJECT);
      this.id = Math.random();
      this.viewer = viewer3;
      this.needDecode = defaultValue8(options.needDecode, false);
      if (!defined10(options.url)) {
        throw new DeveloperError7("options.url is required.");
      }
      var resource = Resource5.createIfNeeded(options.url);
      var style = options.style;
      var tileMatrixSetID = options.tileMatrixSetID;
      var url = resource.url;
      if (url.indexOf("{") >= 0) {
        var templateValues = {
          style,
          Style: style,
          TileMatrixSet: tileMatrixSetID
        };
        resource.setTemplateValues(templateValues);
        this._useKvp = false;
      } else {
        resource.setQueryParameters(defaultParameters4);
        this._useKvp = true;
      }
      this._resource = resource;
      this._layer = options.layer;
      this._style = style;
      this._tileMatrixSetID = tileMatrixSetID;
      this._tileMatrixLabels = options.tileMatrixLabels;
      this._format = defaultValue8(options.format, "image/jpeg");
      this._tileDiscardPolicy = options.tileDiscardPolicy;
      this._tilingScheme = defined10(options.tilingScheme) ? options.tilingScheme : new WebMercatorTilingScheme5({ ellipsoid: options.ellipsoid });
      this._tileWidth = defaultValue8(options.tileWidth, 256);
      this._tileHeight = defaultValue8(options.tileHeight, 256);
      this._minimumLevel = defaultValue8(options.minimumLevel, 0);
      this._maximumLevel = options.maximumLevel;
      this._rectangle = defaultValue8(options.rectangle, this._tilingScheme.rectangle);
      this._dimensions = options.dimensions;
      var that = this;
      this._reload = void 0;
      if (defined10(options.times)) {
        this._timeDynamicImagery = new TimeDynamicImagery4({
          clock: options.clock,
          times: options.times,
          requestImageFunction: function(x3, y3, level, request, interval) {
            return requestImage(that, x3, y3, level, request, interval);
          },
          reloadFunction: function() {
            if (defined10(that._reload)) {
              that._reload();
            }
          }
        });
      }
      this._readyPromise = defer8();
      var swTile = this._tilingScheme.positionToTileXY(Rectangle4.southwest(this._rectangle), this._minimumLevel);
      var neTile = this._tilingScheme.positionToTileXY(Rectangle4.northeast(this._rectangle), this._minimumLevel);
      var tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);
      if (tileCount > 4) {
        throw new DeveloperError7("The imagery provider's rectangle and minimumLevel indicate that there are " + tileCount + " tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.");
      }
      this._errorEvent = new Event5();
      var credit = options.credit;
      this._credit = typeof credit === "string" ? new Credit5(credit) : credit;
      this._subdomains = options.subdomains;
      if (isArray4(this._subdomains)) {
        this._subdomains = this._subdomains.slice();
      } else if (defined10(this._subdomains) && this._subdomains.length > 0) {
        this._subdomains = this._subdomains.split("");
      } else {
        this._subdomains = ["a", "b", "c"];
      }
      this.ready = {
        value: true
      };
      this._readyPromise.resolve(true);
      this.cache = {};
      this.options = options;
      this.lightMap = {};
      this.showLevel = options.showLevel || 16;
      this.processor = new Cesium.TaskProcessor("HillShaderWorker", Number.POSITIVE_INFINITY);
      var canvas = document.createElement("canvas");
      this.image = canvas;
      this.ratio = 1;
      if (options.hasOwnProperty("ratio")) {
        this.ratio = options.ratio;
      }
      this.textureQueue = new TextureQueue_default(this.viewer.scene.context._gl);
      this.decimalLevel = 10;
      this.getDecimalLevel();
      this.viewer.scene.camera.moveEnd.addEventListener(this.getDecimalLevel.bind(this));
      this.encoding = "mapbox";
      const rasterBoundsArray = new RasterBoundsArray_default();
      rasterBoundsArray.emplaceBack(0, 0, 0, 0, 0, 0);
      rasterBoundsArray.emplaceBack(EXTENT2, 0, 32767, 0, 0, 0);
      rasterBoundsArray.emplaceBack(0, EXTENT2, 0, 32767, 0, 0);
      rasterBoundsArray.emplaceBack(EXTENT2, EXTENT2, 32767, 32767, 0, 0);
      this.rasterBoundsBuffer = BufferUtil.fromStructArray(rasterBoundsArray, BufferUtil.BufferType.VERTEX);
      this.rasterBoundsVAO = new VertexArrayObject_default();
      if (this.options["hillshade-shadow-color"]) {
        this.options["hillshade-shadow-color"] = this.formatColor(this.options["hillshade-shadow-color"], 1);
      } else {
        this.options["hillshade-shadow-color"] = this.formatColor("#000000", 1);
      }
      if (this.options["hillshade-highlight-color"]) {
        this.options["hillshade-highlight-color"] = this.formatColor(this.options["hillshade-highlight-color"], 1);
      } else {
        this.options["hillshade-highlight-color"] = this.formatColor("#00FF00", 1);
      }
      if (this.options["hillshade-accent-color"]) {
        this.options["hillshade-accent-color"] = this.formatColor(this.options["hillshade-accent-color"], 1);
      } else {
        this.options["hillshade-accent-color"] = this.formatColor("#000000", 1);
      }
      if (!this.options["hillshade-illumination-direction"]) {
        this.options["hillshade-illumination-direction"] = 335;
      }
      if (!this.options["hillshade-illumination-anchor"]) {
        this.options["hillshade-illumination-anchor"] = "viewport";
      }
      if (!this.options["hillshade-exaggeration"]) {
        this.options["hillshade-exaggeration"] = 0.5;
      }
    }
    formatColor(hexColor, alpha) {
      let rgbColor = this.fromHex(hexColor);
      let rgba = [rgbColor[0] / 255, rgbColor[1] / 255, rgbColor[2] / 255, alpha];
      return rgba;
    }
    fromHex(color) {
      color = color.toUpperCase();
      var regexpHex = /^#[0-9a-fA-F]{3,6}$/;
      if (regexpHex.test(color)) {
        var hexArray = [];
        var count = 1;
        for (var i = 1; i <= 3; i++) {
          if (color.length - 2 * i > 3 - i) {
            hexArray.push(Number("0x" + color.substring(count, count + 2)));
            count += 2;
          } else {
            hexArray.push(Number("0x" + color.charAt(count) + color.charAt(count)));
            count += 1;
          }
        }
        return hexArray;
      }
    }
    draw(tilesToRender) {
    }
    getRenderTileMap(renderTiles) {
      let renderTileMap = {};
      for (let i = 0; i < renderTiles.length; i++) {
        let tileImagerys = renderTiles[i].data.imagery;
        for (let j = 0; j < tileImagerys.length; j++) {
          let tileImagery = tileImagerys[j];
          let imagery = tileImagery.readyImagery;
          if (imagery && imagery.imageryLayer._imageryProvider.id == this.id) {
            let key2 = imagery.x + "_" + imagery.y + "_" + imagery.level;
            renderTileMap[key2] = true;
          }
        }
      }
      return renderTileMap;
    }
    requestImageNow(imageryProvider, col, row, level, request, interval) {
      var labels = imageryProvider._tileMatrixLabels;
      var tileMatrix = defined10(labels) ? labels[level] : level.toString();
      var subdomains = imageryProvider._subdomains;
      var staticDimensions = imageryProvider._dimensions;
      var dynamicIntervalData = defined10(interval) ? interval.data : void 0;
      var resource;
      if (!imageryProvider._useKvp) {
        var templateValues = {
          z: tileMatrix,
          y: row.toString(),
          x: col.toString(),
          s: subdomains[(col + row + level) % subdomains.length]
        };
        resource = imageryProvider._resource.getDerivedResource({
          request
        });
        resource.setTemplateValues(templateValues);
        if (defined10(staticDimensions)) {
          resource.setTemplateValues(staticDimensions);
        }
        if (defined10(dynamicIntervalData)) {
          resource.setTemplateValues(dynamicIntervalData);
        }
      } else {
        var query = {};
        query.tilematrix = tileMatrix;
        query.layer = imageryProvider._layer;
        query.style = imageryProvider._style;
        query.tilerow = row;
        query.tilecol = col;
        query.tilematrixset = imageryProvider._tileMatrixSetID;
        query.format = imageryProvider._format;
        if (defined10(staticDimensions)) {
          query = combine5(query, staticDimensions);
        }
        if (defined10(dynamicIntervalData)) {
          query = combine5(query, dynamicIntervalData);
        }
        resource = imageryProvider._resource.getDerivedResource({
          queryParameters: query,
          request
        });
      }
      var deferred = defer8();
      let xyz = { x: col, y: row, z: level };
      let tileLevel = resource._templateValues.z;
      let cameraLevel = this.viewer.camera.getLevel();
      if (tileLevel < this.showLevel) {
        deferred.reject();
        return deferred.promise;
      }
      let success = this.requestJsonData(deferred, imageryProvider, resource, xyz, request);
      if (!success) {
        return void 0;
      }
      return deferred.promise;
    }
    requestJsonData(deferred, imageryProvider, resource, xyz, request) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let z2 = xyz.z;
      let level = resource._templateValues.z;
      let name2 = x3 + "_" + y3 + "_" + z2;
      let hillShaderTile = this.cache[name2];
      if (hillShaderTile) {
        deferred.resolve({ isTexture: true, texture: hillShaderTile.texture });
        return deferred;
      }
      let imagePromise = resource.fetchImage();
      if (!imagePromise) {
        return false;
      }
      imagePromise.then(function(deferred2, xyz2, level2, request2, image) {
        let rawImageData = Browser_default.getImageData(image);
        let promise = this.processor.scheduleTask({ rawImageData });
        promise.then(function(deferred3, xyz3, level3, request3, results) {
          if (results == true) {
            request3.state = RequestState3.CANCELLED;
            deferred3.reject();
            return;
          }
          this.jsonPromiseResult(deferred3, xyz3, level3, results);
        }.bind(this, deferred2, xyz2, level2, request2), function(e, e1) {
          deferred2.reject();
        }.bind());
      }.bind(this, deferred, xyz, level, request), function(deferred2) {
        deferred2.reject();
      }.bind(this, deferred));
      return true;
    }
    jsonPromiseResult(deferred, xyz, level, dem) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let name2 = x3 + "_" + y3 + "_" + xyz.z;
      let rectangle = this._tilingScheme.tileXYToRectangle(xyz.x, xyz.y, xyz.z);
      let rectangle1 = this._tilingScheme.tileXYToRectangle(xyz.x, xyz.y + 1, xyz.z);
      let lat = CesiumMath5.toDegrees(rectangle.north - rectangle.height / 2);
      let lat1 = CesiumMath5.toDegrees(rectangle1.north - rectangle1.height / 2);
      let latrange = [lat, lat1];
      let hillShaderTile = new HillShaderTile_default(name2, this.viewer.scene.context._gl, dem, null, latrange, level);
      this.cache[name2] = hillShaderTile;
      let _texture = this.drawFbo(hillShaderTile, name2);
      let texture = { _target: 3553, _texture, destroy: this.destroyTexture };
      hillShaderTile.texture = texture;
      deferred.resolve({ isTexture: true, texture });
    }
    destroyTexture() {
    }
    drawFbo(tile, key2, zoom) {
      return DrawFboHillShade_default(this, tile, key2);
    }
    get url() {
      return this._resource.url;
    }
    get proxy() {
      return this._resource.proxy;
    }
    get tileWidth() {
      return this._tileWidth;
    }
    get tileHeight() {
      return this._tileHeight;
    }
    get maximumLevel() {
      return this._maximumLevel;
    }
    get minimumLevel() {
      return this._minimumLevel;
    }
    get tilingScheme() {
      return this._tilingScheme;
    }
    get rectangle() {
      return this._rectangle;
    }
    get tileDiscardPolicy() {
      return this._tileDiscardPolicy;
    }
    get errorEvent() {
      return this._errorEvent;
    }
    get format() {
      return this._format;
    }
    get readyPromise() {
      return this._readyPromise;
    }
    get credit() {
      return this._credit;
    }
    get hasAlphaChannel() {
      return true;
    }
    get clock() {
      return this._timeDynamicImagery.clock;
    }
    set clock(value) {
      this._timeDynamicImagery.clock = value;
    }
    get times() {
      return this._timeDynamicImagery.times;
    }
    set times(value) {
      this._timeDynamicImagery.times = value;
    }
    get dimensions() {
      return this._dimensions;
    }
    set dimensions(value) {
      if (this._dimensions !== value) {
        this._dimensions = value;
        if (defined10(this._reload)) {
          this._reload();
        }
      }
    }
    getTileCredits(x3, y3, level) {
      return void 0;
    }
    requestImage(x3, y3, level, request) {
      var result;
      var timeDynamicImagery = this._timeDynamicImagery;
      var currentInterval;
      if (defined10(timeDynamicImagery)) {
        currentInterval = timeDynamicImagery.currentInterval;
        result = timeDynamicImagery.getFromCache(x3, y3, level, request);
      }
      if (!defined10(result)) {
        result = this.requestImageNow(this, x3, y3, level, request, currentInterval);
      }
      if (defined10(result) && defined10(timeDynamicImagery)) {
        timeDynamicImagery.checkApproachingInterval(x3, y3, level, request);
      }
      return result;
    }
    pickFeatures(x3, y3, level, longitude, latitude) {
      return void 0;
    }
    destroy() {
      this.viewer.scene.camera.moveEnd.removeEventListener(this.getDecimalLevel.bind(this));
      for (let key2 in this.cache) {
        let tile = this.cache[key2];
        tile.destroy();
      }
      this.cache = {};
    }
    removeImageryFromCache(x3, y3, z2) {
      let key2 = x3 + "_" + y3 + "_" + z2;
      let tile = this.cache[key2];
      if (tile) {
        tile.destroy();
        this.textureQueue.remove(tile.name);
        delete this.cache[key2];
      }
    }
    useProgram(name2) {
      return ProgramFactory_default.createProgram(this.viewer.scene.context._gl, name2);
    }
    getTexture(imagery) {
      return null;
    }
    getDecimalLevel() {
      let scale = 1;
      let decimalLevel = this.decimalLevel;
      let _zoom = this.viewer.camera.getLevel();
      let arr2 = _zoom.toString().split(".");
      let a2 = arr2[0];
      let b = "0." + arr2[1];
      a2 = Number(a2);
      let currLevel = a2;
      b = Number(b);
      if (b) {
        let decimal = Math.round(b * decimalLevel) / decimalLevel;
        currLevel = currLevel + decimal;
        scale = scale + decimal;
      }
      this.zoom = a2;
      this._zoom = currLevel;
      this.scale = scale;
    }
  };
  var HillShaderTileServiceImageryProvider_default = HillShaderTileServiceImageryProvider;

  // Source/custom/layer/house/HouseDataSource.js
  var Cartesian35 = Cesium.Cartesian3;
  var Color5 = Cesium.Color;
  var defined11 = Cesium.defined;
  var CallbackProperty2 = Cesium.CallbackProperty;
  var CesiumMath6 = Cesium.Math;
  var PrimitivePipeline3 = Cesium.PrimitivePipeline;
  var Matrix46 = Cesium.Matrix4;
  var PrimitiveState3 = Cesium.PrimitiveState;
  var BatchTable3 = Cesium.BatchTable;
  var Cartesian42 = Cesium.Cartesian4;
  var BEGIN3 = 1;
  var LOADED3 = 2;
  var ADDED3 = 3;
  var REMOVED3 = 4;
  var polygonMaterial = new Cesium.Material.fromType("Image", {
    image: "data:image/jpeg;base64,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",
    repeat: {
      x: -1,
      y: 1
    }
  });
  var waterMaterial = new Cesium.Material({
    fabric: {
      type: "Water",
      uniforms: {
        normalMap: "data:image/jpeg;base64,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",
        frequency: 1e3,
        animationSpeed: 0.1,
        amplitude: 2
      }
    }
  });
  function getShader(lightMap, sourceVS, sourceFS) {
    let vsArr = [];
    let fsArr = [];
    for (let type in lightMap) {
      let light = lightMap[type];
      let shader = light.getPolygonColorPrimitiveShader();
      let vsTtem = { name: light.type, shader: shader.vertexShaderSource };
      let fsTtem = { name: light.type, shader: shader.fragmentShaderSource };
      vsArr.push(vsTtem);
      fsArr.push(fsTtem);
    }
    return { vs: LightTool_default.composeMainShader(sourceVS, vsArr), fs: LightTool_default.composeMainShader(sourceFS, fsArr) };
  }
  var HouseDataSource = class {
    constructor(name2, results, level, viewer3, options, lightMap) {
      this.name = name2;
      this.level = level;
      this.viewer = viewer3;
      this.options = options;
      this.type = "house";
      this.state = BEGIN3;
      this.translucent = false;
      if (this.options.hasOwnProperty("translucent")) {
        this.translucent = this.options.translucent;
      }
      if (this.options.translucentMaterial) {
        this.polygonPrimitive = new Cesium.Primitive({
          shadows: Cesium.ShadowMode.ENABLED,
          geometryInstances: [],
          undisplayable: true,
          appearance: new Cesium.MaterialAppearance({
            material: polygonMaterial,
            transparent: this.translucent
          })
        });
      } else {
        this.polygonPrimitive = new Cesium.Primitive({
          shadows: Cesium.ShadowMode.ENABLED,
          geometryInstances: [],
          undisplayable: true,
          appearance: new Cesium.PerInstanceColorAppearance({
            flat: false,
            translucent: this.translucent,
            closed: true
          })
        });
      }
      this.outlinePrimitive = new Cesium.Primitive({
        geometryInstances: [],
        undisplayable: true,
        appearance: new Cesium.PerInstanceColorAppearance({
          flat: true,
          translucent: this.translucent,
          closed: true
        })
      });
      this.waterPrimitive = new Cesium.Primitive({
        geometryInstances: [],
        undisplayable: true,
        appearance: new Cesium.EllipsoidSurfaceAppearance({
          material: waterMaterial
        })
      });
      this.ridingLanternPrimitive = null;
      this.polygonSourceVs = this.polygonPrimitive.appearance.vertexShaderSource;
      this.polygonSourceFs = this.polygonPrimitive.appearance.fragmentShaderSource;
      this.setLightMap(lightMap);
      this.load(results);
    }
    load(results) {
      let polygon2 = results.polygon;
      let water = results.water;
      let outline = results.outline;
      let ridingLantern = results.ridingLantern;
      if (polygon2) {
        this.setPrimitive(this.polygonPrimitive, polygon2);
      } else {
        this.polygonPrimitive = null;
      }
      if (outline) {
        this.setPrimitive(this.outlinePrimitive, outline);
      } else {
        this.outlinePrimitive = null;
      }
      if (water) {
        this.setPrimitive(this.waterPrimitive, water);
      } else {
        this.waterPrimitive = null;
      }
      if (ridingLantern) {
        this.ridingLanternPrimitive = Custom.RidingLanternGlowPrimitive.createRidingLantern({
          viewer: this.viewer,
          height: 200,
          speed: 100,
          type: 1,
          direction: 1,
          color: new Cesium.Color(0.3, 0.5, 0.8, 2),
          translucent: true
        });
        this.setPrimitive(this.ridingLanternPrimitive, ridingLantern);
      }
      this.state = LOADED3;
    }
    setPrimitive(primitive, results) {
      let result = PrimitivePipeline3.unpackCombineGeometryResults(results);
      primitive.isExt = true;
      primitive._geometries = result.geometries;
      primitive._attributeLocations = result.attributeLocations;
      primitive.modelMatrix = Matrix46.clone(result.modelMatrix, primitive.modelMatrix);
      primitive._pickOffsets = result.pickOffsets;
      primitive._offsetInstanceExtend = result.offsetInstanceExtend;
      primitive._instanceBoundingSpheres = result.boundingSpheres;
      primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;
      primitive.propertiesMapBuffer = results.propertiesMapBuffer;
      if (defined11(primitive._geometries) && primitive._geometries.length > 0) {
        primitive._recomputeBoundingSpheres = true;
        primitive._state = PrimitiveState3.COMBINED;
      } else {
      }
      this.createBatchTable(primitive, results);
    }
    createBatchTable(primitive, result) {
      let attributes = result.attributes;
      let attributesLength = attributes.length;
      let ids = result.ids;
      let batchValues = result.batchValues;
      let numberOfInstances = ids.length;
      let pickId = result.pickId;
      let context = this.viewer.scene.frameState.context;
      let batchTable = new BatchTable3(context, attributes, numberOfInstances);
      batchTable._batchValues = batchValues;
      var scratchGetAttributeCartesian4 = new Cartesian42();
      if (primitive._allowPicking) {
        for (let i = 0; i < numberOfInstances; ++i) {
          var pickObject = {
            primitive
          };
          let id = ids[i];
          if (defined11(id)) {
            pickObject.id = id;
          }
          pickId++;
          context._pickObjects[pickId] = pickObject;
        }
      }
      primitive._instanceIds = ids;
      primitive._batchTable = batchTable;
      primitive._batchTableAttributeIndices = result.attributeIndices;
    }
    remove() {
      if (this.polygonPrimitive) {
        this.viewer.scene.primitives.remove(this.polygonPrimitive);
      }
      if (this.outlinePrimitive) {
        this.viewer.scene.primitives.remove(this.outlinePrimitive);
      }
      if (this.waterPrimitive) {
        this.viewer.scene.primitives.remove(this.waterPrimitive);
      }
      if (this.ridingLanternPrimitive) {
        this.viewer.scene.primitives.remove(this.ridingLanternPrimitive);
      }
      this.state = REMOVED3;
    }
    destroy() {
      this.remove();
      if (this.polygonPrimitive && !this.polygonPrimitive.isDestroyed()) {
        this.polygonPrimitive.destroy();
      }
      if (this.outlinePrimitive && !this.outlinePrimitive.isDestroyed()) {
        this.outlinePrimitive.destroy();
      }
      if (this.waterPrimitive && !this.waterPrimitive.isDestroyed()) {
        this.waterPrimitive.destroy();
      }
      this.destroyed = true;
    }
    addToPrimitives() {
      if (this.polygonPrimitive) {
        this.viewer.scene.primitives.add(this.polygonPrimitive);
      }
      if (this.outlinePrimitive) {
        this.viewer.scene.primitives.add(this.outlinePrimitive);
      }
      if (this.waterPrimitive) {
        this.viewer.scene.primitives.add(this.waterPrimitive);
      }
      if (this.ridingLanternPrimitive) {
        this.viewer.scene.primitives.add(this.ridingLanternPrimitive);
      }
      this.state = ADDED3;
    }
    showPrimitive(primitive) {
      for (let i = 0; i < primitive._instanceIds.length; i++) {
        primitive._batchTable.setBatchedAttribute(i, 1, 1);
      }
    }
    show(styleFun) {
      if (this.state == REMOVED3 || this.state == LOADED3) {
        this.addToPrimitives();
      }
    }
    setLightMap(lightMap) {
      if (!this.polygonPrimitive) {
        return;
      }
      let hasLight = false;
      for (let key2 in lightMap) {
        hasLight = true;
      }
      if (hasLight) {
        let shader = getShader(lightMap, this.polygonSourceVs, this.polygonSourceFs);
        if (this.options.translucentMaterial) {
          this.polygonPrimitive.appearance = new Cesium.MaterialAppearance({
            material: polygonMaterial,
            transparent: true,
            vertexShaderSource: shader.vs,
            fragmentShaderSource: shader.fs
          });
        } else {
          this.polygonPrimitive.appearance = new Cesium.PerInstanceColorAppearance({
            flat: false,
            translucent: this.translucent,
            closed: true,
            vertexShaderSource: shader.vs,
            fragmentShaderSource: shader.fs
          });
        }
      } else {
        if (this.options.translucentMaterial) {
          this.polygonPrimitive.appearance = new Cesium.MaterialAppearance({
            material: polygonMaterial,
            transparent: true
          });
        } else {
          this.polygonPrimitive.appearance = new Cesium.PerInstanceColorAppearance({
            flat: false,
            translucent: this.translucent,
            closed: true
          });
        }
      }
    }
  };
  var HouseDataSource_default = HouseDataSource;

  // Source/custom/layer/house/HouseTileServiceImageryProvider.js
  var combine6 = Cesium.combine;
  var Credit6 = Cesium.Credit;
  var defaultValue9 = Cesium.defaultValue;
  var defined12 = Cesium.defined;
  var DeveloperError8 = Cesium.DeveloperError;
  var Event6 = Cesium.Event;
  var freezeObject3 = Cesium.freezeObject;
  var isArray5 = Array.isArray;
  var Rectangle5 = Cesium.Rectangle;
  var Resource6 = Cesium.Resource;
  var WebMercatorTilingScheme6 = Cesium.WebMercatorTilingScheme;
  var ImageryProvider3 = Cesium.ImageryProvider;
  var TimeDynamicImagery5 = Cesium.TimeDynamicImagery;
  var RequestState4 = Cesium.RequestState;
  var defer9 = Cesium.defer;
  var defaultParameters5 = {
    service: "WMTS",
    version: "1.0.0",
    request: "GetTile"
  };
  var HouseTileServiceImageryProvider = class extends ElevationImageryProvider_default {
    constructor(viewer3, options) {
      super(viewer3, options);
      this.indexDbName = "house_" + this.indexDbName;
      options = defaultValue9(options, defaultValue9.EMPTY_OBJECT);
      this.id = Math.random();
      this.needDecode = defaultValue9(options.needDecode, false);
      if (!defined12(options.url)) {
        throw new DeveloperError8("options.url is required.");
      }
      var resource = Resource6.createIfNeeded(options.url);
      var style = options.style;
      var tileMatrixSetID = options.tileMatrixSetID;
      var url = resource.url;
      if (url.indexOf("{") >= 0) {
        var templateValues = {
          style,
          Style: style,
          TileMatrixSet: tileMatrixSetID
        };
        resource.setTemplateValues(templateValues);
        this._useKvp = false;
      } else {
        resource.setQueryParameters(defaultParameters5);
        this._useKvp = true;
      }
      this._resource = resource;
      this._layer = options.layer;
      this._style = style;
      this._tileMatrixSetID = tileMatrixSetID;
      this._tileMatrixLabels = options.tileMatrixLabels;
      this._format = defaultValue9(options.format, "image/jpeg");
      this._tileDiscardPolicy = options.tileDiscardPolicy;
      this._tilingScheme = defined12(options.tilingScheme) ? options.tilingScheme : new WebMercatorTilingScheme6({ ellipsoid: options.ellipsoid });
      this._tileWidth = defaultValue9(options.tileWidth, 256);
      this._tileHeight = defaultValue9(options.tileHeight, 256);
      this._minimumLevel = defaultValue9(options.minimumLevel, 0);
      this._maximumLevel = options.maximumLevel;
      this._rectangle = defaultValue9(options.rectangle, this._tilingScheme.rectangle);
      this._dimensions = options.dimensions;
      var that = this;
      this._reload = void 0;
      if (defined12(options.times)) {
        this._timeDynamicImagery = new TimeDynamicImagery5({
          clock: options.clock,
          times: options.times,
          requestImageFunction: function(x3, y3, level, request, interval) {
            return requestImage(that, x3, y3, level, request, interval);
          },
          reloadFunction: function() {
            if (defined12(that._reload)) {
              that._reload();
            }
          }
        });
      }
      this._readyPromise = defer9();
      var swTile = this._tilingScheme.positionToTileXY(Rectangle5.southwest(this._rectangle), this._minimumLevel);
      var neTile = this._tilingScheme.positionToTileXY(Rectangle5.northeast(this._rectangle), this._minimumLevel);
      var tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);
      if (tileCount > 4) {
        throw new DeveloperError8("The imagery provider's rectangle and minimumLevel indicate that there are " + tileCount + " tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.");
      }
      this._errorEvent = new Event6();
      var credit = options.credit;
      this._credit = typeof credit === "string" ? new Credit6(credit) : credit;
      this._subdomains = options.subdomains;
      if (isArray5(this._subdomains)) {
        this._subdomains = this._subdomains.slice();
      } else if (defined12(this._subdomains) && this._subdomains.length > 0) {
        this._subdomains = this._subdomains.split("");
      } else {
        this._subdomains = ["a", "b", "c"];
      }
      this.dataType = "binary";
      if (options.hasOwnProperty("dataType")) {
        this.dataType = options["dataType"];
      } else {
        this.dataType = "Json";
      }
      this.hasTerrain = false;
      if (viewer3.terrainProvider.name == "RGBWorldTerrainProvider") {
        this.hasTerrain = true;
      }
      if (this.dataType == "binary") {
        this.processor = new Cesium.TaskProcessor("HouseBinaryWorker", Number.POSITIVE_INFINITY);
      } else {
        this.processor = new Cesium.TaskProcessor("HouseWorker", Number.POSITIVE_INFINITY);
      }
      this.parseUrl(options.url);
      this.loadStyle().then(function() {
        this.ready = {
          value: true
        };
        this._readyPromise.resolve(true);
      }.bind(this));
      this.cache = {};
      this.options = options;
      this.lightMap = {};
      this.showLevel = options.showLevel || 16;
      this.image = document.createElement("canvas");
      this.ridingLanternHeight = defaultValue9(
        options.ridingLanternHeight,
        200
      );
      this.ridingLanternColor = defaultValue9(
        options.ridingLanternColor,
        "#4D80CD"
      );
      this.ridingLanternAlpha = defaultValue9(
        options.ridingLanternAlpha,
        1
      );
      this.ridingLanternType = defaultValue9(
        options.ridingLanternType,
        1
      );
      this.ridingLanternSpeed = defaultValue9(
        options.ridingLanternSpeed,
        100
      );
    }
    draw(tilesToRender) {
      let renderTileMap = this.getRenderTileMap(tilesToRender);
      for (let key2 in this.cache) {
        if (!renderTileMap[key2]) {
          let tile = this.cache[key2];
          tile.remove();
        }
      }
      for (let name2 in renderTileMap) {
        let ds = this.cache[name2];
        if (ds) {
          ds.show(this.styleFun);
        }
      }
    }
    getRenderTileMap(renderTiles) {
      let renderTileMap = {};
      for (let i = 0; i < renderTiles.length; i++) {
        let tileImagerys = renderTiles[i].data.imagery;
        for (let j = 0; j < tileImagerys.length; j++) {
          let tileImagery = tileImagerys[j];
          let imagery = tileImagery.readyImagery;
          if (imagery && imagery.imageryLayer._imageryProvider.id == this.id) {
            let key2 = imagery.x + "_" + imagery.y + "_" + imagery.level;
            renderTileMap[key2] = true;
          }
        }
      }
      return renderTileMap;
    }
    parseUrl(url) {
      let urlParts = url.split("?");
      let urlPartOne = urlParts[0].split("/mapserver/");
      this.host = urlPartOne[0];
      if (this._subdomains.length > 0) {
        this.host = this.host.replace("{s}", this._subdomains[0]);
      }
      this.servername = urlPartOne[1].split("/")[1];
      this.queryParam = urlParts[1];
      let params2 = this.queryParam.split("&");
      for (let i = 0; i < params2.length; i++) {
        let param = params2[i];
        let keyValue = param.split("=");
        if (keyValue[0] == "styleId") {
          this.styleId = keyValue[1];
        }
        if (keyValue[0] == "return_type") {
          this.return_type = keyValue[1];
        }
      }
    }
    loadStyle() {
      let promises = [];
      let styleUrl = this.host + "/mapserver/styleInfo/" + this.servername + "/" + this.styleId + "/layer/style.js?" + Math.random();
      let resource = Resource6.createIfNeeded(styleUrl);
      let promise1 = resource.fetchText();
      promises.push(promise1);
      let promise2 = null;
      if (this.dataType == "binary") {
        let styleUrl2 = this.host + "/mapserver/serverInfo/" + this.servername + ".json?" + Math.random();
        let resource2 = Resource6.createIfNeeded(styleUrl2);
        promise2 = resource2.fetchJson();
        promises.push(promise2);
      }
      let deferred = defer9();
      Promise.all(promises).then(function(result) {
        let styleStr = result[0];
        let results = result[1];
        let options = {
          init: true,
          styleStr,
          tileSize: this._tileWidth,
          return_type: this.return_type,
          hasTerrain: this.hasTerrain
        };
        if (results && results.layerMap) {
          this.serverInfo = {};
          this.layerFieldMap = {};
          for (let key2 in results.layerMap) {
            this.serverInfo[key2] = {
              geometryType: results.layerMap[key2].geometryType,
              fieldsConfig: results.layerMap[key2].fields
            };
            if (!this.layerFieldMap[key2]) {
              this.layerFieldMap[key2] = results.layerMap[key2].fields.length;
            }
          }
          options.serverInfo = this.serverInfo;
          options.layerFieldMap = this.layerFieldMap;
        }
        if (this.options.hasOwnProperty("fillColor")) {
          options.fillColor = this.options.fillColor;
        }
        if (this.options.hasOwnProperty("opacity")) {
          options.opacity = this.options.opacity;
        }
        if (this.options.hasOwnProperty("heightProperty")) {
          options.heightProperty = this.options.heightProperty;
        }
        if (this.options.hasOwnProperty("heightScale")) {
          options.heightScale = this.options.heightScale;
        }
        if (this.options.hasOwnProperty("translucentMaterial")) {
          options.translucentMaterial = this.options.translucentMaterial;
        }
        if (this.options.hasOwnProperty("heightValue")) {
          options.heightValue = this.options.heightValue;
        }
        options.indexDbNames = this.getBottomProviderIndexDbNames();
        options.indexDbName = this.indexDbName;
        let promise = this.processor.scheduleTask(options);
        promise.then(function() {
          deferred.resolve();
        });
      }.bind(this));
      return deferred.promise;
    }
    requestImageNow(imageryProvider, col, row, level, request, interval) {
      var labels = imageryProvider._tileMatrixLabels;
      var tileMatrix = defined12(labels) ? labels[level] : level.toString();
      var subdomains = imageryProvider._subdomains;
      var staticDimensions = imageryProvider._dimensions;
      var dynamicIntervalData = defined12(interval) ? interval.data : void 0;
      var resource;
      if (!imageryProvider._useKvp) {
        var templateValues = {
          z: tileMatrix,
          y: row.toString(),
          x: col.toString(),
          s: subdomains[(col + row + level) % subdomains.length]
        };
        resource = imageryProvider._resource.getDerivedResource({
          request
        });
        resource.setTemplateValues(templateValues);
        if (defined12(staticDimensions)) {
          resource.setTemplateValues(staticDimensions);
        }
        if (defined12(dynamicIntervalData)) {
          resource.setTemplateValues(dynamicIntervalData);
        }
      } else {
        var query = {};
        query.tilematrix = tileMatrix;
        query.layer = imageryProvider._layer;
        query.style = imageryProvider._style;
        query.tilerow = row;
        query.tilecol = col;
        query.tilematrixset = imageryProvider._tileMatrixSetID;
        query.format = imageryProvider._format;
        if (defined12(staticDimensions)) {
          query = combine6(query, staticDimensions);
        }
        if (defined12(dynamicIntervalData)) {
          query = combine6(query, dynamicIntervalData);
        }
        resource = imageryProvider._resource.getDerivedResource({
          queryParameters: query,
          request
        });
      }
      var deferred = defer9();
      let xyz = { x: col, y: row, z: level };
      let tileLevel = resource._templateValues.z;
      if (tileLevel < this.showLevel) {
        deferred.reject();
        return deferred.promise;
      }
      this.requestJsonData(deferred, imageryProvider, resource, xyz, request);
      return deferred.promise;
    }
    requestJsonData(deferred, imageryProvider, url, xyz, request) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let z2 = xyz.z;
      let level = url._templateValues.z;
      let name2 = x3 + "_" + y3 + "_" + z2;
      if (this.cache[name2]) {
        deferred.resolve(this.image);
        return deferred;
      }
      let rectangle = this._tilingScheme.tileXYToRectangle(xyz.x, xyz.y, xyz.z);
      let rectangleObj = { west: rectangle.west, north: rectangle.north, width: rectangle.width, height: rectangle.height };
      let styleLevel = Math.round(this.viewer.camera.getLevel());
      let xyzStr = xyz.x + "_" + xyz.y + "_" + xyz.z;
      let promise = this.processor.scheduleTask({
        url: url.url,
        xyz: xyzStr,
        needDecode: this.options.needDecode,
        level: styleLevel,
        filterLayerId: this.options.filterLayerId,
        ridingLanternLayerId: this.options.ridingLanternLayerId,
        ridingLanternHeight: this.ridingLanternHeight,
        ridingLanternColor: this.ridingLanternColor,
        ridingLanternAlpha: this.ridingLanternAlpha,
        ridingLanternType: this.ridingLanternType,
        ridingLanternSpeed: this.ridingLanternSpeed,
        waterLayerId: this.options.waterLayerId,
        rectangle: rectangleObj
      });
      promise.then(function(deferred2, xyz2, level2, request2, results) {
        if (results == true) {
          request2.state = RequestState4.CANCELLED;
          deferred2.reject();
          return;
        }
        this.jsonPromiseResult(deferred2, xyz2, level2, results);
        this.updateOtherProviderElevation(xyz2);
      }.bind(this, deferred, xyz, level, request), function(error) {
        deferred.reject();
      });
      return true;
    }
    jsonPromiseResult(deferred, xyz, level, results) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let z2 = xyz.z;
      let name2 = x3 + "_" + y3 + "_" + z2;
      let tile = new HouseDataSource_default(name2, results, level, this.viewer, this.options, this.lightMap);
      this.cache[tile.name] = tile;
      deferred.resolve(this.image);
    }
    updateTileElevation(xyz, tileSize) {
      let name2 = xyz.x + "_" + xyz.y + "_" + xyz.z;
      if (!this.cache[name2]) {
        return false;
      }
      return true;
    }
    get url() {
      return this._resource.url;
    }
    get proxy() {
      return this._resource.proxy;
    }
    get tileWidth() {
      return this._tileWidth;
    }
    get tileHeight() {
      return this._tileHeight;
    }
    get maximumLevel() {
      return this._maximumLevel;
    }
    get minimumLevel() {
      return this._minimumLevel;
    }
    get tilingScheme() {
      return this._tilingScheme;
    }
    get rectangle() {
      return this._rectangle;
    }
    get tileDiscardPolicy() {
      return this._tileDiscardPolicy;
    }
    get errorEvent() {
      return this._errorEvent;
    }
    get format() {
      return this._format;
    }
    get readyPromise() {
      return this._readyPromise;
    }
    get credit() {
      return this._credit;
    }
    get hasAlphaChannel() {
      return true;
    }
    get clock() {
      return this._timeDynamicImagery.clock;
    }
    set clock(value) {
      this._timeDynamicImagery.clock = value;
    }
    get times() {
      return this._timeDynamicImagery.times;
    }
    set times(value) {
      this._timeDynamicImagery.times = value;
    }
    get dimensions() {
      return this._dimensions;
    }
    set dimensions(value) {
      if (this._dimensions !== value) {
        this._dimensions = value;
        if (defined12(this._reload)) {
          this._reload();
        }
      }
    }
    getTileCredits(x3, y3, level) {
      return void 0;
    }
    requestImage(x3, y3, level, request) {
      var result;
      var timeDynamicImagery = this._timeDynamicImagery;
      var currentInterval;
      if (defined12(timeDynamicImagery)) {
        currentInterval = timeDynamicImagery.currentInterval;
        result = timeDynamicImagery.getFromCache(x3, y3, level, request);
      }
      if (!defined12(result)) {
        result = this.requestImageNow(this, x3, y3, level, request, currentInterval);
      }
      if (defined12(result) && defined12(timeDynamicImagery)) {
        timeDynamicImagery.checkApproachingInterval(x3, y3, level, request);
      }
      return result;
    }
    pickFeatures(x3, y3, level, longitude, latitude) {
      return void 0;
    }
    updateLightShader(light) {
      this.lightMap[light.type] = light;
      this.updateLightMap();
    }
    removeLightShader(type) {
      delete this.lightMap[type];
      this.updateLightMap();
    }
    updateLightMap() {
      for (let key2 in this.cache) {
        let houseDataSource = this.cache[key2];
        houseDataSource.setLightMap(this.lightMap);
      }
    }
    destroy() {
      for (let key2 in this.cache) {
        let tile = this.cache[key2];
        tile.destroy();
      }
      this.cache = {};
    }
    removeImageryFromCache(x3, y3, z2) {
      let key2 = x3 + "_" + y3 + "_" + z2;
      let tile = this.cache[key2];
      if (tile) {
        tile.destroy();
        delete this.cache[key2];
      }
    }
    removeTile(xyzStr) {
      let tile = this.cache[xyzStr];
      if (tile) {
        tile.remove();
      }
    }
  };
  var HouseTileServiceImageryProvider_default = HouseTileServiceImageryProvider;

  // Source/custom/layer/image/ImageTileProvider.js
  var Color6 = Cesium.Color;
  var defaultValue10 = Cesium.defaultValue;
  var defined13 = Cesium.defined;
  var Event7 = Cesium.Event;
  var GeographicTilingScheme2 = Cesium.GeographicTilingScheme;
  function ImageTileProvider(options) {
    options = defaultValue10(options, defaultValue10.EMPTY_OBJECT);
    this._tilingScheme = defined13(options.tilingScheme) ? options.tilingScheme : new GeographicTilingScheme2({ ellipsoid: options.ellipsoid });
    this._color = defaultValue10(options.color, Color6.YELLOW);
    this._errorEvent = new Event7();
    this._tileWidth = defaultValue10(options.tileWidth, 256);
    this._tileHeight = defaultValue10(options.tileHeight, 256);
    this._readyPromise = Promise.resolve(true);
    this.options = options;
    if (this.options.hasOwnProperty("showLevels")) {
      this.showLevels = this.options["showLevels"];
      for (let i = 0; i < this.showLevels.length; i++) {
        this.showLevels[i] = parseInt(this.showLevels[i]);
      }
    } else {
      this.showLevels = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];
    }
    this.defaultAlpha = void 0;
    this.defaultNightAlpha = void 0;
    this.defaultDayAlpha = void 0;
    this.defaultBrightness = void 0;
    this.defaultContrast = void 0;
    this.defaultHue = void 0;
    this.defaultSaturation = void 0;
    this.defaultGamma = void 0;
    this.defaultMinificationFilter = void 0;
    this.defaultMagnificationFilter = void 0;
  }
  Object.defineProperties(ImageTileProvider.prototype, {
    proxy: {
      get: function() {
        return void 0;
      }
    },
    tileWidth: {
      get: function() {
        return this._tileWidth;
      }
    },
    tileHeight: {
      get: function() {
        return this._tileHeight;
      }
    },
    maximumLevel: {
      get: function() {
        return void 0;
      }
    },
    minimumLevel: {
      get: function() {
        return void 0;
      }
    },
    tilingScheme: {
      get: function() {
        return this._tilingScheme;
      }
    },
    rectangle: {
      get: function() {
        return this._tilingScheme.rectangle;
      }
    },
    tileDiscardPolicy: {
      get: function() {
        return void 0;
      }
    },
    errorEvent: {
      get: function() {
        return this._errorEvent;
      }
    },
    ready: {
      get: function() {
        return true;
      }
    },
    readyPromise: {
      get: function() {
        return this._readyPromise;
      }
    },
    credit: {
      get: function() {
        return void 0;
      }
    },
    hasAlphaChannel: {
      get: function() {
        return true;
      }
    }
  });
  ImageTileProvider.prototype.getTileCredits = function(x3, y3, level) {
    return void 0;
  };
  ImageTileProvider.prototype.requestImage = function(x3, y3, level, request) {
    if (this.showLevels.indexOf(level) > -1) {
      return Promise.resolve(this.options.img);
    } else {
      return Promise.resolve(document.createElement("canvas"));
      ;
    }
  };
  ImageTileProvider.prototype.pickFeatures = function(x3, y3, level, longitude, latitude) {
    return void 0;
  };
  var ImageTileProvider_default = ImageTileProvider;

  // Source/custom/layer/label/avoid/GGridIndex.js
  var NUM_PARAMS = 3;
  function GGridIndex(extent, n, padding) {
    var cells2 = this.cells = [];
    if (extent instanceof ArrayBuffer) {
      this.arrayBuffer = extent;
      var array2 = new Int32Array(this.arrayBuffer);
      extent = array2[0];
      n = array2[1];
      padding = array2[2];
      this.d = n + 2 * padding;
      for (var k = 0; k < this.d * this.d; k++) {
        var start2 = array2[NUM_PARAMS + k];
        var end = array2[NUM_PARAMS + k + 1];
        cells2.push(start2 === end ? null : array2.subarray(start2, end));
      }
      var keysOffset = array2[NUM_PARAMS + cells2.length];
      var bboxesOffset = array2[NUM_PARAMS + cells2.length + 1];
      this.keys = array2.subarray(keysOffset, bboxesOffset);
      this.bboxes = array2.subarray(bboxesOffset);
      this.insert = this._insertReadonly;
    } else {
      this.d = n + 2 * padding;
      for (var i = 0; i < this.d * this.d; i++) {
        cells2.push([]);
      }
      this.keys = [];
      this.bboxes = [];
    }
    this.n = n;
    this.extent = extent;
    this.padding = padding;
    this.scale = n / extent;
    this.uid = 0;
    var p = padding / n * extent;
    this.min = -p;
    this.max = extent + p;
    this.keyUidMap = {};
  }
  GGridIndex.prototype.insert = function(key2, x12, y12, x22, y22) {
    this._forEachCell(x12, y12, x22, y22, this._insertCell, this.uid++);
    this.keyUidMap[key2] = this.uid;
    this.keys.push(key2);
    this.bboxes.push(x12);
    this.bboxes.push(y12);
    this.bboxes.push(x22);
    this.bboxes.push(y22);
  };
  GGridIndex.prototype.remove = function(key2, x12, y12, x22, y22) {
    var cx1 = this._convertToCellCoord(x12);
    var cy1 = this._convertToCellCoord(y12);
    var cx2 = this._convertToCellCoord(x22);
    var cy2 = this._convertToCellCoord(y22);
    let uid = this.keyUidMap[key2];
    delete this.keyUidMap[key2];
    for (var x3 = cx1; x3 <= cx2; x3++) {
      for (var y3 = cy1; y3 <= cy2; y3++) {
        var cellIndex = this.d * y3 + x3;
        this.cells[cellIndex][uid] = -1;
      }
    }
  };
  GGridIndex.prototype._insertReadonly = function() {
    throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
  };
  GGridIndex.prototype._insertCell = function(x12, y12, x22, y22, cellIndex, uid) {
    this.cells[cellIndex].push(uid);
  };
  GGridIndex.prototype.query = function(x12, y12, x22, y22) {
    var min = this.min;
    var max = this.max;
    if (x12 <= min && y12 <= min && max <= x22 && max <= y22) {
      return Array.prototype.slice.call(this.keys);
    } else {
      var result = [];
      var seenUids = {};
      this._forEachCell(x12, y12, x22, y22, this._queryCell, result, seenUids);
      return result;
    }
  };
  GGridIndex.prototype._queryCell = function(x12, y12, x22, y22, cellIndex, result, seenUids) {
    var cell = this.cells[cellIndex];
    if (cell !== null) {
      var keys = this.keys;
      var bboxes = this.bboxes;
      for (var u = 0; u < cell.length; u++) {
        var uid = cell[u];
        if (uid == -1) {
          continue;
        }
        if (seenUids[uid] === void 0) {
          var offset = uid * 4;
          if (x12 <= bboxes[offset + 2] && y12 <= bboxes[offset + 3] && x22 >= bboxes[offset + 0] && y22 >= bboxes[offset + 1]) {
            seenUids[uid] = true;
            result.push(keys[uid]);
          } else {
            seenUids[uid] = false;
          }
        }
      }
    }
  };
  GGridIndex.prototype._forEachCell = function(x12, y12, x22, y22, fn, arg1, arg2) {
    var cx1 = this._convertToCellCoord(x12);
    var cy1 = this._convertToCellCoord(y12);
    var cx2 = this._convertToCellCoord(x22);
    var cy2 = this._convertToCellCoord(y22);
    for (var x3 = cx1; x3 <= cx2; x3++) {
      for (var y3 = cy1; y3 <= cy2; y3++) {
        var cellIndex = this.d * y3 + x3;
        if (fn.call(this, x12, y12, x22, y22, cellIndex, arg1, arg2))
          return;
      }
    }
  };
  GGridIndex.prototype._convertToCellCoord = function(x3) {
    return Math.max(0, Math.min(this.d - 1, Math.floor(x3 * this.scale) + this.padding));
  };
  GGridIndex.prototype.toArrayBuffer = function() {
    if (this.arrayBuffer)
      return this.arrayBuffer;
    var cells2 = this.cells;
    var metadataLength = NUM_PARAMS + this.cells.length + 1 + 1;
    var totalCellLength = 0;
    for (var i = 0; i < this.cells.length; i++) {
      totalCellLength += this.cells[i].length;
    }
    var array2 = new Int32Array(metadataLength + totalCellLength + this.keys.length + this.bboxes.length);
    array2[0] = this.extent;
    array2[1] = this.n;
    array2[2] = this.padding;
    var offset = metadataLength;
    for (var k = 0; k < cells2.length; k++) {
      var cell = cells2[k];
      array2[NUM_PARAMS + k] = offset;
      array2.set(cell, offset);
      offset += cell.length;
    }
    array2[NUM_PARAMS + cells2.length] = offset;
    array2.set(this.keys, offset);
    offset += this.keys.length;
    array2[NUM_PARAMS + cells2.length + 1] = offset;
    array2.set(this.bboxes, offset);
    offset += this.bboxes.length;
    return array2.buffer;
  };
  var GGridIndex_default = GGridIndex;

  // Source/custom/layer/label/avoid/AvoidUtil.js
  var Font = null;
  var _path = "./../../../../";
  var AvoidUtil = class {
    static getRealLength(str) {
      var length2 = str.length;
      var realLength = 0;
      for (var i = 0; i < length2; i++) {
        let charCode = str.charCodeAt(i);
        if (charCode >= 0 && charCode <= 128) {
          realLength += 0.5;
        } else {
          realLength += 1;
        }
      }
      return realLength;
    }
    static isNotNull(label) {
      if (!label && label != 0) {
        return false;
      }
      if (typeof label == "string") {
        label = label.toLowerCase();
        if (label == "" || label == "undefined" || label == "null") {
          return false;
        }
      }
      return true;
    }
    static formatFont(font, ratio2, isChangeFont) {
      var fontArr = font;
      if (isChangeFont) {
        if (Font == null) {
          Font = __require(_path + "src/utils/font/Font");
        }
        var farr = font.split(" ");
        if (farr.length - 1 != 0) {
          if ("italic" == farr[0].toLowerCase()) {
            if (farr[arr.length - 1] != "simbei") {
              farr[farr.length - 1] = Font.getDefaultFont();
            }
          }
        }
        farr[farr.length - 1] = "SimHei";
        fontArr = farr.join(" ");
      }
      return fontArr.replace(
        /(\d+\.?\d*)(px|em|rem|pt)/g,
        function(w, m, u) {
          if (m < 12) {
            m = 12 * ratio2;
          } else {
            m = Math.round(m) * ratio2;
          }
          return m + u;
        }
      );
    }
    static formatLabel(label) {
      if (label) {
        label = label + "";
        label = label.replace(/([\x00-\x1f\x7f])/g, "");
        label = label.replace(/(\s*$)/g, "");
        label = label.replace(/<br\/>/g, "");
      }
      return label;
    }
    static getAngle(p1, p2) {
      if (!p2 || !p1) {
        debugger;
      }
      if (p2[0] - p1[0] == 0) {
        if (p2[1] > p1[0]) {
          return 90;
        } else {
          return -90;
        }
      }
      let k = (p2[1] - p1[1]) / (p2[0] - p1[0]);
      let angle = 360 * Math.atan(k) / (2 * Math.PI);
      return angle;
    }
    static getUpdateAngle(angle, bearing2) {
      let totalAngle = angle - bearing2;
      if (totalAngle > 45 && totalAngle <= 135) {
        return -90;
      }
      if (totalAngle > 135 && totalAngle <= 225) {
        return -180;
      }
      if (totalAngle >= -225 && totalAngle < -135) {
        return 180;
      }
      if (totalAngle >= -135 && totalAngle < -45) {
        return 90;
      }
      return 0;
    }
    static updateAngle(angle, bearing2) {
      let totalAngle = angle - bearing2;
      if (totalAngle > 45 && totalAngle <= 135) {
        return angle - 90;
      }
      if (totalAngle > 135 && totalAngle <= 225) {
        return angle - 180;
      }
      if (totalAngle >= -225 && totalAngle < -135) {
        return angle + 180;
      }
      if (totalAngle >= -135 && totalAngle < -45) {
        return angle + 90;
      }
      return angle;
    }
    static isChangeDirection(label, p1, p2, angle) {
      let showChange = false;
      if (/.*[\u4e00-\u9fa5]+.*$/.test(label)) {
        if (p1[0] == p2[0]) {
          if (p1[1] > p2[1]) {
            showChange = true;
            return showChange;
          }
        }
        if (angle < -45 && angle > -90) {
          if (p1[0] < p2[0]) {
            showChange = true;
          }
        } else {
          if (p1[0] > p2[0]) {
            showChange = true;
          }
        }
      } else {
        if (p1[0] > p2[0]) {
          showChange = true;
        }
      }
      return showChange;
    }
    static textToSameBearing(textPoints) {
      if (textPoints.length < 2) {
        return;
      }
      for (let i = 1; i < textPoints.length; i++) {
        let preAngle = textPoints[i - 1][1];
        let angle1 = textPoints[i][1];
        if (Math.abs(angle1 - preAngle) > 45) {
          if (angle1 - preAngle > 0) {
            textPoints[i][1] = angle1 - 90;
          } else {
            textPoints[i][1] = angle1 + 90;
          }
        }
      }
    }
  };
  var AvoidUtil_default = AvoidUtil;

  // Source/custom/layer/label/avoid/Util.js
  var Util = class {
    static measureText(label, font, ctx) {
      return ctx.measureText(label).width;
    }
    static sort(features, styleMap2, hasImportant) {
      if (features.length > 0) {
        return features.sort(function(a2, b) {
          if (hasImportant) {
            let aStyle = styleMap2[a2.styleId];
            let bStyle = styleMap2[b.styleId];
            if (aStyle.isImportant && !bStyle.isImportant) {
              return -1;
            }
            if (bStyle.isImportant && !aStyle.isImportant) {
              return 1;
            }
          }
          let aAttr = a2.weight;
          let bAttr = b.weight;
          let aId = a2.primaryId;
          let bId = b.primaryId;
          if (!aAttr) {
            aAttr = -1;
          }
          if (!bAttr) {
            bAttr = -1;
          }
          if (aAttr < bAttr) {
            return 1;
          } else if (aAttr == bAttr) {
            if (aId < bId) {
              return 1;
            } else {
              return -1;
            }
          } else {
            return -1;
          }
        }.bind(this));
      }
    }
    static sortPrimaryId(features) {
      if (features.length > 0) {
        return features.sort(function(a2, b) {
          let aAttr = a2.weight;
          let bAttr = b.weight;
          let aId = a2.primaryId;
          let bId = b.primaryId;
          if (!aAttr) {
            aAttr = -1;
          }
          if (!bAttr) {
            bAttr = -1;
          }
          if (aAttr < bAttr) {
            return 1;
          } else if (aAttr == bAttr) {
            if (aId < bId) {
              return 1;
            } else {
              return -1;
            }
          } else {
            return -1;
          }
        }.bind(this));
      }
    }
    static groupByLabel(features) {
      let labelMap = {};
      for (let i = 0; i < features.length; i++) {
        let feature3 = features[i];
        if (feature3.label == null && feature3.iconImg != null) {
          if (labelMap[feature3.attributeId] == null) {
            labelMap[feature3.attributeId] = [];
          }
          labelMap[feature3.attributeId].push(feature3);
        } else {
          if (!labelMap[feature3.type + "_" + feature3.label]) {
            labelMap[feature3.type + "_" + feature3.label] = [];
          }
          labelMap[feature3.type + "_" + feature3.label].push(feature3);
        }
      }
      return labelMap;
    }
  };
  var Util_default = Util;

  // Source/custom/layer/label/avoid/GLabelBox.js
  var GLabelBox = class {
    constructor(ctx, formatFont, bearing2) {
      this.boxDistance = 0;
      this.ctx = ctx;
      this.formatFont = formatFont;
      this.bearing = bearing2;
    }
    setBox(features, styleMap2, isClient) {
      features.forEach(function(f, index) {
        f.hidden = false;
        let style = styleMap2[f.styleId];
        if (style.show == false) {
          f.hidden = true;
          return;
        }
        if (f.type == 1) {
          if (isClient) {
            this.setPointBox(f, f.datas, this.ctx, style);
          } else {
            this.setPointBox(f, f.sourceAngleData, this.ctx, style);
          }
        }
        if (f.type == 2) {
          if (f.lineType == "text") {
            if (isClient) {
              this.setTextLineBox(f, f.datas, this.ctx, style);
            } else {
              this.setTextLineBox(f, f.sourceAngleData, this.ctx, style);
            }
          }
          if (f.lineType == "code") {
            if (isClient) {
              this.setCodeLineBox(f, f.datas, this.ctx, style);
            } else {
              this.setCodeLineBox(f, f.sourceAngleData, this.ctx, style);
            }
          }
          if (f.lineType == "arrow") {
            if (isClient) {
              this.setArrowLineBox(f, f.datas, style);
            } else {
              this.setArrowLineBox(f, f.sourceAngleData, style);
            }
          }
        }
      }.bind(this));
      return features;
    }
    setPointBox(feature3, datas, ctx, style) {
      style.isImportant = false;
      if (style.labelFunction) {
        let labelFunction = new Function("label", style.labelFunction);
        try {
          feature3.label = labelFunction.call({}, feature3.attributes[style.labelfield]);
        } catch (e) {
          console.warn(feature3.label + ": \u8C03\u7528labelFunction\u5931\u8D25!");
        }
      }
      let labelIsNotNull = AvoidUtil_default.isNotNull(feature3.label);
      if (!labelIsNotNull && !feature3.iconImg) {
        feature3.hidden = true;
        return;
      }
      let param = this.getFontWidthHeight(ctx, feature3, style, labelIsNotNull);
      let graphicWidth = param.graphicWidth;
      let graphicHeight = param.graphicHeight;
      let fontWidth = param.fontWidth;
      let fontHeight = param.fontHeight;
      let maxFontheight = param.maxFontheight;
      let pointOffsetX = style.pointOffsetX;
      let pointOffsetY = style.pointOffsetY;
      if (!pointOffsetX) {
        pointOffsetX = 0;
      }
      if (!pointOffsetY) {
        pointOffsetY = 0;
      }
      let pt = [datas[0][0][0], datas[0][0][1]];
      pt[0] = pt[0] + pointOffsetX;
      pt[1] = pt[1] + pointOffsetY;
      if (pt[0] < 0 || pt[1] < 0) {
        feature3.hidden = true;
        return;
      }
      let pointBackgroundGap = style.pointBackgroundGap;
      if (style.pointHashBackground != true) {
        pointBackgroundGap = 0;
      }
      let graphicDistance = style.graphicDistance;
      if (graphicHeight == 0 || graphicWidth == 0) {
        graphicDistance = 0;
      }
      if (!style.hasOwnProperty("direction")) {
        style.direction = 0;
      }
      let boxs = [];
      let offsetPostion = [];
      if (style.texture) {
        if (feature3.label) {
          boxs = this.getPointAvoidBox(
            pt,
            style,
            graphicDistance,
            graphicWidth,
            graphicHeight,
            fontWidth + 2,
            maxFontheight + 2
          );
          offsetPostion = this.getPointOffsetPosition(
            style,
            graphicDistance,
            graphicWidth,
            graphicHeight,
            fontWidth,
            fontHeight
          );
        } else {
          let middleBox = [
            pt[0] - graphicWidth * 0.5,
            pt[1] - fontHeight * 0.5,
            pt[0] + graphicWidth * 0.5,
            pt[1] + fontHeight * 0.5
          ];
          middleBox = this.boxScale(middleBox, style.pointBoxDisance);
          boxs = [middleBox];
          offsetPostion = [new Cesium.Cartesian2(0, 0)];
        }
      } else {
        let middleBox = [
          pt[0] - fontWidth * 0.5,
          pt[1] - maxFontheight * 0.5,
          pt[0] + fontWidth * 0.5,
          pt[1] + maxFontheight * 0.5
        ];
        middleBox = this.boxScale(middleBox, style.pointBoxDisance);
        boxs = [middleBox];
        offsetPostion = [new Cesium.Cartesian2(-fontWidth * 0.5, 0)];
      }
      feature3.boxs = boxs;
      feature3.offsetPostion = offsetPostion;
      feature3.box = boxs[0];
    }
    getFontWidthHeight(ctx, feature3, style, labelIsNotNull) {
      let currPara = {};
      let graphicWidth = style.graphicWidth;
      let graphicHeight = style.graphicHeight;
      let img = feature3.iconImg;
      if (img) {
        if (!graphicWidth || !graphicHeight) {
          graphicWidth = img.width;
          graphicHeight = img.height;
        }
      } else {
        graphicWidth = 0;
        graphicHeight = 0;
      }
      currPara.graphicWidth = graphicWidth;
      currPara.graphicHeight = graphicHeight;
      currPara.fontWidth = graphicWidth;
      currPara.fontHeight = graphicHeight;
      if (labelIsNotNull) {
        let lableObject = feature3.labels[0];
        currPara.fontWidth = lableObject.totalWidth;
        currPara.fontHeight = lableObject.totalHeight;
        currPara.maxFontheight = currPara.fontHeight > graphicHeight ? currPara.fontHeight : graphicHeight;
      }
      return currPara;
    }
    getPointAvoidBox(pt, style, graphicDistance, graphicWidth, graphicHeight, fontWidth, maxFontheight) {
      let rightBox = [
        pt[0] - graphicWidth * 0.5,
        pt[1] - maxFontheight * 0.5,
        pt[0] + graphicWidth * 0.5 + graphicDistance + fontWidth,
        pt[1] + maxFontheight * 0.5
      ];
      let leftBox = [
        pt[0] - graphicWidth * 0.5 - graphicDistance - fontWidth,
        rightBox[1],
        pt[0] + graphicWidth * 0.5,
        rightBox[3]
      ];
      let bottomBox = [
        pt[0] - fontWidth * 0.5,
        pt[1] - graphicHeight * 0.5,
        pt[0] + fontWidth * 0.5,
        pt[1] + graphicHeight * 0.5 + graphicDistance + maxFontheight
      ];
      let topBox = [
        bottomBox[0],
        pt[1] - graphicDistance - maxFontheight - graphicHeight * 0.5,
        bottomBox[2],
        pt[1] + graphicHeight * 0.5
      ];
      rightBox = this.boxScale(rightBox, style.pointBoxDisance);
      leftBox = this.boxScale(leftBox, style.pointBoxDisance);
      bottomBox = this.boxScale(bottomBox, style.pointBoxDisance);
      topBox = this.boxScale(topBox, style.pointBoxDisance);
      let boxs = [rightBox, leftBox, bottomBox, topBox];
      if (!style.isFourDirections && !style.isEightDirections) {
        return [boxs[style.direction]];
      }
      if (style.isFourDirections) {
        if (style.direction > 0) {
          let item = boxs.splice(style.direction, 1);
          boxs.unshift(item[0]);
        }
        return boxs;
      }
      let rightTopBox = [
        rightBox[0],
        topBox[1],
        rightBox[2],
        pt[1] + graphicHeight * 0.5
      ];
      let rightBottomBox = [
        rightBox[0],
        pt[1] - graphicHeight * 0.5,
        rightBox[2],
        bottomBox[3]
      ];
      let leftTopBox = [
        leftBox[0],
        topBox[1],
        leftBox[2],
        pt[1] + graphicHeight * 0.5
      ];
      let leftBottomBox = [
        leftBox[0],
        pt[1] - graphicHeight * 0.5,
        leftBox[2],
        bottomBox[3]
      ];
      boxs = [rightBox, leftBox, bottomBox, topBox, rightTopBox, rightBottomBox, leftTopBox, leftBottomBox];
      if (style.direction > 0) {
        let item = boxs.splice(style.direction, 1);
        boxs.unshift(item[0]);
      }
      return boxs;
    }
    getPointOffsetPosition(style, graphicDistance, graphicWidth, graphicHeight, fontWidth, fontHeight) {
      let rPoint = new Cesium.Cartesian2(
        graphicWidth * 0.5 + graphicDistance,
        0
      );
      let lPoint = new Cesium.Cartesian2(
        -graphicWidth * 0.5 - graphicDistance - fontWidth,
        0
      );
      let bPoint = new Cesium.Cartesian2(
        -fontWidth * 0.5,
        graphicDistance + fontHeight * 0.5 + graphicHeight * 0.5
      );
      let tPoint = new Cesium.Cartesian2(
        bPoint.x,
        -graphicDistance - fontHeight * 0.5 - graphicHeight * 0.5
      );
      let drawPositions = [rPoint, lPoint, bPoint, tPoint];
      if (!style.isFourDirections && !style.isEightDirections) {
        return [drawPositions[style.direction]];
      }
      if (style.isFourDirections) {
        if (style.direction > 0) {
          let item = drawPositions.splice(style.direction, 1);
          drawPositions.unshift(item[0]);
        }
        return drawPositions;
      }
      let rtPoint = new Cesium.Cartesian2(rPoint.x, tPoint.y);
      let rbPoint = new Cesium.Cartesian2(rPoint.x, bPoint.y);
      let ltPoint = new Cesium.Cartesian2(lPoint.x, tPoint.y);
      let lbPoint = new Cesium.Cartesian2(lPoint.x, bPoint.y);
      drawPositions = [rPoint, lPoint, bPoint, tPoint, rtPoint, rbPoint, ltPoint, lbPoint];
      if (style.direction > 0) {
        let item = drawPositions.splice(style.direction, 1);
        drawPositions.unshift(item[0]);
      }
      return drawPositions;
    }
    setTextLineBox(feature3, datas, ctx, style) {
      let label = feature3.label;
      let textPoints = datas;
      if (textPoints.length == 0) {
        feature3.hidden = true;
        return;
      }
      feature3.textPoints = textPoints;
      let lineBoxs = [];
      if (style.lineHashBackground == true || textPoints.length == 1) {
        let p = textPoints[0][0];
        if (textPoints.length > 1) {
          let index = Math.floor(label.length / 2);
          p = textPoints[index][0];
        }
        let w = feature3.label.length * style.lineHeight;
        if (ctx) {
          ctx.save();
          if (this.formatFont) {
            ctx.font = Util_default.formatFont(style.lineFillFont, 1, true);
          } else {
            ctx.font = style.lineFillFont;
          }
          w = Util_default.measureText(feature3.label, ctx.font, ctx);
          ctx.restore();
        } else {
        }
        if (!style.lineBackgroundGap) {
          style.lineBackgroundGap = 0;
        }
        let minX = p[0] - w / 2 - style.lineBackgroundGap;
        let maxX = p[0] + w / 2 + style.lineBackgroundGap;
        let minY = p[1] - style.lineHeight * 0.5 - style.lineBackgroundGap;
        let maxY = p[1] + style.lineHeight * 0.5 + style.lineBackgroundGap;
        let box = [minX, minY, maxX, maxY];
        this.boxScale(box, style.lineTextBoxDisance);
        lineBoxs.push(box);
      } else {
        if (style.lineTextRotate || style.lineTextRotate == 0) {
          for (let m = 0; m < textPoints.length; m++) {
            textPoints[m][1] = style.lineTextRotate;
          }
        } else {
          this.updateAngle(textPoints);
          if (!style.isImportant) {
            if (this.isMessy(feature3, textPoints, style, label)) {
              feature3.hidden = true;
              return;
            }
          }
        }
        let boxs = this.getLineBoxs(label, textPoints, style, ctx);
        if (boxs) {
          lineBoxs = lineBoxs.concat(boxs);
        } else {
          feature3.hidden = true;
          return;
        }
      }
      let angle = AvoidUtil_default.getAngle(textPoints[0][0], textPoints[textPoints.length - 1][0]);
      let showChanged = AvoidUtil_default.isChangeDirection(label, textPoints[0][0], textPoints[textPoints.length - 1][0], angle);
      feature3.changeDirection = showChanged;
      feature3.boxs = lineBoxs;
    }
    boxScale(box, pointBoxDisance) {
      if (!pointBoxDisance && pointBoxDisance != 0) {
        pointBoxDisance = this.boxDistance;
      }
      box[0] = box[0] - pointBoxDisance * 0.5;
      box[1] = box[1] - pointBoxDisance * 0.5;
      box[2] = box[2] + pointBoxDisance * 0.5;
      box[3] = box[3] + pointBoxDisance * 0.5;
      return box;
    }
    setCodeLineBox(feature3, datas, ctx, style) {
      let codePoints = datas;
      if (codePoints.length == 0) {
        feature3.hidden = true;
        return;
      }
      let p = codePoints[0][0];
      let w = feature3.label.length * style.codeLineHeight;
      let scale = 1;
      if (ctx) {
        ctx.save();
        if (this.formatFont) {
          ctx.font = Util_default.formatFont(style.codeLineFillFont, 1, true);
        } else {
          ctx.font = style.codeLineFillFont;
        }
        w = Util_default.measureText(feature3.label, ctx.font, ctx);
        ctx.restore();
      } else {
      }
      let minX = p[0] - w / 2 - style.codeLineBackgroundGap;
      let maxX = p[0] + w / 2 + style.codeLineBackgroundGap;
      let minY = p[1] - style.codeLineHeight * 0.5 - style.codeLineBackgroundGap;
      let maxY = p[1] + style.codeLineHeight * 0.5 + style.codeLineBackgroundGap;
      let box = [minX, minY, maxX, maxY];
      this.boxScale(box, style.lineCodeBoxDisance);
      feature3.boxs = [box];
      feature3.codePoint = p;
    }
    setArrowLineBox(feature3, datas, style) {
      let arrowPoints = datas;
      if (arrowPoints.length != 3) {
        feature3.hiden = true;
        return;
      }
      let p = arrowPoints[0][0];
      let p1 = arrowPoints[1][0];
      let minX = p[0] < p1[0] ? p[0] : p1[0];
      let maxX = p[0] > p1[0] ? p[0] : p1[0];
      let minY = p[1] < p1[1] ? p[1] : p1[1];
      let maxY = p[1] > p1[1] ? p[1] : p1[1];
      let box = [minX, minY, maxX, maxY];
      this.boxScale(box, style.lineArrowBoxDisance);
      feature3.boxs = [box];
      feature3.arrowPoint = arrowPoints;
    }
    isMessy(feature3, textPoints, style, label) {
      let firstPoint = textPoints[0][0];
      let minX = firstPoint[0];
      let minY = firstPoint[1];
      let maxX = firstPoint[0];
      let maxY = firstPoint[1];
      let minAngle = textPoints[0][1];
      let maxAngle = textPoints[0][1];
      for (let i = 0; i < label.length; i++) {
        let currPoint = textPoints[i][0];
        let currAngle = textPoints[i][1];
        if (currPoint[0] > maxX)
          maxX = currPoint[0];
        if (currPoint[0] < minX)
          minX = currPoint[0];
        if (currPoint[1] > maxY)
          maxY = currPoint[1];
        if (currPoint[1] < minY)
          minY = currPoint[1];
        if (currAngle > maxAngle)
          maxAngle = currAngle;
        if (currAngle < minAngle)
          minAngle = currAngle;
      }
      if (maxAngle - minAngle > style.angle) {
        if (style.angleSwitch == false && style.angleColor) {
          feature3.lineFillStyle = style.angleColor;
        } else {
          return true;
        }
      }
      return false;
    }
    getLineBoxs(label, textPoints, style, ctx) {
      let boxs = [];
      let owmCrashBoxs = [];
      for (let i = 0; i < label.length; i++) {
        let pt = textPoints[i][0];
        if (textPoints[i][1] == 0) {
          textPoints[i][1] = 0.5;
        }
        let scale = 1;
        if (!ctx) {
        }
        let labelBox = [
          pt[0] - style.lineHeight * 1.2 * 0.5 * scale,
          pt[1] - style.lineHeight * 1.2 * 0.5 * scale,
          pt[0] + style.lineHeight * 1.2 * 0.5 * scale,
          pt[1] + style.lineHeight * 1.2 * 0.5 * scale
        ];
        let owmCrashBox = [
          pt[0] - style.lineHeight * 0.6 * 0.25 * scale,
          pt[1] - style.lineHeight * 0.6 * 0.25 * scale,
          pt[0] + style.lineHeight * 0.6 * 0.25 * scale,
          pt[1] + style.lineHeight * 0.6 * 0.25 * scale
        ];
        owmCrashBoxs.push(owmCrashBox);
        boxs.push(labelBox);
      }
      if (!style.isImportant) {
        for (let j = 0; j < owmCrashBoxs.length - 1; j++) {
          let box1 = owmCrashBoxs[j];
          for (let k = j + 1; k < owmCrashBoxs.length; k++) {
            let box2 = owmCrashBoxs[k];
            if (this.crashBox(box1, box2)) {
              return null;
            }
          }
        }
      }
      return boxs;
    }
    crashBox(ibox, jbox) {
      return ibox[0] <= jbox[2] && ibox[2] >= jbox[0] && ibox[1] <= jbox[3] && ibox[3] >= jbox[1];
    }
    updateAngle(textPoints) {
      let angle = AvoidUtil_default.getUpdateAngle(textPoints[0][1], this.bearing);
      for (let i = 0; i < textPoints.length; i++) {
        textPoints[i][2] = textPoints[i][1] + angle;
      }
    }
  };
  var GLabelBox_default = GLabelBox;

  // Source/custom/layer/label/avoid/GAnnoAvoid.js
  var GAnnoAvoid = class {
    constructor(ctx, formatFont, bearing2) {
      this.ctx = ctx;
      this.grid = null;
      if (!ctx) {
        this.grid = new GGridIndex_default(4096, 32, 0);
      }
      this.GLabelBox = new GLabelBox_default(ctx, formatFont, bearing2);
      this.featureMap = {};
    }
    defaultAvoid(features, styleMap2, isClient, hasImportant, ableWeight) {
      if (this.ctx) {
        if (isClient) {
          this.grid = new GGridIndex_default(4096, 32, 0);
        } else {
          this.grid = new GGridIndex_default(512, 32, 32);
        }
      }
      if (features == null || features.length < 1)
        return [];
      if (ableWeight) {
        Util_default.sort(features, styleMap2, hasImportant);
      }
      for (let i = 0; i < features.length; i++) {
        let feature3 = features[i];
        let style = styleMap2[feature3.styleId];
        this.avoidFeature(feature3, style);
        this.showOrHideFeature(feature3);
      }
      return features;
    }
    avoidFeature(f, style) {
      if (style.show == false || f.hidden == true || !f.boxs) {
        f.hidden = true;
        return;
      }
      let show = true;
      if (f.boxs) {
        if (f.type == 1) {
          show = this.avoidPoint(f, style);
        } else {
          if (f.isCollision) {
            f.hidden = true;
            return;
          } else {
            show = this.avoidLine(f, style);
          }
        }
      }
      f.hidden = !show;
    }
    avoidPoint(feature3, style) {
      feature3.boxIndex = 0;
      if (style.isImportant == true) {
        this.addBoxFeatureCells(feature3, style);
        return true;
      }
      if ((style.isFourDirections || style.isEightDirections) && style.texture) {
        return this.addFourCollisionFeatureToCells(feature3, style, 0);
      } else {
        if (feature3.boxIndexs && !feature3.boxIndexs[0]) {
          return false;
        }
        let isCollision = this.isCollision(feature3.box);
        if (isCollision) {
          return false;
        }
        this.addBoxFeatureCells(feature3, style);
        return true;
      }
    }
    avoidLine(feature3, style) {
      if (style.isImportant == true) {
        this.addBoxFeatureCells(feature3, style);
        return true;
      }
      let isCollision = false;
      for (let i = 0; i < feature3.boxs.length; i++) {
        let box = feature3.boxs[i];
        if (this.isCollision(box)) {
          isCollision = true;
          break;
        }
      }
      if (isCollision) {
        return false;
      } else {
        this.addBoxFeatureCells(feature3, style);
        return true;
      }
    }
    addFourCollisionFeatureToCells(feature3, style, index) {
      let isCollision = true;
      let box = [];
      if (!feature3.boxIndexs || feature3.boxIndexs && feature3.boxIndexs[index]) {
        box = feature3.boxs[index];
        isCollision = this.isCollision(box);
      }
      if (isCollision) {
        index++;
        if (index == feature3.boxs.length) {
          index = index - feature3.boxs.length;
        }
        if (index == 0) {
          return false;
        } else {
          return this.addFourCollisionFeatureToCells(feature3, style, index);
        }
      } else {
        feature3.boxIndex = index;
        feature3.box = box;
        this.addBoxFeatureCells(feature3, style);
        return true;
      }
    }
    isCollision(box) {
      let x12 = box[0];
      let y12 = box[1];
      let x22 = box[2];
      let y22 = box[3];
      let result = this.grid.query(x12, y12, x22, y22);
      return result.length > 0;
    }
    getCollisionIds(box) {
      let x12 = box[0];
      let y12 = box[1];
      let x22 = box[2];
      let y22 = box[3];
      return this.grid.query(x12, y12, x22, y22);
    }
    getCollisionFeatureIds(feature3) {
      if (feature3.type == 1) {
        return this.getCollisionIds(feature3.boxs[feature3.boxIndex]);
      }
      if (feature3.type == 2) {
        let ids = [];
        for (let i = 0; i < feature3.boxs.length; i++) {
          let keys = this.getCollisionIds(feature3.boxs[i]);
          ids = ids.concat(keys);
        }
        return ids;
      }
    }
    isShowCurrFeature(style, feature3, keys) {
      if (style.isImportant) {
        return true;
      }
      let weight = feature3.weight;
      for (let i = 0; i < keys.length; i++) {
        let item = this.featureMap[keys[i]];
        if (item) {
          let itemStyle = item.style;
          if (itemStyle.isImportant) {
            return false;
          }
          let itemFeature = item.feature;
          if (itemFeature.weight >= weight) {
            return false;
          }
        }
      }
      return true;
    }
    hideCollisionFeatures(f, keys) {
      for (let i = 0; i < keys.length; i++) {
        let item = this.featureMap[keys[i]];
        if (item) {
          let itemFeature = item.feature;
          let itemStyle = item.style;
          if (itemStyle.isImportant && itemFeature.objectId != f.objectId) {
            continue;
          }
          itemFeature.hidden = true;
          this.showOrHideFeature(itemFeature);
          this.removeBoxFeatureCells(itemFeature);
        }
      }
    }
    addBoxToCells(feature3, key2, box) {
      let x12 = box[0];
      let y12 = box[1];
      let x22 = box[2];
      let y22 = box[3];
      this.grid.insert(key2, x12, y12, x22, y22);
    }
    filterFeature(features) {
      let returnFeatures = [];
      for (let i = 0; i < features.length; i++) {
        if (!features[i].hidden) {
          features[i].drawed = true;
          returnFeatures.push(features[i]);
        }
      }
      return returnFeatures;
    }
    addBoxFeatureCells(feature3, style) {
      this.featureMap[feature3.primaryId] = { feature: feature3, style };
      if (feature3.type == 1) {
        this.addBoxToCells(feature3, feature3.primaryId, feature3.box);
      }
      if (feature3.type == 2) {
        for (let i = 0; i < feature3.boxs.length; i++) {
          let box = feature3.boxs[i];
          this.addBoxToCells(feature3, feature3.primaryId, box);
        }
      }
    }
    removeBoxFeatureCells(feature3) {
      if (this.featureMap[feature3.primaryId]) {
        delete this.featureMap[feature3.primaryId];
      } else {
        return;
      }
      if (feature3.type == 1) {
        this.removeBoxToCells(feature3.primaryId, feature3.box);
      }
      if (feature3.type == 2) {
        for (let i = 0; i < feature3.boxs.length; i++) {
          let box = feature3.boxs[i];
          this.removeBoxToCells(feature3.primaryId, box);
        }
      }
    }
    removeBoxToCells(key2, box) {
      let x12 = box[0];
      let y12 = box[1];
      let x22 = box[2];
      let y22 = box[3];
      this.grid.remove(key2, x12, y12, x22, y22);
    }
    showOrHideFeature(feature3) {
      let show = !feature3.hidden;
      if (feature3.labels) {
        for (let i = 0; i < feature3.labels.length; i++) {
          let label = feature3.labels[i];
          label.show = show;
          if (feature3.type == 1 && show) {
            label.pixelOffset = feature3.offsetPostion[feature3.boxIndex];
          }
        }
      }
      if (feature3.iconImg) {
        feature3.billboard.show = show;
      }
    }
  };
  var GAnnoAvoid_default = GAnnoAvoid;

  // Source/custom/layer/label/avoid/GDistance.js
  var GDistance = class {
    getLengthPoint(fromX, fromY, toX, toY, len, index) {
      let dx = toX - fromX;
      let dy = toY - fromY;
      let x_new;
      let y_new;
      if (dx == 0) {
        x_new = toX;
        if (dy > 0) {
          y_new = fromY + len;
        } else {
          y_new = fromY - len;
        }
        if (index == null) {
          return [x_new, y_new];
        } else {
          return [x_new, y_new, index];
        }
      }
      let tan3 = dy / dx;
      let sec = Math.sqrt(tan3 * tan3 + 1);
      let dx_new = Math.abs(len / sec);
      let dy_new = Math.abs(dx_new * tan3);
      if (dx > 0) {
        x_new = fromX + dx_new;
      } else {
        x_new = fromX - dx_new;
      }
      if (dy > 0) {
        y_new = fromY + dy_new;
      } else {
        y_new = fromY - dy_new;
      }
      if (index == null) {
        return [x_new, y_new];
      } else {
        return [x_new, y_new, index];
      }
    }
    getAngle(p1, p2) {
      if (p2[0] - p1[0] == 0) {
        if (p2[1] > p1[0]) {
          return 90;
        } else {
          return -90;
        }
      }
      let k = (p2[1] - p1[1]) / (p2[0] - p1[0]);
      let angle = 360 * Math.atan(k) / (2 * Math.PI);
      return angle;
    }
    length(x02, y02, x12, y12) {
      let dx = x12 - x02;
      let dy = y12 - y02;
      let len = Math.sqrt(dx * dx + dy * dy);
      return len;
    }
    getNodePath(coords, interval) {
      let previous = [];
      let points = {};
      let pointList = [];
      let intervalLength = interval.length;
      let fun_getInterval = function(interval2) {
        let value = interval2[0];
        interval2.splice(0, 1);
        return value;
      };
      let markLength = fun_getInterval(interval);
      let index = 0;
      while (true) {
        if (pointList.length == intervalLength) {
          points.index = index;
          points.pointList = pointList;
          return points;
        }
        if (index >= coords.length) {
          points.index = index;
          points.pointList = pointList;
          return points;
        }
        let x3 = coords[index];
        let y3 = coords[index + 1];
        if (previous.length == 0) {
          previous[0] = x3;
          previous[1] = y3;
          continue;
        } else {
          let lengthPath = this.length(previous[0], previous[1], x3, y3);
          if (lengthPath >= markLength) {
            let savePoint = this.getLengthPoint(previous[0], previous[1], x3, y3, markLength, null);
            let angle = this.getAngle(previous, [x3, y3]);
            if (angle == 90) {
              angle = 0;
            }
            if (angle == -90) {
              angle = 0;
            }
            if (angle == 0) {
              angle = 0.5;
            }
            if (angle >= 45) {
              angle = angle - 90;
            } else {
              if (angle <= -45) {
                angle = angle + 90;
              }
            }
            let pointAngle = [savePoint, angle];
            pointList.push(pointAngle);
            previous[0] = savePoint[0];
            previous[1] = savePoint[1];
            markLength = fun_getInterval(interval);
          } else {
            markLength = markLength - lengthPath;
            previous[0] = x3;
            previous[1] = y3;
            index = index + 2;
          }
        }
      }
      points.index = index;
      points.pointList = pointList;
      return points;
    }
  };
  var GDistance_default = GDistance;

  // Source/custom/layer/label/avoid/GCutLine.js
  var GCutLine = class {
    static cutLineFeature(feature3, style, scale) {
      let fs = [];
      let index = 0;
      if (feature3.sourceData.length < 4) {
        return fs;
      }
      let lineText = this.createLineTextFeatrue(feature3, style, index, scale);
      index = lineText.index;
      if (lineText.feature) {
        fs.push(lineText.feature);
      }
      let lineCode = this.createLineCodeFeatrue(feature3, style, index);
      index = lineCode.index;
      if (lineCode.feature) {
        fs.push(lineCode.feature);
      }
      let lineArrow = this.createLineArrowFeatrue(feature3, style, index);
      if (lineArrow.feature) {
        fs.push(lineArrow.feature);
      }
      return fs;
    }
    static createLineTextFeatrue(feature3, style, index, scale, filedName) {
      let line = feature3.sourceData;
      if (filedName) {
        line = feature3[filedName];
      }
      let d = new GDistance_default();
      let gaps = [];
      let textFeature = null;
      if (!scale) {
        scale = 1;
      }
      if (AvoidUtil_default.isNotNull(feature3.label)) {
        feature3.label = feature3.label + "";
        for (let count = 0; count < feature3.label.length; count++) {
          gaps.push((style.lineHeight * 1.2 + 2 + style.gap) * scale);
        }
        let cloneGaps = [].concat(gaps);
        let points = d.getNodePath(line, gaps);
        let textPoints = points.pointList;
        if (textPoints.length > 1) {
          index = points.index;
          let delayLength = feature3.label.length - textPoints.length;
          if (delayLength > 0) {
            index = line.length;
            if (delayLength < style.extendedNum) {
              this.delayTextPoint(line, textPoints, feature3.label, (style.chinaLabelWidth + style.gap) * scale);
            } else {
              return { feature: null, index };
            }
          }
          AvoidUtil_default.textToSameBearing(textPoints);
          textFeature = this.cloneFeature(feature3);
          if (style.changeDirection != false) {
          }
          textFeature.attributeId = feature3.attributeId + "_text";
          textFeature.sourceAngleData = textPoints;
          textFeature.lineType = "text";
        } else {
        }
        if (textFeature) {
          if (style.lineOffset && textFeature.sourceAngleData.length > 1) {
            textFeature.sourceAngleData = GisTools_default.lineOffset(textFeature.sourceAngleData, style.lineOffset);
          }
          textFeature.textPoints = textFeature.sourceAngleData;
          textFeature.primaryId = textFeature.attributeId + "_row_" + feature3.xyz.y + "_col_" + feature3.xyz.x + "_level_" + feature3.xyz.z + "_x_" + textFeature.sourceAngleData[0][0][0] + "_y_" + textFeature.sourceAngleData[0][0][1];
          textFeature.id = textFeature.attributeId + "_row_" + feature3.xyz.y + "_col_" + feature3.xyz.x + "_level_" + feature3.xyz.z + "_x_" + line[0] + "_y_" + line[1];
        }
      }
      return { feature: textFeature, index };
    }
    static createLineCodeFeatrue(feature3, style, index) {
      let line = feature3.sourceData;
      let d = new GDistance_default();
      let gaps = [];
      let codeFeature = null;
      let roadLabel = feature3.roadCodeLabel;
      if (style.showRoadCode && AvoidUtil_default.isNotNull(roadLabel) && index < line.length) {
        let codeLine = line.slice(index, line.length - 1);
        gaps.push(30);
        let cPoints = d.getNodePath(codeLine, gaps);
        let codePoints = cPoints.pointList;
        if (codePoints.length == 1) {
          index = index + cPoints.index;
          codeFeature = this.cloneFeature(feature3);
          codeFeature.attributeId = feature3.attributeId + "_code";
          codeFeature.sourceAngleData = codePoints;
          codeFeature.lineType = "code";
          codeFeature.label = roadLabel + "";
        }
        if (codePoints.length == 0) {
          codeFeature = this.cloneFeature(feature3);
          codeFeature.attributeId = feature3.attributeId + "_code";
          codeFeature.sourceAngleData = [[[line[0], line[1]], 0]];
          codeFeature.lineType = "code";
          codeFeature.label = roadLabel + "";
          index = 2;
        }
        codeFeature.textPoints = [codeFeature.sourceAngleData[0][0]];
        codeFeature.primaryId = codeFeature.attributeId + "_row_" + feature3.xyz.y + "_col_" + feature3.xyz.x + "_level_" + feature3.xyz.z + "_x_" + codeFeature.sourceAngleData[0][0][0] + "_y_" + codeFeature.sourceAngleData[0][0][1];
        codeFeature.id = codeFeature.attributeId + "_row_" + feature3.xyz.y + "_col_" + feature3.xyz.x + "_level_" + feature3.xyz.z + "_x_" + line[0] + "_y_" + line[1];
      }
      return { feature: codeFeature, index };
    }
    static createLineArrowFeatrue(feature3, style, index) {
      let line = feature3.sourceData;
      let d = new GDistance_default();
      let gaps = [];
      let arrowFeature = null;
      if (style.showArrow && index < line.length) {
        let arrowLine = line.slice(index, line.length - 1);
        gaps.push(16);
        gaps.push(16);
        let aPoints = d.getNodePath(arrowLine, gaps);
        let arrowPoints = aPoints.pointList;
        if (arrowPoints.length == 2) {
          arrowFeature = this.cloneFeature(feature3);
          arrowFeature.attributeId = feature3.attributeId + "_arrow";
          arrowFeature.sourceAngleData = arrowPoints;
          arrowFeature.textPoints = arrowPoints;
          arrowFeature.lineType = "arrow";
          arrowFeature.primaryId = arrowFeature.attributeId + "_row_" + feature3.xyz.y + "_col_" + feature3.xyz.x + "_level_" + feature3.xyz.z + "_x_" + arrowFeature.sourceAngleData[0][0][0] + "_y_" + arrowFeature.sourceAngleData[0][0][1];
          arrowFeature.id = arrowFeature.attributeId + "_row_" + feature3.xyz.y + "_col_" + feature3.xyz.x + "_level_" + feature3.xyz.z + "_x_" + line[0] + "_y_" + line[1];
        }
      }
      return { feature: arrowFeature, index };
    }
    static delayTextPoint(line, textPoints, label, gap) {
      let fristPoint = null;
      let secondPoint = null;
      if (textPoints.length == 1) {
        fristPoint = [line[0], line[1]];
      } else {
        fristPoint = textPoints[textPoints.length - 2][0];
      }
      secondPoint = textPoints[textPoints.length - 1][0];
      let angle = textPoints[textPoints.length - 1][1];
      let len = textPoints.length;
      for (let i = 1; i < label.length - len + 1; i++) {
        let p = this.getPoint(fristPoint, secondPoint, gap * i);
        let textPoint = [p, angle];
        textPoints.push(textPoint);
      }
    }
    static cloneFeature(feature3) {
      return {
        type: feature3.type,
        datas: feature3.datas,
        centerPoint: feature3.centerPoint,
        sourceData: feature3.sourceData,
        label: feature3.label,
        roadCodeLabel: feature3.roadCodeLabel,
        attributes: feature3.attributes,
        attributeId: feature3.attributeId,
        styleId: feature3.styleId,
        textures: feature3.textures,
        xyz: feature3.xyz,
        lineType: feature3.lineType,
        weight: feature3.weight,
        layerName: feature3.layerName,
        objectId: feature3.objectId
      };
    }
    static getDistance(p1, p2) {
      let calX = p2[0] - p1[0];
      let calY = p2[1] - p1[1];
      return Math.pow(calX * calX + calY * calY, 0.5);
    }
    static getLineDistance(line) {
      if (line.length < 4) {
        return 0;
      }
      let dis = 0;
      for (let i = 0; i < line.length / 2 - 1; i++) {
        let p1 = [line[2 * i], line[2 * i + 1]];
        let p2 = [line[2 * (i + 1)], line[2 * (i + 1) + 1]];
        dis = dis + this.getDistance(p1, p2);
      }
      return dis;
    }
    static getPoint(p1, p2, d) {
      let xab = p2[0] - p1[0];
      let yab = p2[1] - p1[1];
      let xd = p2[0];
      let yd = p2[1];
      if (xab == 0) {
        if (yab > 0) {
          yd = p2[1] + d;
        } else {
          yd = p2[1] - d;
        }
      } else {
        let xbd = Math.sqrt(d * d / (yab / xab * (yab / xab) + 1));
        if (xab < 0) {
          xbd = -xbd;
        }
        xd = p2[0] + xbd;
        yd = p2[1] + yab / xab * xbd;
      }
      return [xd, yd];
    }
  };
  var GCutLine_default = GCutLine;

  // Source/custom/layer/label/AvoidTile.js
  var tiles = [];
  var labelAvoid = null;
  var finished = true;
  var styleMap;
  var needCutLine = false;
  var z;
  var viewer2;
  var AvoidTile = class {
    static init(ts, heading, sm, vr) {
      finished = false;
      styleMap = sm;
      tiles = ts;
      viewer2 = vr;
      needCutLine = false;
      let l = viewer2.camera.getLevel();
      if (!z || Math.abs(l - z) > 0.1) {
        needCutLine = true;
      }
      z = l;
      labelAvoid = new GAnnoAvoid_default(null, null, heading);
    }
    static setTiles(ts, heading) {
      finished = false;
      tiles = ts;
      labelAvoid = new GAnnoAvoid_default(null, null, heading);
    }
    static avoidTile() {
      const startTime = new Date().getTime();
      const shouldPausePlacement = () => {
        const elapsedTime = new Date().getTime() - startTime;
        return elapsedTime > 3;
      };
      let level = viewer2.camera.getLevel();
      while (tiles.length > 0) {
        let tile = tiles.shift();
        if (tile.isDestroy) {
          continue;
        }
        if (needCutLine) {
          let scale = Math.pow(2, tile.level) / Math.pow(2, level) * 0.5;
          AvoidTile.cutLine(tile, tile.features, scale);
        }
        tile.updateScreenPt(tile.features);
        labelAvoid.GLabelBox.setBox(tile.features, tile.styleMap, true);
        labelAvoid.defaultAvoid(tile.features, tile.styleMap, true, true, false);
        AvoidTile.updateLineLable(tile.features);
        if (shouldPausePlacement()) {
          return;
        }
      }
      finished = true;
    }
    static cutLine(tile, features, scale) {
      for (let i = 0; i < features.length; i++) {
        let feature3 = features[i];
        if (feature3.lineType != "text") {
          continue;
        }
        let f = GCutLine_default.createLineTextFeatrue(feature3, styleMap[feature3.styleId], 0, scale).feature;
        feature3.anglePositions = [];
        if (f) {
          for (let j = 0; j < f.sourceAngleData.length; j++) {
            let anglePosition = [];
            let sourceAngleData = f.sourceAngleData[j];
            let position = tile.toCartesian3([sourceAngleData[0][0], sourceAngleData[0][1]]);
            anglePosition.push(position);
            anglePosition.push(feature3.sourceAngleData[j][1]);
            feature3.anglePositions.push(anglePosition);
            let label = feature3.labels[j];
            if (feature3.anglePositions[j][0]) {
              label.show = true;
              label.position = feature3.anglePositions[j][0];
            } else {
              label.show = false;
            }
          }
        }
      }
    }
    static screenToposition(x3, y3) {
      let c = new Cesium.Cartesian2(x3, y3);
      let position = viewer2.camera.pickEllipsoid(c, viewer2.scene.globe.ellipsoid);
      return position;
    }
    static updateLineLable(features) {
      for (let i = 0; i < features.length; i++) {
        let feature3 = features[i];
        if (!feature3.hidden && feature3.lineType == "text" && feature3.labels) {
          for (let j = 0; j < feature3.labels.length; j++) {
            let label = feature3.labels[j];
            if (feature3.changeDirection) {
              label.text = feature3.label.charAt(feature3.labels.length - 1 - j);
            } else {
              label.text = feature3.label.charAt(j);
            }
            let angle = -feature3.textPoints[j][2];
            if (angle != label.angle) {
              label.angle = angle;
              label.rotation = Cesium.Math.toRadians(angle);
            }
          }
        }
      }
    }
    static isFinished() {
      return finished;
    }
  };
  var AvoidTile_default = AvoidTile;

  // Source/custom/layer/label/avoid/LabelDrawer.js
  var LabelDrawer = class {
    constructor(layerDataMap, styleMap2, level) {
      this.layerDataMap = layerDataMap;
      this.level = level;
      this.styleMap = styleMap2;
      this.propertyGetterMap = {};
    }
    getLayer(layername) {
      this.layerDatas = {};
      let data = this.layerDataMap[layername];
      if (data == null || data.features == null) {
        return this;
      }
      this.propertyGetterMap[layername] = this.getProperty(data.fieldsConfig);
      this.layerDatas[layername] = data;
      return this;
    }
    getAllLayer() {
      this.layerDatas = this.layerDataMap;
      for (let layername in this.layerDataMap) {
        this.propertyGetterMap[layername] = this.getProperty(this.layerDataMap[layername].fieldsConfig);
      }
      return this;
    }
    getGroupLayer(layername, value) {
      this.layerDatas = {};
      let valueArr = value.split(",");
      let length2 = valueArr.length;
      if (length2 == 0) {
        return this;
      }
      let data = this.layerDataMap[layername];
      if (data == null || data.features == null) {
        return this;
      }
      this.propertyGetterMap[layername] = this.getProperty(data.fieldsConfig);
      this.layerDatas[layername] = data;
      return this;
    }
    getProperty(fieldsConfig) {
      let propertyConfig = {};
      let idIndex = 0;
      for (var i = 0; i < fieldsConfig.length; i++) {
        if (fieldsConfig[i].id == "true" || fieldsConfig[i].id == true) {
          idIndex = fieldsConfig[i].index;
        }
        propertyConfig[fieldsConfig[i].name] = parseInt(fieldsConfig[i].index);
      }
      return { propertyConfig, idIndex };
    }
    setStyle(fn) {
      for (let layername in this.layerDatas) {
        let layerData = this.layerDatas[layername];
        let propertyGetter = this.propertyGetterMap[layername];
        for (let i = 0; i < layerData.features.length; i++) {
          let feature3 = layerData.features[i];
          let get2 = function(key2) {
            return feature3[1][propertyGetter.propertyConfig[key2]];
          };
          let style = fn.call({}, this.level, get2);
          if (style && style.show == true) {
            if (!this.styleMap[style._id]) {
              this.styleMap[style._id] = style;
            }
            feature3.avoidWeight = this.getWeight(style, feature3, propertyGetter);
            feature3.styleId = style._id;
          }
        }
      }
    }
    setGlobalStyle(fn) {
      this.globalStyle = fn.call({});
    }
    getWeight(style, feature3, propertyGetter) {
      let weight = feature3[1][propertyGetter.propertyConfig[style.avoidField]];
      if (weight) {
        weight = parseInt(weight);
        if (isNaN(weight)) {
          weight = 0;
        }
      } else {
        weight = 0;
      }
      if (weight == 0) {
        if (style.avoidWeight) {
          return style.avoidWeight;
        }
      }
      return weight;
    }
    draw() {
    }
  };
  var LabelDrawer_default = LabelDrawer;

  // Source/custom/layer/label/avoid/ParseLabelData.js
  var _path2 = "./../../../../";
  var TextureManager = null;
  var ParseLabelData = class {
    static parseLayerDatas(layerDatas, styleMap2, textures, xyz, isClient) {
      let pointFeatures = [];
      let lineFeatures = [];
      for (let layername in layerDatas) {
        if (layername == "_layerAvoids") {
          continue;
        }
        let layerData = layerDatas[layername];
        layerData.xyz = xyz;
        let propertyGetter = ParseLabelData.getProperty(layerData.fieldsConfig);
        if (layerData.type == 1) {
          let pfs = ParseLabelData.parsePointLayer(layerData, layername, propertyGetter, styleMap2, textures, isClient);
          pointFeatures = pointFeatures.concat(pfs);
        }
        if (layerData.type == 2) {
          let lfs = ParseLabelData.parseLineLayer(layerData, layername, propertyGetter, styleMap2, isClient);
          lineFeatures = lineFeatures.concat(lfs);
        }
      }
      return { pointFeatures, lineFeatures };
    }
    static parsePointLayer(layerData, layername, propertyGetter, styleMap2, textures, isClient) {
      let pointFeatures = [];
      for (let i = 0; i < layerData.features.length; i++) {
        let feature3 = layerData.features[i];
        let style = styleMap2[feature3.styleId];
        if (!style) {
          continue;
        }
        feature3.centerPoint = feature3[2];
        feature3.attributeId = layername + "__" + feature3[1][propertyGetter.idIndex];
        feature3.layerName = layername;
        feature3.xyz = layerData.xyz;
        feature3.propertyGetter = propertyGetter;
        feature3.type = layerData.type;
        feature3.weight = feature3.avoidWeight;
        if (feature3.avoidWeight == null || isNaN(feature3.avoidWeight)) {
          feature3.avoidWeight = style.avoidWeight;
          feature3.weight = feature3.avoidWeight;
          if (feature3.weight == null) {
            feature3.weight = 0;
            feature3.avoidWeight = 0;
          }
        }
        if (style.isImportant) {
          feature3.avoidWeight = 99999999;
          feature3.weight = 99999999;
        }
        feature3 = ParseLabelData.parsePoint(feature3, style, textures, isClient);
        pointFeatures.push(feature3);
      }
      return pointFeatures;
    }
    static parseLineLayer(layerData, layername, propertyGetter, styleMap2, isClient) {
      let lineFeatures = [];
      for (let i = 0; i < layerData.features.length; i++) {
        let feature3 = layerData.features[i];
        let style = styleMap2[feature3.styleId];
        if (!style) {
          continue;
        }
        feature3.layerName = layername;
        let features = ParseLabelData.parseLine(feature3, style, layerData, propertyGetter, isClient);
        lineFeatures = lineFeatures.concat(features);
      }
      return lineFeatures;
    }
    static parsePoint(feature3, style, textures, isClient) {
      if (isClient) {
        feature3.iconImg = textures[style.texture];
      } else {
        if (TextureManager == null) {
          TextureManager = __require(_path2 + "src/process/texture/TextureManager");
        }
        if (style.texture) {
          let texture = TextureManager.getTexture(style.texture);
          if (texture != null) {
            feature3.iconImg = texture.toPattern(ratio);
          }
        }
      }
      feature3.attributes = ParseLabelData.getAttributes(feature3[1], feature3.propertyGetter);
      let point2 = feature3[2];
      let sourceAngleData = [[point2, 0]];
      let label = feature3.attributes[style.labelfield];
      feature3.primaryId = feature3.attributeId + "_row_" + feature3.xyz.y + "_col_" + feature3.xyz.x + "_level_" + feature3.xyz.z + "_x_" + sourceAngleData[0][0][0] + "_y_" + sourceAngleData[0][0][1];
      feature3.label = AvoidUtil_default.formatLabel(label);
      feature3.weight = feature3.avoidWeight;
      let radius = 0;
      if (style.pointBoxDisance) {
        radius = style.pointBoxDisance * 0.5;
      }
      feature3.filterBox = [
        feature3.centerPoint[0] - radius,
        feature3.centerPoint[1] - radius,
        feature3.centerPoint[0] + radius,
        feature3.centerPoint[1] + radius
      ];
      feature3.sourceData = point2;
      feature3.sourceAngleData = sourceAngleData;
      if (isClient) {
        feature3.id = Math.round(Math.random() * 256 * 256 * 256);
      }
      return feature3;
    }
    static parseLine(feature3, style, layerData, propertyGetter, isClient) {
      if (feature3[2].length == 0) {
        return [];
      }
      let lines = [];
      ParseLabelData.processLineString(lines, feature3[2], feature3, style, layerData, propertyGetter, isClient);
      return lines;
    }
    static processLineString(lines, components, feature3, style, layerData, propertyGetter, isClient) {
      if (Array.isArray(components[0])) {
        let len = components.length;
        for (let i = 0; i < len; i++) {
          let component = components[i];
          ParseLabelData.processLineString(lines, component, feature3, style, layerData, propertyGetter, isClient);
        }
      } else {
        let ls = ParseLabelData.parseMultiLine(feature3, components, layerData, propertyGetter, style, isClient);
        for (let i = 0; i < ls.length; i++) {
          lines.push(ls[i]);
        }
      }
    }
    static parseMultiLine(feature3, line, layerData, propertyGetter, style, isClient) {
      let attributes = ParseLabelData.getAttributes(feature3[1], propertyGetter);
      let multiLines = [];
      let label = attributes[style.labelfield];
      let roadCodeLabel = attributes[style.roadCodeLabel];
      label = AvoidUtil_default.formatLabel(label);
      roadCodeLabel = AvoidUtil_default.formatLabel(roadCodeLabel);
      let objectid = feature3[1][propertyGetter.idIndex];
      let attributeId = feature3.layerName + "__" + objectid;
      let weight = feature3.avoidWeight;
      if (style.isImportant) {
        weight = 99999999;
      }
      let featureItem = {
        type: layerData.type,
        sourceData: line,
        label,
        weight: feature3.avoidWeight,
        roadCodeLabel,
        attributes,
        attributeId,
        styleId: feature3.styleId,
        xyz: layerData.xyz,
        layerName: feature3.layerName
      };
      multiLines = multiLines.concat(ParseLabelData.cutLineFeature(featureItem, style, isClient, false));
      return multiLines;
    }
    static cutLineFeature(feature3, style, isClient, isLocal) {
      if (isClient) {
        if (style.type == "_default__") {
          feature3.sourceAngleData = ParseLabelData.lineToSourceAngleData(feature3.sourceData);
          return [feature3];
        }
      }
      let features = GCutLine_default.cutLineFeature(feature3, style, 1);
      let radius = 5;
      for (let i = 0; i < features.length; i++) {
        let f = features[i];
        f.primaryId = f.attributeId + "_row_" + feature3.xyz.y + "_col_" + feature3.xyz.x + "_level_" + feature3.xyz.z + "_x_" + f.sourceAngleData[0][0][0] + "_y_" + f.sourceAngleData[0][0][1];
        if (isClient) {
          f.id = Math.round(Math.random() * 256 * 256 * 256);
        }
        f.layerName = feature3.layerName;
        if (f.lineType == "text") {
          let centerIndex = Math.floor(f.sourceAngleData.length / 2);
          f.centerPoint = f.sourceAngleData[centerIndex][0];
          if (style.lineTextBoxDisance) {
            radius = style.lineTextBoxDisance * 0.5;
          }
        }
        if (f.lineType == "code") {
          f.centerPoint = f.sourceAngleData[0][0];
          if (style.lineCodeBoxDisance) {
            radius = style.lineCodeBoxDisance * 0.5;
          }
        }
        if (f.lineType == "arrow") {
          f.centerPoint = f.sourceAngleData[1][0];
        }
        f.filterBox = [f.centerPoint[0] - radius, f.centerPoint[1] - radius, f.centerPoint[0] + radius, f.centerPoint[1] + radius];
      }
      return features;
    }
    static lineToSourceAngleData(line) {
      let sourceAngleData = [];
      for (let i = 0; i < line.length; i++) {
        let x3 = line[i];
        let y3 = line[i + 1];
        sourceAngleData.push([[x3, y3], 0]);
        i++;
      }
      return sourceAngleData;
    }
    static transformData(points, xyz, maxExtent, extent, res, tileSize) {
      let left = extent[0];
      let top = extent[3];
      let mLeft = maxExtent[0];
      let mTop = maxExtent[3];
      let x3 = (left - mLeft) / res;
      let y3 = (mTop - top) / res;
      let rPoint = [];
      for (let i = 0; i < points.length; i++) {
        let point2 = points[i][0];
        let gx = point2[0] + xyz.x * tileSize;
        let gy = point2[1] + xyz.y * tileSize;
        let p = [gx - x3, gy - y3];
        rPoint.push([p, points[i][1]]);
      }
      return rPoint;
    }
    static toLonlat(rectangle, point2, tileSize) {
      var lon = CesiumMath.toDegrees(rectangle.west + rectangle.width / tileSize * x);
      var lat = CesiumMath.toDegrees(rectangle.north - rectangle.height / tileSize * y);
      return [lon, lat];
    }
    static getProperty(fieldsConfig) {
      let propertyConfig = {};
      let idIndex = 0;
      for (var i = 0; i < fieldsConfig.length; i++) {
        if (fieldsConfig[i].id == "true" || fieldsConfig[i].id == true) {
          idIndex = fieldsConfig[i].index;
        }
        propertyConfig[fieldsConfig[i].name] = parseInt(fieldsConfig[i].index);
      }
      return { propertyConfig, idIndex };
    }
    static getAttributes(feature3, propertyGetter) {
      let attributes = {};
      let propertyConfig = propertyGetter.propertyConfig;
      for (let name2 in propertyConfig) {
        attributes[name2] = feature3[propertyConfig[name2]];
      }
      return attributes;
    }
  };
  var ParseLabelData_default = ParseLabelData;

  // Source/custom/layer/label/avoid/GridFilterLabel.js
  var GridFilterLabel = class {
    static fristFilter(pointFeatures, lineFeatures, styleMap2, ableWeight, needSort, tilesize, cellsize, buffer4, maxPerCell) {
      if (ableWeight && needSort) {
        Util_default.sort(pointFeatures);
        Util_default.sort(lineFeatures);
      }
      pointFeatures = GridFilterLabel.fristFilterStart(pointFeatures, tilesize, cellsize, buffer4, maxPerCell);
      lineFeatures = GridFilterLabel.fristFilterStart(lineFeatures, tilesize, cellsize, buffer4, maxPerCell);
      return { pointFeatures, lineFeatures };
    }
    static scendFilter(pointFeatures, lineFeatures, styleMap2, ableWeight, needSort, tilesize, cellsize, buffer4, maxPerCell) {
      if (ableWeight && needSort) {
        Util_default.sort(pointFeatures);
        Util_default.sort(lineFeatures);
      }
      pointFeatures = GridFilterLabel.scendFilterStart(pointFeatures, tilesize, 16, buffer4);
      lineFeatures = GridFilterLabel.scendFilterStart(lineFeatures, tilesize, 16, buffer4);
      let returnFeatures = [];
      returnFeatures = returnFeatures.concat(pointFeatures);
      returnFeatures = returnFeatures.concat(lineFeatures);
      return returnFeatures;
    }
    static removeTileOutPointFeatures(features, tileSize) {
      let newFeatures = [];
      for (let i = 0; i < features.length; i++) {
        let feature3 = features[i];
        let pt = feature3.centerPoint;
        if (pt[0] >= 0 && pt[0] <= tileSize && pt[1] >= 0 && pt[1] <= tileSize) {
          newFeatures.push(feature3);
        }
      }
      return newFeatures;
    }
    static removeTileOutLineFeatures(features, tileSize) {
      let newFeatures = [];
      for (let i = 0; i < features.length; i++) {
        let feature3 = features[i];
        for (let j = 0; j < feature3.datas.length; j++) {
          let pt = feature3.datas[j][0];
          if (pt[0] >= 0 && pt[0] <= tileSize && pt[1] >= 0 && pt[1] <= tileSize) {
            newFeatures.push(feature3);
            break;
          }
        }
      }
      return newFeatures;
    }
    static fristFilterStart(features, tilesize, cellsize, buffer4, maxPerCell) {
      let gridFilter = new GridFilter_default(tilesize, cellsize, buffer4, maxPerCell);
      let returnFeatures = [];
      for (let i = 0; i < features.length; i++) {
        let feature3 = features[i];
        let bool = gridFilter.filter(feature3.centerPoint[0], feature3.centerPoint[1]);
        if (bool) {
          returnFeatures.push(feature3);
        }
      }
      return returnFeatures;
    }
    static scendFilterStart(features, tilesize, cellsize, buffer4) {
      let gridFilter = new GridFilter_default(tilesize, cellsize, buffer4, 1);
      let returnFeatures = [];
      for (let i = 0; i < features.length; i++) {
        let feature3 = features[i];
        let bool = gridFilter.filterByBox(feature3.filterBox);
        if (bool) {
          returnFeatures.push(feature3);
        }
      }
      return returnFeatures;
    }
    static threeFilter(features, tileSize, cellsize, buffer4, styleMap2) {
      let fs = GridFilterLabel.getImportantOtherFeatures(features, styleMap2);
      let labelMap = Util_default.groupByLabel(fs.otherFeatures);
      let returnFeatures = [];
      for (let label in labelMap) {
        let labelArr = labelMap[label];
        if (labelArr.length == 1) {
          returnFeatures.push(labelArr[0]);
        } else {
          returnFeatures = returnFeatures.concat(GridFilterLabel.distinctFeatures(labelArr, tileSize, cellsize, buffer4, styleMap2));
        }
      }
      returnFeatures = returnFeatures.concat(fs.importantFeatures);
      return returnFeatures;
    }
    static distinctFeatures(features, tileSize, cellsize, buffer4, styleMap2) {
      let feature3 = features[0];
      let field = "";
      if (feature3.type == 1) {
        field = "distance";
      }
      if (feature3.type == 2) {
        if (feature3.lineType == "text") {
          field = "lineTextDistance";
        }
        if (feature3.lineType == "code") {
          field = "lineCodeDistance";
        }
      }
      let style = styleMap2[feature3.styleId];
      let distance = style[field] ? style[field] : 0;
      let fs = [];
      let gridFilter = new GridFilter_default(tileSize, cellsize, buffer4, 1);
      for (let i = 0; i < features.length - 1; i++) {
        let feature4 = features[i];
        let box = GisTools_default.boxScale(feature4.filterBox, distance);
        let bool = gridFilter.filterByBox(box);
        if (bool) {
          fs.push(feature4);
        }
      }
      return fs;
    }
    static getImportantOtherFeatures(features, styleMap2) {
      let importantFeatures = [];
      let otherFeatures = [];
      for (let i = 0; i < features.length; i++) {
        let feature3 = features[i];
        let style = styleMap2[feature3.styleId];
        if (style.isImportant) {
          importantFeatures.push(feature3);
        } else {
          otherFeatures.push(feature3);
        }
      }
      return { otherFeatures, importantFeatures };
    }
  };
  var GridFilterLabel_default = GridFilterLabel;

  // Source/custom/layer/label/LabelTile.js
  var BEGIN4 = 1;
  var ADDED4 = 2;
  var REMOVED4 = 3;
  var LabelTile = class {
    constructor(defaultHeight, name2, xyz, tileSize, rectangle, data, indexDbNames, styleFun, dataType, level, styleMap2, textures, scene) {
      this.defaultHeight = defaultHeight;
      this.name = name2;
      this.xyz = xyz;
      this.tileSize = tileSize;
      this.rectangle = rectangle;
      this.sourceData = data;
      this.indexDbNames = indexDbNames;
      this.styleFun = styleFun;
      this.dataType = dataType;
      this.level = level;
      this.styleMap = styleMap2;
      this.textures = textures;
      this.scene = scene;
      this.labelCollection = new LabelCollectionExt_default({ blendOption: Cesium.BlendOption.OPAQUE, enuEnabled: false });
      this.roadLabelCollection = new LabelCollectionExt_default({ blendOption: Cesium.BlendOption.OPAQUE, enuEnabled: true });
      this.billboardCollection = new Cesium.BillboardCollection({ blendOption: Cesium.BlendOption.OPAQUE });
      this.ableAvoid = true;
      this.ableWeight = true;
      this.cellsize = 4;
      this.maxPerCell = 1;
      this.state = BEGIN4;
      this.ready = false;
      this.parse();
    }
    reset() {
      this.state = BEGIN4;
      this.ready = false;
      this.parse();
    }
    parse() {
      if (this.dataType == "binary") {
        let drawer = new LabelDrawer_default(this.sourceData, this.styleMap, this.level);
        this.styleFun.call({}, drawer, this.level);
      } else {
        let render2 = new LabelDrawer_default(this.sourceData, this.styleMap, this.level);
        this.styleFun.call({}, render2, this.level);
      }
      let features = ParseLabelData_default.parseLayerDatas(
        this.sourceData,
        this.styleMap,
        this.textures,
        this.xyz,
        true
      );
      features.pointFeatures = GridFilterLabel_default.removeTileOutPointFeatures(features.pointFeatures, this.tileSize);
      let labelFeatures = GridFilterLabel_default.fristFilter(
        features.pointFeatures,
        features.lineFeatures,
        this.styleMap,
        this.ableWeight,
        true,
        this.tileSize,
        this.cellsize,
        this.tileSize * 0.5,
        this.maxPerCell
      );
      labelFeatures = GridFilterLabel_default.scendFilter(labelFeatures.pointFeatures, labelFeatures.lineFeatures, this.styleMap, this.ableWeight, true, this.tileSize, this.cellsize, this.tileSize * 0.5);
      this.features = GridFilterLabel_default.threeFilter(labelFeatures, this.tileSize, this.cellsize, this.tileSize * 0.5, this.styleMap);
      this.cartographics = this.toLabelBillboards(this.features);
    }
    updateElevationData(elevationDataMap) {
      this.elevationDataMap = elevationDataMap;
      let heights = this.getElevationHeights(this.features);
      this.updateLabelPostion(heights);
    }
    toLngLatAndCartographic(feature3) {
      let cartographics = [];
      feature3.lonLats = [];
      for (let j = 0; j < feature3.sourceAngleData.length; j++) {
        let sourceAngleData = feature3.sourceAngleData[j];
        let x3 = sourceAngleData[0][0];
        let y3 = sourceAngleData[0][1];
        let lon = Cesium.Math.toDegrees(this.rectangle.west + this.rectangle.width / this.tileSize * x3);
        let lat = Cesium.Math.toDegrees(this.rectangle.north - this.rectangle.height / this.tileSize * y3);
        feature3.lonLats.push([lon, lat]);
        let cartographic = new Cesium.Cartographic(Cesium.Math.toRadians(lon), Cesium.Math.toRadians(lat));
        cartographics.push(cartographic);
      }
      return cartographics;
    }
    getElevationHeights(features) {
      let heights = [];
      for (let i = 0; i < features.length; i++) {
        let feature3 = features[i];
        for (let j = 0; j < feature3.sourceAngleData.length; j++) {
          let sourceAngleData = feature3.sourceAngleData[j];
          let height = this.getHeight(Math.round(sourceAngleData[0][0]), Math.round(sourceAngleData[0][1]));
          heights.push({ height });
        }
      }
      return heights;
    }
    toCartesian3(pt) {
      let x3 = pt[0];
      let y3 = pt[1];
      let lon = Cesium.Math.toDegrees(this.rectangle.west + this.rectangle.width / this.tileSize * x3);
      let lat = Cesium.Math.toDegrees(this.rectangle.north - this.rectangle.height / this.tileSize * y3);
      let height = this.getHeight(Math.round(x3), Math.round(y3));
      let position = Cesium.Cartesian3.fromDegrees(lon, lat, height);
      return position;
    }
    getHeight(x3, y3) {
      x3 = x3 == this.tileSize ? this.tileSize - 1 : x3;
      y3 = y3 == this.tileSize ? this.tileSize - 1 : y3;
      for (let i = this.indexDbNames.length - 1; i >= 0; i--) {
        let indexDbName = this.indexDbNames[i];
        let terrainData = this.elevationDataMap[indexDbName];
        if (!terrainData) {
          continue;
        }
        let index = y3 * this.tileSize + x3;
        let h = terrainData.data[index];
        if (h != 0) {
          return h;
        }
      }
      return this.defaultHeight;
    }
    updateScreenPt(features) {
      for (let i = 0; i < features.length; i++) {
        let feature3 = features[i];
        feature3.datas = [];
        for (let j = 0; j < feature3.anglePositions.length; j++) {
          let anglePostion = feature3.anglePositions[j];
          if (!anglePostion[0]) {
            feature3.datas.push([[-50, -50], anglePostion[1]]);
            continue;
          }
          var pt = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.scene, anglePostion[0]);
          if (pt) {
            feature3.datas.push([[pt.x, pt.y], anglePostion[1]]);
          } else {
            feature3.datas.push([[-50, -50], anglePostion[1]]);
          }
        }
      }
    }
    toLabelBillboards(features) {
      let cs = [];
      for (let i = 0; i < features.length; i++) {
        let feature3 = features[i];
        if (feature3.type == 1) {
          this.toPointLabelOption(feature3);
        }
        if (feature3.type == 2) {
          this.toLineLabelOption(feature3);
        }
        let cartographics = this.toLngLatAndCartographic(feature3);
        cs = cs.concat(cartographics);
      }
      return cs;
    }
    updateLabelPostion(heights) {
      let index = 0;
      for (let i = 0; i < this.features.length; i++) {
        let feature3 = this.features[i];
        feature3.anglePositions = [];
        for (let k = 0; k < feature3.sourceAngleData.length; k++) {
          let anglePosition = [];
          let sourceAngleData = feature3.sourceAngleData[k];
          let height = heights[index].height;
          let lonLat = feature3.lonLats[k];
          let position = Cesium.Cartesian3.fromDegrees(lonLat[0], lonLat[1], height);
          anglePosition.push(position);
          anglePosition.push(sourceAngleData[1]);
          feature3.anglePositions.push(anglePosition);
          index++;
        }
        if (feature3.labelOptions) {
          for (let i2 = 0; i2 < feature3.labelOptions.length; i2++) {
            let labelOption = feature3.labelOptions[i2];
            labelOption.position = feature3.anglePositions[i2][0];
          }
        }
        if (feature3.billboardOption) {
          feature3.billboardOption.position = feature3.anglePositions[0][0];
        }
        if (feature3.labels) {
          for (let j = 0; j < feature3.labels.length; j++) {
            let label = feature3.labels[j];
            label.position = feature3.anglePositions[j][0];
          }
        }
        if (feature3.billboard) {
          feature3.billboard.position = feature3.anglePositions[0][0];
        }
      }
    }
    toPointLabelOption(feature3) {
      feature3.labelOptions = [];
      let style = this.styleMap[feature3.styleId];
      let iconWidth = feature3.iconImg ? feature3.iconImg.width : 0;
      let dis = style.graphicDistance + iconWidth * 0.5;
      let option = {
        show: false,
        disableDepthTestDistance: Number.POSITIVE_INFINITY,
        text: feature3.label + "",
        font: style.pointFillFont,
        style: Cesium.LabelStyle.FILL,
        verticalOrigin: Cesium.VerticalOrigin.CENTER,
        pixelOffset: new Cesium.Cartesian2(dis, 0),
        fillColor: Cesium.Color.fromCssColorString(style.pointFillStyle).withAlpha(style.pointFillAlpha)
      };
      if (style.pointHashBackground == true) {
        option.showBackground = true;
        option.backgroundColor = Cesium.Color.fromCssColorString(style.pointBackgroundColor).withAlpha(style.pointBackgroundAlpha);
        option.backgroundPadding = new Cesium.Cartesian2(style.pointBackgroundGap, style.pointBackgroundGap);
      }
      if (style.pointHashOutline == true) {
        option.style = Cesium.LabelStyle.FILL_AND_OUTLINE;
        option.outlineColor = Cesium.Color.fromCssColorString(style.pointStrokeStyle).withAlpha(style.pointStrokeAlpha), option.outlineWidth = style.pointLineWidth + 2;
      }
      feature3.labelOptions.push(option);
      if (feature3.iconImg) {
        let option2 = this.toBillboardOption(feature3.iconImg, style);
        feature3.billboardOption = option2;
      }
    }
    toLineLabelOption(feature3) {
      feature3.labelOptions = [];
      let style = this.styleMap[feature3.styleId];
      if (feature3.lineType == "text") {
        if (style.lineHashBackground == true) {
          let index = Math.floor(feature3.sourceAngleData.length / 2);
          let option = {
            show: false,
            disableDepthTestDistance: Number.POSITIVE_INFINITY,
            text: feature3.label + "",
            font: style.lineFillFont,
            style: Cesium.LabelStyle.FILL,
            verticalOrigin: Cesium.VerticalOrigin.CENTER,
            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
            fillColor: Cesium.Color.fromCssColorString(style.lineFillStyle).withAlpha(style.lineFillAlpha)
          };
          option.showBackground = true;
          option.backgroundColor = Cesium.Color.fromCssColorString(style.backgroundColor).withAlpha(style.backgroundAlpha), option.backgroundPadding = style.lineBackgroundGap;
          feature3.labelOptions.push(option);
        } else if (feature3.sourceAngleData.length == 1) {
          let option = {
            show: false,
            disableDepthTestDistance: Number.POSITIVE_INFINITY,
            text: feature3.label + "",
            font: style.lineFillFont,
            style: Cesium.LabelStyle.FILL,
            verticalOrigin: Cesium.VerticalOrigin.CENTER,
            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
            fillColor: Cesium.Color.fromCssColorString(style.lineFillStyle).withAlpha(style.lineFillAlpha)
          };
          feature3.labelOptions.push(option);
        } else {
          for (let i = 0; i < feature3.sourceAngleData.length; i++) {
            let sourceAnglePosition = feature3.sourceAngleData[i];
            let option = {
              show: false,
              disableDepthTestDistance: Number.POSITIVE_INFINITY,
              text: (feature3.label + "").charAt(i),
              font: style.lineFillFont,
              style: Cesium.LabelStyle.FILL,
              verticalOrigin: Cesium.VerticalOrigin.CENTER,
              horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
              rotation: Cesium.Math.toRadians(sourceAnglePosition[1]),
              fillColor: Cesium.Color.fromCssColorString(style.lineFillStyle).withAlpha(style.lineFillAlpha)
            };
            if (style.lineHashOutline == true) {
              option.style = Cesium.LabelStyle.FILL_AND_OUTLINE;
              let lineStrokeStyle = style.lineStrokeStyle ? style.lineStrokeStyle : "#ff0000";
              option.outlineColor = Cesium.Color.fromCssColorString(lineStrokeStyle).withAlpha(style.lineStrokeAlpha), option.outlineWidth = style.lineLineWidth;
            }
            feature3.labelOptions.push(option);
          }
        }
      }
      if (feature3.lineType == "code") {
        let style2 = this.styleMap[feature3.styleId];
        let option = {
          show: false,
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
          text: feature3.label + "",
          font: style2.codeLineFillFont,
          style: Cesium.LabelStyle.FILL,
          verticalOrigin: Cesium.VerticalOrigin.CENTER,
          horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
          fillColor: Cesium.Color.fromCssColorString(style2.codeLineFillStyle).withAlpha(style2.codeLineFillAlpha)
        };
        option.showBackground = true;
        option.backgroundColor = Cesium.Color.fromCssColorString(style2.codeBackgroundColor).withAlpha(style2.codeBackgroundAlpha);
        option.backgroundPadding = new Cesium.Cartesian2(style2.codeLineBackgroundGap, style2.codeLineBackgroundGap);
        if (style2.codeLineHashOutline == true) {
          option.style = Cesium.LabelStyle.FILL_AND_OUTLINE;
          option.outlineColor = Cesium.Color.fromCssColorString(style2.codeLineStrokeStyle).withAlpha(style2.codeLineStrokeAlpha);
          option.outlineWidth = style2.codeLineLineWidth + 2;
        }
        feature3.labelOptions.push(option);
      }
    }
    toBillboardOption(image, style) {
      let width = style.graphicWidth;
      let height = style.graphicHeight;
      if (!width || !height) {
        width = image.width;
        height = image.height;
      }
      let billboardOption = {
        show: false,
        disableDepthTestDistance: Number.POSITIVE_INFINITY,
        image,
        width,
        height
      };
      return billboardOption;
    }
    addToMap() {
      if (this.state == BEGIN4) {
        this.toDrawLabel();
      }
      if (this.labelCollection._labels.length > 0) {
        this.scene.primitives.add(this.labelCollection);
      }
      if (this.roadLabelCollection._labels.length > 0) {
        this.scene.primitives.add(this.roadLabelCollection);
      }
      if (this.billboardCollection._billboards.length > 0) {
        this.scene.primitives.add(this.billboardCollection);
      }
      this.updateNow();
      this.state = ADDED4;
    }
    toDrawLabel() {
      for (let i = 0; i < this.features.length; i++) {
        let feature3 = this.features[i];
        feature3.labels = [];
        if (feature3.type == 1) {
          for (let j = 0; j < feature3.labelOptions.length; j++) {
            feature3.labels.push(this.labelCollection.add(feature3.labelOptions[j]));
          }
          if (feature3.iconImg) {
            feature3.billboard = this.billboardCollection.add(feature3.billboardOption);
          }
        }
        if (feature3.type == 2) {
          if (feature3.lineType == "text") {
            for (let k = 0; k < feature3.labelOptions.length; k++) {
              feature3.labels.push(this.roadLabelCollection.add(feature3.labelOptions[k]));
            }
          }
          if (feature3.lineType == "code") {
            for (let m = 0; m < feature3.labelOptions.length; m++) {
              feature3.labels.push(this.labelCollection.add(feature3.labelOptions[m]));
            }
          }
        }
      }
    }
    updateNow() {
      if (this.labelCollection._labels.length > 0) {
        this.labelCollection.update(this.scene._frameState);
      }
      if (this.roadLabelCollection._labels.length > 0) {
        this.roadLabelCollection.update(this.scene._frameState);
      }
      if (this.billboardCollection._billboards.length > 0) {
        this.billboardCollection.update(this.scene._frameState);
      }
    }
    remove() {
      if (this.state == ADDED4) {
        this.scene.primitives.remove(this.labelCollection);
        this.scene.primitives.remove(this.roadLabelCollection);
        this.scene.primitives.remove(this.billboardCollection);
        this.state = REMOVED4;
      }
    }
    show() {
      if (this.state == BEGIN4 || this.state == REMOVED4) {
        this.addToMap();
      }
    }
    destroy() {
      this.remove();
      this.labelCollection.destroy();
      this.roadLabelCollection.destroy();
      this.billboardCollection.destroy();
      this.isDestroy = true;
    }
  };
  var LabelTile_default = LabelTile;

  // Source/custom/layer/label/glyph/is_char_in_unicode_block.js
  var unicodeBlockLookup = {
    "Latin-1 Supplement": (char) => char >= 128 && char <= 255,
    "Arabic": (char) => char >= 1536 && char <= 1791,
    "Arabic Supplement": (char) => char >= 1872 && char <= 1919,
    "Arabic Extended-A": (char) => char >= 2208 && char <= 2303,
    "Hangul Jamo": (char) => char >= 4352 && char <= 4607,
    "Unified Canadian Aboriginal Syllabics": (char) => char >= 5120 && char <= 5759,
    "Unified Canadian Aboriginal Syllabics Extended": (char) => char >= 6320 && char <= 6399,
    "General Punctuation": (char) => char >= 8192 && char <= 8303,
    "Letterlike Symbols": (char) => char >= 8448 && char <= 8527,
    "Number Forms": (char) => char >= 8528 && char <= 8591,
    "Miscellaneous Technical": (char) => char >= 8960 && char <= 9215,
    "Control Pictures": (char) => char >= 9216 && char <= 9279,
    "Optical Character Recognition": (char) => char >= 9280 && char <= 9311,
    "Enclosed Alphanumerics": (char) => char >= 9312 && char <= 9471,
    "Geometric Shapes": (char) => char >= 9632 && char <= 9727,
    "Miscellaneous Symbols": (char) => char >= 9728 && char <= 9983,
    "Miscellaneous Symbols and Arrows": (char) => char >= 11008 && char <= 11263,
    "CJK Radicals Supplement": (char) => char >= 11904 && char <= 12031,
    "Kangxi Radicals": (char) => char >= 12032 && char <= 12255,
    "Ideographic Description Characters": (char) => char >= 12272 && char <= 12287,
    "CJK Symbols and Punctuation": (char) => char >= 12288 && char <= 12351,
    "Hiragana": (char) => char >= 12352 && char <= 12447,
    "Katakana": (char) => char >= 12448 && char <= 12543,
    "Bopomofo": (char) => char >= 12544 && char <= 12591,
    "Hangul Compatibility Jamo": (char) => char >= 12592 && char <= 12687,
    "Kanbun": (char) => char >= 12688 && char <= 12703,
    "Bopomofo Extended": (char) => char >= 12704 && char <= 12735,
    "CJK Strokes": (char) => char >= 12736 && char <= 12783,
    "Katakana Phonetic Extensions": (char) => char >= 12784 && char <= 12799,
    "Enclosed CJK Letters and Months": (char) => char >= 12800 && char <= 13055,
    "CJK Compatibility": (char) => char >= 13056 && char <= 13311,
    "CJK Unified Ideographs Extension A": (char) => char >= 13312 && char <= 19903,
    "Yijing Hexagram Symbols": (char) => char >= 19904 && char <= 19967,
    "CJK Unified Ideographs": (char) => char >= 19968 && char <= 40959,
    "Yi Syllables": (char) => char >= 40960 && char <= 42127,
    "Yi Radicals": (char) => char >= 42128 && char <= 42191,
    "Hangul Jamo Extended-A": (char) => char >= 43360 && char <= 43391,
    "Hangul Syllables": (char) => char >= 44032 && char <= 55215,
    "Hangul Jamo Extended-B": (char) => char >= 55216 && char <= 55295,
    "Private Use Area": (char) => char >= 57344 && char <= 63743,
    "CJK Compatibility Ideographs": (char) => char >= 63744 && char <= 64255,
    "Arabic Presentation Forms-A": (char) => char >= 64336 && char <= 65023,
    "Vertical Forms": (char) => char >= 65040 && char <= 65055,
    "CJK Compatibility Forms": (char) => char >= 65072 && char <= 65103,
    "Small Form Variants": (char) => char >= 65104 && char <= 65135,
    "Arabic Presentation Forms-B": (char) => char >= 65136 && char <= 65279,
    "Halfwidth and Fullwidth Forms": (char) => char >= 65280 && char <= 65519
  };
  var is_char_in_unicode_block_default = unicodeBlockLookup;

  // Source/custom/layer/label/glyph/script_detection.js
  var allowsIdeographicBreaking = function(chars) {
    for (const char of chars) {
      if (!exports.charAllowsIdeographicBreaking(char.charCodeAt(0)))
        return false;
    }
    return true;
  };
  var allowsVerticalWritingMode = function(chars) {
    for (const char of chars) {
      if (exports.charHasUprightVerticalOrientation(char.charCodeAt(0)))
        return true;
    }
    return false;
  };
  var allowsLetterSpacing = function(chars) {
    for (const char of chars) {
      if (!exports.charAllowsLetterSpacing(char.charCodeAt(0)))
        return false;
    }
    return true;
  };
  var charAllowsLetterSpacing = function(char) {
    if (is_char_in_unicode_block_default["Arabic"](char))
      return false;
    if (is_char_in_unicode_block_default["Arabic Supplement"](char))
      return false;
    if (is_char_in_unicode_block_default["Arabic Extended-A"](char))
      return false;
    if (is_char_in_unicode_block_default["Arabic Presentation Forms-A"](char))
      return false;
    if (is_char_in_unicode_block_default["Arabic Presentation Forms-B"](char))
      return false;
    return true;
  };
  var charAllowsIdeographicBreaking = function(char) {
    if (char < 11904)
      return false;
    if (is_char_in_unicode_block_default["Bopomofo Extended"](char))
      return true;
    if (is_char_in_unicode_block_default["Bopomofo"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Compatibility Forms"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Compatibility Ideographs"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Compatibility"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Radicals Supplement"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Strokes"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Symbols and Punctuation"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Unified Ideographs Extension A"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Unified Ideographs"](char))
      return true;
    if (is_char_in_unicode_block_default["Enclosed CJK Letters and Months"](char))
      return true;
    if (is_char_in_unicode_block_default["Halfwidth and Fullwidth Forms"](char))
      return true;
    if (is_char_in_unicode_block_default["Hiragana"](char))
      return true;
    if (is_char_in_unicode_block_default["Ideographic Description Characters"](char))
      return true;
    if (is_char_in_unicode_block_default["Kangxi Radicals"](char))
      return true;
    if (is_char_in_unicode_block_default["Katakana Phonetic Extensions"](char))
      return true;
    if (is_char_in_unicode_block_default["Katakana"](char))
      return true;
    if (is_char_in_unicode_block_default["Vertical Forms"](char))
      return true;
    if (is_char_in_unicode_block_default["Yi Radicals"](char))
      return true;
    if (is_char_in_unicode_block_default["Yi Syllables"](char))
      return true;
    return false;
  };
  var charHasUprightVerticalOrientation = function(char) {
    if (char === 746 || char === 747) {
      return true;
    }
    if (char < 4352)
      return false;
    if (is_char_in_unicode_block_default["Bopomofo Extended"](char))
      return true;
    if (is_char_in_unicode_block_default["Bopomofo"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Compatibility Forms"](char)) {
      if (!(char >= 65097 && char <= 65103)) {
        return true;
      }
    }
    if (is_char_in_unicode_block_default["CJK Compatibility Ideographs"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Compatibility"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Radicals Supplement"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Strokes"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Symbols and Punctuation"](char)) {
      if (!(char >= 12296 && char <= 12305) && !(char >= 12308 && char <= 12319) && char !== 12336) {
        return true;
      }
    }
    if (is_char_in_unicode_block_default["CJK Unified Ideographs Extension A"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Unified Ideographs"](char))
      return true;
    if (is_char_in_unicode_block_default["Enclosed CJK Letters and Months"](char))
      return true;
    if (is_char_in_unicode_block_default["Hangul Compatibility Jamo"](char))
      return true;
    if (is_char_in_unicode_block_default["Hangul Jamo Extended-A"](char))
      return true;
    if (is_char_in_unicode_block_default["Hangul Jamo Extended-B"](char))
      return true;
    if (is_char_in_unicode_block_default["Hangul Jamo"](char))
      return true;
    if (is_char_in_unicode_block_default["Hangul Syllables"](char))
      return true;
    if (is_char_in_unicode_block_default["Hiragana"](char))
      return true;
    if (is_char_in_unicode_block_default["Ideographic Description Characters"](char))
      return true;
    if (is_char_in_unicode_block_default["Kanbun"](char))
      return true;
    if (is_char_in_unicode_block_default["Kangxi Radicals"](char))
      return true;
    if (is_char_in_unicode_block_default["Katakana Phonetic Extensions"](char))
      return true;
    if (is_char_in_unicode_block_default["Katakana"](char)) {
      if (char !== 12540) {
        return true;
      }
    }
    if (is_char_in_unicode_block_default["Halfwidth and Fullwidth Forms"](char)) {
      if (char !== 65288 && char !== 65289 && char !== 65293 && !(char >= 65306 && char <= 65310) && char !== 65339 && char !== 65341 && char !== 65343 && !(char >= 65371 && char <= 65503) && char !== 65507 && !(char >= 65512 && char <= 65519)) {
        return true;
      }
    }
    if (is_char_in_unicode_block_default["Small Form Variants"](char)) {
      if (!(char >= 65112 && char <= 65118) && !(char >= 65123 && char <= 65126)) {
        return true;
      }
    }
    if (is_char_in_unicode_block_default["Unified Canadian Aboriginal Syllabics"](char))
      return true;
    if (is_char_in_unicode_block_default["Unified Canadian Aboriginal Syllabics Extended"](char))
      return true;
    if (is_char_in_unicode_block_default["Vertical Forms"](char))
      return true;
    if (is_char_in_unicode_block_default["Yijing Hexagram Symbols"](char))
      return true;
    if (is_char_in_unicode_block_default["Yi Syllables"](char))
      return true;
    if (is_char_in_unicode_block_default["Yi Radicals"](char))
      return true;
    return false;
  };
  var charHasNeutralVerticalOrientation = function(char) {
    if (is_char_in_unicode_block_default["Latin-1 Supplement"](char)) {
      if (char === 167 || char === 169 || char === 174 || char === 177 || char === 188 || char === 189 || char === 190 || char === 215 || char === 247) {
        return true;
      }
    }
    if (is_char_in_unicode_block_default["General Punctuation"](char)) {
      if (char === 8214 || char === 8224 || char === 8225 || char === 8240 || char === 8241 || char === 8251 || char === 8252 || char === 8258 || char === 8263 || char === 8264 || char === 8265 || char === 8273) {
        return true;
      }
    }
    if (is_char_in_unicode_block_default["Letterlike Symbols"](char))
      return true;
    if (is_char_in_unicode_block_default["Number Forms"](char))
      return true;
    if (is_char_in_unicode_block_default["Miscellaneous Technical"](char)) {
      if (char >= 8960 && char <= 8967 || char >= 8972 && char <= 8991 || char >= 8996 && char <= 9e3 || char === 9003 || char >= 9085 && char <= 9114 || char >= 9150 && char <= 9165 || char === 9167 || char >= 9169 && char <= 9179 || char >= 9186 && char <= 9215) {
        return true;
      }
    }
    if (is_char_in_unicode_block_default["Control Pictures"](char) && char !== 9251)
      return true;
    if (is_char_in_unicode_block_default["Optical Character Recognition"](char))
      return true;
    if (is_char_in_unicode_block_default["Enclosed Alphanumerics"](char))
      return true;
    if (is_char_in_unicode_block_default["Geometric Shapes"](char))
      return true;
    if (is_char_in_unicode_block_default["Miscellaneous Symbols"](char)) {
      if (!(char >= 9754 && char <= 9759)) {
        return true;
      }
    }
    if (is_char_in_unicode_block_default["Miscellaneous Symbols and Arrows"](char)) {
      if (char >= 11026 && char <= 11055 || char >= 11088 && char <= 11097 || char >= 11192 && char <= 11243) {
        return true;
      }
    }
    if (is_char_in_unicode_block_default["CJK Symbols and Punctuation"](char))
      return true;
    if (is_char_in_unicode_block_default["Katakana"](char))
      return true;
    if (is_char_in_unicode_block_default["Private Use Area"](char))
      return true;
    if (is_char_in_unicode_block_default["CJK Compatibility Forms"](char))
      return true;
    if (is_char_in_unicode_block_default["Small Form Variants"](char))
      return true;
    if (is_char_in_unicode_block_default["Halfwidth and Fullwidth Forms"](char))
      return true;
    if (char === 8734 || char === 8756 || char === 8757 || char >= 9984 && char <= 10087 || char >= 10102 && char <= 10131 || char === 65532 || char === 65533) {
      return true;
    }
    return false;
  };
  var charHasRotatedVerticalOrientation = function(char) {
    return !(exports.charHasUprightVerticalOrientation(char) || exports.charHasNeutralVerticalOrientation(char));
  };
  var script_detection_default = {
    allowsIdeographicBreaking,
    allowsVerticalWritingMode,
    allowsLetterSpacing,
    charAllowsLetterSpacing,
    charAllowsIdeographicBreaking,
    charHasUprightVerticalOrientation,
    charHasNeutralVerticalOrientation,
    charHasRotatedVerticalOrientation
  };

  // Source/custom/layer/label/glyph/verticalize_punctuation.js
  function verticalizePunctuation(input) {
    let output = "";
    for (let i = 0; i < input.length; i++) {
      const nextCharCode = input.charCodeAt(i + 1) || null;
      const prevCharCode = input.charCodeAt(i - 1) || null;
      const canReplacePunctuation = (!nextCharCode || !script_detection_default.charHasRotatedVerticalOrientation(nextCharCode) || lookup[input[i + 1]]) && (!prevCharCode || !script_detection_default.charHasRotatedVerticalOrientation(prevCharCode) || lookup[input[i - 1]]);
      if (canReplacePunctuation && lookup[input[i]]) {
        output += lookup[input[i]];
      } else {
        output += input[i];
      }
    }
    return output;
  }
  var lookup = {
    "!": "\uFE15",
    "#": "\uFF03",
    "$": "\uFF04",
    "%": "\uFF05",
    "&": "\uFF06",
    "(": "\uFE35",
    ")": "\uFE36",
    "*": "\uFF0A",
    "+": "\uFF0B",
    ",": "\uFE10",
    "-": "\uFE32",
    ".": "\u30FB",
    "/": "\uFF0F",
    ":": "\uFE13",
    ";": "\uFE14",
    "<": "\uFE3F",
    "=": "\uFF1D",
    ">": "\uFE40",
    "?": "\uFE16",
    "@": "\uFF20",
    "[": "\uFE47",
    "\\": "\uFF3C",
    "]": "\uFE48",
    "^": "\uFF3E",
    "_": "\uFE33",
    "`": "\uFF40",
    "{": "\uFE37",
    "|": "\u2015",
    "}": "\uFE38",
    "~": "\uFF5E",
    "\xA2": "\uFFE0",
    "\xA3": "\uFFE1",
    "\xA5": "\uFFE5",
    "\xA6": "\uFFE4",
    "\xAC": "\uFFE2",
    "\xAF": "\uFFE3",
    "\u2013": "\uFE32",
    "\u2014": "\uFE31",
    "\u2018": "\uFE43",
    "\u2019": "\uFE44",
    "\u201C": "\uFE41",
    "\u201D": "\uFE42",
    "\u2026": "\uFE19",
    "\u2027": "\u30FB",
    "\u20A9": "\uFFE6",
    "\u3001": "\uFE11",
    "\u3002": "\uFE12",
    "\u3008": "\uFE3F",
    "\u3009": "\uFE40",
    "\u300A": "\uFE3D",
    "\u300B": "\uFE3E",
    "\u300C": "\uFE41",
    "\u300D": "\uFE42",
    "\u300E": "\uFE43",
    "\u300F": "\uFE44",
    "\u3010": "\uFE3B",
    "\u3011": "\uFE3C",
    "\u3014": "\uFE39",
    "\u3015": "\uFE3A",
    "\u3016": "\uFE17",
    "\u3017": "\uFE18",
    "\uFF01": "\uFE15",
    "\uFF08": "\uFE35",
    "\uFF09": "\uFE36",
    "\uFF0C": "\uFE10",
    "\uFF0D": "\uFE32",
    "\uFF0E": "\u30FB",
    "\uFF1A": "\uFE13",
    "\uFF1B": "\uFE14",
    "\uFF1C": "\uFE3F",
    "\uFF1E": "\uFE40",
    "\uFF1F": "\uFE16",
    "\uFF3B": "\uFE47",
    "\uFF3D": "\uFE48",
    "\uFF3F": "\uFE33",
    "\uFF5B": "\uFE37",
    "\uFF5C": "\u2015",
    "\uFF5D": "\uFE38",
    "\uFF5F": "\uFE35",
    "\uFF60": "\uFE36",
    "\uFF61": "\uFE12",
    "\uFF62": "\uFE41",
    "\uFF63": "\uFE42"
  };
  var verticalize_punctuation_default = { verticalizePunctuation, lookup };

  // Source/custom/layer/label/glyph/glyphs.js
  function toRGBA(glyph) {
    glyph.height = glyph.height + 6;
    glyph.width = glyph.width + 6;
    let dist = new Uint8Array(glyph.bitmap.length * 4);
    for (let i = 0; i < glyph.bitmap.length; i++) {
      let a2 = glyph.bitmap[i];
      if (a2 != 0) {
        dist[i * 4 + 0] = a2;
        dist[i * 4 + 1] = a2;
        dist[i * 4 + 2] = a2;
        dist[i * 4 + 3] = a2;
      }
    }
    glyph.arrayBufferView = dist;
  }
  function Glyphs(pbf, end) {
    this.stacks = pbf.readFields(readFontstacks, [], end);
    for (var i = 0; i < this.stacks.length; i++) {
      var glyphs = this.stacks[i].glyphs;
      for (var key2 in glyphs) {
        var glyph = glyphs[key2];
        toRGBA(glyph);
      }
    }
  }
  function readFontstacks(tag, stacks, pbf) {
    if (tag === 1) {
      const fontstack = pbf.readMessage(readFontstack, { glyphs: {} });
      stacks.push(fontstack);
    }
  }
  function readFontstack(tag, fontstack, pbf) {
    if (tag === 1)
      fontstack.name = pbf.readString();
    else if (tag === 2)
      fontstack.range = pbf.readString();
    else if (tag === 3) {
      const glyph = pbf.readMessage(readGlyph, {});
      fontstack.glyphs[glyph.id] = glyph;
    }
  }
  function readGlyph(tag, glyph, pbf) {
    if (tag === 1)
      glyph.id = pbf.readVarint();
    else if (tag === 2)
      glyph.bitmap = pbf.readBytes();
    else if (tag === 3)
      glyph.width = pbf.readVarint();
    else if (tag === 4)
      glyph.height = pbf.readVarint();
    else if (tag === 5)
      glyph.left = pbf.readSVarint();
    else if (tag === 6)
      glyph.top = pbf.readSVarint();
    else if (tag === 7)
      glyph.advance = pbf.readVarint();
  }
  var glyphs_default = Glyphs;

  // Source/custom/layer/label/glyph/GlyphSource.js
  var import_pbf = __toESM(require_pbf(), 1);
  var Resource7 = Cesium.Resource;
  var GlyphSource = class {
    constructor(url) {
      this.url = url;
      this.stacks = {};
      this.loading = {};
    }
    getSimpleGlyphs(fontstack, glyphIDs, callback) {
      if (this.stacks[fontstack] === void 0) {
        this.stacks[fontstack] = {};
      }
      const glyphs = {};
      const stack = this.stacks[fontstack];
      const buffer4 = 3;
      const missing = {};
      let remaining = 0;
      const getGlyph = (glyphID) => {
        const range = Math.floor(glyphID / 256);
        if (stack[range]) {
          const glyph = stack[range].glyphs[glyphID];
          if (glyph)
            glyphs[glyphID] = glyph;
        } else {
          if (missing[range] === void 0) {
            missing[range] = [];
            remaining++;
          }
          missing[range].push(glyphID);
        }
      };
      for (let i = 0; i < glyphIDs.length; i++) {
        const glyphID = glyphIDs[i];
        const string = String.fromCharCode(glyphID);
        getGlyph(glyphID);
        if (verticalize_punctuation_default.lookup[string]) {
          getGlyph(verticalize_punctuation_default.lookup[string].charCodeAt(0));
        }
      }
      if (!remaining)
        callback(void 0, glyphs, fontstack);
      const onRangeLoaded = (err, range, data) => {
        if (!err) {
          const stack2 = this.stacks[fontstack][range] = data.stacks[0];
          for (let i = 0; i < missing[range].length; i++) {
            const glyphID = missing[range][i];
            const glyph = stack2.glyphs[glyphID];
            if (glyph) {
              glyphs[glyphID] = glyph;
            }
          }
        }
        remaining--;
        if (!remaining)
          callback(void 0, glyphs, fontstack);
      };
      for (const r in missing) {
        this.loadRange(fontstack, r, onRangeLoaded);
      }
    }
    loadRange(fontstack, range, callback) {
      if (range * 256 > 65535)
        return callback("glyphs > 65535 not supported");
      if (this.loading[fontstack] === void 0) {
        this.loading[fontstack] = {};
      }
      const loading = this.loading[fontstack];
      if (loading[range]) {
        loading[range].push(callback);
      } else {
        loading[range] = [callback];
        const rangeName = `${range * 256}-${range * 256 + 255}`;
        const url = glyphUrl(fontstack, rangeName, this.url);
        let resource = new Resource7({ url });
        resource.fetchArrayBuffer().then(function(data) {
          const glyphs = new glyphs_default(new import_pbf.default(data));
          for (let i = 0; i < loading[range].length; i++) {
            loading[range][i](null, range, glyphs);
          }
          delete loading[range];
        }.bind(this));
      }
    }
  };
  function glyphUrl(fontstack, range, url) {
    fontstack = encodeURIComponent(fontstack);
    return url.replace("{fontstack}", fontstack).replace("{range}", range);
  }
  var GlyphSource_default = GlyphSource;

  // Source/custom/layer/label/LabelTileServiceImageryProvider.js
  var combine7 = Cesium.combine;
  var Credit7 = Cesium.Credit;
  var defaultValue11 = Cesium.defaultValue;
  var defined14 = Cesium.defined;
  var DeveloperError9 = Cesium.DeveloperError;
  var Event8 = Cesium.Event;
  var freezeObject4 = Cesium.freezeObject;
  var isArray6 = Array.isArray;
  var Rectangle6 = Cesium.Rectangle;
  var Resource8 = Cesium.Resource;
  var WebMercatorTilingScheme7 = Cesium.WebMercatorTilingScheme;
  var TimeDynamicImagery6 = Cesium.TimeDynamicImagery;
  var defer10 = Cesium.defer;
  var defaultParameters6 = {
    service: "WMTS",
    version: "1.0.0",
    request: "GetTile"
  };
  var LabelTileServiceImageryProvider = class extends ElevationImageryProvider_default {
    constructor(viewer3, options) {
      super(viewer3, options);
      this.indexDbName = "house_" + this.indexDbName;
      options = defaultValue11(options, defaultValue11.EMPTY_OBJECT);
      this.id = Math.random();
      this.scene = viewer3.scene;
      this.needDecode = defaultValue11(options.needDecode, false);
      this.defaultHeight = defaultValue11(options.defaultHeight, 0);
      if (!defined14(options.url)) {
        throw new DeveloperError9("options.url is required.");
      }
      let resource = Resource8.createIfNeeded(options.url);
      let style = options.style;
      let tileMatrixSetID = options.tileMatrixSetID;
      let url = resource.url;
      if (url.indexOf("{") >= 0) {
        let templateValues = {
          style,
          Style: style,
          TileMatrixSet: tileMatrixSetID
        };
        resource.setTemplateValues(templateValues);
        this._useKvp = false;
      } else {
        resource.setQueryParameters(defaultParameters6);
        this._useKvp = true;
      }
      this._resource = resource;
      this._layer = options.layer;
      this._style = style;
      this._tileMatrixSetID = tileMatrixSetID;
      this._tileMatrixLabels = options.tileMatrixLabels;
      this._format = defaultValue11(options.format, "image/jpeg");
      this._tileDiscardPolicy = options.tileDiscardPolicy;
      this._tilingScheme = defined14(options.tilingScheme) ? options.tilingScheme : new WebMercatorTilingScheme7({ ellipsoid: options.ellipsoid });
      this._tileWidth = defaultValue11(options.tileWidth, 256);
      this._tileHeight = defaultValue11(options.tileHeight, 256);
      this._minimumLevel = defaultValue11(options.minimumLevel, 0);
      this._maximumLevel = options.maximumLevel;
      this._rectangle = defaultValue11(options.rectangle, this._tilingScheme.rectangle);
      this._dimensions = options.dimensions;
      let that = this;
      this._reload = void 0;
      if (defined14(options.times)) {
        this._timeDynamicImagery = new TimeDynamicImagery6({
          clock: options.clock,
          times: options.times,
          requestImageFunction: function(x3, y3, level, request, interval) {
            return requestImage(that, x3, y3, level, request, interval);
          },
          reloadFunction: function() {
            if (defined14(that._reload)) {
              that._reload();
            }
          }
        });
      }
      this._readyPromise = defer10();
      let swTile = this._tilingScheme.positionToTileXY(Rectangle6.southwest(this._rectangle), this._minimumLevel);
      let neTile = this._tilingScheme.positionToTileXY(Rectangle6.northeast(this._rectangle), this._minimumLevel);
      let tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);
      if (tileCount > 4) {
        throw new DeveloperError9("The imagery provider's rectangle and minimumLevel indicate that there are " + tileCount + " tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.");
      }
      this._errorEvent = new Event8();
      let credit = options.credit;
      this._credit = typeof credit === "string" ? new Credit7(credit) : credit;
      this._subdomains = options.subdomains;
      if (isArray6(this._subdomains)) {
        this._subdomains = this._subdomains.slice();
      } else if (defined14(this._subdomains) && this._subdomains.length > 0) {
        this._subdomains = this._subdomains.split("");
      } else {
        this._subdomains = ["a", "b", "c"];
      }
      this.dataType = "binary";
      if (options.hasOwnProperty("dataType")) {
        this.dataType = options["dataType"];
      } else {
        this.dataType = "Json";
      }
      this.needDecode = options.needDecode;
      this.parseUrl(options.url);
      let promises = this.loadStyle();
      if (this.dataType == "binary") {
        let styleUrl = this.host + "/mapserver/serverInfo/" + this.servername + ".json?" + Math.random();
        let resource2 = Resource8.createIfNeeded(styleUrl);
        let promise2 = resource2.fetchJson();
        promises.push(promise2);
      }
      this.hasTerrain = false;
      if (viewer3.terrainProvider.name == "RGBWorldTerrainProvider") {
        this.hasTerrain = true;
      }
      this.dbMap = {};
      this.indexDbNames = this.getBottomProviderIndexDbNames();
      let promise3 = ElevationTool_default.getDBMap(this.indexDbNames, this.dbMap);
      promises.push(promise3);
      Promise.all(promises).then(function(data) {
        let results = data[2];
        if (results && results.layerMap) {
          this.serverInfo = {};
          this.layerFieldMap = {};
          for (let key2 in results.layerMap) {
            this.serverInfo[key2] = {
              geometryType: results.layerMap[key2].geometryType,
              fieldsConfig: results.layerMap[key2].fields
            };
            if (!this.layerFieldMap[key2]) {
              this.layerFieldMap[key2] = results.layerMap[key2].fields.length;
            }
          }
        }
        ;
        this.ready = {
          value: true
        };
        this._readyPromise.resolve(true);
      }.bind(this));
      this.cache = {};
      this.textures = {};
      this.styleMap = {};
      if (options.glyphUrl && options.fontName) {
        this.fontName = options.fontName;
        if (!this.viewer.glyphSource) {
          this.viewer.glyphSource = new GlyphSource_default(options.glyphUrl);
        }
      }
      this.prevPosition = null;
      this.prevRenderTilesLength = -1;
      this.image = document.createElement("canvas");
    }
    updateStle(url) {
      let resource = Resource8.createIfNeeded(url);
      let style = this._style;
      let tileMatrixSetID = this.tileMatrixSetID;
      url = resource.url;
      if (url.indexOf("{") >= 0) {
        let templateValues = {
          style,
          Style: style,
          TileMatrixSet: tileMatrixSetID
        };
        resource.setTemplateValues(templateValues);
        this._useKvp = false;
      } else {
        resource.setQueryParameters(defaultParameters6);
        this._useKvp = true;
      }
      this._resource = resource;
      this.parseUrl(url);
      Promise.all(this.loadStyle()).then(function() {
        for (let key2 in this.cache) {
          let labelTile = this.cache[key2];
          labelTile.reset();
        }
      }.bind(this));
      this.textures = {};
      this.styleMap = {};
    }
    draw(tilesToRender) {
      let renderTileMap = this.getRenderTileMap(tilesToRender);
      for (let key2 in this.cache) {
        if (!renderTileMap[key2]) {
          let tile = this.cache[key2];
          tile.remove();
        }
      }
      let renderTiles = [];
      for (let name2 in renderTileMap) {
        let labelTile = this.cache[name2];
        if (labelTile && labelTile.ready) {
          renderTiles.push(labelTile);
          labelTile.show(this.styleFun);
        }
      }
      this.avoid(renderTiles);
    }
    avoid(renderTiles) {
      let position = this.scene.camera.position;
      let dis = 200;
      if (this.prevPosition) {
        dis = Cesium.Cartesian3.distance(position, this.prevPosition);
      }
      let heading = Cesium.Math.toDegrees(this.viewer.camera.heading).toFixed(2);
      if (heading > 180) {
        heading = heading - 360;
      }
      if (dis > 15) {
        AvoidTile_default.init(renderTiles, heading, this.styleMap, this.viewer);
        this.prevPosition = new Cesium.Cartesian3(position.x, position.y, position.z);
      } else {
        if (heading != this.prevHeading || this.prevRenderTilesLength != renderTiles.length && renderTiles.length > 0) {
          AvoidTile_default.setTiles(renderTiles, heading);
          this.prevRenderTilesLength = renderTiles.length;
        }
        this.prevHeading = heading;
      }
      if (!AvoidTile_default.isFinished()) {
        AvoidTile_default.avoidTile();
      }
    }
    getRenderTileMap(renderTiles) {
      let renderTileMap = {};
      for (let i = 0; i < renderTiles.length; i++) {
        let tileImagerys = renderTiles[i].data.imagery;
        for (let j = 0; j < tileImagerys.length; j++) {
          let tileImagery = tileImagerys[j];
          let imagery = tileImagery.readyImagery;
          if (imagery && imagery.imageryLayer._imageryProvider.id == this.id) {
            let key2 = imagery.x + "_" + imagery.y + "_" + imagery.level;
            renderTileMap[key2] = true;
          }
        }
      }
      return renderTileMap;
    }
    parseUrl(url) {
      let urlParts = url.split("?");
      let urlPartOne = urlParts[0].split("/mapserver/");
      this.host = urlPartOne[0];
      if (this._subdomains.length > 0) {
        this.host = this.host.replace("{s}", this._subdomains[0]);
      }
      this.servername = urlPartOne[1].split("/")[1];
      this.queryParam = urlParts[1];
      let params2 = this.queryParam.split("&");
      for (let i = 0; i < params2.length; i++) {
        let param = params2[i];
        let keyValue = param.split("=");
        if (keyValue[0] == "styleId") {
          this.styleId = keyValue[1];
          return;
        }
      }
    }
    loadStyle() {
      let styleUrl = this.host + "/mapserver/styleInfo/" + this.servername + "/" + this.styleId + "/label/style.js?" + Math.random();
      let resource = Resource8.createIfNeeded(styleUrl);
      let promise1 = resource.fetchText().then(function(result) {
        if (this.dataType == "binary") {
          this.styleFun = new Function("render", "level", result);
        } else {
          this.styleFun = new Function("drawer", "level", result);
        }
      }.bind(this));
      let deferred = defer10();
      let imageUrl = this.host + "/mapserver/styleInfo/" + this.servername + "/" + this.styleId + "/label/texture.js?" + Math.random();
      let imageResource = Resource8.createIfNeeded(imageUrl);
      imageResource.fetchText().then(function(deferred2, result) {
        let textures = JSON.parse(result);
        let totalCount = 0;
        for (let i in textures) {
          totalCount++;
        }
        if (totalCount == 0) {
          deferred2.resolve();
          return;
        }
        let count = 0;
        for (let key2 in textures) {
          let img = new Image();
          img.name = key2;
          img.onload = function(data) {
            count++;
            let name2 = data.target.name;
            this.textures[name2] = data.target;
            if (count == totalCount) {
              deferred2.resolve();
            }
          }.bind(this);
          img.src = textures[key2];
        }
      }.bind(this, deferred));
      return [promise1, deferred.promise];
    }
    requestImageNow(imageryProvider, col, row, level, request, interval) {
      let labels = imageryProvider._tileMatrixLabels;
      let tileMatrix = defined14(labels) ? labels[level] : level.toString();
      let subdomains = imageryProvider._subdomains;
      let staticDimensions = imageryProvider._dimensions;
      let dynamicIntervalData = defined14(interval) ? interval.data : void 0;
      let resource;
      if (!imageryProvider._useKvp) {
        let templateValues = {
          z: tileMatrix,
          y: row.toString(),
          x: col.toString(),
          s: subdomains[(col + row + level) % subdomains.length]
        };
        resource = imageryProvider._resource.getDerivedResource({
          request
        });
        resource.setTemplateValues(templateValues);
        if (defined14(staticDimensions)) {
          resource.setTemplateValues(staticDimensions);
        }
        if (defined14(dynamicIntervalData)) {
          resource.setTemplateValues(dynamicIntervalData);
        }
      } else {
        let query = {};
        query.tilematrix = tileMatrix;
        query.layer = imageryProvider._layer;
        query.style = imageryProvider._style;
        query.tilerow = row;
        query.tilecol = col;
        query.tilematrixset = imageryProvider._tileMatrixSetID;
        query.format = imageryProvider._format;
        if (defined14(staticDimensions)) {
          query = combine7(query, staticDimensions);
        }
        if (defined14(dynamicIntervalData)) {
          query = combine7(query, dynamicIntervalData);
        }
        resource = imageryProvider._resource.getDerivedResource({
          queryParameters: query,
          request
        });
      }
      let deferred = defer10();
      let xyz = { x: col, y: row, z: level };
      let success = this.requestJsonData(deferred, imageryProvider, resource, xyz);
      if (!success) {
        return void 0;
      }
      return deferred.promise;
    }
    requestJsonData(deferred, imageryProvider, url, xyz) {
      let resource = Resource8.createIfNeeded(url);
      let promises = [];
      let jsonPromise = null;
      if (this.dataType == "binary") {
        jsonPromise = resource.fetchArrayBuffer();
      } else {
        jsonPromise = resource.fetchJson();
      }
      if (!jsonPromise) {
        return false;
      }
      promises.push(jsonPromise);
      let level = url._templateValues.z;
      let data, stacks, labelTile;
      let p1 = Promise.all(promises).then(function(result) {
        data = result[0];
        labelTile = this.jsonPromiseResult(xyz, level, data);
        stacks = this.getStacks(labelTile.features);
        const xyzStr = xyz.x + "_" + xyz.y + "_" + xyz.z;
        const promise1 = ElevationTool_default.getElevation(this.dbMap, this.indexDbNames, xyzStr);
        const promise2 = this.getGlyphs(stacks);
        return Promise.all([promise1, promise2]);
      }.bind(this));
      let p2 = p1.then(function(result) {
        let elevationDataMap = result[0];
        let glyphs = result[1];
        labelTile.labelCollection.setGlyphs(glyphs);
        labelTile.roadLabelCollection.setGlyphs(glyphs);
        labelTile.updateElevationData(elevationDataMap);
        labelTile.ready = true;
        deferred.resolve(this.image);
      }.bind(this));
      return true;
    }
    jsonPromiseResult(xyz, level, data) {
      if (this.dataType == "binary") {
        if (data) {
          data = this.toBuffer(data);
          data = this.parseBinaryData(data);
        }
      }
      if (!data) {
        data = {};
      }
      let labelData = data.label ? data.label : data;
      if (data != {}) {
        let x3 = xyz.x;
        let y3 = xyz.y;
        let z2 = xyz.z;
        let rectangle = this._tilingScheme.tileXYToRectangle(x3, y3, z2);
        let name2 = x3 + "_" + y3 + "_" + z2;
        let labelTile = this.cache[name2];
        if (!labelTile) {
          labelTile = new LabelTile_default(
            this.defaultHeight,
            name2,
            xyz,
            this.tileWidth,
            rectangle,
            labelData,
            this.indexDbNames,
            this.styleFun,
            this.dataType,
            level,
            this.styleMap,
            this.textures,
            this.scene
          );
          this.cache[labelTile.name] = labelTile;
        }
        return labelTile;
      }
    }
    toBuffer(ab) {
      let buf = new Buffer4(ab.byteLength);
      let view = new Uint8Array(ab);
      for (let i = 0; i < buf.length; ++i) {
        buf[i] = view[i];
      }
      return buf;
    }
    parseBinaryData(buf) {
      let vant = new VarintReader_default(buf, 4, this.layerFieldMap);
      let layerNameArr = vant.getAllLayerNames();
      let layers = {};
      for (let i = 0; i < layerNameArr.length; i++) {
        let layerName = layerNameArr[i];
        layers[layerName] = {
          features: [],
          fieldsConfig: this.serverInfo[layerName] ? this.serverInfo[layerName].fieldsConfig : {},
          type: 1
        };
        let geometryType = vant.getGeometryType(layerName);
        let props = vant.getLayerPro(layerName);
        if (geometryType.toLowerCase() == "point") {
          layers[layerName].type = 1;
        } else if (geometryType.toLowerCase() == "line" || geometryType.toLowerCase() == "linestring" || geometryType.toLowerCase() == "multilinestring") {
          layers[layerName].type = 2;
        }
        if (props && props.length > 0) {
          for (let k = 0; k < props.length; k++) {
            let tDataArr = [];
            tDataArr.push(geometryType);
            tDataArr.push(props[k]);
            tDataArr.push(vant.getCoordinatesByIndex(layerName, k, 10));
            layers[layerName].features.push(tDataArr);
          }
        }
      }
      return layers;
    }
    getStacks(features) {
      let stack = [];
      let statcks = {};
      statcks[this.fontName] = stack;
      let index = 0;
      for (let i = 0; i < features.length; i++) {
        let label = features[i].label;
        if (label) {
          for (let j = 0; j < label.length; j++) {
            stack[index] = label.charCodeAt(j);
            index++;
          }
        }
      }
      stack[index] = "?".charCodeAt(0);
      return statcks;
    }
    getGlyphs(stacks) {
      let deferred = defer10();
      let remaining = Object.keys(stacks).length;
      const allGlyphs = {};
      for (const fontName in stacks) {
        this.viewer.glyphSource.getSimpleGlyphs(fontName, stacks[fontName], done);
      }
      function done(err, glyphs, fontName) {
        if (err)
          console.error(err);
        allGlyphs[fontName] = glyphs;
        remaining--;
        if (remaining === 0) {
          deferred.resolve(allGlyphs);
        }
      }
      return deferred.promise;
    }
    updateTileElevation(xyz, tileSize) {
      let name2 = xyz.x + "_" + xyz.y + "_" + xyz.z;
      let tile = this.cache[name2];
      if (!tile) {
        return false;
      }
      let key2 = xyz.x + "_" + xyz.y + "_" + xyz.z;
      let promise = ElevationTool_default.getElevation(this.dbMap, this.indexDbNames, key2);
      promise.then(function(name3, elevationDataMap) {
        tile = this.cache[name3];
        if (tile) {
          tile.updateElevationData(elevationDataMap);
        }
      }.bind(this, name2));
      return true;
    }
    get url() {
      return this._resource.url;
    }
    get proxy() {
      return this._resource.proxy;
    }
    get tileWidth() {
      return this._tileWidth;
    }
    get tileHeight() {
      return this._tileHeight;
    }
    get maximumLevel() {
      return this._maximumLevel;
    }
    get minimumLevel() {
      return this._minimumLevel;
    }
    get tilingScheme() {
      return this._tilingScheme;
    }
    get rectangle() {
      return this._rectangle;
    }
    get tileDiscardPolicy() {
      return this._tileDiscardPolicy;
    }
    get errorEvent() {
      return this._errorEvent;
    }
    get format() {
      return this._format;
    }
    get readyPromise() {
      return this._readyPromise;
    }
    get credit() {
      return this._credit;
    }
    get hasAlphaChannel() {
      return true;
    }
    get clock() {
      return this._timeDynamicImagery.clock;
    }
    set clock(value) {
      this._timeDynamicImagery.clock = value;
    }
    get times() {
      return this._timeDynamicImagery.times;
    }
    set times(value) {
      this._timeDynamicImagery.times = value;
    }
    get dimensions() {
      return this._dimensions;
    }
    set dimensions(value) {
      if (this._dimensions !== value) {
        this._dimensions = value;
        if (defined14(this._reload)) {
          this._reload();
        }
      }
    }
    getTileCredits(x3, y3, level) {
      return void 0;
    }
    requestImage(x3, y3, level, request) {
      let result;
      let timeDynamicImagery = this._timeDynamicImagery;
      let currentInterval;
      if (defined14(timeDynamicImagery)) {
        currentInterval = timeDynamicImagery.currentInterval;
        result = timeDynamicImagery.getFromCache(x3, y3, level, request);
      }
      if (!defined14(result)) {
        result = this.requestImageNow(this, x3, y3, level, request, currentInterval);
      }
      if (defined14(result) && defined14(timeDynamicImagery)) {
        timeDynamicImagery.checkApproachingInterval(x3, y3, level, request);
      }
      return result;
    }
    pickFeatures(x3, y3, level, longitude, latitude) {
      return void 0;
    }
    destroy() {
      for (let key2 in this.cache) {
        let tile = this.cache[key2];
        tile.destroy();
      }
      this.cache = {};
    }
    removeImageryFromCache(x3, y3, z2) {
      let key2 = x3 + "_" + y3 + "_" + z2;
      let tile = this.cache[key2];
      if (tile) {
        tile.destroy();
        delete this.cache[key2];
      }
    }
  };
  var LabelTileServiceImageryProvider_default = LabelTileServiceImageryProvider;

  // Source/custom/layer/model/ModelDataSource.js
  var Cartesian36 = Cesium.Cartesian3;
  var Color7 = Cesium.Color;
  var defined15 = Cesium.defined;
  var CallbackProperty3 = Cesium.CallbackProperty;
  var CesiumMath7 = Cesium.Math;
  var Matrix47 = Cesium.Matrix4;
  var Cartesian43 = Cesium.Cartesian4;
  var defer11 = Cesium.defer;
  var BEGIN5 = 1;
  var LOADED4 = 2;
  var ADDED5 = 3;
  var REMOVED5 = 4;
  var ModelDataSource = class {
    constructor(name2, results, level, viewer3, options, lightMap) {
      this.name = name2;
      this.level = level;
      this.viewer = viewer3;
      this.options = options;
      this.type = "model";
      this.state = BEGIN5;
      this.modelArray = [];
      this.urlMap = options.urlTypeLevelMap;
      this.readyPromise = defer11();
      this.ready = false;
      this.load(results);
    }
    load(results) {
      let instancesMap = {};
      for (let layerName in results) {
        let layerDatas = results[layerName];
        for (let i = 0; i < layerDatas.length; i++) {
          let data = layerDatas[i];
          let type = data.properties[this.options.modelTypeField];
          type = type ? type : "1";
          if (!instancesMap[type]) {
            instancesMap[type] = [];
          }
          let heading = Number(data.properties[this.options.headingField]);
          let scale = Number(data.properties[this.options.scaleField]);
          let lon = Number(data.properties[this.options.lonField]);
          let lat = Number(data.properties[this.options.latField]);
          let addHeight = this.options.hasOwnProperty("addHeight") ? Number(this.options.addHeight) : 0;
          let height = Number(data.properties[this.options.heightField]);
          height = height ? height : 0;
          height = height + addHeight;
          let position = Cesium.Cartesian3.fromDegrees(lon, lat, height);
          if (!scale) {
            scale = 1;
          }
          let modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(
            position,
            new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(heading), Cesium.Math.toRadians(0), Cesium.Math.toRadians(0))
          );
          Cesium.Matrix4.multiplyByUniformScale(
            modelMatrix,
            scale,
            modelMatrix
          );
          instancesMap[type].push({
            modelMatrix
          });
        }
      }
      let promises = [];
      for (let type in instancesMap) {
        let instances = instancesMap[type];
        if (!this.urlMap[type] || !this.urlMap[type][this.level]) {
          continue;
        }
        let url = this.urlMap[type][this.level];
        for (let i = 0; i < instances.length; i++) {
          let instance = instances[i];
          let model = Cesium.Model.fromGltf({
            asynchronous: false,
            gltf: url,
            modelMatrix: instance.modelMatrix
          });
          this.modelArray.push(model);
          model.update(this.viewer.scene.frameState);
          promises.push(model.readyPromise);
        }
      }
      this.state = LOADED4;
      this.readyPromise.resolve();
      this.ready = true;
    }
    remove() {
      for (let i = 0; i < this.modelArray.length; i++) {
        this.viewer.scene.primitives.remove(this.modelArray[i]);
      }
      this.state = REMOVED5;
    }
    destroy() {
      this.remove();
      for (let i = 0; i < this.modelArray.length; i++) {
        let model = this.modelArray[i];
        if (!model.finishedDestroy) {
          model.destroy();
          model.finishedDestroy = true;
        }
      }
      this.modelArray = [];
      this.destroyed = true;
    }
    addToPrimitives() {
      for (let i = 0; i < this.modelArray.length; i++) {
        this.viewer.scene.primitives.add(this.modelArray[i]);
      }
      this.state = ADDED5;
    }
    showPrimitive(primitive) {
    }
    show(styleFun) {
      if (this.state == LOADED4 || this.state == REMOVED5) {
        this.addToPrimitives();
      }
    }
  };
  var ModelDataSource_default = ModelDataSource;

  // Source/custom/layer/model/ModelTileServiceImageryProvider.js
  var combine8 = Cesium.combine;
  var Credit8 = Cesium.Credit;
  var defaultValue12 = Cesium.defaultValue;
  var defined16 = Cesium.defined;
  var DeveloperError10 = Cesium.DeveloperError;
  var Event9 = Cesium.Event;
  var freezeObject5 = Cesium.freezeObject;
  var isArray7 = Array.isArray;
  var Rectangle7 = Cesium.Rectangle;
  var Resource9 = Cesium.Resource;
  var WebMercatorTilingScheme8 = Cesium.WebMercatorTilingScheme;
  var ImageryProvider4 = Cesium.ImageryProvider;
  var TimeDynamicImagery7 = Cesium.TimeDynamicImagery;
  var RequestState5 = Cesium.RequestState;
  var defer12 = Cesium.defer;
  var defaultParameters7 = {
    service: "WMTS",
    version: "1.0.0",
    request: "GetTile"
  };
  var ModelTileServiceImageryProvider = class extends ElevationImageryProvider_default {
    constructor(viewer3, options, shaders) {
      super(viewer3, options);
      this.options = options;
      this.indexDbName = "house_" + this.indexDbName;
      options = defaultValue12(options, defaultValue12.EMPTY_OBJECT);
      this.id = Math.random();
      this.needDecode = defaultValue12(options.needDecode, false);
      if (!defined16(options.url)) {
        throw new DeveloperError10("options.url is required.");
      }
      var resource = Resource9.createIfNeeded(options.url);
      var style = options.style;
      var tileMatrixSetID = options.tileMatrixSetID;
      var url = resource.url;
      if (url.indexOf("{") >= 0) {
        var templateValues = {
          style,
          Style: style,
          TileMatrixSet: tileMatrixSetID
        };
        resource.setTemplateValues(templateValues);
        this._useKvp = false;
      } else {
        resource.setQueryParameters(defaultParameters7);
        this._useKvp = true;
      }
      this._resource = resource;
      this._layer = options.layer;
      this._style = style;
      this._tileMatrixSetID = tileMatrixSetID;
      this._tileMatrixLabels = options.tileMatrixLabels;
      this._format = defaultValue12(options.format, "image/jpeg");
      this._tileDiscardPolicy = options.tileDiscardPolicy;
      this._tilingScheme = defined16(options.tilingScheme) ? options.tilingScheme : new WebMercatorTilingScheme8({ ellipsoid: options.ellipsoid });
      this._tileWidth = defaultValue12(options.tileWidth, 256);
      this._tileHeight = defaultValue12(options.tileHeight, 256);
      this._minimumLevel = defaultValue12(options.minimumLevel, 0);
      this._maximumLevel = options.maximumLevel;
      this._rectangle = defaultValue12(options.rectangle, this._tilingScheme.rectangle);
      this._dimensions = options.dimensions;
      var that = this;
      this._reload = void 0;
      if (defined16(options.times)) {
        this._timeDynamicImagery = new TimeDynamicImagery7({
          clock: options.clock,
          times: options.times,
          requestImageFunction: function(x3, y3, level, request, interval) {
            return requestImage(that, x3, y3, level, request, interval);
          },
          reloadFunction: function() {
            if (defined16(that._reload)) {
              that._reload();
            }
          }
        });
      }
      this._readyPromise = defer12();
      var swTile = this._tilingScheme.positionToTileXY(Rectangle7.southwest(this._rectangle), this._minimumLevel);
      var neTile = this._tilingScheme.positionToTileXY(Rectangle7.northeast(this._rectangle), this._minimumLevel);
      var tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);
      if (tileCount > 4) {
        throw new DeveloperError10("The imagery provider's rectangle and minimumLevel indicate that there are " + tileCount + " tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.");
      }
      this._errorEvent = new Event9();
      var credit = options.credit;
      this._credit = typeof credit === "string" ? new Credit8(credit) : credit;
      this._subdomains = options.subdomains;
      if (isArray7(this._subdomains)) {
        this._subdomains = this._subdomains.slice();
      } else if (defined16(this._subdomains) && this._subdomains.length > 0) {
        this._subdomains = this._subdomains.split("");
      } else {
        this._subdomains = ["a", "b", "c"];
      }
      this.dataType = "binary";
      if (options.hasOwnProperty("dataType")) {
        this.dataType = options["dataType"];
      } else {
        this.dataType = "Json";
      }
      this.hasTerrain = false;
      if (viewer3.terrainProvider.name == "RGBWorldTerrainProvider") {
        this.hasTerrain = true;
      }
      if (this.dataType == "binary") {
        this.processor = new Cesium.TaskProcessor("ModelPointBinaryWorker", Number.POSITIVE_INFINITY);
      } else {
        this.processor = new Cesium.TaskProcessor("ModelPointWorker", Number.POSITIVE_INFINITY);
      }
      Cesium.FeatureDetection.supportsWebP.initialize();
      this.parseUrl(options.url);
      let result = this.parseModelUrlMap();
      let promiseArr = result.promiseArr;
      promiseArr.push(this.loadStyle());
      Promise.all(promiseArr).finally(function() {
        for (let i = 0; i < result.modelArr.length; i++) {
          viewer3.scene.primitives.remove(result.modelArr[i]);
        }
        this.ready = {
          value: true
        };
        this._readyPromise.resolve(true);
      }.bind(this));
      this.cache = {};
      this.lightMap = {};
      this.showLevel = options.showLevel || 16;
      this.image = document.createElement("canvas");
      this.showTilesMap = {};
    }
    parseModelUrlMap() {
      let urlArray = [];
      if (this.options.urlMap) {
        let urlTypeLevelMap = {};
        for (let key2 in this.options.urlMap) {
          let obj = this.options.urlMap[key2];
          let urlLevelMap = {};
          for (let levelKey in obj) {
            let levelArr = levelKey.split("-");
            let startLevel = levelArr[0];
            let endLevel = levelArr[1];
            for (let i = startLevel; i <= endLevel; i++) {
              urlLevelMap[i] = obj[levelKey];
            }
            urlArray.push(obj[levelKey]);
          }
          urlTypeLevelMap[key2] = urlLevelMap;
        }
        this.options["urlTypeLevelMap"] = urlTypeLevelMap;
      }
      let modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(
        Cesium.Cartesian3.fromDegrees(0, 0, 0),
        new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(0), Cesium.Math.toRadians(0), Cesium.Math.toRadians(0))
      );
      let promiseArr = [];
      let modelArr = [];
      for (let i = 0; i < urlArray.length; i++) {
        let model = Cesium.Model.fromGltf({
          asynchronous: false,
          gltf: urlArray[i],
          modelMatrix
        });
        promiseArr.push(model.readyPromise);
        modelArr.push(model);
        viewer.scene.primitives.add(model);
      }
      return { promiseArr, modelArr };
    }
    draw(tilesToRender) {
      if (Cesium.cleanScreenTiles) {
        this.showTilesMap = {};
        Cesium.cleanScreenTiles = false;
      }
      let renderTileMap = this.getRenderTileMap(tilesToRender);
      for (let key2 in this.cache) {
        if (!renderTileMap[key2]) {
          let tile = this.cache[key2];
          tile.remove();
        }
      }
      for (let name2 in renderTileMap) {
        let ds = this.cache[name2];
        if (ds) {
          ds.show(this.styleFun);
          if (!this.showTilesMap[name2]) {
            this.showTilesMap[name2] = true;
          }
        }
      }
    }
    getRenderTileMap(renderTiles) {
      let renderTileMap = {};
      for (let i = 0; i < renderTiles.length; i++) {
        let tile = renderTiles[i];
        let tileImagerys = tile.data.imagery;
        for (let j = 0; j < tileImagerys.length; j++) {
          let tileImagery = tileImagerys[j];
          let imagery = tileImagery.readyImagery;
          if (imagery && imagery.imageryLayer._imageryProvider.id == this.id) {
            let key2 = imagery.x + "_" + imagery.y + "_" + imagery.level;
            renderTileMap[key2] = true;
          }
        }
      }
      return renderTileMap;
    }
    parseUrl(url) {
      let urlParts = url.split("?");
      let urlPartOne = urlParts[0].split("/mapserver/");
      this.host = urlPartOne[0];
      if (this._subdomains.length > 0) {
        this.host = this.host.replace("{s}", this._subdomains[0]);
      }
      this.servername = urlPartOne[1].split("/")[1];
      this.queryParam = urlParts[1];
      let params2 = this.queryParam.split("&");
      for (let i = 0; i < params2.length; i++) {
        let param = params2[i];
        let keyValue = param.split("=");
        if (keyValue[0] == "styleId") {
          this.styleId = keyValue[1];
        }
        if (keyValue[0] == "return_type") {
          this.return_type = keyValue[1];
        }
      }
    }
    loadStyle() {
      let promises = [];
      let styleUrl = this.host + "/mapserver/styleInfo/" + this.servername + "/" + this.styleId + "/layer/style.js?" + Math.random();
      let resource = Resource9.createIfNeeded(styleUrl);
      let promise1 = resource.fetchText();
      promises.push(promise1);
      let promise2 = null;
      if (this.dataType == "binary") {
        let styleUrl2 = this.host + "/mapserver/serverInfo/" + this.servername + ".json?" + Math.random();
        let resource2 = Resource9.createIfNeeded(styleUrl2);
        promise2 = resource2.fetchJson();
        promises.push(promise2);
      }
      let deferred = defer12();
      Promise.all(promises).then(function(result) {
        let styleStr = result[0];
        let results = result[1];
        let options = {
          init: true,
          styleStr,
          tileSize: this._tileWidth,
          return_type: this.return_type,
          hasTerrain: this.hasTerrain
        };
        if (results && results.layerMap) {
          this.serverInfo = {};
          this.layerFieldMap = {};
          for (let key2 in results.layerMap) {
            this.serverInfo[key2] = {
              geometryType: results.layerMap[key2].geometryType,
              fieldsConfig: results.layerMap[key2].fields
            };
            if (!this.layerFieldMap[key2]) {
              this.layerFieldMap[key2] = results.layerMap[key2].fields.length;
            }
          }
          options.serverInfo = this.serverInfo;
          options.layerFieldMap = this.layerFieldMap;
        }
        options.indexDbNames = this.getBottomProviderIndexDbNames();
        options.indexDbName = this.indexDbName;
        let promise = this.processor.scheduleTask(options);
        promise.then(function() {
          deferred.resolve();
        });
      }.bind(this));
      return deferred.promise;
    }
    requestImageNow(imageryProvider, col, row, level, request, interval) {
      var labels = imageryProvider._tileMatrixLabels;
      var tileMatrix = defined16(labels) ? labels[level] : level.toString();
      var subdomains = imageryProvider._subdomains;
      var staticDimensions = imageryProvider._dimensions;
      var dynamicIntervalData = defined16(interval) ? interval.data : void 0;
      var resource;
      if (!imageryProvider._useKvp) {
        var templateValues = {
          z: tileMatrix,
          y: row.toString(),
          x: col.toString(),
          s: subdomains[(col + row + level) % subdomains.length]
        };
        resource = imageryProvider._resource.getDerivedResource({
          request
        });
        resource.setTemplateValues(templateValues);
        if (defined16(staticDimensions)) {
          resource.setTemplateValues(staticDimensions);
        }
        if (defined16(dynamicIntervalData)) {
          resource.setTemplateValues(dynamicIntervalData);
        }
      } else {
        var query = {};
        query.tilematrix = tileMatrix;
        query.layer = imageryProvider._layer;
        query.style = imageryProvider._style;
        query.tilerow = row;
        query.tilecol = col;
        query.tilematrixset = imageryProvider._tileMatrixSetID;
        query.format = imageryProvider._format;
        if (defined16(staticDimensions)) {
          query = combine8(query, staticDimensions);
        }
        if (defined16(dynamicIntervalData)) {
          query = combine8(query, dynamicIntervalData);
        }
        resource = imageryProvider._resource.getDerivedResource({
          queryParameters: query,
          request
        });
      }
      var deferred = defer12();
      let xyz = { x: col, y: row, z: level };
      let tileLevel = resource._templateValues.z;
      if (tileLevel < this.showLevel) {
        deferred.reject();
        return deferred.promise;
      }
      this.requestJsonData(deferred, imageryProvider, resource, xyz, request);
      return deferred.promise;
    }
    requestJsonData(deferred, imageryProvider, url, xyz, request) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let z2 = xyz.z;
      let level = url._templateValues.z;
      let name2 = x3 + "_" + y3 + "_" + z2;
      if (this.cache[name2] || z2 == 0) {
        deferred.resolve(this.image);
        return deferred;
      }
      let rectangle = this._tilingScheme.tileXYToRectangle(xyz.x, xyz.y, xyz.z);
      let rectangleObj = { west: rectangle.west, north: rectangle.north, width: rectangle.width, height: rectangle.height };
      let xyzStr = xyz.x + "_" + xyz.y + "_" + xyz.z;
      let promise = this.processor.scheduleTask({
        url: url.url,
        xyz: xyzStr,
        needDecode: this.options.needDecode,
        level,
        filterLayerId: this.options.filterLayerId,
        ridingLanternLayerId: this.options.ridingLanternLayerId,
        ridingLanternHeight: this.ridingLanternHeight,
        ridingLanternColor: this.ridingLanternColor,
        ridingLanternAlpha: this.ridingLanternAlpha,
        ridingLanternType: this.ridingLanternType,
        ridingLanternSpeed: this.ridingLanternSpeed,
        waterLayerId: this.options.waterLayerId,
        rectangle: rectangleObj
      });
      promise.then(function(deferred2, xyz2, level2, request2, results) {
        if (results == true) {
          request2.state = RequestState5.CANCELLED;
          deferred2.reject();
          return;
        }
        this.jsonPromiseResult(deferred2, xyz2, level2, results);
        this.updateOtherProviderElevation(xyz2);
      }.bind(this, deferred, xyz, level, request), function(error) {
        deferred.reject();
      });
      return true;
    }
    jsonPromiseResult(deferred, xyz, level, results) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let z2 = xyz.z;
      let name2 = x3 + "_" + y3 + "_" + z2;
      let tile = new ModelDataSource_default(name2, results, level, this.viewer, this.options, this.lightMap);
      this.cache[tile.name] = tile;
      tile.readyPromise.promise.then(function() {
        deferred.resolve(this.image);
      }.bind(this), function() {
        deferred.reject();
      });
    }
    updateTileElevation(xyz, tileSize) {
      let name2 = xyz.x + "_" + xyz.y + "_" + xyz.z;
      if (!this.cache[name2]) {
        return false;
      }
      return true;
    }
    get url() {
      return this._resource.url;
    }
    get proxy() {
      return this._resource.proxy;
    }
    get tileWidth() {
      return this._tileWidth;
    }
    get tileHeight() {
      return this._tileHeight;
    }
    get maximumLevel() {
      return this._maximumLevel;
    }
    get minimumLevel() {
      return this._minimumLevel;
    }
    get tilingScheme() {
      return this._tilingScheme;
    }
    get rectangle() {
      return this._rectangle;
    }
    get tileDiscardPolicy() {
      return this._tileDiscardPolicy;
    }
    get errorEvent() {
      return this._errorEvent;
    }
    get format() {
      return this._format;
    }
    get readyPromise() {
      return this._readyPromise;
    }
    get credit() {
      return this._credit;
    }
    get hasAlphaChannel() {
      return true;
    }
    get clock() {
      return this._timeDynamicImagery.clock;
    }
    set clock(value) {
      this._timeDynamicImagery.clock = value;
    }
    get times() {
      return this._timeDynamicImagery.times;
    }
    set times(value) {
      this._timeDynamicImagery.times = value;
    }
    get dimensions() {
      return this._dimensions;
    }
    set dimensions(value) {
      if (this._dimensions !== value) {
        this._dimensions = value;
        if (defined16(this._reload)) {
          this._reload();
        }
      }
    }
    getTileCredits(x3, y3, level) {
      return void 0;
    }
    requestImage(x3, y3, level, request) {
      var result;
      var timeDynamicImagery = this._timeDynamicImagery;
      var currentInterval;
      if (defined16(timeDynamicImagery)) {
        currentInterval = timeDynamicImagery.currentInterval;
        result = timeDynamicImagery.getFromCache(x3, y3, level, request);
      }
      if (!defined16(result)) {
        result = this.requestImageNow(this, x3, y3, level, request, currentInterval);
      }
      if (defined16(result) && defined16(timeDynamicImagery)) {
        timeDynamicImagery.checkApproachingInterval(x3, y3, level, request);
      }
      return result;
    }
    pickFeatures(x3, y3, level, longitude, latitude) {
      return void 0;
    }
    updateLightShader(light) {
      this.lightMap[light.type] = light;
      this.updateLightMap();
    }
    removeLightShader(type) {
      delete this.lightMap[type];
      this.updateLightMap();
    }
    updateLightMap() {
      for (let key2 in this.cache) {
        let houseDataSource = this.cache[key2];
        houseDataSource.setLightMap(this.lightMap);
      }
    }
    destroy() {
      for (let key2 in this.cache) {
        let tile = this.cache[key2];
        tile.destroy();
      }
      this.cache = {};
    }
    removeImageryFromCache(x3, y3, z2) {
      let key2 = x3 + "_" + y3 + "_" + z2;
      let tile = this.cache[key2];
      if (tile) {
        tile.destroy();
        delete this.cache[key2];
      }
    }
    removeTile(xyzStr) {
      let tile = this.cache[xyzStr];
      if (tile) {
        tile.remove();
      }
    }
  };
  var ModelTileServiceImageryProvider_default = ModelTileServiceImageryProvider;

  // Source/custom/layer/terrain/RGBWorldTerrainProvider.js
  var import_md5_node2 = __toESM(require_md5_node(), 1);
  var Credit9 = Cesium.Credit;
  var defaultValue13 = Cesium.defaultValue;
  var defined17 = Cesium.defined;
  var DeveloperError11 = Cesium.DeveloperError;
  var Ellipsoid = Cesium.Ellipsoid;
  var Event10 = Cesium.Event;
  var GeographicTilingScheme3 = Cesium.GeographicTilingScheme;
  var HeightmapTerrainData2 = Cesium.HeightmapTerrainData;
  var Resource10 = Cesium.Resource;
  var TerrainProvider2 = Cesium.TerrainProvider;
  var RequestState6 = Cesium.RequestState;
  var defer13 = Cesium.defer;
  function RGBWorldTerrainProvider(options) {
    options = defaultValue13(options, defaultValue13.EMPTY_OBJECT);
    this.name = "RGBWorldTerrainProvider";
    this._tileMatrixLabels = options.tileMatrixLabels;
    if (!defined17(options.url)) {
      throw new DeveloperError11("options.url is required.");
    }
    var resource = Resource10.createIfNeeded(options.url);
    this._resource = resource;
    this._errorEvent = new Event10();
    this._ready = false;
    this._readyPromise = defer13();
    var credit = options.credit;
    if (typeof credit === "string") {
      credit = new Credit9(credit);
    }
    this._credit = credit;
    this._tilingScheme = void 0;
    this._rectangles = [];
    var ellipsoid = defaultValue13(options.ellipsoid, Ellipsoid.WGS84);
    this._maxLevel = defaultValue13(options.maxLevel, 15);
    this._tilingScheme = defaultValue13(options.tilingScheme, new GeographicTilingScheme3({ ellipsoid }));
    this._width = parseInt(defaultValue13(options.width, 65));
    this.tileSize = defaultValue13(options.tileSize, 512);
    var _levelZero = this.tileSize == 512 ? 1 : 0;
    this._levelZeroMaximumGeometricError = TerrainProvider2.getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid, 65, this._tilingScheme.getNumberOfXTilesAtLevel(_levelZero));
    this.processor = new Cesium.TaskProcessor("TerrainWorker", Number.POSITIVE_INFINITY);
    if (options.url) {
      this.url = options.url;
      this.indexDbName = "terrain_" + (0, import_md5_node2.default)(options.url);
    }
    let tilingSchemeName = this._tilingScheme instanceof GeographicTilingScheme3 ? "GeographicTilingScheme" : "WebMercatorTilingScheme";
    let promise = this.processor.scheduleTask({ init: true, w: this._width, indexDbName: this.indexDbName, tilingSchemeName, maxLevel: this._maxLevel, tileSize: this.tileSize });
    promise.then(function() {
      this._ready = true;
      this._readyPromise.resolve(true);
    }.bind(this));
  }
  Object.defineProperties(RGBWorldTerrainProvider.prototype, {
    errorEvent: {
      get: function() {
        return this._errorEvent;
      }
    },
    credit: {
      get: function() {
        return this._credit;
      }
    },
    tilingScheme: {
      get: function() {
        return this._tilingScheme;
      }
    },
    ready: {
      get: function() {
        return this._ready;
      }
    },
    readyPromise: {
      get: function() {
        return this._readyPromise.promise;
      }
    },
    hasWaterMask: {
      get: function() {
        return false;
      }
    },
    hasVertexNormals: {
      get: function() {
        return false;
      }
    }
  });
  RGBWorldTerrainProvider.prototype.requestTileGeometry = function(x3, y3, level, request) {
    if (!this.ready) {
      throw new DeveloperError11("requestTileGeometry must not be called before ready returns true.");
    }
    var labels = this._tileMatrixLabels;
    var l = defined17(labels) ? labels[0] : 0;
    var tileMatrix = level + parseInt(l);
    var resource = this._resource.getDerivedResource({
      request
    });
    var templateValues = {
      z: tileMatrix,
      y: y3,
      x: x3
    };
    resource.setTemplateValues(templateValues);
    let xyz = { x: templateValues.x, y: templateValues.y, z: level };
    var parameters = { url: resource.url, xyz };
    if (level > this._maxLevel) {
      parameters.resourceUrl = this.url;
    }
    let promise = this.processor.scheduleTask(parameters);
    var deferred = defer13();
    promise.then(function(deferred2, request2, data) {
      if (!data) {
        request2.state = RequestState6.CANCELLED;
        deferred2.reject();
        return;
      }
      let heightmapTerrainData = new HeightmapTerrainData2({
        buffer: data.sData,
        _minimumHeight: data._minimumHeight,
        _maximumHeight: data._maximumHeight,
        width: this._width,
        height: this._width
      });
      deferred2.resolve(heightmapTerrainData);
    }.bind(this, deferred, request), function(error) {
      request.state = RequestState6.CANCELLED;
      deferred.reject();
    }.bind(this, deferred, request));
    return deferred.promise;
  };
  RGBWorldTerrainProvider.prototype.getLevelMaximumGeometricError = function(level) {
    if (!this.ready) {
      throw new DeveloperError11("requestTileGeometry must not be called before ready returns true.");
    }
    return this._levelZeroMaximumGeometricError / (1 << level);
  };
  RGBWorldTerrainProvider.prototype.getTileDataAvailable = function(x3, y3, level) {
    return void 0;
  };
  RGBWorldTerrainProvider.prototype.loadTileDataAvailability = function(x3, y3, level) {
    return void 0;
  };
  var RGBWorldTerrainProvider_default = RGBWorldTerrainProvider;

  // Source/custom/layer/vector/LineAtlas.js
  var PixelFormat = Cesium.PixelFormat;
  var LineAtlas = class {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.nextRow = 0;
      this.bytes = 4;
      this.data = new Uint8Array(this.width * this.height * this.bytes);
      this.positions = {};
    }
    setSprite(sprite) {
      this.sprite = sprite;
    }
    getDash(dasharray, round) {
      const key2 = dasharray.join(",") + round;
      if (!this.positions[key2]) {
        this.positions[key2] = this.addDash(dasharray, round);
      }
      return this.positions[key2];
    }
    addDash(dasharray, round) {
      const n = round ? 7 : 0;
      const height = 2 * n + 1;
      const offset = 128;
      if (this.nextRow + height > this.height) {
        console.log("LineAtlas out of space");
        return null;
      }
      let length2 = 0;
      for (let i = 0; i < dasharray.length; i++) {
        length2 += dasharray[i];
      }
      const stretch = this.width / length2;
      const halfWidth = stretch / 2;
      const oddLength = dasharray.length % 2 === 1;
      for (let y3 = -n; y3 <= n; y3++) {
        const row = this.nextRow + n + y3;
        const index = this.width * row;
        let left = oddLength ? -dasharray[dasharray.length - 1] : 0;
        let right = dasharray[0];
        let partIndex = 1;
        for (let x3 = 0; x3 < this.width; x3++) {
          while (right < x3 / stretch) {
            left = right;
            right = right + dasharray[partIndex];
            if (oddLength && partIndex === dasharray.length - 1) {
              right += dasharray[0];
            }
            partIndex++;
          }
          const distLeft = Math.abs(x3 - left * stretch);
          const distRight = Math.abs(x3 - right * stretch);
          const dist = Math.min(distLeft, distRight);
          const inside = partIndex % 2 === 1;
          let signedDistance;
          if (round) {
            const distMiddle = n ? y3 / n * (halfWidth + 1) : 0;
            if (inside) {
              const distEdge = halfWidth - Math.abs(distMiddle);
              signedDistance = Math.sqrt(dist * dist + distEdge * distEdge);
            } else {
              signedDistance = halfWidth - Math.sqrt(dist * dist + distMiddle * distMiddle);
            }
          } else {
            signedDistance = (inside ? 1 : -1) * dist;
          }
          this.data[3 + (index + x3) * 4] = Math.max(0, Math.min(255, signedDistance + offset));
        }
      }
      const pos = {
        y: (this.nextRow + n + 0.5) / this.height,
        height: 2 * n / this.height,
        width: length2
      };
      this.nextRow += height;
      this.dirty = true;
      return pos;
    }
    bind(gl) {
      if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
      } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        if (this.dirty) {
          this.dirty = false;
          gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
        }
      }
    }
  };
  var LineAtlas_default = LineAtlas;

  // Source/custom/layer/vector/VectorTile.js
  var VectorTile = class {
    constructor(name2, level, tileData, buckets, texture) {
      this.name = name2;
      this.level = level;
      this.tileData = tileData;
      this.buckets = buckets;
      this.texture = texture;
    }
    destroy() {
      for (let i = 0; i < this.buckets.length; i++) {
        let bucket = this.buckets[i];
        bucket.layoutVertexBuffer.destroy();
        if (bucket.layoutVertexBuffer2)
          bucket.layoutVertexBuffer2.destroy();
        bucket.indexBuffer.destroy();
        if (bucket.indexBuffer2) {
          bucket.indexBuffer2.destroy();
        }
        for (let i2 = 0; i2 < bucket.segments.segments.length; i2++) {
          const segment = bucket.segments.segments[i2];
          if (segment.vao) {
            segment.vao.destroy();
            segment.vao = null;
          }
        }
        if (bucket.segments2) {
          for (let i2 = 0; i2 < bucket.segments2.segments.length; i2++) {
            const segment = bucket.segments2.segments[i2];
            if (segment.vao) {
              segment.vao.destroy();
              segment.vao = null;
            }
          }
        }
      }
    }
  };
  var VectorTile_default = VectorTile;

  // Source/custom/layer/vector/draw/DrawFill.js
  function drawFill(vectorProvider, bucket, matrix, remove) {
    let style = bucket.style;
    if (style.fill) {
      drawFillTiles(vectorProvider, bucket, matrix, false, remove);
    }
  }
  function drawFillTiles(vectorProvider, bucket, matrix, isOutline, remove) {
    const gl = vectorProvider.viewer.scene.context._gl;
    const image = null;
    let drawMode, programName, uniformValues, layoutVertexBuffer, indexBuffer, segments;
    if (!isOutline) {
      programName = image ? "fillPattern" : "fill";
      drawMode = gl.TRIANGLES;
    } else {
      programName = image ? "fillOutlinePattern" : "fillOutline";
      drawMode = gl.LINES;
    }
    const program = vectorProvider.useProgram(programName);
    if (image) {
    }
    if (!isOutline) {
      layoutVertexBuffer = bucket.layoutVertexBuffer;
      indexBuffer = bucket.indexBuffer;
      segments = bucket.segments;
      uniformValues = image ? null : gl.uniformMatrix4fv(program.u_matrix, false, matrix);
      setUniforms(gl, program, bucket.style);
    } else {
      layoutVertexBuffer = bucket.layoutVertexBuffer2;
      indexBuffer = bucket.indexBuffer2;
      segments = bucket.segments2;
      const drawingBufferSize = [gl.drawingBufferWidth, gl.drawingBufferHeight];
      uniformValues = programName === "fillOutlinePattern" && image ? null : fillOutlineUniformValues(program, gl, matrix, drawingBufferSize, vectorProvider, bucket.style);
    }
    const primitiveSize = {
      [gl.LINES]: 2,
      [gl.TRIANGLES]: 3,
      [gl.LINE_STRIP]: 1
    }[drawMode];
    for (let i = 0; i < segments.segments.length; i++) {
      const segment = segments.segments[i];
      if (!segment.vao) {
        segment.vao = new VertexArrayObject_default();
      }
      segment.vao.bind(gl, program, layoutVertexBuffer, indexBuffer, null, segment.vertexOffset);
      gl.drawElements(drawMode, segment.primitiveLength * primitiveSize, gl.UNSIGNED_SHORT, segment.primitiveOffset * primitiveSize * 2);
      if (remove) {
        segment.vao.destroy();
      }
    }
  }
  function fillOutlineUniformValues(program, gl, matrix, drawingBufferSize, vectorProvider, style) {
    gl.uniformMatrix4fv(program.u_matrix, false, matrix);
    let w = vectorProvider._tileWidth * vectorProvider.ratio * vectorProvider.scale;
    gl.uniform2f(program.u_world, w, w);
    gl.uniform4fv(program.outline_color, style.strokeColor);
    gl.uniform1f(program.opacity, style.strokeOpacity);
  }
  function setUniforms(gl, program, style) {
    gl.uniform4fv(program.u_color, style.fillColor);
    gl.uniform1f(program.u_opacity, style.fillOpacity);
  }
  var DrawFill_default = drawFill;

  // Source/custom/layer/vector/draw/DrawLine.js
  function drawLine(vectorProvider, bucket, matrix, remove, lineWidthScale) {
    let style = bucket.style;
    const width = style.strokeWidth;
    const opacity = style.strokeOpacity;
    if (opacity == 0 || width == 0)
      return;
    const dasharray = style["dash"];
    const image = null;
    const gradient = null;
    const programId = image ? "linePattern" : dasharray ? "lineSDF" : gradient ? "lineGradient" : "line";
    const gl = vectorProvider.viewer.scene.context._gl;
    const program = vectorProvider.useProgram(programId);
    const uniformValues = image ? null : dasharray ? lineSDFUniformValues(gl, program, matrix, vectorProvider, dasharray, style) : gradient ? null : lineUniformValues(gl, program, matrix, vectorProvider._tileWidth);
    if (image) {
    } else if (dasharray) {
    } else if (gradient) {
    }
    setUniforms2(gl, program, style, lineWidthScale);
    for (let i = 0; i < bucket.segments.segments.length; i++) {
      const segment = bucket.segments.segments[i];
      if (!segment.vao) {
        segment.vao = new VertexArrayObject_default();
      }
      segment.vao.bind(gl, program, bucket.layoutVertexBuffer, bucket.indexBuffer, null, segment.vertexOffset);
      gl.drawElements(gl.TRIANGLES, segment.primitiveLength * 3, gl.UNSIGNED_SHORT, segment.primitiveOffset * 3 * 2);
      if (remove) {
        segment.vao.destroy();
      }
    }
  }
  function lineSDFUniformValues(gl, program, matrix, vectorProvider, dasharray, style) {
    gl.uniformMatrix4fv(program.u_matrix, false, matrix);
    gl.uniform1f(program.u_ratio, vectorProvider._tileWidth / 8192);
    gl.uniform2f(program.u_gl_units_to_pixels, 1 / (2 / gl.drawingBufferWidth), 1 / (-2 / gl.drawingBufferHeight));
    let posA, posB, imagePosA, imagePosB;
    const tileRatio = vectorProvider._tileWidth / 8192;
    posA = vectorProvider.lineAtlas.getDash(dasharray, style["lineCap"] === "round");
    posB = vectorProvider.lineAtlas.getDash(dasharray, style["lineJoin"] === "round");
    const widthA = posA.width * 2;
    const widthB = posB.width * 1;
    gl.uniform2f(program.u_patternscale_a, tileRatio / widthA, -posA.height / 2);
    gl.uniform2f(program.u_patternscale_b, tileRatio / widthB, -posB.height / 2);
    gl.uniform1f(program.u_sdfgamma, vectorProvider.lineAtlas.width / (Math.min(widthA, widthB) * 256 * 1.25) / 2);
    gl.uniform1i(program.u_image, 0);
    gl.activeTexture(gl.TEXTURE0);
    vectorProvider.lineAtlas.bind(gl);
    gl.uniform1f(program.u_tex_y_a, posA.y);
    gl.uniform1f(program.u_tex_y_b, posB.y);
    gl.uniform1f(program.u_mix, 1);
  }
  function lineUniformValues(gl, program, matrix, tileSize) {
    gl.uniformMatrix4fv(program.u_matrix, false, matrix);
    gl.uniform1f(program.u_ratio, tileSize / 8192);
    gl.uniform2f(program.u_gl_units_to_pixels, 1 / (2 / gl.drawingBufferWidth), 1 / (-2 / gl.drawingBufferHeight));
  }
  function setUniforms2(gl, program, style, lineWidthScale) {
    let w = style.strokeWidth;
    if (lineWidthScale) {
      w = w / lineWidthScale;
    }
    gl.uniform1f(program.u_width, w);
    gl.uniform4fv(program.color, style.strokeColor);
    gl.uniform1f(program.opacity, style.strokeOpacity);
    gl.uniform1f(program.blur, 0);
    gl.uniform1f(program.a_gapwidth, 0);
    gl.uniform1f(program.a_offset, 0);
  }
  var DrawLine_default = drawLine;

  // Source/custom/layer/vector/draw/DrawVector.js
  var draw = {
    fill: DrawFill_default,
    line: DrawLine_default
  };
  var drawTile = function(vectorProvider, buckets, m, remove, lineWidthScale) {
    const gl = vectorProvider.viewer.scene.context._gl;
    gl.disable(gl.DEPTH_TEST);
    for (let j = 0; j < buckets.length; j++) {
      let bucket = buckets[j];
      draw[bucket.type](vectorProvider, bucket, m, remove, lineWidthScale);
    }
    gl.enable(gl.DEPTH_TEST);
  };
  var DrawVector_default = drawTile;

  // Source/custom/layer/vector/draw/DrawFboVector.js
  var mat43 = gl_matrix_default.mat4;
  var DrawFboVector = class {
    static drawFboVector(vectorProvider, buckets, key2, level) {
      const gl = vectorProvider.viewer.scene.context._gl;
      const passState = vectorProvider.viewer.scene._view.passState;
      let framebuffer = null;
      if (passState.framebuffer) {
        framebuffer = passState.framebuffer._framebuffer;
      }
      const viewport = passState.viewport;
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      let texture = vectorProvider.textureQueue.getOne(key2, vectorProvider._zoom, level);
      if (!texture) {
        let styleScale = 1;
        texture = DrawFboVector.initFramebufferObject(vectorProvider, gl, vectorProvider.scale, styleScale);
        vectorProvider.textureQueue.add(key2, vectorProvider._zoom, level, texture);
        DrawFboVector.drawRasterTile(vectorProvider, buckets, gl, styleScale);
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.viewport(0, 0, viewport.width, viewport.height);
      gl.viewport(0, 0, vectorProvider.viewer._lastWidth, vectorProvider.viewer._lastHeight);
      return texture;
    }
    static drawRasterTile(vectorProvider, buckets, gl, styleScale) {
      let m = mat43.identity(new Float32Array(16));
      mat43.translate(m, m, [-1, -1, 0]);
      mat43.scale(m, m, [2 / 8192, 2 / 8192, 1]);
      DrawFboVector.cleanViewPort(gl, vectorProvider._tileWidth * vectorProvider.ratio * vectorProvider.scale * styleScale, vectorProvider._tileWidth * vectorProvider.ratio * vectorProvider.scale * styleScale);
      gl.clearColor(1, 1, 1, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      DrawVector_default(vectorProvider, buckets, m, true);
    }
    static initFramebufferObject(vectorProvider, gl, scale, styleScale) {
      let fbo = vectorProvider.viewportFbo;
      if (!fbo) {
        let fbo2 = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo2);
        vectorProvider.viewportFbo = fbo2;
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      }
      let texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, vectorProvider._tileWidth * vectorProvider.ratio * scale * styleScale, vectorProvider._tileWidth * vectorProvider.ratio * scale * styleScale, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      return texture;
    }
    static cleanViewPort(gl, width, height) {
      gl.viewport(0, 0, width, height);
    }
  };
  var DrawFboVector_default = DrawFboVector.drawFboVector;

  // Source/custom/layer/vector/draw/DrawTilesFboVector.js
  var mat44 = gl_matrix_default.mat4;
  var DrawTilesFboVector = class {
    static drawFboVector(vectorProvider, tiles2, needDrawTilesMap, styleLevel, drawAll) {
      if (tiles2.length == 0) {
        return;
      }
      const startTime = Browser_default.now();
      const shouldPausePlacement = () => {
        const elapsedTime = Browser_default.now() - startTime;
        return elapsedTime > 3;
      };
      const passState = vectorProvider.viewer.scene._view.passState;
      let framebuffer = null;
      if (passState.framebuffer) {
        framebuffer = passState.framebuffer._framebuffer;
      }
      const viewport = passState.viewport;
      const gl = vectorProvider.viewer.scene.context._gl;
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      while (tiles2.length > 0) {
        let tile = tiles2.shift();
        if (!styleLevel) {
          styleLevel = tile.level;
        }
        let mapName = tile.name + "_" + vectorProvider._zoom + "_" + styleLevel;
        delete needDrawTilesMap[mapName];
        let key2 = tile.name;
        let buckets = tile.buckets;
        let styleScale = 1;
        if (styleLevel - tile.level == 1) {
          styleScale = 2;
        }
        let texture = DrawTilesFboVector.initFramebufferObject(vectorProvider, gl, vectorProvider.scale, styleScale);
        vectorProvider.textureQueue.add(key2, vectorProvider._zoom, styleLevel, texture);
        let lineWidthScale = Math.pow(2, styleLevel) / Math.pow(2, tile.level);
        DrawTilesFboVector.drawRasterTile(vectorProvider, buckets, gl, styleScale, lineWidthScale);
        if (shouldPausePlacement() && !drawAll) {
          gl.disable(gl.BLEND);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.viewport(0, 0, viewport.width, viewport.height);
          return true;
        }
      }
      gl.disable(gl.BLEND);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.viewport(0, 0, viewport.width, viewport.height);
      return true;
    }
    static drawRasterTile(vectorProvider, buckets, gl, styleScale, lineWidthScale) {
      let m = mat44.identity(new Float32Array(16));
      mat44.translate(m, m, [-1, -1, 0]);
      mat44.scale(m, m, [2 / 8192, 2 / 8192, 1]);
      DrawTilesFboVector.cleanViewPort(gl, vectorProvider._tileWidth * vectorProvider.ratio * vectorProvider.scale * styleScale, vectorProvider._tileWidth * vectorProvider.ratio * vectorProvider.scale * styleScale);
      gl.clearColor(1, 1, 1, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      DrawVector_default(vectorProvider, buckets, m, false, lineWidthScale);
    }
    static initFramebufferObject(vectorProvider, gl, scale, styleScale) {
      let fbo = vectorProvider.viewportFbo;
      if (!fbo) {
        let fbo2 = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo2);
        vectorProvider.viewportFbo = fbo2;
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      }
      let texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, vectorProvider._tileWidth * vectorProvider.ratio * scale * styleScale, vectorProvider._tileWidth * vectorProvider.ratio * scale * styleScale, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      return texture;
    }
    static cleanViewPort(gl, width, height) {
      gl.viewport(0, 0, width, height);
    }
  };
  var DrawTilesFboVector_default = DrawTilesFboVector.drawFboVector;

  // Source/custom/layer/vector/VectorTileServiceImageryProvider.js
  var combine9 = Cesium.combine;
  var Credit10 = Cesium.Credit;
  var defaultValue14 = Cesium.defaultValue;
  var defined18 = Cesium.defined;
  var DeveloperError12 = Cesium.DeveloperError;
  var Event11 = Cesium.Event;
  var freezeObject6 = Cesium.freezeObject;
  var isArray8 = Array.isArray;
  var Rectangle8 = Cesium.Rectangle;
  var Resource11 = Cesium.Resource;
  var WebMercatorTilingScheme9 = Cesium.WebMercatorTilingScheme;
  var ImageryProvider5 = Cesium.ImageryProvider;
  var TimeDynamicImagery8 = Cesium.TimeDynamicImagery;
  var RequestState7 = Cesium.RequestState;
  var FillBucket = Cesium.FillBucket;
  var LineBucket = Cesium.LineBucket;
  var defer14 = Cesium.defer;
  var defaultParameters8 = {
    service: "WMTS",
    version: "1.0.0",
    request: "GetTile"
  };
  var VectorTileServiceImageryProvider = class {
    constructor(viewer3, options, shaders) {
      options = defaultValue14(options, defaultValue14.EMPTY_OBJECT);
      this.id = Math.random();
      this.viewer = viewer3;
      this.needDecode = defaultValue14(options.needDecode, false);
      if (!defined18(options.url)) {
        throw new DeveloperError12("options.url is required.");
      }
      var resource = Resource11.createIfNeeded(options.url);
      var style = options.style;
      var tileMatrixSetID = options.tileMatrixSetID;
      var url = resource.url;
      if (url.indexOf("{") >= 0) {
        var templateValues = {
          style,
          Style: style,
          TileMatrixSet: tileMatrixSetID
        };
        resource.setTemplateValues(templateValues);
        this._useKvp = false;
      } else {
        resource.setQueryParameters(defaultParameters8);
        this._useKvp = true;
      }
      this._resource = resource;
      this._layer = options.layer;
      this._style = style;
      this._tileMatrixSetID = tileMatrixSetID;
      this._tileMatrixLabels = options.tileMatrixLabels;
      this._format = defaultValue14(options.format, "image/jpeg");
      this._tileDiscardPolicy = options.tileDiscardPolicy;
      this._tilingScheme = defined18(options.tilingScheme) ? options.tilingScheme : new WebMercatorTilingScheme9({ ellipsoid: options.ellipsoid });
      this._tileWidth = defaultValue14(options.tileWidth, 256);
      this._tileHeight = defaultValue14(options.tileHeight, 256);
      this._minimumLevel = defaultValue14(options.minimumLevel, 0);
      this._maximumLevel = options.maximumLevel;
      this._rectangle = defaultValue14(options.rectangle, this._tilingScheme.rectangle);
      this._dimensions = options.dimensions;
      var that = this;
      this._reload = void 0;
      if (defined18(options.times)) {
        this._timeDynamicImagery = new TimeDynamicImagery8({
          clock: options.clock,
          times: options.times,
          requestImageFunction: function(x3, y3, level, request, interval) {
            return requestImage(that, x3, y3, level, request, interval);
          },
          reloadFunction: function() {
            if (defined18(that._reload)) {
              that._reload();
            }
          }
        });
      }
      this._readyPromise = defer14();
      var swTile = this._tilingScheme.positionToTileXY(Rectangle8.southwest(this._rectangle), this._minimumLevel);
      var neTile = this._tilingScheme.positionToTileXY(Rectangle8.northeast(this._rectangle), this._minimumLevel);
      var tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);
      if (tileCount > 4) {
        throw new DeveloperError12("The imagery provider's rectangle and minimumLevel indicate that there are " + tileCount + " tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.");
      }
      this._errorEvent = new Event11();
      var credit = options.credit;
      this._credit = typeof credit === "string" ? new Credit10(credit) : credit;
      this._subdomains = options.subdomains;
      if (isArray8(this._subdomains)) {
        this._subdomains = this._subdomains.slice();
      } else if (defined18(this._subdomains) && this._subdomains.length > 0) {
        this._subdomains = this._subdomains.split("");
      } else {
        this._subdomains = ["a", "b", "c"];
      }
      if (options.hasOwnProperty("serverName") && options.hasOwnProperty("styleId") && options.hasOwnProperty("host")) {
        this.host = options.host;
        this.styleId = options.styleId;
        this.serverName = options.serverName;
      } else {
        this.parseUrl(options.url);
      }
      this.cache = {};
      this.options = options;
      this.lightMap = {};
      this.showLevel = options.showLevel || 16;
      this.dataType = "binary";
      if (options.hasOwnProperty("dataType")) {
        this.dataType = options["dataType"];
      } else {
        this.dataType = "Json";
      }
      if (this.dataType == "binary") {
        this.processor = new Cesium.TaskProcessor("VectorBinaryWorker", Number.POSITIVE_INFINITY);
      } else {
        this.processor = new Cesium.TaskProcessor("VectorWorker", Number.POSITIVE_INFINITY);
      }
      var canvas = document.createElement("canvas");
      this.image = canvas;
      this.ratio = 1;
      if (options.hasOwnProperty("ratio")) {
        this.ratio = options.ratio;
      }
      this.textureQueue = new TextureQueue_default(this.viewer.scene.context._gl);
      this.lineAtlas = new LineAtlas_default(256, 512);
      this.decimalLevel = 10;
      this.getDecimalLevel();
      this.viewer.scene.camera.moveEnd.addEventListener(this.getDecimalLevel.bind(this));
      this.changeStyleTilesMap = {};
      this.needDrawTilesMap = {};
      this.needDrawTiles = [];
      this.loadStyle(this.styleId).then(function() {
        this.ready = {
          value: true
        };
        this._readyPromise.resolve(true);
      }.bind(this));
      this.changStylePromise = [];
    }
    updateUrl(url) {
      this.options.url = url;
      let resource = Resource11.createIfNeeded(this.options.url);
      let style = this.options.style;
      let tileMatrixSetID = this.options.tileMatrixSetID;
      if (url.indexOf("{") >= 0) {
        let templateValues = {
          style,
          Style: style,
          TileMatrixSet: tileMatrixSetID
        };
        resource.setTemplateValues(templateValues);
        this._useKvp = false;
      } else {
        resource.setQueryParameters(defaultParameters8);
        this._useKvp = true;
      }
      this._resource = resource;
      if (this.options.hasOwnProperty("serverName") && this.options.hasOwnProperty("styleId") && this.options.hasOwnProperty("host")) {
        this.host = this.options.host;
        this.styleId = this.options.styleId;
        this.serverName = this.options.serverName;
      } else {
        this.parseUrl(this.options.url);
      }
      this._readyPromise = defer14();
      this.ready = {
        value: false
      };
      this.loadStyle(this.styleId).then(function() {
        this.ready = {
          value: true
        };
        this._readyPromise.resolve(true);
        this.cache = {};
        this.textureQueue.empty();
        this.redraw();
      }.bind(this));
    }
    redraw() {
      let layers = this.viewer.imageryLayers._layers;
      let imagerLayer = null;
      let index = -1;
      for (let i = 0; i < layers.length; i++) {
        let layer = layers[i];
        if (layer.imageryProvider == this) {
          imagerLayer = layer;
          index = i;
        }
      }
      if (imagerLayer) {
        this.viewer.imageryLayers.layerShownOrHidden.raiseEvent(
          imagerLayer,
          index,
          false
        );
        this.viewer.imageryLayers.layerShownOrHidden.raiseEvent(
          imagerLayer,
          index,
          true
        );
      }
    }
    updateStyle(styleId) {
      this.loadStyle(styleId).then(function() {
        this.styleId = styleId;
      }.bind(this));
    }
    draw(tilesToRender) {
      if (this.changStylePromise.length > 0) {
        return;
      }
      let renderTileMap = this.getRenderTileMap(tilesToRender);
      for (let name2 in renderTileMap) {
        let tile = this.cache[name2];
        if (tile) {
          let styleLevel = tile.level;
          let key2 = tile.name + "_" + this._zoom + "_" + styleLevel;
          if (tile.styleId != this.styleId) {
            let promise = this.changeStyle(tile, styleLevel, key2);
            this.changStylePromise.push(promise);
            tile.styleId = this.styleId;
          } else {
            let texture = this.textureQueue.getOne(tile.name, this._zoom, styleLevel);
            if (!texture) {
              if (this.needDrawTilesMap[key2]) {
                continue;
              }
              this.needDrawTilesMap[key2] = true;
              if (styleLevel != tile.level) {
                this.changeStyle(tile, styleLevel, key2);
              } else {
                this.needDrawTiles.push(tile);
              }
            }
          }
        }
      }
      if (this.changStylePromise.length > 0) {
        Promise.all(this.changStylePromise).then(function() {
          for (let i = 0; i < this.needDrawTiles.length; i++) {
            this.textureQueue.remove(this.needDrawTiles[i].name);
          }
          this.changStylePromise = [];
          DrawTilesFboVector_default(this, this.needDrawTiles, this.needDrawTilesMap, null, true);
        }.bind(this));
        return;
      }
      DrawTilesFboVector_default(this, this.needDrawTiles, this.needDrawTilesMap, null);
    }
    getStyleLevel() {
      let z2 = Math.round(this.viewer.camera.getLevel()) - 1;
      let labels = this._tileMatrixLabels;
      let styleLevel = defined18(labels) ? labels[z2] : z2.toString();
      return styleLevel;
    }
    changeStyle(tile, styleLevel, key2) {
      if (this.changeStyleTilesMap[key2]) {
        return;
      }
      this.changeStyleTilesMap[key2] = true;
      let promise = this.processor.scheduleTask({
        changeStyle: true,
        needDecode: this.options.needDecode,
        level: styleLevel,
        tileData: tile.tileData,
        filterLayerId: this.options.filterLayerId,
        dataType: this.dataType
      });
      promise.then(function(tile2, key3, buckets) {
        this.createBuffer(buckets);
        tile2.buckets = buckets;
        this.needDrawTiles.push(tile2);
        delete this.changeStyleTilesMap[key3];
      }.bind(this, tile, key2), function(key3, error) {
        delete this.changeStyleTilesMap[key3];
      }.bind(this, key2));
      return promise;
    }
    getRenderTileMap(renderTiles) {
      let renderTileMap = {};
      let labels = this._tileMatrixLabels;
      for (let i = 0; i < renderTiles.length; i++) {
        let tileImagerys = renderTiles[i].data.imagery;
        for (let j = 0; j < tileImagerys.length; j++) {
          let tileImagery = tileImagerys[j];
          let imagery = tileImagery.readyImagery;
          if (imagery && imagery.imageryLayer._imageryProvider.id == this.id) {
            let level = defined18(labels) ? labels[imagery.level] : imagery.level;
            let key2 = imagery.x + "_" + imagery.y + "_" + level;
            renderTileMap[key2] = true;
          }
        }
      }
      return renderTileMap;
    }
    parseUrl(url) {
      let urlParts = url.split("?");
      let urlPartOne = urlParts[0].split("/mapserver/");
      this.host = urlPartOne[0];
      if (this._subdomains.length > 0) {
        this.host = this.host.replace("{s}", this._subdomains[0]);
      }
      this.serverName = urlPartOne[1].split("/")[1];
      this.queryParam = urlParts[1];
      let params2 = this.queryParam.split("&");
      for (let i = 0; i < params2.length; i++) {
        let param = params2[i];
        let keyValue = param.split("=");
        if (keyValue[0] == "styleId") {
          this.styleId = keyValue[1];
        }
        if (keyValue[0] == "return_type") {
          this.return_type = keyValue[1];
        }
      }
    }
    loadStyle(styleId) {
      let promises = [];
      let styleUrl = this.host + "/mapserver/styleInfo/" + this.serverName + "/" + styleId + "/layer/style.js?" + Math.random();
      let resource = Resource11.createIfNeeded(styleUrl);
      let promise1 = resource.fetchText();
      promises.push(promise1);
      let promise2 = null;
      if (this.dataType == "binary") {
        let styleUrl2 = this.host + "/mapserver/serverInfo/" + this.serverName + ".json?" + Math.random();
        let resource2 = Resource11.createIfNeeded(styleUrl2);
        promise2 = resource2.fetchJson();
        promises.push(promise2);
      }
      let deferred = defer14();
      Promise.all(promises).then(function(result) {
        let styleStr = result[0];
        let results = result[1];
        let options = {
          init: true,
          styleStr,
          tileSize: this._tileWidth,
          return_type: this.return_type
        };
        if (results && results.layerMap) {
          this.serverInfo = {};
          this.layerFieldMap = {};
          for (let key2 in results.layerMap) {
            this.serverInfo[key2] = {
              geometryType: results.layerMap[key2].geometryType,
              fieldsConfig: results.layerMap[key2].fields
            };
            if (!this.layerFieldMap[key2]) {
              this.layerFieldMap[key2] = results.layerMap[key2].fields.length;
            }
          }
          options.serverInfo = this.serverInfo;
          options.layerFieldMap = this.layerFieldMap;
        }
        let promise = this.processor.scheduleTask(options);
        promise.then(function() {
          deferred.resolve();
        });
      }.bind(this));
      return deferred.promise;
    }
    requestImageNow(imageryProvider, col, row, level, request, interval) {
      var labels = imageryProvider._tileMatrixLabels;
      var tileMatrix = defined18(labels) ? labels[level] : level.toString();
      var subdomains = imageryProvider._subdomains;
      var staticDimensions = imageryProvider._dimensions;
      var dynamicIntervalData = defined18(interval) ? interval.data : void 0;
      var resource;
      if (!imageryProvider._useKvp) {
        var templateValues = {
          z: tileMatrix,
          y: row.toString(),
          x: col.toString(),
          s: subdomains[(col + row + level) % subdomains.length]
        };
        resource = imageryProvider._resource.getDerivedResource({
          request
        });
        resource.setTemplateValues(templateValues);
        if (defined18(staticDimensions)) {
          resource.setTemplateValues(staticDimensions);
        }
        if (defined18(dynamicIntervalData)) {
          resource.setTemplateValues(dynamicIntervalData);
        }
      } else {
        var query = {};
        query.tilematrix = tileMatrix;
        query.layer = imageryProvider._layer;
        query.style = imageryProvider._style;
        query.tilerow = row;
        query.tilecol = col;
        query.tilematrixset = imageryProvider._tileMatrixSetID;
        query.format = imageryProvider._format;
        if (defined18(staticDimensions)) {
          query = combine9(query, staticDimensions);
        }
        if (defined18(dynamicIntervalData)) {
          query = combine9(query, dynamicIntervalData);
        }
        resource = imageryProvider._resource.getDerivedResource({
          queryParameters: query,
          request
        });
      }
      var deferred = defer14();
      let xyz = { x: col, y: row, z: level };
      let tileLevel = resource._templateValues.z;
      let cameraLevel = this.viewer.camera.getLevel();
      if (tileLevel < this.showLevel) {
        deferred.reject();
        return deferred.promise;
      }
      let success = this.requestJsonData(deferred, imageryProvider, resource, xyz, request);
      if (!success) {
        return void 0;
      }
      return deferred.promise;
    }
    requestJsonData(deferred, imageryProvider, url, xyz, request) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let z2 = xyz.z;
      let level = url._templateValues.z;
      let name2 = x3 + "_" + y3 + "_" + level;
      let vectorTile = this.cache[name2];
      if (vectorTile) {
        deferred.resolve({ isTexture: true, texture: vectorTile.texture });
        return deferred;
      }
      let promise = this.processor.scheduleTask({
        url: url.url,
        needDecode: this.options.needDecode,
        level,
        filterLayerId: this.options.filterLayerId
      });
      promise.then(function(deferred2, xyz2, level2, request2, url2, results) {
        if (results == true) {
          request2.state = RequestState7.CANCELLED;
          deferred2.reject();
          return;
        }
        this.jsonPromiseResult(deferred2, xyz2, level2, results);
      }.bind(this, deferred, xyz, level, request, url.url), function(deferred2, error) {
        deferred2.reject();
      }.bind(this, deferred));
      return true;
    }
    jsonPromiseResult(deferred, xyz, level, results) {
      let x3 = xyz.x;
      let y3 = xyz.y;
      let buckets = results.buckets;
      let tileData = results.tileData;
      let name2 = x3 + "_" + y3 + "_" + level;
      this.createBuffer(buckets);
      let _texture = this.drawFbo(buckets, name2, level);
      let texture = { _target: 3553, _texture, destroy: this.destroyTexture };
      let vectorTile = new VectorTile_default(name2, level, tileData, buckets, texture);
      vectorTile.styleId = this.styleId;
      this.cache[name2] = vectorTile;
      deferred.resolve({ isTexture: true, texture });
    }
    destroyTexture() {
    }
    drawFbo(buckets, key2, level) {
      return DrawFboVector_default(this, buckets, key2, level);
    }
    createBuffer(bucktes) {
      for (let i = 0; i < bucktes.length; i++) {
        let bucket = bucktes[i];
        if (bucket.type == "fill") {
          FillBucket.createBuffer(bucket);
        }
        if (bucket.type == "line") {
          LineBucket.createBuffer(bucket);
        }
      }
    }
    get url() {
      return this._resource.url;
    }
    get proxy() {
      return this._resource.proxy;
    }
    get tileWidth() {
      return this._tileWidth;
    }
    get tileHeight() {
      return this._tileHeight;
    }
    get maximumLevel() {
      return this._maximumLevel;
    }
    get minimumLevel() {
      return this._minimumLevel;
    }
    get tilingScheme() {
      return this._tilingScheme;
    }
    get rectangle() {
      return this._rectangle;
    }
    get tileDiscardPolicy() {
      return this._tileDiscardPolicy;
    }
    get errorEvent() {
      return this._errorEvent;
    }
    get format() {
      return this._format;
    }
    get readyPromise() {
      return this._readyPromise;
    }
    get credit() {
      return this._credit;
    }
    get hasAlphaChannel() {
      return true;
    }
    get clock() {
      return this._timeDynamicImagery.clock;
    }
    set clock(value) {
      this._timeDynamicImagery.clock = value;
    }
    get times() {
      return this._timeDynamicImagery.times;
    }
    set times(value) {
      this._timeDynamicImagery.times = value;
    }
    get dimensions() {
      return this._dimensions;
    }
    set dimensions(value) {
      if (this._dimensions !== value) {
        this._dimensions = value;
        if (defined18(this._reload)) {
          this._reload();
        }
      }
    }
    getTileCredits(x3, y3, level) {
      return void 0;
    }
    requestImage(x3, y3, level, request) {
      var result;
      var timeDynamicImagery = this._timeDynamicImagery;
      var currentInterval;
      if (defined18(timeDynamicImagery)) {
        currentInterval = timeDynamicImagery.currentInterval;
        result = timeDynamicImagery.getFromCache(x3, y3, level, request);
      }
      if (!defined18(result)) {
        result = this.requestImageNow(this, x3, y3, level, request, currentInterval);
      }
      if (defined18(result) && defined18(timeDynamicImagery)) {
        timeDynamicImagery.checkApproachingInterval(x3, y3, level, request);
      }
      return result;
    }
    pickFeatures(x3, y3, level, longitude, latitude) {
      return void 0;
    }
    destroy() {
      this.viewer.scene.camera.moveEnd.removeEventListener(this.getDecimalLevel.bind(this));
      for (let key2 in this.cache) {
        let tile = this.cache[key2];
        tile.destroy();
      }
      this.cache = {};
    }
    removeImageryFromCache(x3, y3, z2) {
      let labels = this._tileMatrixLabels;
      let level = defined18(labels) ? labels[z2] : z2;
      let key2 = x3 + "_" + y3 + "_" + level;
      let tile = this.cache[key2];
      if (tile) {
        tile.destroy();
        this.textureQueue.remove(tile.name);
        delete this.cache[key2];
      }
    }
    useProgram(name2) {
      return ProgramFactory_default.createProgram(this.viewer.scene.context._gl, name2);
    }
    getTexture(imagery) {
      let z2 = imagery.level;
      let labels = this._tileMatrixLabels;
      let tileMatrix = defined18(labels) ? labels[z2] : z2.toString();
      let key2 = imagery.x + "_" + imagery.y + "_" + tileMatrix;
      let styleLevel = this.getStyleLevel();
      let _texture = this.textureQueue.get(key2, this._zoom, styleLevel);
      if (_texture) {
        let texture = { _target: 3553, _texture, destroy: this.destroyTexture };
        return texture;
      }
      return null;
    }
    getDecimalLevel() {
      let scale = 1;
      let decimalLevel = this.decimalLevel;
      let _zoom = this.viewer.camera.getLevel();
      let arr2 = _zoom.toString().split(".");
      let a2 = arr2[0];
      let b = "0." + arr2[1];
      a2 = Number(a2);
      let currLevel = a2;
      b = Number(b);
      if (b) {
        let decimal = Math.round(b * decimalLevel) / decimalLevel;
        currLevel = currLevel + decimal;
        scale = scale + decimal;
      }
      this.zoom = a2;
      this._zoom = currLevel;
      this.scale = scale;
    }
  };
  var VectorTileServiceImageryProvider_default = VectorTileServiceImageryProvider;

  // Source/custom/layer/wmts/WebMapTileServiceImageryProvider.js
  var combine10 = Cesium.combine;
  var Credit11 = Cesium.Credit;
  var defaultValue15 = Cesium.defaultValue;
  var defined19 = Cesium.defined;
  var DeveloperError13 = Cesium.DeveloperError;
  var Event12 = Cesium.Event;
  var Rectangle9 = Cesium.Rectangle;
  var Resource12 = Cesium.Resource;
  var WebMercatorTilingScheme10 = Cesium.WebMercatorTilingScheme;
  var ImageryProvider6 = Cesium.ImageryProvider;
  var TimeDynamicImagery9 = Cesium.TimeDynamicImagery;
  var defaultParameters9 = Object.freeze({
    service: "WMTS",
    version: "1.0.0",
    request: "GetTile"
  });
  function WebMapTileServiceImageryProvider(viewer3, options) {
    this.viewer = viewer3;
    options = defaultValue15(options, defaultValue15.EMPTY_OBJECT);
    if (!defined19(options.url)) {
      throw new DeveloperError13("options.url is required.");
    }
    if (!defined19(options.layer)) {
      throw new DeveloperError13("options.layer is required.");
    }
    if (!defined19(options.style)) {
      throw new DeveloperError13("options.style is required.");
    }
    if (!defined19(options.tileMatrixSetID)) {
      throw new DeveloperError13("options.tileMatrixSetID is required.");
    }
    if (defined19(options.times) && !defined19(options.clock)) {
      throw new DeveloperError13("options.times was specified, so options.clock is required.");
    }
    if (options.hasOwnProperty("hostUrl")) {
      var urlArr = options.url.split("mapserver");
      if (urlArr.length == 2) {
        options.url = options.hostUrl + "/" + urlArr[1];
      }
    }
    var resource = Resource12.createIfNeeded(options.url);
    var style = options.style;
    var tileMatrixSetID = options.tileMatrixSetID;
    var url = resource.url;
    if (url.indexOf("{") >= 0) {
      var templateValues = {
        style,
        Style: style,
        TileMatrixSet: tileMatrixSetID
      };
      resource.setTemplateValues(templateValues);
      this._useKvp = false;
    } else {
      resource.setQueryParameters(defaultParameters9);
      this._useKvp = true;
    }
    this._resource = resource;
    this._layer = options.layer;
    this._style = style;
    this._tileMatrixSetID = tileMatrixSetID;
    this._tileMatrixLabels = options.tileMatrixLabels;
    this._format = defaultValue15(options.format, "image/jpeg");
    this._tileDiscardPolicy = options.tileDiscardPolicy;
    this._tilingScheme = defined19(options.tilingScheme) ? options.tilingScheme : new WebMercatorTilingScheme10({ ellipsoid: options.ellipsoid });
    this._tileWidth = defaultValue15(options.tileWidth, 256);
    this._tileHeight = defaultValue15(options.tileHeight, 256);
    this._minimumLevel = defaultValue15(options.minimumLevel, 0);
    this._maximumLevel = options.maximumLevel;
    this._rectangle = defaultValue15(options.rectangle, this._tilingScheme.rectangle);
    this._dimensions = options.dimensions;
    this.isDrawNow = defaultValue15(options.isDrawNow, false);
    if (this.isDrawNow == false) {
      this.requestPromises = [];
    }
    var that = this;
    this._reload = void 0;
    if (defined19(options.times)) {
      this._timeDynamicImagery = new TimeDynamicImagery9({
        clock: options.clock,
        times: options.times,
        requestImageFunction: function(x3, y3, level, request, interval) {
          return requestImage2(that, x3, y3, level, request, interval);
        },
        reloadFunction: function() {
          if (defined19(that._reload)) {
            that._reload();
          }
        }
      });
    }
    this._readyPromise = Promise.resolve(true);
    var swTile = this._tilingScheme.positionToTileXY(Rectangle9.southwest(this._rectangle), this._minimumLevel);
    var neTile = this._tilingScheme.positionToTileXY(Rectangle9.northeast(this._rectangle), this._minimumLevel);
    var tileCount = (Math.abs(neTile.x - swTile.x) + 1) * (Math.abs(neTile.y - swTile.y) + 1);
    if (tileCount > 4) {
      throw new DeveloperError13("The imagery provider's rectangle and minimumLevel indicate that there are " + tileCount + " tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.");
    }
    this._errorEvent = new Event12();
    var credit = options.credit;
    this._credit = typeof credit === "string" ? new Credit11(credit) : credit;
    this._subdomains = options.subdomains;
    if (Array.isArray(this._subdomains)) {
      this._subdomains = this._subdomains.slice();
    } else if (defined19(this._subdomains) && this._subdomains.length > 0) {
      this._subdomains = this._subdomains.split("");
    } else {
      this._subdomains = ["a", "b", "c"];
    }
    if (!options.highlightLayer) {
      this.viewer.imageryLayers.layerAdded.addEventListener(WebMapTileServiceImageryProvider.prototype._onLayerAdded, this);
      this.viewer.imageryLayers.layerRemoved.addEventListener(WebMapTileServiceImageryProvider.prototype._onLayerRemoved, this);
      this.viewer.imageryLayers.layerMoved.addEventListener(WebMapTileServiceImageryProvider.prototype._onLayerMoved, this);
    }
    this.options = options;
    this.sourceUrl = options.url.split("&control")[0];
    this.gxyzUtil = new GXYZUtil_default();
    this.gxyzUtil.tileSize = this.tilesize;
    this.gxyzUtil.parseUrl(options.url);
  }
  function requestImage2(imageryProvider, col, row, level, request, interval) {
    var labels = imageryProvider._tileMatrixLabels;
    var tileMatrix = defined19(labels) ? labels[level] : level.toString();
    var subdomains = imageryProvider._subdomains;
    var staticDimensions = imageryProvider._dimensions;
    var dynamicIntervalData = defined19(interval) ? interval.data : void 0;
    var resource;
    if (!imageryProvider._useKvp) {
      var templateValues = {
        TileMatrix: tileMatrix,
        TileRow: row.toString(),
        TileCol: col.toString(),
        s: subdomains[(col + row + level) % subdomains.length]
      };
      resource = imageryProvider._resource.getDerivedResource({
        request
      });
      resource.setTemplateValues(templateValues);
      if (defined19(staticDimensions)) {
        resource.setTemplateValues(staticDimensions);
      }
      if (defined19(dynamicIntervalData)) {
        resource.setTemplateValues(dynamicIntervalData);
      }
    } else {
      var query = {};
      query.tilematrix = tileMatrix;
      query.layer = imageryProvider._layer;
      query.style = imageryProvider._style;
      query.tilerow = row;
      query.tilecol = col;
      query.tilematrixset = imageryProvider._tileMatrixSetID;
      query.format = imageryProvider._format;
      if (defined19(staticDimensions)) {
        query = combine10(query, staticDimensions);
      }
      if (defined19(dynamicIntervalData)) {
        query = combine10(query, dynamicIntervalData);
      }
      resource = imageryProvider._resource.getDerivedResource({
        queryParameters: query,
        request
      });
    }
    var templateValuesTemp = resource.templateValues;
    return ImageryProvider6.loadImage(imageryProvider, resource);
  }
  Object.defineProperties(WebMapTileServiceImageryProvider.prototype, {
    url: {
      get: function() {
        return this._resource.url;
      }
    },
    proxy: {
      get: function() {
        return this._resource.proxy;
      }
    },
    tileWidth: {
      get: function() {
        return this._tileWidth;
      }
    },
    tileHeight: {
      get: function() {
        return this._tileHeight;
      }
    },
    maximumLevel: {
      get: function() {
        return this._maximumLevel;
      }
    },
    minimumLevel: {
      get: function() {
        return this._minimumLevel;
      }
    },
    tilingScheme: {
      get: function() {
        return this._tilingScheme;
      }
    },
    rectangle: {
      get: function() {
        return this._rectangle;
      }
    },
    tileDiscardPolicy: {
      get: function() {
        return this._tileDiscardPolicy;
      }
    },
    errorEvent: {
      get: function() {
        return this._errorEvent;
      }
    },
    format: {
      get: function() {
        return this._format;
      }
    },
    ready: {
      value: true
    },
    readyPromise: {
      get: function() {
        return this._readyPromise;
      }
    },
    credit: {
      get: function() {
        return this._credit;
      }
    },
    hasAlphaChannel: {
      get: function() {
        return true;
      }
    },
    clock: {
      get: function() {
        return this._timeDynamicImagery.clock;
      },
      set: function(value) {
        this._timeDynamicImagery.clock = value;
      }
    },
    times: {
      get: function() {
        return this._timeDynamicImagery.times;
      },
      set: function(value) {
        this._timeDynamicImagery.times = value;
      }
    },
    dimensions: {
      get: function() {
        return this._dimensions;
      },
      set: function(value) {
        if (this._dimensions !== value) {
          this._dimensions = value;
          if (defined19(this._reload)) {
            this._reload();
          }
        }
      }
    }
  });
  WebMapTileServiceImageryProvider.prototype.getTileCredits = function(x3, y3, level) {
    return void 0;
  };
  WebMapTileServiceImageryProvider.prototype.requestImage = function(x3, y3, level, request) {
    var result;
    var timeDynamicImagery = this._timeDynamicImagery;
    var currentInterval;
    if (defined19(timeDynamicImagery)) {
      currentInterval = timeDynamicImagery.currentInterval;
      result = timeDynamicImagery.getFromCache(x3, y3, level, request);
    }
    if (!defined19(result)) {
      result = requestImage2(this, x3, y3, level, request, currentInterval);
    }
    if (defined19(result) && defined19(timeDynamicImagery)) {
      timeDynamicImagery.checkApproachingInterval(x3, y3, level, request);
    }
    return result;
  };
  WebMapTileServiceImageryProvider.prototype.pickFeatures = function(x3, y3, level, longitude, latitude) {
    return void 0;
  };
  WebMapTileServiceImageryProvider.prototype._onLayerAdded = function(layer, index) {
    if (layer.imageryProvider != this) {
      return;
    }
    this.index = index;
  };
  WebMapTileServiceImageryProvider.prototype._onLayerRemoved = function(layer, index) {
    if (layer.imageryProvider != this) {
      return;
    }
    this.cancelHighlight();
  };
  WebMapTileServiceImageryProvider.prototype._onLayerMoved = function(layer, newIndex, oldIndex) {
    if (layer.imageryProvider != this) {
      return;
    }
    this.index = newIndex;
  };
  WebMapTileServiceImageryProvider.prototype.setFilter = function(filter) {
    this.isSetIngFilter = true;
    if (!filter || filter.layers.length == 0 && filter.order.length == 0) {
      this.isSetIngFilter = false;
      this.controlId = null;
      this.control = null;
      this.UpdateUrl(this.sourceUrl);
      this.redraw();
      return;
    }
    this.gxyzUtil.setFilter(filter, function(result) {
      this.isSetIngFilter = false;
      if (result.isIE) {
        this.controlId = result.id;
        let url = this.sourceUrl + "&controlId=" + result.id;
        this.UpdateUrl(url);
        this.redraw();
      } else {
        this.control = result.id;
        let url = this.sourceUrl + "&control=" + result.id;
        this.UpdateUrl(url);
        this.redraw();
      }
    }.bind(this));
  }, WebMapTileServiceImageryProvider.prototype.UpdateUrl = function(url) {
    this.options.url = url;
    var resource = Resource12.createIfNeeded(this.options.url);
    var style = this.options.style;
    var tileMatrixSetID = this.options.tileMatrixSetID;
    var url = resource.url;
    if (url.indexOf("{") >= 0) {
      var templateValues = {
        style,
        Style: style,
        TileMatrixSet: tileMatrixSetID
      };
      resource.setTemplateValues(templateValues);
      this._useKvp = false;
    } else {
      resource.setQueryParameters(defaultParameters9);
      this._useKvp = true;
    }
    this._resource = resource;
  };
  WebMapTileServiceImageryProvider.prototype.redraw = function() {
    let layers = this.viewer.imageryLayers._layers;
    let imagerLayer = null;
    let index = -1;
    for (let i = 0; i < layers.length; i++) {
      let layer = layers[i];
      if (layer.imageryProvider == this) {
        imagerLayer = layer;
        index = i;
      }
    }
    if (imagerLayer) {
      this.viewer.imageryLayers.layerShownOrHidden.raiseEvent(
        imagerLayer,
        index,
        false
      );
      this.viewer.imageryLayers.layerShownOrHidden.raiseEvent(
        imagerLayer,
        index,
        true
      );
    }
  };
  WebMapTileServiceImageryProvider.prototype.highlightByFilter = function(filter) {
    if (filter.layers.length == 0) {
      return;
    }
    if (!this.highlightLayer) {
      let options = Object.assign({ highlightLayer: true }, this.options);
      this.highlightProvider = new WebMapTileServiceImageryProvider(this.viewer, options);
      this.highlightLayer = new Cesium.ImageryLayer(this.highlightProvider);
      this.viewer.imageryLayers.add(this.highlightLayer, this.index + 1);
    }
    this.highlightProvider.setFilter(filter);
  };
  WebMapTileServiceImageryProvider.prototype.cancelHighlight = function() {
    if (this.highlightLayer) {
      this.viewer.imageryLayers.remove(this.highlightLayer);
      this.highlightLayer = null;
    }
  };
  WebMapTileServiceImageryProvider.prototype.highlightFeatures = function(layerFeatures, style) {
    var filter = this.gxyzUtil.CreateHighlightFilter(layerFeatures, style);
    if (filter.layers.length == 0) {
      return;
    }
    if (!this.highlightLayer) {
      let options = Object.assign({ highlightLayer: true }, this.options);
      this.highlightProvider = new WebMapTileServiceImageryProvider(this.viewer, options);
      this.highlightLayer = new Cesium.ImageryLayer(this.highlightProvider);
      this.viewer.imageryLayers.add(this.highlightLayer, this.index + 1);
    }
    this.highlightProvider.setFilter(filter);
  };
  var WebMapTileServiceImageryProvider_default = WebMapTileServiceImageryProvider;

  // Source/custom/material/dynamicGlow/DynamicGlowMaterialProperty.js
  var DynamicGlowMaterialProperty = class {
    constructor(options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
      this._definitionChanged = new Cesium.Event();
      this._image = options.image || options.url;
      this._color = Cesium.defaultValue(Cesium.Color.fromCssColorString(options.color), Cesium.Color.RED);
      this._axisY = Cesium.defaultValue(options.axisY, false);
      this._speed = Cesium.defaultValue(options.speed, 10);
      this._repeat = Cesium.defaultValue(options.repeat, new Cesium.Cartesian2(1, 1));
    }
    get isConstant() {
      return false;
    }
    get definitionChanged() {
      return this._definitionChanged;
    }
    getType() {
      return "DynamicGlow";
    }
    getValue(time, result) {
      if (!Cesium.defined(result)) {
        result = {};
      }
      result.image = this._image;
      result.color = this.getCesiumValue(this._color, Cesium.Color, time);
      result.repeat = this.getCesiumValue(this._repeat, Cesium.Cartesian2, time);
      result.axisY = this._axisY;
      result.speed = this.getCesiumValue(this._speed, Number, time);
      return result;
    }
    getCesiumValue(obj, ClasName, time) {
      if (!obj) {
        return obj;
      }
      if (ClasName) {
        if (obj instanceof ClasName) {
          return obj;
        } else if (obj._value && obj._value instanceof ClasName) {
          return obj._value;
        }
      }
      if (typeof obj.getValue == "function") {
        return obj.getValue(time || Cesium.JulianDate.now());
      }
      return obj;
    }
    equals(other) {
      return this == other || other instanceof DynamicGlowMaterialProperty && Cesium.Property.equals(this._color, other._color) && Cesium.Property.equals(this._repeat, other._repeat) && this._image == other._image && this._axisY == other._axisY && this._speed == other._speed;
    }
  };
  var DynamicGlowType = "DynamicGlow";
  var DynamicGlowSource = `czm_material czm_getMaterial(czm_materialInput materialInput)
{
    czm_material material = czm_getDefaultMaterial(materialInput);
    vec2 st = repeat * materialInput.st;
    vec4 colorImage = texture2D(image, vec2(fract((axisY?st.t:st.s) - speed*czm_frameNumber/1000.0), st.t));
    if(color.a == 0.0) {
    if(colorImage.rgb == vec3(1.0)){
        discard;
        }
        material.alpha = colorImage.a;
        material.diffuse = colorImage.rgb;
    }
    else {
        material.alpha = colorImage.a * color.a;
        material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb);
    }

    return material;
}`;
  Cesium.Material._materialCache.addMaterial(DynamicGlowType, {
    fabric: {
      type: DynamicGlowType,
      uniforms: {
        image: Cesium.Material.DefaultImageId,
        color: new Cesium.Color(1, 0, 0, 1),
        repeat: new Cesium.Cartesian2(1, 1),
        axisY: false,
        speed: 10
      },
      source: DynamicGlowSource
    },
    translucent: function() {
      return true;
    }
  });
  var DynamicGlowMaterialProperty_default = DynamicGlowMaterialProperty;

  // Source/custom/material/flowWaterMaterial/FlowWaterMaterialProperty.js
  var FlowWaterMaterialProperty = class {
    constructor(options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
      this._definitionChanged = new Cesium.Event();
      if (!options.WaveImage) {
        return;
      }
      this._WaveImage = options.WaveImage;
      this._wateralpha = Cesium.defaultValue(options.wateralpha, 0.7);
    }
    get isConstant() {
      return false;
    }
    get definitionChanged() {
      return this._definitionChanged;
    }
    getType() {
      return "FlowWater";
    }
    getValue(time, result) {
      if (!Cesium.defined(result)) {
        result = {};
      }
      result.WaveImage = this._WaveImage;
      result.wateralpha = this._wateralpha;
      return result;
    }
    getCesiumValue(obj, ClasName, time) {
      if (!obj) {
        return obj;
      }
      if (ClasName) {
        if (obj instanceof ClasName) {
          return obj;
        } else if (obj._value && obj._value instanceof ClasName) {
          return obj._value;
        }
      }
      if (typeof obj.getValue == "function") {
        return obj.getValue(time || Cesium.JulianDate.now());
      }
      return obj;
    }
    equals(other) {
      return this == other || other instanceof FlowWaterMaterialProperty && this._WaveImage == other._WaveImage && this._wateralpha == other._wateralpha;
    }
  };
  var FlowWaterType = "FlowWater";
  var FlowWaterSource = `
    float getMixValue(float cycle, inout float offset1, inout float offset2)
    {

        float mixval = cycle * 2.0;
        if(mixval > 1.0) mixval = 2.0 - mixval;
        offset1 = cycle;
        offset2 = mod(offset1 + .5, 1.0);
        return mixval;
    }

    float  getInterval(float _interval)
    {
        float time = czm_frameNumber;
        //\u95F4\u9694\u901F\u5EA6\uFF0C\u503C\u8D8A\u5927\uFF0C\u95F4\u9694\u65F6\u95F4\u8D8A\u957F\uFF1B\u503C\u8D8A\u5C0F\uFF0C\u95F4\u9694\u65F6\u95F4\u8D8A\u5927\uFF1B
        float cycle = mod(time, _interval)/_interval;   
        return cycle;
    }
 
    czm_material czm_getMaterial(czm_materialInput materialInput)
    { 
        //\u6C34\u6CE2\u65F6\u95F4
        float timeInterval=200.;
        float _WaveXSpeed=0.05;
        float _WaveYSpeed=0.05; 
        vec3 bottomColor=vec3(0.7451, 0.7686, 0.6471);
        float o1, o2 = 0.;
        float cycle = mod(czm_frameNumber, timeInterval)/timeInterval;
        float mv = getMixValue(cycle, o1, o2);
        float _time=getInterval(timeInterval);

        //\u5F80\u4E0B\u6D41
         vec2 xia_speed =vec2(-_WaveXSpeed, _WaveYSpeed);


        czm_material material = czm_getDefaultMaterial(materialInput); 

        vec3 bump1 = normalize(texture2D(WaveImage, fract(materialInput.st))).rgb; 
        vec3 bump2 = normalize(texture2D(WaveImage, fract(materialInput.st)-o1*xia_speed)).rgb; 
        //\u53C9\u4E58\u5F97\u5230\u6CD5\u7EBF\u5206\u91CF
        vec3 bumpnormaCross1 = normalize(cross(bump1, bump2));
        vec3 bump3 = normalize(texture2D(WaveImage, fract(materialInput.st))).rgb; 
        vec3 bump4 = normalize(texture2D(WaveImage, fract(materialInput.st)-o2*xia_speed)).rgb; 
        //\u53C9\u4E58\u5F97\u5230\u6CD5\u7EBF\u5206\u91CF\u5206\u91CF
        vec3 bumpnormaCross2 = normalize(cross(bump3, bump4));
        // //\u5F97\u5230\u65B0\u7684\u5206\u91CF,\u4FDD\u8BC1\u6C34\u6D41\u8FDE\u7EED
        vec3 bumpnormaCross=mix(bumpnormaCross2, bumpnormaCross1, mv);
       
        //opengl\u5149\u7167\u539F\u7406,\u4F20\u5165\u6CD5\u5411\u91CF
        float diffuseFactor=czm_getLambertDiffuse(czm_lightDirectionEC,bumpnormaCross);
        float specularFactor = czm_getSpecular(czm_lightDirectionEC, bumpnormaCross,normalize(materialInput.positionToEyeEC),10.0);
       
        
        diffuseFactor= pow(diffuseFactor, 2.)* 1.;
        
        vec4 blue = vec4(0., 69., 129., 0.) / 255.;
        vec4 orange = vec4(.7, .3, 0.1, 0.0);
        float wd = dot(bumpnormaCross, czm_lightDirectionEC);
        wd = max(0.0, wd);
        float wrp = 0.5;
        wd = (wd+wrp)/(1.+wrp);
        
        vec3 frescol = diffuseFactor*orange.rgb*0.4+blue.rgb*wd;

        material.diffuse=mix(bottomColor,frescol,0.3);
        material.normal=normalize(materialInput.tangentToEyeMatrix * bumpnormaCross);;
        material.specular=specularFactor;
        material.shininess=10.;
        material.alpha=wateralpha;
        return material;
    }
    `;
  Cesium.Material._materialCache.addMaterial(FlowWaterType, {
    fabric: {
      type: FlowWaterType,
      uniforms: {
        WaveImage: Cesium.Material.DefaultImageId,
        wateralpha: 0.7
      },
      source: FlowWaterSource
    },
    translucent: function() {
      return true;
    }
  });
  var FlowWaterMaterialProperty_default = FlowWaterMaterialProperty;

  // Source/custom/material/reflexWaterMaterial/ReflexWaterMaterialProperty.js
  var ReflexWaterMaterialProperty = class {
    constructor(options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
      this._definitionChanged = new Cesium.Event();
      if (!options.WaveImage) {
        return;
      }
      this._WaveImage = options.WaveImage;
      this._bottomImage = options.bottomImage;
      this._repeat = Cesium.defaultValue(options.repeat, new Cesium.Cartesian2(1, 1));
      this._RainState = Cesium.defaultValue(options.RainState, false);
      this._RainSize = Cesium.defaultValue(options.RainSize, 1);
      this._RainNoiseImage = options.RainNoiseImage;
      this._wateralpha = Cesium.defaultValue(options.wateralpha, 0.7);
      this._Vortex = Cesium.defaultValue(options.Vortex, false);
      this._FlowWater = options.FlowWater;
      this._FlowMapImage = options.FlowMapImage;
    }
    get isConstant() {
      return false;
    }
    get definitionChanged() {
      return this._definitionChanged;
    }
    getType() {
      return "ReflexWater";
    }
    getValue(time, result) {
      if (!Cesium.defined(result)) {
        result = {};
      }
      result.WaveImage = this._WaveImage;
      result.bottomImage = this._bottomImage;
      result.repeat = this.getCesiumValue(this._repeat, Cesium.Cartesian2, time);
      result.RainState = this._RainState;
      result.RainSize = this._RainSize;
      result.RainNoiseImage = this._RainNoiseImage;
      result.wateralpha = this._wateralpha;
      result.Vortex = this._Vortex;
      result.FlowWater = this._FlowWater;
      result.FlowMapImage = this._FlowMapImage;
      return result;
    }
    getCesiumValue(obj, ClasName, time) {
      if (!obj) {
        return obj;
      }
      if (ClasName) {
        if (obj instanceof ClasName) {
          return obj;
        } else if (obj._value && obj._value instanceof ClasName) {
          return obj._value;
        }
      }
      if (typeof obj.getValue == "function") {
        return obj.getValue(time || Cesium.JulianDate.now());
      }
      return obj;
    }
    equals(other) {
      return this == other || other instanceof ReflexWaterMaterialProperty && this._WaveImage == other._WaveImage && this._bottomImage == other._bottomImage && Cesium.Property.equals(this._repeat, other._repeat) && this._RainState == other._RainState && this._RainSize == other._RainSize && this._RainNoiseImage == other._RainNoiseImage && this._wateralpha == other._wateralpha && this._Vortex == other._Vortex && this._FlowWater == other._FlowWater && this._FlowMapImage == other._FlowMapImage;
    }
  };
  var ReflexWaterType = "ReflexWater";
  var ReflexWaterSource = `
    float hash( vec2 p ) {
        float h = dot(p,vec2(127.1,311.7));	
        return fract(sin(h)*43758.5453123);
    }
    float noise( in vec2 p ) {
        vec2 i = floor( p );
        vec2 f = fract( p );	
        vec2 u = f*f*(3.0-2.0*f);
        return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), 
                        hash( i + vec2(1.0,0.0) ), u.x),
                    mix( hash( i + vec2(0.0,1.0) ), 
                        hash( i + vec2(1.0,1.0) ), u.x), u.y);
    }

    float water(vec2 uv) {
        uv += noise(uv * .8);        
        vec2 wv = 1.0-abs(sin(uv)); 
        return (wv.x + wv.y) * .5;
    }
    float river(vec2 uv)
    {
        float s = 0.;
        const float levels = 4.;
        mat2 r;
        r[0] = vec2(0.4, 0.4);
        r[1] = vec2(-0.24, 0.27);
        for (int i = 1; i < 5; i++)
        {
            uv *= r;
            s += water(uv * vec2(i) * vec2(2.));
        }
        s /= (levels + 1.);
        return s;
    }
    vec3 seagrad(in vec2 uv, float bump, float t)
    {
        uv *= 100.;
        float hc = river(uv);
        vec2 off = vec2(3./t, 0.0);
        float hh = river(uv + off);
        float hv = river(uv + off.yx);
        
        vec3 h = normalize(vec3(bump, hh - hc, 0.)); 
        vec3 v = normalize(vec3(0., hv - hc, bump));
        return -normalize(cross(h, v));
    }


    float texNoise1( in vec3 x, float lod_bias )
    {   
        vec3 p = floor( x );
        vec3 f = fract( x );
        f = f * f * ( 3.0 - 2.0 * f );
        vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
        vec2 rg = texture2D(RainNoiseImage, fract(uv*(1./256.0))).yx;
        return mix( rg.x, rg.y, f.z );

    }

    vec4 BlendUnder(vec4 accum,vec4 col)
    {
        col = clamp( col, vec4( 0 ), vec4( 1 ) );   
        accum += vec4( col.rgb * col.a, col.a ) * ( 1.0 - accum.a );   
        return accum;
    }
    float getMixValue(float cycle, inout float offset1, inout float offset2)
    {

        float mixval = cycle * 2.0;
        if(mixval > 1.0) mixval = 2.0 - mixval;
        offset1 = cycle;
        offset2 = mod(offset1 + .5, 1.0);
        return mixval;
    }
    
    float  getInterval(float _interval)
    {
        float time = czm_frameNumber;
        //\u95F4\u9694\u901F\u5EA6\uFF0C\u503C\u8D8A\u5927\uFF0C\u95F4\u9694\u65F6\u95F4\u8D8A\u957F\uFF1B\u503C\u8D8A\u5C0F\uFF0C\u95F4\u9694\u65F6\u95F4\u8D8A\u5927\uFF1B
        float cycle = mod(time, _interval)/_interval;   
        return cycle;
    }


    vec4 getNoise( vec2 uv,sampler2D normalSampler,float time)
    {
        vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
        vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
        vec2 uv2 = uv / vec2( 897.0, 983.0 ) + vec2( time / 101.0, time / 97.0 );
        vec2 uv3 = uv / vec2( 991.0, 877.0 ) - vec2( time / 109.0, time / -113.0 );
        uv0 = fract(uv0);
        uv1 = fract(uv1);
        uv2 = fract(uv2);
        uv3 = fract(uv3);
        vec4 noise = texture2D( normalSampler, uv0 ) +
            texture2D( normalSampler, uv1 ) +
            texture2D( normalSampler, uv2 ) +
            texture2D( normalSampler, uv3 );
        return ((noise /4.0) - 0.5)*2.0;
	}
    czm_material czm_getMaterial(czm_materialInput materialInput)
    { 
        //\u6C34\u6CE2\u65F6\u95F4
        float timeInterval=200.;
        float _WaveXSpeed=0.05;
        float _WaveYSpeed=0.05; 
        vec3 waterColor = vec3(0.0196, 0.4235, 0.6431)*1.5;
        // vec3 bottomColor=vec3(0.7608, 0.8118, 0.5569);
        vec3 bottomColor=vec3(0.7451, 0.7686, 0.6471);
        float o1, o2 = 0.;
        float cycle = mod(czm_frameNumber, timeInterval)/timeInterval;
        float mv = getMixValue(cycle, o1, o2);
        float _time=getInterval(timeInterval);
        
        //\u6D41\u5411\u63A7\u5236
        
        //\u5F80\u4E0A\u6D41
        vec2 shang_speed = _time* vec2(_WaveXSpeed, -_WaveYSpeed);
        //\u5F80\u4E0B\u6D41
         vec2 xia_speed =vec2(-_WaveXSpeed, _WaveYSpeed);
        //\u5F80\u5DE6\u6D41
         vec2 zuo_speed = _time* vec2(_WaveXSpeed, _WaveYSpeed);
        //\u5F80\u53F3\u6D41
         vec2 you_speed = _time* vec2(-_WaveXSpeed, -_WaveYSpeed);


        czm_material material = czm_getDefaultMaterial(materialInput); 
        
        
        //  vec3 bottomColor =texture2D(bottomImage, materialInput.st.xy).rgb;//\u7EB9\u7406\u6620\u5C04
        //  vec3 bump1 = normalize(getNoise(materialInput.st*8000.-speed,WaveImage,czm_frameNumber)).rgb; 
        //  bump1= bump1.xyz * vec3(1.0, 1.0, (1.0 / 5.));
        //  vec3 bump2 = normalize(getNoise(materialInput.st*8000.+speed,WaveImage,czm_frameNumber)).rgb; 
        //  bump2=bump2.xyz * vec3(1.0, 1.0, (1.0 / 5.));
        //  vec3 bumpnormaCross =normalize(cross(bump1, bump2)); 
        

        vec3 bump1 = normalize(texture2D(WaveImage, fract(repeat*materialInput.st))).rgb; 
        vec3 bump2 = normalize(texture2D(WaveImage, fract(repeat*materialInput.st)-o1*xia_speed)).rgb; 
        //\u53C9\u4E58\u5F97\u5230\u6CD5\u7EBF\u5206\u91CF
        vec3 bumpnormaCross1 = normalize(cross(bump1, bump2));
        vec3 bump3 = normalize(texture2D(WaveImage, fract(repeat*materialInput.st))).rgb; 
        vec3 bump4 = normalize(texture2D(WaveImage, fract(repeat*materialInput.st)-o2*xia_speed)).rgb; 
        //\u53C9\u4E58\u5F97\u5230\u6CD5\u7EBF\u5206\u91CF\u5206\u91CF
        vec3 bumpnormaCross2 = normalize(cross(bump3, bump4));
        // //\u5F97\u5230\u65B0\u7684\u5206\u91CF,\u4FDD\u8BC1\u6C34\u6D41\u8FDE\u7EED
        vec3 bumpnormaCross=mix(bumpnormaCross2, bumpnormaCross1, mv);
       
        //opengl\u5149\u7167\u539F\u7406,\u4F20\u5165\u6CD5\u5411\u91CF
        float diffuseFactor=czm_getLambertDiffuse(czm_lightDirectionEC,bumpnormaCross);
        float specularFactor = czm_getSpecular(czm_lightDirectionEC, bumpnormaCross,normalize(materialInput.positionToEyeEC),10.0);
       
        
        diffuseFactor= pow(diffuseFactor, 2.)* 1.;
        
        vec4 blue = vec4(0., 69., 129., 0.) / 255.;
        vec4 orange = vec4(.7, .3, 0.1, 0.0);
        float wd = dot(bumpnormaCross, czm_lightDirectionEC);
        wd = max(0.0, wd);
        float wrp = 0.5;
        wd = (wd+wrp)/(1.+wrp);
        
        
        vec3 frescol = diffuseFactor*orange.rgb*0.4+blue.rgb*wd;

        // \u65CB\u6DA1
        float _flowtimeInterval=2000.;
        float _flowtime=getInterval(_flowtimeInterval);
        vec3 flowDir = texture2D(FlowMapImage, fract(vec2(1.2,1.2)*materialInput.st.xy)).rgb*vec3(4.0)-vec3(1.0);
        float phase0 = fract(_flowtime + 0.2) ;
        float phase1 = fract(_flowtime);
        vec3 color0 = texture2D(FlowWater, fract(materialInput.st.xy + vec2(phase0) * flowDir.xy)).rgb;
        vec3 color1 = texture2D(FlowWater, fract(materialInput.st.xy + vec2(phase1) * flowDir.xy)).rgb;
        float flowLerp =(abs(phase0 - 0.5)) * 2.0;
        vec3 finalCol = mix(color0, color1, flowLerp);

        vec3 mixTargetCol=mix(bottomColor,frescol,0.4);
        if(RainState)
        {
            vec3 uvw = materialInput.positionToEyeEC;
            uvw *= 0.2*1.0/RainSize;
            uvw.y += czm_frameNumber * 0.5;//\u901F\u5EA6
            float dens = texNoise1(uvw, 0.0 );
            dens = pow( dens, 5. );//\u5BC6\u5EA6
            dens=sin(dens);
            dens *= 0.4;
            mixTargetCol = BlendUnder( vec4(mixTargetCol,0.0), vec4( 1, 1, 1, dens )).xyz;

            if (Vortex) {
              mixTargetCol = mix(mixTargetCol,finalCol,0.5);
            }
        } 
        else {
          if (Vortex) {
            mixTargetCol = mix(mix(bottomColor,frescol,0.3),finalCol,0.9)*vec3(1.2);
          }
        }
        material.diffuse=mixTargetCol;
        material.normal=normalize(materialInput.tangentToEyeMatrix * bumpnormaCross);;
        material.specular=specularFactor;
        material.shininess=10.;
        material.alpha=wateralpha;
        return material;
    }
    `;
  Cesium.Material._materialCache.addMaterial(ReflexWaterType, {
    fabric: {
      type: ReflexWaterType,
      uniforms: {
        WaveImage: Cesium.Material.DefaultImageId,
        bottomImage: Cesium.Material.DefaultImageId,
        repeat: new Cesium.Cartesian2(1, 1),
        RainState: false,
        RainSize: 1,
        RainNoiseImage: Cesium.Material.DefaultImageId,
        wateralpha: 0.7,
        Vortex: false,
        FlowWater: Cesium.Material.DefaultImageId,
        FlowMapImage: Cesium.Material.DefaultImageId
      },
      source: ReflexWaterSource
    },
    translucent: function() {
      return true;
    }
  });
  var ReflexWaterMaterialProperty_default = ReflexWaterMaterialProperty;

  // Source/custom/material/rippleWaterMaterial/RippleWaterMaterialProperty.js
  var RippleWaterMaterialProperty = class {
    constructor(options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
      this._definitionChanged = new Cesium.Event();
      if (!options.RippleImg) {
        return;
      }
      this._RippleImg = options.RippleImg;
    }
    get isConstant() {
      return false;
    }
    get definitionChanged() {
      return this._definitionChanged;
    }
    getType() {
      return "RippleWater";
    }
    getValue(time, result) {
      if (!Cesium.defined(result)) {
        result = {};
      }
      result.RippleImg = this._RippleImg;
      return result;
    }
    getCesiumValue(obj, ClasName, time) {
      if (!obj) {
        return obj;
      }
      if (ClasName) {
        if (obj instanceof ClasName) {
          return obj;
        } else if (obj._value && obj._value instanceof ClasName) {
          return obj._value;
        }
      }
      if (typeof obj.getValue == "function") {
        return obj.getValue(time || Cesium.JulianDate.now());
      }
      return obj;
    }
    equals(other) {
      return this == other || other instanceof RippleWaterMaterialProperty && this._RippleImg == other._RippleImg;
    }
  };
  var RippleWaterType = "RippleWater";
  var RippleWaterSource = `
    #define MAX_RADIUS 2
    #define HASHSCALE1 .1
    #define HASHSCALE3 vec3(0.1,0.2,0.3)

    float getMixValue(float cycle, inout float offset1, inout float offset2)
    {

        float mixval = cycle * 2.0;
        if(mixval > 1.0) mixval = 2.0 - mixval;
        offset1 = cycle;
        offset2 = mod(offset1 + .5, 1.0);
        return mixval;
    }

    float  getInterval(float _interval)
    {
        float time = czm_frameNumber;
        //\u95F4\u9694\u901F\u5EA6\uFF0C\u503C\u8D8A\u5927\uFF0C\u95F4\u9694\u65F6\u95F4\u8D8A\u957F\uFF1B\u503C\u8D8A\u5C0F\uFF0C\u95F4\u9694\u65F6\u95F4\u8D8A\u5927\uFF1B
        float cycle = mod(time, _interval)/_interval;   
        return cycle;
    }
 
    float hash12(vec2 p)
    {
        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
        p3 += dot(p3, p3.yzx + 10.);
        return fract((p3.x + p3.y) * p3.z); 
    }

    vec2 hash22(vec2 p)
    {
        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);
        p3 += dot(p3, p3.yzx+20.);
        return fract((p3.xx+p3.yz)*p3.zy);

    }
    vec3 getRippleColor(float t,vec2 _uv,float tiling)
    {
        float LianyiTime=t;
        vec2 uv = _uv *tiling;
        vec2 p0 = floor(uv);
        vec2 circles = vec2(0.);
        for (int j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)
        {
            for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)
            {
                vec2 pi = p0 + vec2(i, j);
                vec2 p = pi + hash22(pi);

                float t = fract(0.05*LianyiTime + hash12(pi));
                vec2 v = p-uv;
                float d = length(v) - (float(MAX_RADIUS) + 1.)*t;

                float h = 1e-3;
                float d1 = d - h;
                float d2 = d + h;   
                float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);
                float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2); 
                circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));
            }
        }
        circles /= float((MAX_RADIUS*2+1)*(MAX_RADIUS*2+1));
        float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05*LianyiTime + 0.5)*2.-1.)));
        vec3 n = vec3(circles, sqrt(1. - dot(circles, circles)));
        vec3 _color = texture2D(RippleImg, _uv-intensity*n.xy).rgb;
        float nosie = 5.*pow(clamp(dot(n, normalize(vec3(1., 0.7, 0.5))), 0., 1.), 6.);
        _color = _color + nosie;
        return _color;

    }   
    czm_material czm_getMaterial(czm_materialInput materialInput)
    { 
        czm_material material = czm_getDefaultMaterial(materialInput); 
        float tiling = 20.;
        float LianyiTime = czm_frameNumber/5.;
        vec3 _color=getRippleColor(LianyiTime,materialInput.st,tiling);
    

        material.diffuse=_color;
        return material;
        }
    `;
  Cesium.Material._materialCache.addMaterial(RippleWaterType, {
    fabric: {
      type: RippleWaterType,
      uniforms: {
        RippleImg: Cesium.Material.DefaultImageId
      },
      source: RippleWaterSource
    },
    translucent: function() {
      return true;
    }
  });
  var RippleWaterMaterialProperty_default = RippleWaterMaterialProperty;

  // Source/custom/material/videoTranslucentMaterial/VideoTranslucentMaterialProperty.js
  var VideoTranslucentMaterialProperty = class {
    constructor(options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
      this._definitionChanged = new Cesium.Event();
      if (!options.video || options.translucentImage) {
        return;
      }
      this._video = options.video;
      this._translucentImage = options.translucentImage;
    }
    get isConstant() {
      return false;
    }
    get definitionChanged() {
      return this._definitionChanged;
    }
    getType() {
      return "VideoTranslucent";
    }
    getValue(time, result) {
      if (!Cesium.defined(result)) {
        result = {};
      }
      result.video = this._video;
      result.translucentImage = this._translucentImage;
      return result;
    }
    getCesiumValue(obj, ClasName, time) {
      if (!obj) {
        return obj;
      }
      if (ClasName) {
        if (obj instanceof ClasName) {
          return obj;
        } else if (obj._value && obj._value instanceof ClasName) {
          return obj._value;
        }
      }
      if (typeof obj.getValue == "function") {
        return obj.getValue(time || Cesium.JulianDate.now());
      }
      return obj;
    }
    equals(other) {
      return this == other || other instanceof VideoTranslucentMaterialProperty && this._video == other.video && this._translucentImage == other.translucentImage;
    }
  };
  var VideoTranslucentMaterialType = "VideoTranslucent";
  Cesium.Material._materialCache.addMaterial(VideoTranslucentMaterialType, {
    fabric: {
      type: VideoTranslucentMaterialType,
      uniforms: {
        video: Cesium.Material.DefaultImageId,
        translucentImage: Cesium.Material.DefaultImageId,
        repeat: new Cesium.Cartesian2(1, 1),
        color: new Cesium.Color(1, 1, 1, 1)
      },
      components: {
        diffuse: "texture2D(video, fract(repeat * materialInput.st)).rgb * color.rgb",
        alpha: "texture2D(video, fract(repeat * materialInput.st)).a * texture2D(translucentImage, fract(repeat * materialInput.st)).a * color.a"
      }
    },
    translucent: function(material) {
      return material.uniforms.color.alpha < 1;
    }
  });
  var VideoTranslucentMaterialProperty_default = VideoTranslucentMaterialProperty;

  // Source/custom/material/vortexWaterMaterial/VortexWaterMaterialProperty.js
  var VortexWaterMaterialProperty = class {
    constructor(options) {
      options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
      this._definitionChanged = new Cesium.Event();
      if (!options.VortexImg) {
        return;
      }
      this._WaveImage = options.WaveImage;
      this._FlowWater = options.FlowWater;
      this._FlowMapImage = options.FlowMapImage;
      this._wateralpha = Cesium.defaultValue(options.wateralpha, 0.7);
    }
    get isConstant() {
      return false;
    }
    get definitionChanged() {
      return this._definitionChanged;
    }
    getType() {
      return "VortexWater";
    }
    getValue(time, result) {
      if (!Cesium.defined(result)) {
        result = {};
      }
      result.WaveImage = this._WaveImage;
      result.FlowWater = this._FlowWater;
      result.FlowMapImage = this._FlowMapImage;
      result.wateralpha = this._wateralpha;
      return result;
    }
    getCesiumValue(obj, ClasName, time) {
      if (!obj) {
        return obj;
      }
      if (ClasName) {
        if (obj instanceof ClasName) {
          return obj;
        } else if (obj._value && obj._value instanceof ClasName) {
          return obj._value;
        }
      }
      if (typeof obj.getValue == "function") {
        return obj.getValue(time || Cesium.JulianDate.now());
      }
      return obj;
    }
    equals(other) {
      return this == other || other instanceof VortexWaterMaterialProperty && this._WaveImage == other._WaveImage && this._FlowWater == other._FlowWater && this._FlowMapImage == other._FlowMapImage && this._wateralpha == other._wateralpha;
    }
  };
  var VortexWaterType = "VortexWater";
  var VortexWaterSource = `
  float getMixValue(float cycle, inout float offset1, inout float offset2)
    {

        float mixval = cycle * 2.0;
        if(mixval > 1.0) mixval = 2.0 - mixval;
        offset1 = cycle;
        offset2 = mod(offset1 + .5, 1.0);
        return mixval;
    }

    float  getInterval(float _interval)
    {
        float time = czm_frameNumber;
        //\u95F4\u9694\u901F\u5EA6\uFF0C\u503C\u8D8A\u5927\uFF0C\u95F4\u9694\u65F6\u95F4\u8D8A\u957F\uFF1B\u503C\u8D8A\u5C0F\uFF0C\u95F4\u9694\u65F6\u95F4\u8D8A\u5927\uFF1B
        float cycle = mod(time, _interval)/_interval;   
        return cycle;
    }
 
    czm_material czm_getMaterial(czm_materialInput materialInput)
    { 
        //\u6C34\u6CE2\u65F6\u95F4
        float timeInterval=200.;
        float _WaveXSpeed=0.05;
        float _WaveYSpeed=0.05; 
        vec3 bottomColor=vec3(0.7451, 0.7686, 0.6471);
        float o1, o2 = 0.;
        float cycle = mod(czm_frameNumber, timeInterval)/timeInterval;
        float mv = getMixValue(cycle, o1, o2);
        float _time=getInterval(timeInterval);

        //\u5F80\u4E0B\u6D41
         vec2 xia_speed =vec2(-_WaveXSpeed, _WaveYSpeed);


        czm_material material = czm_getDefaultMaterial(materialInput); 

        vec3 bump1 = normalize(texture2D(WaveImage, fract(materialInput.st))).rgb; 
        vec3 bump2 = normalize(texture2D(WaveImage, fract(materialInput.st)-o1*xia_speed)).rgb; 
        //\u53C9\u4E58\u5F97\u5230\u6CD5\u7EBF\u5206\u91CF
        vec3 bumpnormaCross1 = normalize(cross(bump1, bump2));
        vec3 bump3 = normalize(texture2D(WaveImage, fract(materialInput.st))).rgb; 
        vec3 bump4 = normalize(texture2D(WaveImage, fract(materialInput.st)-o2*xia_speed)).rgb; 
        //\u53C9\u4E58\u5F97\u5230\u6CD5\u7EBF\u5206\u91CF\u5206\u91CF
        vec3 bumpnormaCross2 = normalize(cross(bump3, bump4));
        // //\u5F97\u5230\u65B0\u7684\u5206\u91CF,\u4FDD\u8BC1\u6C34\u6D41\u8FDE\u7EED
        vec3 bumpnormaCross=mix(bumpnormaCross2, bumpnormaCross1, mv);
       
        //opengl\u5149\u7167\u539F\u7406,\u4F20\u5165\u6CD5\u5411\u91CF
        float diffuseFactor=czm_getLambertDiffuse(czm_lightDirectionEC,bumpnormaCross);
        float specularFactor = czm_getSpecular(czm_lightDirectionEC, bumpnormaCross,normalize(materialInput.positionToEyeEC),10.0);
       
        
        diffuseFactor= pow(diffuseFactor, 2.)* 1.;
        
        vec4 blue = vec4(0., 69., 129., 0.) / 255.;
        vec4 orange = vec4(.7, .3, 0.1, 0.0);
        float wd = dot(bumpnormaCross, czm_lightDirectionEC);
        wd = max(0.0, wd);
        float wrp = 0.5;
        wd = (wd+wrp)/(1.+wrp);
        
        vec3 frescol = diffuseFactor*orange.rgb*0.4+blue.rgb*wd;

        float _flowtimeInterval=4000.;
        float _flowtime=getInterval(_flowtimeInterval);
        vec3 flowDir = texture2D(FlowMapImage, fract(vec2(4.2,4.2)*materialInput.st.xy)).rgb*vec3(4.0)-vec3(1.0);
        float phase0 = fract(_flowtime + 0.2) ;
        float phase1 = fract(_flowtime);
        vec3 color0 = texture2D(FlowWater, fract(materialInput.st.xy + vec2(phase0) * flowDir.xy)).rgb;
        vec3 color1 = texture2D(FlowWater, fract(materialInput.st.xy + vec2(phase1) * flowDir.xy)).rgb;
        float flowLerp =(abs(phase0 - 0.5)) * 2.0;
        vec3 finalCol = mix(color0, color1, flowLerp);

        material.diffuse=mix(mix(bottomColor,frescol,0.3),finalCol,0.9);
        material.normal=normalize(materialInput.tangentToEyeMatrix * bumpnormaCross);;
        material.specular=specularFactor;
        material.shininess=10.;
        material.alpha=wateralpha;
        return material;
    }
    `;
  Cesium.Material._materialCache.addMaterial(VortexWaterType, {
    fabric: {
      type: VortexWaterType,
      uniforms: {
        WaveImage: Cesium.Material.DefaultImageId,
        FlowWater: Cesium.Material.DefaultImageId,
        FlowMapImage: Cesium.Material.DefaultImageId,
        wateralpha: 0.7
      },
      source: VortexWaterSource
    },
    translucent: function() {
      return true;
    }
  });
  var VortexWaterMaterialProperty_default = VortexWaterMaterialProperty;

  // Source/custom/utils/gistools/BoxSet.js
  var _quadrant_left = 1;
  var _quadrant_left_bottom = 2;
  var _quadrant_bottom = 3;
  var _quadrant_right_bottom = 4;
  var _quadrant_right = 5;
  var _quadrant_right_top = 6;
  var _quadrant_top = 7;
  var _quadrant_left_top = 8;
  var _inner = 9;
  var _save = 1;
  var _question = 2;
  var BoxSet = class {
    constructor(left, right, bottom, top, base, bufferPercent) {
      if (bufferPercent == null) {
        bufferPercent = 5;
      }
      let buffer4 = base * 5 / 100;
      this.left = left - buffer4;
      this.right = right + buffer4;
      this.bottom = bottom - buffer4;
      this.top = top + buffer4;
      this.previous = BoxSet.createEmptyDoubleArray();
      this.now = BoxSet.createEmptyDoubleArray();
      this.question = BoxSet.createEmptyDoubleArray();
      this.point_previous_quadrant = -1;
      this.point_now_quadrant = -1;
      this.point_question_quadrant = -1;
    }
    static createEmptyDoubleArray() {
      return [NaN, NaN];
    }
    copy(form, to) {
      to[0] = form[0];
      to[1] = form[1];
    }
    static isEmpty(array2) {
      if (array2 == null) {
        return true;
      }
      if (isNaN(array2[0]) || isNaN(array2[1])) {
        return true;
      } else {
        return false;
      }
    }
    isQuadrant(point2) {
      let x3 = point2[0];
      let y3 = point2[1];
      if (x3 < this.left) {
        if (y3 > this.top) {
          return _quadrant_left_top;
        }
        if (y3 < this.bottom) {
          return _quadrant_left_bottom;
        } else {
          return _quadrant_left;
        }
      }
      if (x3 > this.right) {
        if (y3 > this.top) {
          return _quadrant_right_top;
        }
        if (y3 < this.bottom) {
          return _quadrant_right_bottom;
        } else {
          return _quadrant_right;
        }
      } else {
        if (y3 > this.top) {
          return _quadrant_top;
        }
        if (y3 < this.bottom) {
          return _quadrant_bottom;
        } else {
          return _inner;
        }
      }
    }
    passrule(point_previous_quadrant, point_now_quadrant) {
      if (point_previous_quadrant == 1) {
        if (point_now_quadrant == 1 || point_now_quadrant == 2 || point_now_quadrant == 8) {
          return _question;
        } else {
          return _save;
        }
      }
      if (point_previous_quadrant == 2) {
        if (point_now_quadrant == 1 || point_now_quadrant == 2 || point_now_quadrant == 8 || point_now_quadrant == 3 || point_now_quadrant == 4) {
          return _question;
        } else {
          return _save;
        }
      }
      if (this.point_previous_quadrant == 3) {
        if (this.point_now_quadrant == 2 || this.point_now_quadrant == 3 || this.point_now_quadrant == 4) {
          return _question;
        } else {
          return _save;
        }
      }
      if (point_previous_quadrant == 4) {
        if (point_now_quadrant == 2 || point_now_quadrant == 3 || point_now_quadrant == 4 || point_now_quadrant == 5 || point_now_quadrant == 6) {
          return _question;
        } else {
          return _save;
        }
      }
      if (point_previous_quadrant == 5) {
        if (point_now_quadrant == 4 || point_now_quadrant == 5 || point_now_quadrant == 6) {
          return _question;
        } else {
          return _save;
        }
      }
      if (point_previous_quadrant == 6) {
        if (point_now_quadrant == 4 || point_now_quadrant == 5 || point_now_quadrant == 6 || point_now_quadrant == 7 || point_now_quadrant == 8) {
          return _question;
        } else {
          return _save;
        }
      }
      if (point_previous_quadrant == 7) {
        if (point_now_quadrant == 6 || point_now_quadrant == 7 || point_now_quadrant == 8) {
          return _question;
        } else {
          return _save;
        }
      }
      if (point_previous_quadrant == 8) {
        if (point_now_quadrant == 6 || point_now_quadrant == 7 || point_now_quadrant == 8 || point_now_quadrant == 1 || point_now_quadrant == 2) {
          return _question;
        } else {
          return _save;
        }
      }
      if (point_previous_quadrant == 9) {
        return _save;
      } else {
        return _save;
      }
    }
    reset() {
      this.previous[0] = NaN;
      this.previous[1] = NaN;
      this.question[0] = NaN;
      this.question[1] = NaN;
      this.now[0] = NaN;
      this.now[1] = NaN;
      this.point_previous_quadrant = -1;
      this.point_now_quadrant = -1;
      this.point_question_quadrant = -1;
    }
    in(now2) {
      if (now2[0] < this.left || now2[0] > this.right) {
        return false;
      }
      if (now2[1] < this.bottom || now2[1] > this.top) {
        return false;
      }
      return true;
    }
    static length(x02, y02, x12, y12) {
      let dx = x12 - x02;
      let dy = y12 - y02;
      let len = Math.sqrt(dx * dx + dy * dy);
      return len;
    }
    push(x3, y3) {
      this.now[0] = x3;
      this.now[1] = y3;
      if (BoxSet.isEmpty(this.previous)) {
        this.copy(this.now, this.previous);
        this.point_previous_quadrant = this.isQuadrant(this.now);
        return [this.now];
      } else {
        this.point_now_quadrant = this.isQuadrant(this.now);
        let passrule = this.passrule(this.point_previous_quadrant, this.point_now_quadrant);
        if (passrule == _save) {
          this.point_previous_quadrant = this.isQuadrant(this.now);
          this.copy(this.now, this.previous);
          if (!BoxSet.isEmpty(this.question)) {
            let returnPoint = [];
            this.copy(this.question, returnPoint);
            this.question = BoxSet.createEmptyDoubleArray();
            return [returnPoint, this.now];
          } else {
            return [this.now];
          }
        }
        if (passrule == _question) {
          if (!BoxSet.isEmpty(this.question)) {
            passrule = this.passrule(this.point_question_quadrant, this.point_now_quadrant);
            if (passrule == _save) {
              let returnPoint = [];
              this.copy(this.question, returnPoint);
              this.question = BoxSet.createEmptyDoubleArray();
              return [returnPoint, this.now];
            }
            if (passrule == _question) {
            }
          }
          this.copy(this.now, this.question);
          this.point_question_quadrant = this.point_now_quadrant;
          return null;
        } else {
          return null;
        }
      }
    }
  };
  var BoxSet_default = BoxSet;

  // Source/custom/layer/shaders/glsl/line_gradient.fragment.js
  var line_gradient_fragment_default = "uniform lowp float u_device_pixel_ratio;\nuniform sampler2D u_image;\n\nvarying vec2 v_width2;\nvarying vec2 v_normal;\nvarying float v_gamma_scale;\nvarying highp vec2 v_uv;\n\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / u_device_pixel_ratio) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    // For gradient lines, v_lineprogress is the ratio along the\n    // entire line, the gradient ramp is stored in a texture.\n    vec4 color = texture2D(u_image, v_uv);\n\n    gl_FragColor = color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n";

  // Source/custom/layer/shaders/glsl/line_gradient.vertex.js
  var line_gradient_vertex_default = `// floor(127 / 2) == 63.0
// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is
// stored in a byte (-128..127). we scale regular normals up to length 63, but
// there are also "special" normals that have a bigger length (of up to 126 in
// this case).
// #define scale 63.0
#define scale 0.015873016

attribute vec2 a_pos_normal;
attribute vec4 a_data;
attribute float a_uv_x;
attribute float a_split_index;

uniform mat4 u_matrix;
uniform mediump float u_ratio;
uniform lowp float u_device_pixel_ratio;
uniform vec2 u_units_to_pixels;
uniform float u_image_height;

varying vec2 v_normal;
varying vec2 v_width2;
varying float v_gamma_scale;
varying highp vec2 v_uv;

#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width

void main() {
    #pragma mapbox: initialize lowp float blur
    #pragma mapbox: initialize lowp float opacity
    #pragma mapbox: initialize mediump float gapwidth
    #pragma mapbox: initialize lowp float offset
    #pragma mapbox: initialize mediump float width

    // the distance over which the line edge fades out.
    // Retina devices need a smaller distance to avoid aliasing.
    float ANTIALIASING = 1.0 / u_device_pixel_ratio / 2.0;

    vec2 a_extrude = a_data.xy - 128.0;
    float a_direction = mod(a_data.z, 4.0) - 1.0;

    highp float texel_height = 1.0 / u_image_height;
    highp float half_texel_height = 0.5 * texel_height;
    v_uv = vec2(a_uv_x, a_split_index * texel_height - half_texel_height);

    vec2 pos = floor(a_pos_normal * 0.5);

    // x is 1 if it's a round cap, 0 otherwise
    // y is 1 if the normal points up, and -1 if it points down
    // We store these in the least significant bit of a_pos_normal
    mediump vec2 normal = a_pos_normal - 2.0 * pos;
    normal.y = normal.y * 2.0 - 1.0;
    v_normal = normal;

    // these transformations used to be applied in the JS and native code bases.
    // moved them into the shader for clarity and simplicity.
    gapwidth = gapwidth / 2.0;
    float halfwidth = width / 2.0;
    offset = -1.0 * offset;

    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);
    float outset = gapwidth + halfwidth * (gapwidth > 0.0 ? 2.0 : 1.0) + (halfwidth == 0.0 ? 0.0 : ANTIALIASING);

    // Scale the extrusion vector down to a normal and then up by the line width
    // of this vertex.
    mediump vec2 dist = outset * a_extrude * scale;

    // Calculate the offset when drawing a line that is to the side of the actual line.
    // We do this by creating a vector that points towards the extrude, but rotate
    // it when we're drawing round end points (a_direction = -1 or 1) since their
    // extrude vector points in another direction.
    mediump float u = 0.5 * a_direction;
    mediump float t = 1.0 - abs(u);
    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);

    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);
    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;
    gl_Position.y =  - gl_Position.y;

    // calculate how much the perspective view squishes or stretches the extrude
    float extrude_length_without_perspective = length(dist);
    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_units_to_pixels);
    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;

    v_width2 = vec2(outset, inset);
}
`;

  // Source/custom/layer/vector/parse/Control.js
  var _defaultOpacity = 0.8;
  var Control = class {
    constructor() {
      this.tabIndex = 0;
      this.stringLineBuffer = [];
      this.allLayerData = true;
    }
    shortFilterControl(str) {
    }
    strToFilterControl(str) {
      let control = JSON.parse(str);
      if (str.length != 0 && control == "") {
        throw new Error("Control\u5B57\u7B26\u4E32\u8F6C\u6362\u5931\u8D25\u8BF7\u68C0\u67E5,\u5982\u679C\u6709\u7279\u6B8A\u4F8B\u5982#@\u7B49,\u9700\u8981\u5C06\u5176\u8F6C\u6362\u6210\u8F6C\u4E49\u7B26");
      }
      let controlObj = control;
      if (control.otherDisplay == null || "" === control.otherDisplay) {
        control.otherDisplay = !control.cmdAll;
      }
      if (control.otherDisplay == null || "" === control.otherDisplay) {
        control.otherDisplay = true;
      } else {
        control.otherDisplay = Boolean(control.otherDisplay);
      }
      delete control.cmdAll;
      this._begin(control.otherDisplay);
      this.controlLayersArr = [];
      if (control.layers == null) {
        return null;
      }
      for (var i = 0; i < control.layers.length; i++) {
        let layer = control.layers[i];
        let layerId = layer.id;
        if (layerId == null) {
          continue;
        }
        this.controlLayersArr.push(layerId);
        this._beginIsInLayer(layerId);
        let idFilter = layer.idFilter;
        if (idFilter != null) {
          this.allLayerData = false;
          this._beginDoIdFilter(idFilter);
          if (layer.display == false) {
            this._push("return false;");
          } else {
            if (layer.color != null) {
              this._push("color = {}");
              this._push('color.color = "' + layer.color.color + '"');
              this._push('color._id = "' + uuid_default.v1() + '"');
              if (layer.color.opacity == null) {
                this._push("color.opacity = " + _defaultOpacity);
              } else {
                this._push("color.opacity = " + layer.color.opacity);
              }
              this._push("return color;");
            } else {
              this._push("return true;");
            }
          }
          this._endDoIdFilter(idFilter);
        }
        let filterStr = layer.filterStr;
        if (filterStr == null || "" == filterStr) {
          if (typeof layer.filters == "object") {
            let filterArr = [];
            for (let index in layer.filters) {
              filterArr.push(index + "=" + layer.filters[index]);
            }
            filterStr = filterArr.join(" and ");
          }
        }
        if (filterStr != null && "" != filterStr) {
          this.allLayerData = false;
          this._beginFilter(filterStr);
          if (layer.display == false) {
            this._push("return false;");
          } else {
            if (layer.color != null) {
              this._push("color = {}");
              this._push('color.color = "' + layer.color.color + '"');
              if (layer.color.opacity == null) {
                this._push("color.opacity = " + _defaultOpacity);
              } else {
                this._push("color.opacity = " + layer.color.opacity);
              }
              this._push("return color;");
            } else {
              this._push("return true;");
            }
          }
          this._endFilter();
        }
        if (this.allLayerData == true) {
          if (layer.display == false) {
            this._push("return false;");
          } else {
            if (layer.color != null) {
              this._push("color = {}");
              this._push('color.color = "' + layer.color.color + '"');
              if (layer.color.opacity == null) {
                this._push("color.opacity = " + _defaultOpacity);
              } else {
                this._push("color.opacity = " + layer.color.opacity);
              }
              this._push("return color;");
            } else {
              this._push("return true;");
            }
          }
        }
        this._endIsInLayer(layerId);
      }
      this._end();
      try {
        controlObj.controlLayersArr = this.controlLayersArr;
        let controlFn = new Function("id", "get", "layerId", this.stringLineBuffer.join("\n"));
        return {
          controlObj,
          controlFn
        };
      } catch (e) {
        throw "\u521B\u5EFA\u8FC7\u6EE4\u5668\u5931\u8D25" + e + "\u8BF7\u68C0\u67E5\u8FC7\u6EE4\u8BED\u53E5";
      }
    }
    _end() {
      this._push("return color;");
    }
    _begin(otherDisplay) {
      if (otherDisplay) {
        this._push("var color = true;");
      } else {
        this._push("var color = false;");
      }
    }
    _endFilter() {
      this.tabIndex--;
      this._push("}");
    }
    _beginFilter(filter) {
      let queryObj = null;
      try {
        queryObj = QueryToJs_default.queryToJs(filter);
      } catch (e) {
        throw "filter: " + filter + " \u89E3\u6790\u5931\u8D25\uFF0C\u9519\u8BEF\uFF1A" + e;
      }
      let jsStr = queryObj.js;
      for (let field of queryObj.fields) {
        this._push("var " + field + ' = get("' + field + '");');
      }
      if (jsStr == "") {
      }
      this._push("if(" + jsStr + "){");
      this.tabIndex++;
    }
    _beginDoIdFilter(idFilter) {
      let str = 'if("' + idFilter + `".split(',').indexOf(id.toString()) != -1){`;
      this._push(str);
      this.tabIndex++;
    }
    _endDoIdFilter(idFilter) {
      this.tabIndex--;
      this._push("}");
    }
    _beginIsInLayer(layerId) {
      let str = 'if(layerId == "' + layerId + '"){';
      this._push(str);
      this.tabIndex++;
    }
    _endIsInLayer(layerId) {
      this._push("return false;");
      this.tabIndex--;
      let str = "}";
      this._push(str);
    }
    _push(str) {
      for (var i = 0; i < this.tabIndex; i++) {
        str = "    " + str;
      }
      this.stringLineBuffer.push(str);
    }
  };
  var Control_default = Control;

  // Source/custom/layer/vector/parse/VectorDrawer.js
  var VectorDrawer = class {
    constructor(layerDataMapArr, level, featureMap, control, highLighStr) {
      this.layerDataMapArr = layerDataMapArr;
      this.level = level;
      this.control = control;
      this.highLight = highLighStr;
      this.featureMap = featureMap;
      this.index = 0;
    }
    getBackground() {
      this.vectorDatas = [];
      return this;
    }
    getTypeString(type) {
      if (type == 1 || type == "POINT") {
        return "Point";
      }
      if (type == 2 || type == "LINESTRING") {
        return "LineString";
      }
      if (type == 3 || type == "POLYGON") {
        return "Polygon";
      }
      if (type == 4 || type == "MULTIPOINT") {
        return "MultiPoint";
      }
      if (type == 5 || type == "MULTILINESTRING") {
        return "MultiLineString";
      }
      if (type == 6 || type == "MULTIPOLYGON") {
        return "MultiPolygon";
      }
      if (type == 7 || type == "FEATURECOLLECTION") {
        return "FeatureCollection";
      }
    }
    getLayer(dataLayerID, styleLayerID) {
      this.index++;
      this.vectorDatas = [];
      if (this.control) {
        if (this.control.controlObj.otherDisplay == false) {
          if (this.control.controlObj.controlLayersArr.indexOf(styleLayerID) == -1) {
            return this;
          }
        }
      }
      for (let i = 0; i < this.layerDataMapArr.length; i++) {
        let data = this.layerDataMapArr[i][dataLayerID];
        if (data == null) {
          continue;
        }
        if (!data.features) {
          data.features = data.datas;
        }
        if (!data.features) {
          continue;
        }
        for (let j = 0; j < data.features.length; j++) {
          let vectorData = data.features[j];
          vectorData.layerName = dataLayerID;
          vectorData.type = this.getTypeString(vectorData[0]);
          if (!vectorData.properties) {
            vectorData.properties = this.getFieldValueMap(data, vectorData);
          }
          if (this._filterByStyle(vectorData, styleLayerID)) {
            let controlRes = this._highLightByStyle(vectorData, styleLayerID);
            if (controlRes["color"] != null) {
              vectorData.customeColor = controlRes;
            }
            this.vectorDatas.push(vectorData);
          }
        }
      }
      return this;
    }
    getGroupLayer(dataLayerID, value, styleLayerID) {
      this.index++;
      this.vectorDatas = [];
      let valueArr = value.split(",");
      let length2 = valueArr.length;
      if (length2 == 0) {
        return this;
      }
      if (this.control) {
        if (this.control.controlObj.otherDisplay == false) {
          if (this.control.controlObj.controlLayersArr.indexOf(styleLayerID) == -1) {
            return this;
          }
        }
      }
      for (let i = 0; i < this.layerDataMapArr.length; i++) {
        let data = this.layerDataMapArr[i][dataLayerID];
        if (data == null) {
          continue;
        }
        if (!data.features) {
          data.features = data.datas;
        }
        if (!data.features) {
          continue;
        }
        for (let j = 0; j < length2; j++) {
          let dataArr = data.features[valueArr[j]];
          if (dataArr == null) {
            continue;
          }
          let vectorData = data.features[i];
          vectorData.layerName = dataLayerID;
          vectorData.type = data.type;
          if (!vectorData.properties) {
            vectorData.properties = this.getFieldValueMap(data, vectorData);
          }
          if (this._filterByStyle(vectorData, styleLayerID)) {
            let controlRes = this._highLightByStyle(vectorData, styleLayerID);
            if (controlRes["color"] != null) {
              vectorData.customeColor = controlRes;
            }
            this.vectorDatas.push(vectorData);
          }
        }
      }
      return this;
    }
    setStyle(fn) {
      for (let i = 0; i < this.vectorDatas.length; i++) {
        let item = this.vectorDatas[i];
        let vectorData = {};
        vectorData.id = Math.random();
        vectorData.layerName = item.layerName;
        vectorData.customeColor = item.customeColor;
        vectorData.type = item.type;
        vectorData.properties = item.properties;
        vectorData.data = item[2];
        vectorData.index = this.index;
        let get2 = function(key2) {
          return vectorData.properties[key2];
        };
        let style = fn.call({}, this.level, get2);
        if (vectorData.type == "MultiLineString" || vectorData.type == "LineString") {
          if (style && style.stroke == false) {
            continue;
          }
        }
        if (style && style.display != false) {
          vectorData.style = style;
          if (vectorData.customeColor) {
            vectorData.style._id = vectorData.customeColor._id;
            if (vectorData.style.hasOwnProperty("fillColor")) {
              vectorData.style.fillColor = vectorData.customeColor["color"];
              vectorData.style.fillOpacity = vectorData.customeColor["opacity"];
            } else {
              vectorData.style.strokeColor = vectorData.customeColor["color"];
              vectorData.style.strokeOpacity = vectorData.customeColor["opacity"];
            }
          }
          let key2 = vectorData.layerName;
          if (!this.featureMap[key2]) {
            this.featureMap[key2] = [];
          }
          this.featureMap[key2].push(vectorData);
        }
      }
    }
    getFieldValueMap(data, vectorData) {
      let fieldValueMap = {};
      for (let i = 0; i < data.fieldsConfig.length; i++) {
        let fieldName = data.fieldsConfig[i]["name"];
        let index = data.fieldsConfig[i]["index"];
        let id = data.fieldsConfig[i]["id"];
        if (id == true) {
          fieldValueMap["primaryId"] = vectorData.layerName + vectorData[1][index];
          fieldValueMap["id"] = vectorData[1][index];
        }
        fieldValueMap[fieldName] = vectorData[1][index];
      }
      return fieldValueMap;
    }
    getWaterMark() {
      this.vectorDatas = [];
      return this;
    }
    draw() {
    }
    _getProperty(data) {
      return data[1];
    }
    _getPoints(data) {
      return data[2];
    }
    _getType(data) {
      return data[0];
    }
    _filterByStyle(gjson, styleLayerID) {
      let type = this._getType(gjson);
      let points = this._getPoints(gjson);
      let property = this._getProperty(gjson);
      if (points == null) {
        throw "\u7ED8\u5236\u5931\u8D25,\u6570\u636E\u4E2D\u7F3A\u5C11Geometry";
      }
      if (type == null) {
        type = "POLYGON";
      }
      let style = null;
      let controlRes = {};
      var get2 = function(fieldName) {
        return gjson.properties[key];
      };
      if (this.control) {
        if (typeof this.control.controlFn == "function") {
          let id = gjson.properties["id"];
          controlRes = this.control.controlFn.call({}, id, get2, styleLayerID);
          if (controlRes == false || controlRes == null) {
            return false;
          }
        }
      }
      return true;
    }
    _highLightByStyle(gjson, styleLayerID) {
      let type = this._getType(gjson);
      let points = this._getPoints(gjson);
      let property = this._getProperty(gjson);
      if (points == null) {
        throw "\u7ED8\u5236\u5931\u8D25,\u6570\u636E\u4E2D\u7F3A\u5C11Geometry";
      }
      if (type == null) {
        type = "POLYGON";
      }
      let style = null;
      let controlRes = {};
      var get2 = function(fieldName) {
        return gjson.properties[key];
      };
      if (this.highLight) {
        if (typeof this.highLight.controlFn == "function") {
          let id = gjson.properties["id"];
          controlRes = this.highLight.controlFn.call({}, id, get2, styleLayerID);
          if (controlRes == false || controlRes == null) {
            return false;
          }
        }
      }
      return controlRes;
    }
  };
  var VectorDrawer_default = VectorDrawer;

  // Source/Custom.js
  var VERSION = "1.97";
  return __toCommonJS(Custom_exports);
})();
//# sourceMappingURL=CustomCesiumSDK.js.map

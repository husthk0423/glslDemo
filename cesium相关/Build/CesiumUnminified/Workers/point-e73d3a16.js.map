{"version":3,"file":"point-e73d3a16.js","sources":["../../../Source/mapbox/data/segment.js","../../../Source/mapbox/data/bucket/Bucket.js","../../../Source/ThirdParty/quickselect.js","../../../Source/mapbox/data/bucket/ClassifyRings.js","../../../Source/mapbox/data/bucket/tess2.js","../../../Source/mapbox/util/BufferUtil.js","../../../Source/mapbox/util/StructArray.js","../../../Source/mapbox/util/ElementArrayType.js","../../../Source/mapbox/util/VertexArrayType.js","../../../Source/mapbox/data/bucket/FillBucket.js","../../../Source/mapbox/data/bucket/LineBucket.js","../../../Source/util/Simplify.js","../../../Source/mapbox/data/point.js"],"sourcesContent":["// @flow\r\nclass SegmentVector {\r\n    constructor(segments) {\r\n        if(segments){\r\n            this.segments = segments;\r\n        }else{\r\n            this.segments = [];\r\n        }\r\n    }\r\n\r\n    prepareSegment(numVertices, layoutVertexArray, indexArray, sortKey) {\r\n        let segment = this.segments[this.segments.length - 1];\r\n        if (numVertices > SegmentVector.MAX_VERTEX_ARRAY_LENGTH) console.log(`Max vertices per segment is ${SegmentVector.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${numVertices}`);\r\n        if (!segment || segment.vertexLength + numVertices > SegmentVector.MAX_VERTEX_ARRAY_LENGTH || segment.sortKey !== sortKey) {\r\n            segment = ({\r\n                vertexOffset: layoutVertexArray.length,\r\n                primitiveOffset: indexArray.length,\r\n                vertexLength: 0,\r\n                primitiveLength: 0\r\n            });\r\n            if (sortKey !== undefined) segment.sortKey = sortKey;\r\n            this.segments.push(segment);\r\n        }\r\n        return segment;\r\n    }\r\n\r\n    get() {\r\n        return this.segments;\r\n    }\r\n\r\n    destroy() {\r\n        for (const segment of this.segments) {\r\n            // for (const k in segment.vaos) {\r\n            //     segment.vaos[k].destroy();\r\n            // }\r\n            if(segment.vao){\r\n                segment.vao.destroy();\r\n            }\r\n        }\r\n    }\r\n\r\n    static simpleSegment(vertexOffset, primitiveOffset, vertexLength, primitiveLength){\r\n        return new SegmentVector([{\r\n            vertexOffset,\r\n            primitiveOffset,\r\n            vertexLength,\r\n            primitiveLength,\r\n            // vaos: {},\r\n            sortKey: 0\r\n        }]);\r\n    }\r\n}\r\n\r\n/*\r\n * The maximum size of a vertex array. This limit is imposed by WebGL's 16 bit\r\n * addressing of vertex buffers.\r\n * @private\r\n * @readonly\r\n */\r\nSegmentVector.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1;\r\n\r\nexport default SegmentVector;\r\n","'use strict';\r\n\r\n\r\n/**\r\n * The `Bucket` class is the single point of knowledge about turning vector\r\n * tiles into WebGL buffers.\r\n *\r\n * `Bucket` is an abstract class. A subclass exists for each style layer type.\r\n * Create a bucket via the `StyleLayer#createBucket` method.\r\n *\r\n * The concrete bucket types, using layout options from the style layer,\r\n * transform feature geometries into vertex and element data for use by the\r\n * vertex shader.  They also (via `ProgramConfiguration`) use feature\r\n * properties and the zoom level to populate the attributes needed for\r\n * data-driven styling.\r\n *\r\n * Buckets are designed to be built on a worker thread and then serialized and\r\n * transferred back to the main thread for rendering.  On the worker side, a\r\n * bucket's vertex, element, and attribute data is stored in `bucket.arrays:\r\n * ArrayGroup`.  When a bucket's data is serialized and sent back to the main\r\n * thread, is gets deserialized (using `new Bucket(serializedBucketData)`, with\r\n * the array data now stored in `bucket.buffers: BufferGroup`.  BufferGroups\r\n * hold the same data as ArrayGroups, but are tuned for consumption by WebGL.\r\n *\r\n * @private\r\n */\r\nclass Bucket {\r\n    /**\r\n     * @param options\r\n     * @param {number} options.zoom Zoom level of the buffers being built. May be\r\n     *     a fractional zoom level.\r\n     * @param options.layer A Mapbox style layer object\r\n     * @param {Object.<string, Buffer>} options.buffers The set of `Buffer`s being\r\n     *     built for this tile. This object facilitates sharing of `Buffer`s be\r\n           between `Bucket`s.\r\n     */\r\n    constructor (options) {\r\n        this.style= options.style;\r\n        this.type = options.type;\r\n        this.tileSize = options.tileSize;\r\n    }\r\n\r\n\r\n    serialize(transferables) {\r\n\r\n    }\r\n\r\n    /**\r\n     * Release the WebGL resources associated with the buffers. Note that because\r\n     * buckets are shared between layers having the same layout properties, they\r\n     * must be destroyed in groups (all buckets for a tile, or all symbol buckets).\r\n     *\r\n     * @private\r\n     */\r\n    destroy() {\r\n    }\r\n}\r\n\r\nexport default Bucket;\r\n","\r\nfunction quickselect(arr, k, left, right, compare) {\r\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\r\n};\r\n\r\nfunction quickselectStep(arr, k, left, right, compare) {\r\n\r\n    while (right > left) {\r\n        if (right - left > 600) {\r\n            var n = right - left + 1;\r\n            var m = k - left + 1;\r\n            var z = Math.log(n);\r\n            var s = 0.5 * Math.exp(2 * z / 3);\r\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\r\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\r\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\r\n            quickselectStep(arr, k, newLeft, newRight, compare);\r\n        }\r\n\r\n        var t = arr[k];\r\n        var i = left;\r\n        var j = right;\r\n\r\n        swap(arr, left, k);\r\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\r\n\r\n        while (i < j) {\r\n            swap(arr, i, j);\r\n            i++;\r\n            j--;\r\n            while (compare(arr[i], t) < 0) i++;\r\n            while (compare(arr[j], t) > 0) j--;\r\n        }\r\n\r\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\r\n        else {\r\n            j++;\r\n            swap(arr, j, right);\r\n        }\r\n\r\n        if (j <= k) left = j + 1;\r\n        if (k <= j) right = j - 1;\r\n    }\r\n}\r\n\r\nfunction swap(arr, i, j) {\r\n    var tmp = arr[i];\r\n    arr[i] = arr[j];\r\n    arr[j] = tmp;\r\n}\r\n\r\nfunction defaultCompare(a, b) {\r\n    return a < b ? -1 : a > b ? 1 : 0;\r\n}\r\n\r\nexport default quickselect;\r\n","import quickselect from '../../../ThirdParty/quickselect';\r\n\r\n// classifies an array of rings into polygons with outer rings and holes\r\n\r\n function calculateSignedArea(ring){\r\n    let sum = 0;\r\n    for (let i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\r\n        p1 = ring[i];\r\n        p2 = ring[j];\r\n        sum += (p2.x - p1.x) * (p1.y + p2.y);\r\n    }\r\n    return sum;\r\n};\r\n\r\nexport default function classifyRings(rings, maxRings) {\r\n    const len = rings.length;\r\n\r\n    if (len <= 0) return [];\r\n\r\n    const polygons = [];\r\n    let polygon =[];\r\n        // ccw;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        const area = calculateSignedArea(rings[i]);\r\n        if (area === 0) continue;\r\n\r\n        rings[i].area = Math.abs(area);\r\n\r\n        // if (ccw === undefined) ccw = area < 0;\r\n        //\r\n        // if (ccw === area < 0) {\r\n        //     if (polygon) polygons.push(polygon);\r\n        //     polygon = [rings[i]];\r\n        //\r\n        // } else {\r\n            polygon.push(rings[i]);\r\n        // }\r\n    }\r\n    if (polygon) polygons.push(polygon);\r\n\r\n    // Earcut performance degrages with the # of rings in a polygon. For this\r\n    // reason, we limit strip out all but the `maxRings` largest rings.\r\n    if (maxRings > 1) {\r\n        for (let j = 0; j < polygons.length; j++) {\r\n            if (polygons[j].length <= maxRings) continue;\r\n            quickselect(polygons[j], maxRings, 1, polygons[j].length - 1, compareAreas);\r\n            polygons[j] = polygons[j].slice(0, maxRings);\r\n        }\r\n    }\r\n\r\n    return polygons;\r\n};\r\n\r\nfunction compareAreas(a, b) {\r\n    return b.area - a.area;\r\n}\r\n","/*\r\n** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)\r\n** Copyright (C) [dates of first publication] Silicon Graphics, Inc.\r\n** All Rights Reserved.\r\n**\r\n** Permission is hereby granted, free of charge, to any person obtaining a copy\r\n** of this software and associated documentation files (the \"Software\"), to deal\r\n** in the Software without restriction, including without limitation the rights\r\n** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n** of the Software, and to permit persons to whom the Software is furnished to do so,\r\n** subject to the following conditions:\r\n**\r\n** The above copyright notice including the dates of first publication and either this\r\n** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be\r\n** included in all copies or substantial portions of the Software.\r\n**\r\n** THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.\r\n** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\r\n** OR OTHER DEALINGS IN THE SOFTWARE.\r\n**\r\n** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not\r\n** be used in advertising or otherwise to promote the sale, use or other dealings in\r\n** this Software without prior written authorization from Silicon Graphics, Inc.\r\n*/\r\n/*\r\n** Author: Mikko Mononen, Aug 2013.\r\n** The code is based on GLU libtess by Eric Veach, July 1994\r\n*/\r\n\r\n\"use strict\";\r\n\r\n/* Public API */\r\n\r\nvar Tess2 = {};\r\n\r\nexport default Tess2;\r\n\r\nTess2.WINDING_ODD = 0;\r\nTess2.WINDING_NONZERO = 1;\r\nTess2.WINDING_POSITIVE = 2;\r\nTess2.WINDING_NEGATIVE = 3;\r\nTess2.WINDING_ABS_GEQ_TWO = 4;\r\n\r\nTess2.POLYGONS = 0;\r\nTess2.CONNECTED_POLYGONS = 1;\r\nTess2.BOUNDARY_CONTOURS = 2;\r\n\r\nTess2.tesselate = function(opts) {\r\n    var debug =  opts.debug || false;\r\n    var tess = new Tesselator();\r\n    for (var i = 0; i < opts.contours.length; i++) {\r\n        tess.addContour(opts.vertexSize || 2, opts.contours[i]);\r\n    }\r\n    tess.tesselate(opts.windingRule || Tess2.WINDING_ODD,\r\n        opts.elementType || Tess2.POLYGONS,\r\n        opts.polySize || 3,\r\n        opts.vertexSize || 2,\r\n        opts.normal || [0,0,1]);\r\n    return {\r\n        vertices: tess.vertices,\r\n        vertexIndices: tess.vertexIndices,\r\n        vertexCount: tess.vertexCount,\r\n        elements: tess.elements,\r\n        elementCount: tess.elementCount,\r\n        mesh: debug ? tess.mesh : undefined\r\n    };\r\n};\r\n\r\n/* Internal */\r\n\r\nvar assert = function(cond) {\r\n    if (!cond) {\r\n        throw \"Assertion Failed!\";\r\n    }\r\n}\r\n\r\n/* The mesh structure is similar in spirit, notation, and operations\r\n* to the \"quad-edge\" structure (see L. Guibas and J. Stolfi, Primitives\r\n* for the manipulation of general subdivisions and the computation of\r\n* Voronoi diagrams, ACM Transactions on Graphics, 4(2):74-123, April 1985).\r\n* For a simplified description, see the course notes for CS348a,\r\n* \"Mathematical Foundations of Computer Graphics\", available at the\r\n* Stanford bookstore (and taught during the fall quarter).\r\n* The implementation also borrows a tiny subset of the graph-based approach\r\n* use in Mantyla's Geometric Work Bench (see M. Mantyla, An Introduction\r\n* to Sold Modeling, Computer Science Press, Rockville, Maryland, 1988).\r\n*\r\n* The fundamental data structure is the \"half-edge\".  Two half-edges\r\n* go together to make an edge, but they point in opposite directions.\r\n* Each half-edge has a pointer to its mate (the \"symmetric\" half-edge Sym),\r\n* its origin vertex (Org), the face on its left side (Lface), and the\r\n* adjacent half-edges in the CCW direction around the origin vertex\r\n* (Onext) and around the left face (Lnext).  There is also a \"next\"\r\n* pointer for the global edge list (see below).\r\n*\r\n* The notation used for mesh navigation:\r\n*  Sym   = the mate of a half-edge (same edge, but opposite direction)\r\n*  Onext = edge CCW around origin vertex (keep same origin)\r\n*  Dnext = edge CCW around destination vertex (keep same dest)\r\n*  Lnext = edge CCW around left face (dest becomes new origin)\r\n*  Rnext = edge CCW around right face (origin becomes new dest)\r\n*\r\n* \"prev\" means to substitute CW for CCW in the definitions above.\r\n*\r\n* The mesh keeps global lists of all vertices, faces, and edges,\r\n* stored as doubly-linked circular lists with a dummy header node.\r\n* The mesh stores pointers to these dummy headers (vHead, fHead, eHead).\r\n*\r\n* The circular edge list is special; since half-edges always occur\r\n* in pairs (e and e->Sym), each half-edge stores a pointer in only\r\n* one direction.  Starting at eHead and following the e->next pointers\r\n* will visit each *edge* once (ie. e or e->Sym, but not both).\r\n* e->Sym stores a pointer in the opposite direction, thus it is\r\n* always true that e->Sym->next->Sym->next == e.\r\n*\r\n* Each vertex has a pointer to next and previous vertices in the\r\n* circular list, and a pointer to a half-edge with this vertex as\r\n* the origin (NULL if this is the dummy header).  There is also a\r\n* field \"data\" for client data.\r\n*\r\n* Each face has a pointer to the next and previous faces in the\r\n* circular list, and a pointer to a half-edge with this face as\r\n* the left face (NULL if this is the dummy header).  There is also\r\n* a field \"data\" for client data.\r\n*\r\n* Note that what we call a \"face\" is really a loop; faces may consist\r\n* of more than one loop (ie. not simply connected), but there is no\r\n* record of this in the data structure.  The mesh may consist of\r\n* several disconnected regions, so it may not be possible to visit\r\n* the entire mesh by starting at a half-edge and traversing the edge\r\n* structure.\r\n*\r\n* The mesh does NOT support isolated vertices; a vertex is deleted along\r\n* with its last edge.  Similarly when two faces are merged, one of the\r\n* faces is deleted (see tessMeshDelete below).  For mesh operations,\r\n* all face (loop) and vertex pointers must not be NULL.  However, once\r\n* mesh manipulation is finished, TESSmeshZapFace can be used to delete\r\n* faces of the mesh, one at a time.  All external faces can be \"zapped\"\r\n* before the mesh is returned to the client; then a NULL face indicates\r\n* a region which is not part of the output polygon.\r\n*/\r\n\r\nfunction TESSvertex() {\r\n    this.next = null;\t/* next vertex (never NULL) */\r\n    this.prev = null;\t/* previous vertex (never NULL) */\r\n    this.anEdge = null;\t/* a half-edge with this origin */\r\n\r\n    /* Internal data (keep hidden) */\r\n    this.coords = [0,0,0];\t/* vertex location in 3D */\r\n    this.s = 0.0;\r\n    this.t = 0.0;\t\t\t/* projection onto the sweep plane */\r\n    this.pqHandle = 0;\t\t/* to allow deletion from priority queue */\r\n    this.n = 0;\t\t\t\t/* to allow identify unique vertices */\r\n    this.idx = 0;\t\t\t/* to allow map result to original verts */\r\n}\r\n\r\nfunction TESSface() {\r\n    this.next = null;\t\t/* next face (never NULL) */\r\n    this.prev = null;\t\t/* previous face (never NULL) */\r\n    this.anEdge = null;\t\t/* a half edge with this left face */\r\n\r\n    /* Internal data (keep hidden) */\r\n    this.trail = null;\t\t/* \"stack\" for conversion to strips */\r\n    this.n = 0;\t\t\t\t/* to allow identiy unique faces */\r\n    this.marked = false;\t/* flag for conversion to strips */\r\n    this.inside = false;\t/* this face is in the polygon interior */\r\n};\r\n\r\nfunction TESShalfEdge(side) {\r\n    this.next = null;\t\t/* doubly-linked list (prev==Sym->next) */\r\n    this.Sym = null;\t\t/* same edge, opposite direction */\r\n    this.Onext = null;\t\t/* next edge CCW around origin */\r\n    this.Lnext = null;\t\t/* next edge CCW around left face */\r\n    this.Org = null;\t\t/* origin vertex (Overtex too long) */\r\n    this.Lface = null;\t\t/* left face */\r\n\r\n    /* Internal data (keep hidden) */\r\n    this.activeRegion = null;\t/* a region with this upper edge (sweep.c) */\r\n    this.winding = 0;\t\t\t/* change in winding number when crossing\r\n\t\t\t\t\t\t\t\t\t   from the right face to the left face */\r\n    this.side = side;\r\n};\r\n\r\nTESShalfEdge.prototype = {\r\n    get Rface() { return this.Sym.Lface; },\r\n    set Rface(v) { this.Sym.Lface = v; },\r\n    get Dst() { return this.Sym.Org; },\r\n    set Dst(v) { this.Sym.Org = v; },\r\n    get Oprev() { return this.Sym.Lnext; },\r\n    set Oprev(v) { this.Sym.Lnext = v; },\r\n    get Lprev() { return this.Onext.Sym; },\r\n    set Lprev(v) { this.Onext.Sym = v; },\r\n    get Dprev() { return this.Lnext.Sym; },\r\n    set Dprev(v) { this.Lnext.Sym = v; },\r\n    get Rprev() { return this.Sym.Onext; },\r\n    set Rprev(v) { this.Sym.Onext = v; },\r\n    get Dnext() { return /*this.Rprev*/this.Sym.Onext.Sym; },  /* 3 pointers */\r\n    set Dnext(v) { /*this.Rprev*/this.Sym.Onext.Sym = v; },  /* 3 pointers */\r\n    get Rnext() { return /*this.Oprev*/this.Sym.Lnext.Sym; },  /* 3 pointers */\r\n    set Rnext(v) { /*this.Oprev*/this.Sym.Lnext.Sym = v; },  /* 3 pointers */\r\n};\r\n\r\n\r\n\r\nfunction TESSmesh() {\r\n    var v = new TESSvertex();\r\n    var f = new TESSface();\r\n    var e = new TESShalfEdge(0);\r\n    var eSym = new TESShalfEdge(1);\r\n\r\n    v.next = v.prev = v;\r\n    v.anEdge = null;\r\n\r\n    f.next = f.prev = f;\r\n    f.anEdge = null;\r\n    f.trail = null;\r\n    f.marked = false;\r\n    f.inside = false;\r\n\r\n    e.next = e;\r\n    e.Sym = eSym;\r\n    e.Onext = null;\r\n    e.Lnext = null;\r\n    e.Org = null;\r\n    e.Lface = null;\r\n    e.winding = 0;\r\n    e.activeRegion = null;\r\n\r\n    eSym.next = eSym;\r\n    eSym.Sym = e;\r\n    eSym.Onext = null;\r\n    eSym.Lnext = null;\r\n    eSym.Org = null;\r\n    eSym.Lface = null;\r\n    eSym.winding = 0;\r\n    eSym.activeRegion = null;\r\n\r\n    this.vHead = v;\t\t/* dummy header for vertex list */\r\n    this.fHead = f;\t\t/* dummy header for face list */\r\n    this.eHead = e;\t\t/* dummy header for edge list */\r\n    this.eHeadSym = eSym;\t/* and its symmetric counterpart */\r\n};\r\n\r\n/* The mesh operations below have three motivations: completeness,\r\n* convenience, and efficiency.  The basic mesh operations are MakeEdge,\r\n* Splice, and Delete.  All the other edge operations can be implemented\r\n* in terms of these.  The other operations are provided for convenience\r\n* and/or efficiency.\r\n*\r\n* When a face is split or a vertex is added, they are inserted into the\r\n* global list *before* the existing vertex or face (ie. e->Org or e->Lface).\r\n* This makes it easier to process all vertices or faces in the global lists\r\n* without worrying about processing the same data twice.  As a convenience,\r\n* when a face is split, the \"inside\" flag is copied from the old face.\r\n* Other internal data (v->data, v->activeRegion, f->data, f->marked,\r\n* f->trail, e->winding) is set to zero.\r\n*\r\n* ********************** Basic Edge Operations **************************\r\n*\r\n* tessMeshMakeEdge( mesh ) creates one edge, two vertices, and a loop.\r\n* The loop (face) consists of the two new half-edges.\r\n*\r\n* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the\r\n* mesh connectivity and topology.  It changes the mesh so that\r\n*  eOrg->Onext <- OLD( eDst->Onext )\r\n*  eDst->Onext <- OLD( eOrg->Onext )\r\n* where OLD(...) means the value before the meshSplice operation.\r\n*\r\n* This can have two effects on the vertex structure:\r\n*  - if eOrg->Org != eDst->Org, the two vertices are merged together\r\n*  - if eOrg->Org == eDst->Org, the origin is split into two vertices\r\n* In both cases, eDst->Org is changed and eOrg->Org is untouched.\r\n*\r\n* Similarly (and independently) for the face structure,\r\n*  - if eOrg->Lface == eDst->Lface, one loop is split into two\r\n*  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one\r\n* In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.\r\n*\r\n* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:\r\n* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop\r\n* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;\r\n* the newly created loop will contain eDel->Dst.  If the deletion of eDel\r\n* would create isolated vertices, those are deleted as well.\r\n*\r\n* ********************** Other Edge Operations **************************\r\n*\r\n* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that\r\n* eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.\r\n* eOrg and eNew will have the same left face.\r\n*\r\n* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,\r\n* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.\r\n* eOrg and eNew will have the same left face.\r\n*\r\n* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst\r\n* to eDst->Org, and returns the corresponding half-edge eNew.\r\n* If eOrg->Lface == eDst->Lface, this splits one loop into two,\r\n* and the newly created loop is eNew->Lface.  Otherwise, two disjoint\r\n* loops are merged into one, and the loop eDst->Lface is destroyed.\r\n*\r\n* ************************ Other Operations *****************************\r\n*\r\n* tessMeshNewMesh() creates a new mesh with no edges, no vertices,\r\n* and no loops (what we usually call a \"face\").\r\n*\r\n* tessMeshUnion( mesh1, mesh2 ) forms the union of all structures in\r\n* both meshes, and returns the new mesh (the old meshes are destroyed).\r\n*\r\n* tessMeshDeleteMesh( mesh ) will free all storage for any valid mesh.\r\n*\r\n* tessMeshZapFace( fZap ) destroys a face and removes it from the\r\n* global face list.  All edges of fZap will have a NULL pointer as their\r\n* left face.  Any edges which also have a NULL pointer as their right face\r\n* are deleted entirely (along with any isolated vertices this produces).\r\n* An entire mesh can be deleted by zapping its faces, one at a time,\r\n* in any order.  Zapped faces cannot be used in further mesh operations!\r\n*\r\n* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.\r\n*/\r\n\r\nTESSmesh.prototype = {\r\n\r\n    /* MakeEdge creates a new pair of half-edges which form their own loop.\r\n    * No vertex or face structures are allocated, but these must be assigned\r\n    * before the current edge operation is completed.\r\n    */\r\n    //static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )\r\n    makeEdge_: function(eNext) {\r\n        var e = new TESShalfEdge(0);\r\n        var eSym = new TESShalfEdge(1);\r\n\r\n        /* Make sure eNext points to the first edge of the edge pair */\r\n        if( eNext.Sym.side < eNext.side ) { eNext = eNext.Sym; }\r\n\r\n        /* Insert in circular doubly-linked list before eNext.\r\n        * Note that the prev pointer is stored in Sym->next.\r\n        */\r\n        var ePrev = eNext.Sym.next;\r\n        eSym.next = ePrev;\r\n        ePrev.Sym.next = e;\r\n        e.next = eNext;\r\n        eNext.Sym.next = eSym;\r\n\r\n        e.Sym = eSym;\r\n        e.Onext = e;\r\n        e.Lnext = eSym;\r\n        e.Org = null;\r\n        e.Lface = null;\r\n        e.winding = 0;\r\n        e.activeRegion = null;\r\n\r\n        eSym.Sym = e;\r\n        eSym.Onext = eSym;\r\n        eSym.Lnext = e;\r\n        eSym.Org = null;\r\n        eSym.Lface = null;\r\n        eSym.winding = 0;\r\n        eSym.activeRegion = null;\r\n\r\n        return e;\r\n    },\r\n\r\n    /* Splice( a, b ) is best described by the Guibas/Stolfi paper or the\r\n    * CS348a notes (see mesh.h).  Basically it modifies the mesh so that\r\n    * a->Onext and b->Onext are exchanged.  This can have various effects\r\n    * depending on whether a and b belong to different face or vertex rings.\r\n    * For more explanation see tessMeshSplice() below.\r\n    */\r\n    // static void Splice( TESShalfEdge *a, TESShalfEdge *b )\r\n    splice_: function(a, b) {\r\n        var aOnext = a.Onext;\r\n        var bOnext = b.Onext;\r\n        aOnext.Sym.Lnext = b;\r\n        bOnext.Sym.Lnext = a;\r\n        a.Onext = bOnext;\r\n        b.Onext = aOnext;\r\n    },\r\n\r\n    /* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the\r\n    * origin of all edges in the vertex loop to which eOrig belongs. \"vNext\" gives\r\n    * a place to insert the new vertex in the global vertex list.  We insert\r\n    * the new vertex *before* vNext so that algorithms which walk the vertex\r\n    * list will not see the newly created vertices.\r\n    */\r\n    //static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )\r\n    makeVertex_: function(newVertex, eOrig, vNext) {\r\n        var vNew = newVertex;\r\n        assert(vNew !== null);\r\n\r\n        /* insert in circular doubly-linked list before vNext */\r\n        var vPrev = vNext.prev;\r\n        vNew.prev = vPrev;\r\n        vPrev.next = vNew;\r\n        vNew.next = vNext;\r\n        vNext.prev = vNew;\r\n\r\n        vNew.anEdge = eOrig;\r\n        /* leave coords, s, t undefined */\r\n\r\n        /* fix other edges on this vertex loop */\r\n        var e = eOrig;\r\n        do {\r\n            e.Org = vNew;\r\n            e = e.Onext;\r\n        } while(e !== eOrig);\r\n    },\r\n\r\n    /* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left\r\n    * face of all edges in the face loop to which eOrig belongs.  \"fNext\" gives\r\n    * a place to insert the new face in the global face list.  We insert\r\n    * the new face *before* fNext so that algorithms which walk the face\r\n    * list will not see the newly created faces.\r\n    */\r\n    // static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )\r\n    makeFace_: function(newFace, eOrig, fNext) {\r\n        var fNew = newFace;\r\n        assert(fNew !== null);\r\n\r\n        /* insert in circular doubly-linked list before fNext */\r\n        var fPrev = fNext.prev;\r\n        fNew.prev = fPrev;\r\n        fPrev.next = fNew;\r\n        fNew.next = fNext;\r\n        fNext.prev = fNew;\r\n\r\n        fNew.anEdge = eOrig;\r\n        fNew.trail = null;\r\n        fNew.marked = false;\r\n\r\n        /* The new face is marked \"inside\" if the old one was.  This is a\r\n        * convenience for the common case where a face has been split in two.\r\n        */\r\n        fNew.inside = fNext.inside;\r\n\r\n        /* fix other edges on this face loop */\r\n        var e = eOrig;\r\n        do {\r\n            e.Lface = fNew;\r\n            e = e.Lnext;\r\n        } while(e !== eOrig);\r\n    },\r\n\r\n    /* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),\r\n    * and removes from the global edge list.\r\n    */\r\n    //static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )\r\n    killEdge_: function(eDel) {\r\n        /* Half-edges are allocated in pairs, see EdgePair above */\r\n        if( eDel.Sym.side < eDel.side ) { eDel = eDel.Sym; }\r\n\r\n        /* delete from circular doubly-linked list */\r\n        var eNext = eDel.next;\r\n        var ePrev = eDel.Sym.next;\r\n        eNext.Sym.next = ePrev;\r\n        ePrev.Sym.next = eNext;\r\n    },\r\n\r\n\r\n    /* KillVertex( vDel ) destroys a vertex and removes it from the global\r\n    * vertex list.  It updates the vertex loop to point to a given new vertex.\r\n    */\r\n    //static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )\r\n    killVertex_: function(vDel, newOrg) {\r\n        var eStart = vDel.anEdge;\r\n        /* change the origin of all affected edges */\r\n        var e = eStart;\r\n        do {\r\n            e.Org = newOrg;\r\n            e = e.Onext;\r\n        } while(e !== eStart);\r\n\r\n        /* delete from circular doubly-linked list */\r\n        var vPrev = vDel.prev;\r\n        var vNext = vDel.next;\r\n        vNext.prev = vPrev;\r\n        vPrev.next = vNext;\r\n    },\r\n\r\n    /* KillFace( fDel ) destroys a face and removes it from the global face\r\n    * list.  It updates the face loop to point to a given new face.\r\n    */\r\n    //static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )\r\n    killFace_: function(fDel, newLface) {\r\n        var eStart = fDel.anEdge;\r\n\r\n        /* change the left face of all affected edges */\r\n        var e = eStart;\r\n        do {\r\n            e.Lface = newLface;\r\n            e = e.Lnext;\r\n        } while(e !== eStart);\r\n\r\n        /* delete from circular doubly-linked list */\r\n        var fPrev = fDel.prev;\r\n        var fNext = fDel.next;\r\n        fNext.prev = fPrev;\r\n        fPrev.next = fNext;\r\n    },\r\n\r\n    /****************** Basic Edge Operations **********************/\r\n\r\n    /* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).\r\n    * The loop consists of the two new half-edges.\r\n    */\r\n    //TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )\r\n    makeEdge: function() {\r\n        var newVertex1 = new TESSvertex();\r\n        var newVertex2 = new TESSvertex();\r\n        var newFace = new TESSface();\r\n        var e = this.makeEdge_( this.eHead);\r\n        this.makeVertex_( newVertex1, e, this.vHead );\r\n        this.makeVertex_( newVertex2, e.Sym, this.vHead );\r\n        this.makeFace_( newFace, e, this.fHead );\r\n        return e;\r\n    },\r\n\r\n    /* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the\r\n    * mesh connectivity and topology.  It changes the mesh so that\r\n    *\teOrg->Onext <- OLD( eDst->Onext )\r\n    *\teDst->Onext <- OLD( eOrg->Onext )\r\n    * where OLD(...) means the value before the meshSplice operation.\r\n    *\r\n    * This can have two effects on the vertex structure:\r\n    *  - if eOrg->Org != eDst->Org, the two vertices are merged together\r\n    *  - if eOrg->Org == eDst->Org, the origin is split into two vertices\r\n    * In both cases, eDst->Org is changed and eOrg->Org is untouched.\r\n    *\r\n    * Similarly (and independently) for the face structure,\r\n    *  - if eOrg->Lface == eDst->Lface, one loop is split into two\r\n    *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one\r\n    * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.\r\n    *\r\n    * Some special cases:\r\n    * If eDst == eOrg, the operation has no effect.\r\n    * If eDst == eOrg->Lnext, the new face will have a single edge.\r\n    * If eDst == eOrg->Lprev, the old face will have a single edge.\r\n    * If eDst == eOrg->Onext, the new vertex will have a single edge.\r\n    * If eDst == eOrg->Oprev, the old vertex will have a single edge.\r\n    */\r\n    //int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )\r\n    splice: function(eOrg, eDst) {\r\n        var joiningLoops = false;\r\n        var joiningVertices = false;\r\n\r\n        if( eOrg === eDst ) return;\r\n\r\n        if( eDst.Org !== eOrg.Org ) {\r\n            /* We are merging two disjoint vertices -- destroy eDst->Org */\r\n            joiningVertices = true;\r\n            this.killVertex_( eDst.Org, eOrg.Org );\r\n        }\r\n        if( eDst.Lface !== eOrg.Lface ) {\r\n            /* We are connecting two disjoint loops -- destroy eDst->Lface */\r\n            joiningLoops = true;\r\n            this.killFace_( eDst.Lface, eOrg.Lface );\r\n        }\r\n\r\n        /* Change the edge structure */\r\n        this.splice_( eDst, eOrg );\r\n\r\n        if( ! joiningVertices ) {\r\n            var newVertex = new TESSvertex();\r\n\r\n            /* We split one vertex into two -- the new vertex is eDst->Org.\r\n            * Make sure the old vertex points to a valid half-edge.\r\n            */\r\n            this.makeVertex_( newVertex, eDst, eOrg.Org );\r\n            eOrg.Org.anEdge = eOrg;\r\n        }\r\n        if( ! joiningLoops ) {\r\n            var newFace = new TESSface();\r\n\r\n            /* We split one loop into two -- the new loop is eDst->Lface.\r\n            * Make sure the old face points to a valid half-edge.\r\n            */\r\n            this.makeFace_( newFace, eDst, eOrg.Lface );\r\n            eOrg.Lface.anEdge = eOrg;\r\n        }\r\n    },\r\n\r\n    /* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:\r\n    * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop\r\n    * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;\r\n    * the newly created loop will contain eDel->Dst.  If the deletion of eDel\r\n    * would create isolated vertices, those are deleted as well.\r\n    *\r\n    * This function could be implemented as two calls to tessMeshSplice\r\n    * plus a few calls to memFree, but this would allocate and delete\r\n    * unnecessary vertices and faces.\r\n    */\r\n    //int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )\r\n    delete: function(eDel) {\r\n        var eDelSym = eDel.Sym;\r\n        var joiningLoops = false;\r\n\r\n        /* First step: disconnect the origin vertex eDel->Org.  We make all\r\n        * changes to get a consistent mesh in this \"intermediate\" state.\r\n        */\r\n        if( eDel.Lface !== eDel.Rface ) {\r\n            /* We are joining two loops into one -- remove the left face */\r\n            joiningLoops = true;\r\n            this.killFace_( eDel.Lface, eDel.Rface );\r\n        }\r\n\r\n        if( eDel.Onext === eDel ) {\r\n            this.killVertex_( eDel.Org, null );\r\n        } else {\r\n            /* Make sure that eDel->Org and eDel->Rface point to valid half-edges */\r\n            eDel.Rface.anEdge = eDel.Oprev;\r\n            eDel.Org.anEdge = eDel.Onext;\r\n\r\n            this.splice_( eDel, eDel.Oprev );\r\n            if( ! joiningLoops ) {\r\n                var newFace = new TESSface();\r\n\r\n                /* We are splitting one loop into two -- create a new loop for eDel. */\r\n                this.makeFace_( newFace, eDel, eDel.Lface );\r\n            }\r\n        }\r\n\r\n        /* Claim: the mesh is now in a consistent state, except that eDel->Org\r\n        * may have been deleted.  Now we disconnect eDel->Dst.\r\n        */\r\n        if( eDelSym.Onext === eDelSym ) {\r\n            this.killVertex_( eDelSym.Org, null );\r\n            this.killFace_( eDelSym.Lface, null );\r\n        } else {\r\n            /* Make sure that eDel->Dst and eDel->Lface point to valid half-edges */\r\n            eDel.Lface.anEdge = eDelSym.Oprev;\r\n            eDelSym.Org.anEdge = eDelSym.Onext;\r\n            this.splice_( eDelSym, eDelSym.Oprev );\r\n        }\r\n\r\n        /* Any isolated vertices or faces have already been freed. */\r\n        this.killEdge_( eDel );\r\n    },\r\n\r\n    /******************** Other Edge Operations **********************/\r\n\r\n    /* All these routines can be implemented with the basic edge\r\n    * operations above.  They are provided for convenience and efficiency.\r\n    */\r\n\r\n\r\n    /* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that\r\n    * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.\r\n    * eOrg and eNew will have the same left face.\r\n    */\r\n    // TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );\r\n    addEdgeVertex: function(eOrg) {\r\n        var eNew = this.makeEdge_( eOrg );\r\n        var eNewSym = eNew.Sym;\r\n\r\n        /* Connect the new edge appropriately */\r\n        this.splice_( eNew, eOrg.Lnext );\r\n\r\n        /* Set the vertex and face information */\r\n        eNew.Org = eOrg.Dst;\r\n\r\n        var newVertex = new TESSvertex();\r\n        this.makeVertex_( newVertex, eNewSym, eNew.Org );\r\n\r\n        eNew.Lface = eNewSym.Lface = eOrg.Lface;\r\n\r\n        return eNew;\r\n    },\r\n\r\n\r\n    /* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,\r\n    * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.\r\n    * eOrg and eNew will have the same left face.\r\n    */\r\n    // TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );\r\n    splitEdge: function(eOrg, eDst) {\r\n        var tempHalfEdge = this.addEdgeVertex( eOrg );\r\n        var eNew = tempHalfEdge.Sym;\r\n\r\n        /* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */\r\n        this.splice_( eOrg.Sym, eOrg.Sym.Oprev );\r\n        this.splice_( eOrg.Sym, eNew );\r\n\r\n        /* Set the vertex and face information */\r\n        eOrg.Dst = eNew.Org;\r\n        eNew.Dst.anEdge = eNew.Sym;\t/* may have pointed to eOrg->Sym */\r\n        eNew.Rface = eOrg.Rface;\r\n        eNew.winding = eOrg.winding;\t/* copy old winding information */\r\n        eNew.Sym.winding = eOrg.Sym.winding;\r\n\r\n        return eNew;\r\n    },\r\n\r\n\r\n    /* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst\r\n    * to eDst->Org, and returns the corresponding half-edge eNew.\r\n    * If eOrg->Lface == eDst->Lface, this splits one loop into two,\r\n    * and the newly created loop is eNew->Lface.  Otherwise, two disjoint\r\n    * loops are merged into one, and the loop eDst->Lface is destroyed.\r\n    *\r\n    * If (eOrg == eDst), the new face will have only two edges.\r\n    * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.\r\n    * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.\r\n    */\r\n\r\n    // TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );\r\n    connect: function(eOrg, eDst) {\r\n        var joiningLoops = false;\r\n        var eNew = this.makeEdge_( eOrg );\r\n        var eNewSym = eNew.Sym;\r\n\r\n        if( eDst.Lface !== eOrg.Lface ) {\r\n            /* We are connecting two disjoint loops -- destroy eDst->Lface */\r\n            joiningLoops = true;\r\n            this.killFace_( eDst.Lface, eOrg.Lface );\r\n        }\r\n\r\n        /* Connect the new edge appropriately */\r\n        this.splice_( eNew, eOrg.Lnext );\r\n        this.splice_( eNewSym, eDst );\r\n\r\n        /* Set the vertex and face information */\r\n        eNew.Org = eOrg.Dst;\r\n        eNewSym.Org = eDst.Org;\r\n        eNew.Lface = eNewSym.Lface = eOrg.Lface;\r\n\r\n        /* Make sure the old face points to a valid half-edge */\r\n        eOrg.Lface.anEdge = eNewSym;\r\n\r\n        if( ! joiningLoops ) {\r\n            var newFace = new TESSface();\r\n            /* We split one loop into two -- the new loop is eNew->Lface */\r\n            this.makeFace_( newFace, eNew, eOrg.Lface );\r\n        }\r\n        return eNew;\r\n    },\r\n\r\n    /* tessMeshZapFace( fZap ) destroys a face and removes it from the\r\n    * global face list.  All edges of fZap will have a NULL pointer as their\r\n    * left face.  Any edges which also have a NULL pointer as their right face\r\n    * are deleted entirely (along with any isolated vertices this produces).\r\n    * An entire mesh can be deleted by zapping its faces, one at a time,\r\n    * in any order.  Zapped faces cannot be used in further mesh operations!\r\n    */\r\n    zapFace: function( fZap )\r\n    {\r\n        var eStart = fZap.anEdge;\r\n        var e, eNext, eSym;\r\n        var fPrev, fNext;\r\n\r\n        /* walk around face, deleting edges whose right face is also NULL */\r\n        eNext = eStart.Lnext;\r\n        do {\r\n            e = eNext;\r\n            eNext = e.Lnext;\r\n\r\n            e.Lface = null;\r\n            if( e.Rface === null ) {\r\n                /* delete the edge -- see TESSmeshDelete above */\r\n\r\n                if( e.Onext === e ) {\r\n                    this.killVertex_( e.Org, null );\r\n                } else {\r\n                    /* Make sure that e->Org points to a valid half-edge */\r\n                    e.Org.anEdge = e.Onext;\r\n                    this.splice_( e, e.Oprev );\r\n                }\r\n                eSym = e.Sym;\r\n                if( eSym.Onext === eSym ) {\r\n                    this.killVertex_( eSym.Org, null );\r\n                } else {\r\n                    /* Make sure that eSym->Org points to a valid half-edge */\r\n                    eSym.Org.anEdge = eSym.Onext;\r\n                    this.splice_( eSym, eSym.Oprev );\r\n                }\r\n                this.killEdge_( e );\r\n            }\r\n        } while( e != eStart );\r\n\r\n        /* delete from circular doubly-linked list */\r\n        fPrev = fZap.prev;\r\n        fNext = fZap.next;\r\n        fNext.prev = fPrev;\r\n        fPrev.next = fNext;\r\n    },\r\n\r\n    countFaceVerts_: function(f) {\r\n        var eCur = f.anEdge;\r\n        var n = 0;\r\n        do\r\n        {\r\n            n++;\r\n            eCur = eCur.Lnext;\r\n        }\r\n        while (eCur !== f.anEdge);\r\n        return n;\r\n    },\r\n\r\n    //int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )\r\n    mergeConvexFaces: function(maxVertsPerFace) {\r\n        var f;\r\n        var eCur, eNext, eSym;\r\n        var vStart;\r\n        var curNv, symNv;\r\n\r\n        for( f = this.fHead.next; f !== this.fHead; f = f.next )\r\n        {\r\n            // Skip faces which are outside the result.\r\n            if( !f.inside )\r\n                continue;\r\n\r\n            eCur = f.anEdge;\r\n            vStart = eCur.Org;\r\n\r\n            while (true)\r\n            {\r\n                eNext = eCur.Lnext;\r\n                eSym = eCur.Sym;\r\n\r\n                // Try to merge if the neighbour face is valid.\r\n                if( eSym && eSym.Lface && eSym.Lface.inside )\r\n                {\r\n                    // Try to merge the neighbour faces if the resulting polygons\r\n                    // does not exceed maximum number of vertices.\r\n                    curNv = this.countFaceVerts_( f );\r\n                    symNv = this.countFaceVerts_( eSym.Lface );\r\n                    if( (curNv+symNv-2) <= maxVertsPerFace )\r\n                    {\r\n                        // Merge if the resulting poly is convex.\r\n                        if( Geom.vertCCW( eCur.Lprev.Org, eCur.Org, eSym.Lnext.Lnext.Org ) &&\r\n                            Geom.vertCCW( eSym.Lprev.Org, eSym.Org, eCur.Lnext.Lnext.Org ) )\r\n                        {\r\n                            eNext = eSym.Lnext;\r\n                            this.delete( eSym );\r\n                            eCur = null;\r\n                            eSym = null;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if( eCur && eCur.Lnext.Org === vStart )\r\n                    break;\r\n\r\n                // Continue to next edge.\r\n                eCur = eNext;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n    /* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.\r\n    */\r\n    check: function() {\r\n        var fHead = this.fHead;\r\n        var vHead = this.vHead;\r\n        var eHead = this.eHead;\r\n        var f, fPrev, v, vPrev, e, ePrev;\r\n\r\n        fPrev = fHead;\r\n        for( fPrev = fHead ; (f = fPrev.next) !== fHead; fPrev = f) {\r\n            assert( f.prev === fPrev );\r\n            e = f.anEdge;\r\n            do {\r\n                assert( e.Sym !== e );\r\n                assert( e.Sym.Sym === e );\r\n                assert( e.Lnext.Onext.Sym === e );\r\n                assert( e.Onext.Sym.Lnext === e );\r\n                assert( e.Lface === f );\r\n                e = e.Lnext;\r\n            } while( e !== f.anEdge );\r\n        }\r\n        assert( f.prev === fPrev && f.anEdge === null );\r\n\r\n        vPrev = vHead;\r\n        for( vPrev = vHead ; (v = vPrev.next) !== vHead; vPrev = v) {\r\n            assert( v.prev === vPrev );\r\n            e = v.anEdge;\r\n            do {\r\n                assert( e.Sym !== e );\r\n                assert( e.Sym.Sym === e );\r\n                assert( e.Lnext.Onext.Sym === e );\r\n                assert( e.Onext.Sym.Lnext === e );\r\n                assert( e.Org === v );\r\n                e = e.Onext;\r\n            } while( e !== v.anEdge );\r\n        }\r\n        assert( v.prev === vPrev && v.anEdge === null );\r\n\r\n        ePrev = eHead;\r\n        for( ePrev = eHead ; (e = ePrev.next) !== eHead; ePrev = e) {\r\n            assert( e.Sym.next === ePrev.Sym );\r\n            assert( e.Sym !== e );\r\n            assert( e.Sym.Sym === e );\r\n            assert( e.Org !== null );\r\n            assert( e.Dst !== null );\r\n            assert( e.Lnext.Onext.Sym === e );\r\n            assert( e.Onext.Sym.Lnext === e );\r\n        }\r\n        assert( e.Sym.next === ePrev.Sym\r\n            && e.Sym === this.eHeadSym\r\n            && e.Sym.Sym === e\r\n            && e.Org === null && e.Dst === null\r\n            && e.Lface === null && e.Rface === null );\r\n    }\r\n\r\n};\r\n\r\nvar Geom = {};\r\n\r\nGeom.vertEq = function(u,v) {\r\n    return (u.s === v.s && u.t === v.t);\r\n};\r\n\r\n/* Returns TRUE if u is lexicographically <= v. */\r\nGeom.vertLeq = function(u,v) {\r\n    return ((u.s < v.s) || (u.s === v.s && u.t <= v.t));\r\n};\r\n\r\n/* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */\r\nGeom.transLeq = function(u,v) {\r\n    return ((u.t < v.t) || (u.t === v.t && u.s <= v.s));\r\n};\r\n\r\nGeom.edgeGoesLeft = function(e) {\r\n    return Geom.vertLeq( e.Dst, e.Org );\r\n};\r\n\r\nGeom.edgeGoesRight = function(e) {\r\n    return Geom.vertLeq( e.Org, e.Dst );\r\n};\r\n\r\nGeom.vertL1dist = function(u,v) {\r\n    return (Math.abs(u.s - v.s) + Math.abs(u.t - v.t));\r\n};\r\n\r\n//TESSreal tesedgeEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\nGeom.edgeEval = function( u, v, w ) {\r\n    /* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),\r\n    * evaluates the t-coord of the edge uw at the s-coord of the vertex v.\r\n    * Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.\r\n    * If uw is vertical (and thus passes thru v), the result is zero.\r\n    *\r\n    * The calculation is extremely accurate and stable, even when v\r\n    * is very close to u or w.  In particular if we set v->t = 0 and\r\n    * let r be the negated result (this evaluates (uw)(v->s)), then\r\n    * r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).\r\n    */\r\n    assert( Geom.vertLeq( u, v ) && Geom.vertLeq( v, w ));\r\n\r\n    var gapL = v.s - u.s;\r\n    var gapR = w.s - v.s;\r\n\r\n    if( gapL + gapR > 0.0 ) {\r\n        if( gapL < gapR ) {\r\n            return (v.t - u.t) + (u.t - w.t) * (gapL / (gapL + gapR));\r\n        } else {\r\n            return (v.t - w.t) + (w.t - u.t) * (gapR / (gapL + gapR));\r\n        }\r\n    }\r\n    /* vertical line */\r\n    return 0.0;\r\n};\r\n\r\n//TESSreal tesedgeSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\nGeom.edgeSign = function( u, v, w ) {\r\n    /* Returns a number whose sign matches EdgeEval(u,v,w) but which\r\n    * is cheaper to evaluate.  Returns > 0, == 0 , or < 0\r\n    * as v is above, on, or below the edge uw.\r\n    */\r\n    assert( Geom.vertLeq( u, v ) && Geom.vertLeq( v, w ));\r\n\r\n    var gapL = v.s - u.s;\r\n    var gapR = w.s - v.s;\r\n\r\n    if( gapL + gapR > 0.0 ) {\r\n        return (v.t - w.t) * gapL + (v.t - u.t) * gapR;\r\n    }\r\n    /* vertical line */\r\n    return 0.0;\r\n};\r\n\r\n\r\n/***********************************************************************\r\n * Define versions of EdgeSign, EdgeEval with s and t transposed.\r\n */\r\n\r\n//TESSreal testransEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\nGeom.transEval = function( u, v, w ) {\r\n    /* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),\r\n    * evaluates the t-coord of the edge uw at the s-coord of the vertex v.\r\n    * Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.\r\n    * If uw is vertical (and thus passes thru v), the result is zero.\r\n    *\r\n    * The calculation is extremely accurate and stable, even when v\r\n    * is very close to u or w.  In particular if we set v->s = 0 and\r\n    * let r be the negated result (this evaluates (uw)(v->t)), then\r\n    * r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).\r\n    */\r\n    assert( Geom.transLeq( u, v ) && Geom.transLeq( v, w ));\r\n\r\n    var gapL = v.t - u.t;\r\n    var gapR = w.t - v.t;\r\n\r\n    if( gapL + gapR > 0.0 ) {\r\n        if( gapL < gapR ) {\r\n            return (v.s - u.s) + (u.s - w.s) * (gapL / (gapL + gapR));\r\n        } else {\r\n            return (v.s - w.s) + (w.s - u.s) * (gapR / (gapL + gapR));\r\n        }\r\n    }\r\n    /* vertical line */\r\n    return 0.0;\r\n};\r\n\r\n//TESSreal testransSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\nGeom.transSign = function( u, v, w ) {\r\n    /* Returns a number whose sign matches TransEval(u,v,w) but which\r\n    * is cheaper to evaluate.  Returns > 0, == 0 , or < 0\r\n    * as v is above, on, or below the edge uw.\r\n    */\r\n    assert( Geom.transLeq( u, v ) && Geom.transLeq( v, w ));\r\n\r\n    var gapL = v.t - u.t;\r\n    var gapR = w.t - v.t;\r\n\r\n    if( gapL + gapR > 0.0 ) {\r\n        return (v.s - w.s) * gapL + (v.s - u.s) * gapR;\r\n    }\r\n    /* vertical line */\r\n    return 0.0;\r\n};\r\n\r\n\r\n//int tesvertCCW( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\nGeom.vertCCW = function( u, v, w ) {\r\n    /* For almost-degenerate situations, the results are not reliable.\r\n    * Unless the floating-point arithmetic can be performed without\r\n    * rounding errors, *any* implementation will give incorrect results\r\n    * on some degenerate inputs, so the client must have some way to\r\n    * handle this situation.\r\n    */\r\n    return (u.s*(v.t - w.t) + v.s*(w.t - u.t) + w.s*(u.t - v.t)) >= 0.0;\r\n};\r\n\r\n/* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),\r\n* or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces\r\n* this in the rare case that one argument is slightly negative.\r\n* The implementation is extremely stable numerically.\r\n* In particular it guarantees that the result r satisfies\r\n* MIN(x,y) <= r <= MAX(x,y), and the results are very accurate\r\n* even when a and b differ greatly in magnitude.\r\n*/\r\nGeom.interpolate = function(a,x,b,y) {\r\n    return (a = (a < 0) ? 0 : a, b = (b < 0) ? 0 : b, ((a <= b) ? ((b == 0) ? ((x+y) / 2) : (x + (y-x) * (a/(a+b)))) : (y + (x-y) * (b/(a+b)))));\r\n};\r\n\r\n/*\r\n#ifndef FOR_TRITE_TEST_PROGRAM\r\n#define Interpolate(a,x,b,y)\tRealInterpolate(a,x,b,y)\r\n#else\r\n\r\n// Claim: the ONLY property the sweep algorithm relies on is that\r\n// MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.\r\n#include <stdlib.h>\r\nextern int RandomInterpolate;\r\n\r\ndouble Interpolate( double a, double x, double b, double y)\r\n{\r\n    printf(\"*********************%d\\n\",RandomInterpolate);\r\n    if( RandomInterpolate ) {\r\n        a = 1.2 * drand48() - 0.1;\r\n        a = (a < 0) ? 0 : ((a > 1) ? 1 : a);\r\n        b = 1.0 - a;\r\n    }\r\n    return RealInterpolate(a,x,b,y);\r\n}\r\n#endif*/\r\n\r\nGeom.intersect = function( o1, d1, o2, d2, v ) {\r\n    /* Given edges (o1,d1) and (o2,d2), compute their point of intersection.\r\n    * The computed point is guaranteed to lie in the intersection of the\r\n    * bounding rectangles defined by each edge.\r\n    */\r\n    var z1, z2;\r\n    var t;\r\n\r\n    /* This is certainly not the most efficient way to find the intersection\r\n    * of two line segments, but it is very numerically stable.\r\n    *\r\n    * Strategy: find the two middle vertices in the VertLeq ordering,\r\n    * and interpolate the intersection s-value from these.  Then repeat\r\n    * using the TransLeq ordering to find the intersection t-value.\r\n    */\r\n\r\n    if( ! Geom.vertLeq( o1, d1 )) { t = o1; o1 = d1; d1 = t; } //swap( o1, d1 ); }\r\n    if( ! Geom.vertLeq( o2, d2 )) { t = o2; o2 = d2; d2 = t; } //swap( o2, d2 ); }\r\n    if( ! Geom.vertLeq( o1, o2 )) { t = o1; o1 = o2; o2 = t; t = d1; d1 = d2; d2 = t; }//swap( o1, o2 ); swap( d1, d2 ); }\r\n\r\n    if( ! Geom.vertLeq( o2, d1 )) {\r\n        /* Technically, no intersection -- do our best */\r\n        v.s = (o2.s + d1.s) / 2;\r\n    } else if( Geom.vertLeq( d1, d2 )) {\r\n        /* Interpolate between o2 and d1 */\r\n        z1 = Geom.edgeEval( o1, o2, d1 );\r\n        z2 = Geom.edgeEval( o2, d1, d2 );\r\n        if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }\r\n        v.s = Geom.interpolate( z1, o2.s, z2, d1.s );\r\n    } else {\r\n        /* Interpolate between o2 and d2 */\r\n        z1 = Geom.edgeSign( o1, o2, d1 );\r\n        z2 = -Geom.edgeSign( o1, d2, d1 );\r\n        if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }\r\n        v.s = Geom.interpolate( z1, o2.s, z2, d2.s );\r\n    }\r\n\r\n    /* Now repeat the process for t */\r\n\r\n    if( ! Geom.transLeq( o1, d1 )) { t = o1; o1 = d1; d1 = t; } //swap( o1, d1 ); }\r\n    if( ! Geom.transLeq( o2, d2 )) { t = o2; o2 = d2; d2 = t; } //swap( o2, d2 ); }\r\n    if( ! Geom.transLeq( o1, o2 )) { t = o1; o1 = o2; o2 = t; t = d1; d1 = d2; d2 = t; } //swap( o1, o2 ); swap( d1, d2 ); }\r\n\r\n    if( ! Geom.transLeq( o2, d1 )) {\r\n        /* Technically, no intersection -- do our best */\r\n        v.t = (o2.t + d1.t) / 2;\r\n    } else if( Geom.transLeq( d1, d2 )) {\r\n        /* Interpolate between o2 and d1 */\r\n        z1 = Geom.transEval( o1, o2, d1 );\r\n        z2 = Geom.transEval( o2, d1, d2 );\r\n        if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }\r\n        v.t = Geom.interpolate( z1, o2.t, z2, d1.t );\r\n    } else {\r\n        /* Interpolate between o2 and d2 */\r\n        z1 = Geom.transSign( o1, o2, d1 );\r\n        z2 = -Geom.transSign( o1, d2, d1 );\r\n        if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }\r\n        v.t = Geom.interpolate( z1, o2.t, z2, d2.t );\r\n    }\r\n};\r\n\r\n\r\n\r\nfunction DictNode() {\r\n    this.key = null;\r\n    this.next = null;\r\n    this.prev = null;\r\n};\r\n\r\nfunction Dict(frame, leq) {\r\n    this.head = new DictNode();\r\n    this.head.next = this.head;\r\n    this.head.prev = this.head;\r\n    this.frame = frame;\r\n    this.leq = leq;\r\n};\r\n\r\nDict.prototype = {\r\n    min: function() {\r\n        return this.head.next;\r\n    },\r\n\r\n    max: function() {\r\n        return this.head.prev;\r\n    },\r\n\r\n    insert: function(k) {\r\n        return this.insertBefore(this.head, k);\r\n    },\r\n\r\n    search: function(key) {\r\n        /* Search returns the node with the smallest key greater than or equal\r\n        * to the given key.  If there is no such key, returns a node whose\r\n        * key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.\r\n        */\r\n        var node = this.head;\r\n        do {\r\n            node = node.next;\r\n        } while( node.key !== null && ! this.leq(this.frame, key, node.key));\r\n\r\n        return node;\r\n    },\r\n\r\n    insertBefore: function(node, key) {\r\n        do {\r\n            node = node.prev;\r\n        } while( node.key !== null && ! this.leq(this.frame, node.key, key));\r\n\r\n        var newNode = new DictNode();\r\n        newNode.key = key;\r\n        newNode.next = node.next;\r\n        node.next.prev = newNode;\r\n        newNode.prev = node;\r\n        node.next = newNode;\r\n\r\n        return newNode;\r\n    },\r\n\r\n    delete: function(node) {\r\n        node.next.prev = node.prev;\r\n        node.prev.next = node.next;\r\n    }\r\n};\r\n\r\n\r\nfunction PQnode() {\r\n    this.handle = null;\r\n}\r\n\r\nfunction PQhandleElem() {\r\n    this.key = null;\r\n    this.node = null;\r\n}\r\n\r\nfunction PriorityQ(size, leq) {\r\n    this.size = 0;\r\n    this.max = size;\r\n\r\n    this.nodes = [];\r\n    this.nodes.length = size+1;\r\n    for (var i = 0; i < this.nodes.length; i++)\r\n        this.nodes[i] = new PQnode();\r\n\r\n    this.handles = [];\r\n    this.handles.length = size+1;\r\n    for (var i = 0; i < this.handles.length; i++)\r\n        this.handles[i] = new PQhandleElem();\r\n\r\n    this.initialized = false;\r\n    this.freeList = 0;\r\n    this.leq = leq;\r\n\r\n    this.nodes[1].handle = 1;\t/* so that Minimum() returns NULL */\r\n    this.handles[1].key = null;\r\n};\r\n\r\nPriorityQ.prototype = {\r\n\r\n    floatDown_: function( curr )\r\n    {\r\n        var n = this.nodes;\r\n        var h = this.handles;\r\n        var hCurr, hChild;\r\n        var child;\r\n\r\n        hCurr = n[curr].handle;\r\n        for( ;; ) {\r\n            child = curr << 1;\r\n            if( child < this.size && this.leq( h[n[child+1].handle].key, h[n[child].handle].key )) {\r\n                ++child;\r\n            }\r\n\r\n            assert(child <= this.max);\r\n\r\n            hChild = n[child].handle;\r\n            if( child > this.size || this.leq( h[hCurr].key, h[hChild].key )) {\r\n                n[curr].handle = hCurr;\r\n                h[hCurr].node = curr;\r\n                break;\r\n            }\r\n            n[curr].handle = hChild;\r\n            h[hChild].node = curr;\r\n            curr = child;\r\n        }\r\n    },\r\n\r\n    floatUp_: function( curr )\r\n    {\r\n        var n = this.nodes;\r\n        var h = this.handles;\r\n        var hCurr, hParent;\r\n        var parent;\r\n\r\n        hCurr = n[curr].handle;\r\n        for( ;; ) {\r\n            parent = curr >> 1;\r\n            hParent = n[parent].handle;\r\n            if( parent == 0 || this.leq( h[hParent].key, h[hCurr].key )) {\r\n                n[curr].handle = hCurr;\r\n                h[hCurr].node = curr;\r\n                break;\r\n            }\r\n            n[curr].handle = hParent;\r\n            h[hParent].node = curr;\r\n            curr = parent;\r\n        }\r\n    },\r\n\r\n    init: function() {\r\n        /* This method of building a heap is O(n), rather than O(n lg n). */\r\n        for( var i = this.size; i >= 1; --i ) {\r\n            this.floatDown_( i );\r\n        }\r\n        this.initialized = true;\r\n    },\r\n\r\n    min: function() {\r\n        return this.handles[this.nodes[1].handle].key;\r\n    },\r\n\r\n    isEmpty: function() {\r\n        this.size === 0;\r\n    },\r\n\r\n    /* really pqHeapInsert */\r\n    /* returns INV_HANDLE iff out of memory */\r\n    //PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )\r\n    insert: function(keyNew)\r\n    {\r\n        var curr;\r\n        var free;\r\n\r\n        curr = ++this.size;\r\n        if( (curr*2) > this.max ) {\r\n            this.max *= 2;\r\n            var s;\r\n            s = this.nodes.length;\r\n            this.nodes.length = this.max+1;\r\n            for (var i = s; i < this.nodes.length; i++)\r\n                this.nodes[i] = new PQnode();\r\n\r\n            s = this.handles.length;\r\n            this.handles.length = this.max+1;\r\n            for (var i = s; i < this.handles.length; i++)\r\n                this.handles[i] = new PQhandleElem();\r\n        }\r\n\r\n        if( this.freeList === 0 ) {\r\n            free = curr;\r\n        } else {\r\n            free = this.freeList;\r\n            this.freeList = this.handles[free].node;\r\n        }\r\n\r\n        this.nodes[curr].handle = free;\r\n        this.handles[free].node = curr;\r\n        this.handles[free].key = keyNew;\r\n\r\n        if( this.initialized ) {\r\n            this.floatUp_( curr );\r\n        }\r\n        return free;\r\n    },\r\n\r\n    //PQkey pqHeapExtractMin( PriorityQHeap *pq )\r\n    extractMin: function() {\r\n        var n = this.nodes;\r\n        var h = this.handles;\r\n        var hMin = n[1].handle;\r\n        var min = h[hMin].key;\r\n\r\n        if( this.size > 0 ) {\r\n            n[1].handle = n[this.size].handle;\r\n            h[n[1].handle].node = 1;\r\n\r\n            h[hMin].key = null;\r\n            h[hMin].node = this.freeList;\r\n            this.freeList = hMin;\r\n\r\n            --this.size;\r\n            if( this.size > 0 ) {\r\n                this.floatDown_( 1 );\r\n            }\r\n        }\r\n        return min;\r\n    },\r\n\r\n    delete: function( hCurr ) {\r\n        var n = this.nodes;\r\n        var h = this.handles;\r\n        var curr;\r\n\r\n        assert( hCurr >= 1 && hCurr <= this.max && h[hCurr].key !== null );\r\n\r\n        curr = h[hCurr].node;\r\n        n[curr].handle = n[this.size].handle;\r\n        h[n[curr].handle].node = curr;\r\n\r\n        --this.size;\r\n        if( curr <= this.size ) {\r\n            if( curr <= 1 || this.leq( h[n[curr>>1].handle].key, h[n[curr].handle].key )) {\r\n                this.floatDown_( curr );\r\n            } else {\r\n                this.floatUp_( curr );\r\n            }\r\n        }\r\n        h[hCurr].key = null;\r\n        h[hCurr].node = this.freeList;\r\n        this.freeList = hCurr;\r\n    }\r\n};\r\n\r\n\r\n/* For each pair of adjacent edges crossing the sweep line, there is\r\n* an ActiveRegion to represent the region between them.  The active\r\n* regions are kept in sorted order in a dynamic dictionary.  As the\r\n* sweep line crosses each vertex, we update the affected regions.\r\n*/\r\n\r\nfunction ActiveRegion() {\r\n    this.eUp = null;\t\t/* upper edge, directed right to left */\r\n    this.nodeUp = null;\t/* dictionary node corresponding to eUp */\r\n    this.windingNumber = 0;\t/* used to determine which regions are\r\n\t\t\t\t\t\t\t\t* inside the polygon */\r\n    this.inside = false;\t\t/* is this region inside the polygon? */\r\n    this.sentinel = false;\t/* marks fake edges at t = +/-infinity */\r\n    this.dirty = false;\t\t/* marks regions where the upper or lower\r\n\t\t\t\t\t\t* edge has changed, but we haven't checked\r\n\t\t\t\t\t\t* whether they intersect yet */\r\n    this.fixUpperEdge = false;\t/* marks temporary edges introduced when\r\n\t\t\t\t\t\t\t* we process a \"right vertex\" (one without\r\n\t\t\t\t\t\t\t* any edges leaving to the right) */\r\n};\r\n\r\nvar Sweep = {};\r\n\r\nSweep.regionBelow = function(r) {\r\n    return r.nodeUp.prev.key;\r\n}\r\n\r\nSweep.regionAbove = function(r) {\r\n    return r.nodeUp.next.key;\r\n}\r\n\r\nSweep.debugEvent = function( tess ) {\r\n    // empty\r\n}\r\n\r\n\r\n/*\r\n* Invariants for the Edge Dictionary.\r\n* - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)\r\n*   at any valid location of the sweep event\r\n* - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2\r\n*   share a common endpoint\r\n* - for each e, e->Dst has been processed, but not e->Org\r\n* - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)\r\n*   where \"event\" is the current sweep line event.\r\n* - no edge e has zero length\r\n*\r\n* Invariants for the Mesh (the processed portion).\r\n* - the portion of the mesh left of the sweep line is a planar graph,\r\n*   ie. there is *some* way to embed it in the plane\r\n* - no processed edge has zero length\r\n* - no two processed vertices have identical coordinates\r\n* - each \"inside\" region is monotone, ie. can be broken into two chains\r\n*   of monotonically increasing vertices according to VertLeq(v1,v2)\r\n*   - a non-invariant: these chains may intersect (very slightly)\r\n*\r\n* Invariants for the Sweep.\r\n* - if none of the edges incident to the event vertex have an activeRegion\r\n*   (ie. none of these edges are in the edge dictionary), then the vertex\r\n*   has only right-going edges.\r\n* - if an edge is marked \"fixUpperEdge\" (it is a temporary edge introduced\r\n*   by ConnectRightVertex), then it is the only right-going edge from\r\n*   its associated vertex.  (This says that these edges exist only\r\n*   when it is necessary.)\r\n*/\r\n\r\n/* When we merge two edges into one, we need to compute the combined\r\n* winding of the new edge.\r\n*/\r\nSweep.addWinding = function(eDst,eSrc) {\r\n    eDst.winding += eSrc.winding;\r\n    eDst.Sym.winding += eSrc.Sym.winding;\r\n}\r\n\r\n\r\n//static int EdgeLeq( TESStesselator *tess, ActiveRegion *reg1, ActiveRegion *reg2 )\r\nSweep.edgeLeq = function( tess, reg1, reg2 ) {\r\n    /*\r\n    * Both edges must be directed from right to left (this is the canonical\r\n    * direction for the upper edge of each region).\r\n    *\r\n    * The strategy is to evaluate a \"t\" value for each edge at the\r\n    * current sweep line position, given by tess->event.  The calculations\r\n    * are designed to be very stable, but of course they are not perfect.\r\n    *\r\n    * Special case: if both edge destinations are at the sweep event,\r\n    * we sort the edges by slope (they would otherwise compare equally).\r\n    */\r\n    var ev = tess.event;\r\n    var t1, t2;\r\n\r\n    var e1 = reg1.eUp;\r\n    var e2 = reg2.eUp;\r\n\r\n    if( e1.Dst === ev ) {\r\n        if( e2.Dst === ev ) {\r\n            /* Two edges right of the sweep line which meet at the sweep event.\r\n            * Sort them by slope.\r\n            */\r\n            if( Geom.vertLeq( e1.Org, e2.Org )) {\r\n                return Geom.edgeSign( e2.Dst, e1.Org, e2.Org ) <= 0;\r\n            }\r\n            return Geom.edgeSign( e1.Dst, e2.Org, e1.Org ) >= 0;\r\n        }\r\n        return Geom.edgeSign( e2.Dst, ev, e2.Org ) <= 0;\r\n    }\r\n    if( e2.Dst === ev ) {\r\n        return Geom.edgeSign( e1.Dst, ev, e1.Org ) >= 0;\r\n    }\r\n\r\n    /* General case - compute signed distance *from* e1, e2 to event */\r\n    var t1 = Geom.edgeEval( e1.Dst, ev, e1.Org );\r\n    var t2 = Geom.edgeEval( e2.Dst, ev, e2.Org );\r\n    return (t1 >= t2);\r\n}\r\n\r\n\r\n//static void DeleteRegion( TESStesselator *tess, ActiveRegion *reg )\r\nSweep.deleteRegion = function( tess, reg ) {\r\n    if( reg.fixUpperEdge ) {\r\n        /* It was created with zero winding number, so it better be\r\n        * deleted with zero winding number (ie. it better not get merged\r\n        * with a real edge).\r\n        */\r\n        assert( reg.eUp.winding === 0 );\r\n    }\r\n    reg.eUp.activeRegion = null;\r\n    tess.dict.delete( reg.nodeUp );\r\n}\r\n\r\n//static int FixUpperEdge( TESStesselator *tess, ActiveRegion *reg, TESShalfEdge *newEdge )\r\nSweep.fixUpperEdge = function( tess, reg, newEdge ) {\r\n    /*\r\n    * Replace an upper edge which needs fixing (see ConnectRightVertex).\r\n    */\r\n    assert( reg.fixUpperEdge );\r\n    tess.mesh.delete( reg.eUp );\r\n    reg.fixUpperEdge = false;\r\n    reg.eUp = newEdge;\r\n    newEdge.activeRegion = reg;\r\n}\r\n\r\n//static ActiveRegion *TopLeftRegion( TESStesselator *tess, ActiveRegion *reg )\r\nSweep.topLeftRegion = function( tess, reg ) {\r\n    var org = reg.eUp.Org;\r\n    var e;\r\n\r\n    /* Find the region above the uppermost edge with the same origin */\r\n    do {\r\n        reg = Sweep.regionAbove( reg );\r\n    } while( reg.eUp.Org === org );\r\n\r\n    /* If the edge above was a temporary edge introduced by ConnectRightVertex,\r\n    * now is the time to fix it.\r\n    */\r\n    if( reg.fixUpperEdge ) {\r\n        e = tess.mesh.connect( Sweep.regionBelow(reg).eUp.Sym, reg.eUp.Lnext );\r\n        if (e === null) return null;\r\n        Sweep.fixUpperEdge( tess, reg, e );\r\n        reg = Sweep.regionAbove( reg );\r\n    }\r\n    return reg;\r\n}\r\n\r\n//static ActiveRegion *TopRightRegion( ActiveRegion *reg )\r\nSweep.topRightRegion = function( reg )\r\n{\r\n    var dst = reg.eUp.Dst;\r\n    var reg = null;\r\n    /* Find the region above the uppermost edge with the same destination */\r\n    do {\r\n        reg = Sweep.regionAbove( reg );\r\n    } while( reg.eUp.Dst === dst );\r\n    return reg;\r\n}\r\n\r\n//static ActiveRegion *AddRegionBelow( TESStesselator *tess, ActiveRegion *regAbove, TESShalfEdge *eNewUp )\r\nSweep.addRegionBelow = function( tess, regAbove, eNewUp ) {\r\n    /*\r\n    * Add a new active region to the sweep line, *somewhere* below \"regAbove\"\r\n    * (according to where the new edge belongs in the sweep-line dictionary).\r\n    * The upper edge of the new region will be \"eNewUp\".\r\n    * Winding number and \"inside\" flag are not updated.\r\n    */\r\n    var regNew = new ActiveRegion();\r\n    regNew.eUp = eNewUp;\r\n    regNew.nodeUp = tess.dict.insertBefore( regAbove.nodeUp, regNew );\r\n    //\tif (regNew->nodeUp == NULL) longjmp(tess->env,1);\r\n    regNew.fixUpperEdge = false;\r\n    regNew.sentinel = false;\r\n    regNew.dirty = false;\r\n\r\n    eNewUp.activeRegion = regNew;\r\n    return regNew;\r\n}\r\n\r\n//static int IsWindingInside( TESStesselator *tess, int n )\r\nSweep.isWindingInside = function( tess, n ) {\r\n    switch( tess.windingRule ) {\r\n        case Tess2.WINDING_ODD:\r\n            return (n & 1) != 0;\r\n        case Tess2.WINDING_NONZERO:\r\n            return (n != 0);\r\n        case Tess2.WINDING_POSITIVE:\r\n            return (n > 0);\r\n        case Tess2.WINDING_NEGATIVE:\r\n            return (n < 0);\r\n        case Tess2.WINDING_ABS_GEQ_TWO:\r\n            return (n >= 2) || (n <= -2);\r\n    }\r\n    assert( false );\r\n    return false;\r\n}\r\n\r\n//static void ComputeWinding( TESStesselator *tess, ActiveRegion *reg )\r\nSweep.computeWinding = function( tess, reg ) {\r\n    reg.windingNumber = Sweep.regionAbove(reg).windingNumber + reg.eUp.winding;\r\n    reg.inside = Sweep.isWindingInside( tess, reg.windingNumber );\r\n}\r\n\r\n\r\n//static void FinishRegion( TESStesselator *tess, ActiveRegion *reg )\r\nSweep.finishRegion = function( tess, reg ) {\r\n    /*\r\n    * Delete a region from the sweep line.  This happens when the upper\r\n    * and lower chains of a region meet (at a vertex on the sweep line).\r\n    * The \"inside\" flag is copied to the appropriate mesh face (we could\r\n    * not do this before -- since the structure of the mesh is always\r\n    * changing, this face may not have even existed until now).\r\n    */\r\n    var e = reg.eUp;\r\n    var f = e.Lface;\r\n\r\n    f.inside = reg.inside;\r\n    f.anEdge = e;   /* optimization for tessMeshTessellateMonoRegion() */\r\n    Sweep.deleteRegion( tess, reg );\r\n}\r\n\r\n\r\n//static TESShalfEdge *FinishLeftRegions( TESStesselator *tess, ActiveRegion *regFirst, ActiveRegion *regLast )\r\nSweep.finishLeftRegions = function( tess, regFirst, regLast ) {\r\n    /*\r\n    * We are given a vertex with one or more left-going edges.  All affected\r\n    * edges should be in the edge dictionary.  Starting at regFirst->eUp,\r\n    * we walk down deleting all regions where both edges have the same\r\n    * origin vOrg.  At the same time we copy the \"inside\" flag from the\r\n    * active region to the face, since at this point each face will belong\r\n    * to at most one region (this was not necessarily true until this point\r\n    * in the sweep).  The walk stops at the region above regLast; if regLast\r\n    * is NULL we walk as far as possible.  At the same time we relink the\r\n    * mesh if necessary, so that the ordering of edges around vOrg is the\r\n    * same as in the dictionary.\r\n    */\r\n    var e, ePrev;\r\n    var reg = null;\r\n    var regPrev = regFirst;\r\n    var ePrev = regFirst.eUp;\r\n    while( regPrev !== regLast ) {\r\n        regPrev.fixUpperEdge = false;\t/* placement was OK */\r\n        reg = Sweep.regionBelow( regPrev );\r\n        e = reg.eUp;\r\n        if( e.Org != ePrev.Org ) {\r\n            if( ! reg.fixUpperEdge ) {\r\n                /* Remove the last left-going edge.  Even though there are no further\r\n                * edges in the dictionary with this origin, there may be further\r\n                * such edges in the mesh (if we are adding left edges to a vertex\r\n                * that has already been processed).  Thus it is important to call\r\n                * FinishRegion rather than just DeleteRegion.\r\n                */\r\n                Sweep.finishRegion( tess, regPrev );\r\n                break;\r\n            }\r\n            /* If the edge below was a temporary edge introduced by\r\n            * ConnectRightVertex, now is the time to fix it.\r\n            */\r\n            e = tess.mesh.connect( ePrev.Lprev, e.Sym );\r\n            //\t\t\tif (e == NULL) longjmp(tess->env,1);\r\n            Sweep.fixUpperEdge( tess, reg, e );\r\n        }\r\n\r\n        /* Relink edges so that ePrev->Onext == e */\r\n        if( ePrev.Onext !== e ) {\r\n            tess.mesh.splice( e.Oprev, e );\r\n            tess.mesh.splice( ePrev, e );\r\n        }\r\n        Sweep.finishRegion( tess, regPrev );\t/* may change reg->eUp */\r\n        ePrev = reg.eUp;\r\n        regPrev = reg;\r\n    }\r\n    return ePrev;\r\n}\r\n\r\n\r\n//static void AddRightEdges( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eFirst, TESShalfEdge *eLast, TESShalfEdge *eTopLeft, int cleanUp )\r\nSweep.addRightEdges = function( tess, regUp, eFirst, eLast, eTopLeft, cleanUp ) {\r\n    /*\r\n    * Purpose: insert right-going edges into the edge dictionary, and update\r\n    * winding numbers and mesh connectivity appropriately.  All right-going\r\n    * edges share a common origin vOrg.  Edges are inserted CCW starting at\r\n    * eFirst; the last edge inserted is eLast->Oprev.  If vOrg has any\r\n    * left-going edges already processed, then eTopLeft must be the edge\r\n    * such that an imaginary upward vertical segment from vOrg would be\r\n    * contained between eTopLeft->Oprev and eTopLeft; otherwise eTopLeft\r\n    * should be NULL.\r\n    */\r\n    var reg, regPrev;\r\n    var e, ePrev;\r\n    var firstTime = true;\r\n\r\n    /* Insert the new right-going edges in the dictionary */\r\n    e = eFirst;\r\n    do {\r\n        assert( Geom.vertLeq( e.Org, e.Dst ));\r\n        Sweep.addRegionBelow( tess, regUp, e.Sym );\r\n        e = e.Onext;\r\n    } while ( e !== eLast );\r\n\r\n    /* Walk *all* right-going edges from e->Org, in the dictionary order,\r\n    * updating the winding numbers of each region, and re-linking the mesh\r\n    * edges to match the dictionary ordering (if necessary).\r\n    */\r\n    if( eTopLeft === null ) {\r\n        eTopLeft = Sweep.regionBelow( regUp ).eUp.Rprev;\r\n    }\r\n    regPrev = regUp;\r\n    ePrev = eTopLeft;\r\n    for( ;; ) {\r\n        reg = Sweep.regionBelow( regPrev );\r\n        e = reg.eUp.Sym;\r\n        if( e.Org !== ePrev.Org ) break;\r\n\r\n        if( e.Onext !== ePrev ) {\r\n            /* Unlink e from its current position, and relink below ePrev */\r\n            tess.mesh.splice( e.Oprev, e );\r\n            tess.mesh.splice( ePrev.Oprev, e );\r\n        }\r\n        /* Compute the winding number and \"inside\" flag for the new regions */\r\n        reg.windingNumber = regPrev.windingNumber - e.winding;\r\n        reg.inside = Sweep.isWindingInside( tess, reg.windingNumber );\r\n\r\n        /* Check for two outgoing edges with same slope -- process these\r\n        * before any intersection tests (see example in tessComputeInterior).\r\n        */\r\n        regPrev.dirty = true;\r\n        if( ! firstTime && Sweep.checkForRightSplice( tess, regPrev )) {\r\n            Sweep.addWinding( e, ePrev );\r\n            Sweep.deleteRegion( tess, regPrev );\r\n            tess.mesh.delete( ePrev );\r\n        }\r\n        firstTime = false;\r\n        regPrev = reg;\r\n        ePrev = e;\r\n    }\r\n    regPrev.dirty = true;\r\n    assert( regPrev.windingNumber - e.winding === reg.windingNumber );\r\n\r\n    if( cleanUp ) {\r\n        /* Check for intersections between newly adjacent edges. */\r\n        Sweep.walkDirtyRegions( tess, regPrev );\r\n    }\r\n}\r\n\r\n\r\n//static void SpliceMergeVertices( TESStesselator *tess, TESShalfEdge *e1, TESShalfEdge *e2 )\r\nSweep.spliceMergeVertices = function( tess, e1, e2 ) {\r\n    /*\r\n    * Two vertices with idential coordinates are combined into one.\r\n    * e1->Org is kept, while e2->Org is discarded.\r\n    */\r\n    tess.mesh.splice( e1, e2 );\r\n}\r\n\r\n//static void VertexWeights( TESSvertex *isect, TESSvertex *org, TESSvertex *dst, TESSreal *weights )\r\nSweep.vertexWeights = function( isect, org, dst ) {\r\n    /*\r\n    * Find some weights which describe how the intersection vertex is\r\n    * a linear combination of \"org\" and \"dest\".  Each of the two edges\r\n    * which generated \"isect\" is allocated 50% of the weight; each edge\r\n    * splits the weight between its org and dst according to the\r\n    * relative distance to \"isect\".\r\n    */\r\n    var t1 = Geom.vertL1dist( org, isect );\r\n    var t2 = Geom.vertL1dist( dst, isect );\r\n    var w0 = 0.5 * t2 / (t1 + t2);\r\n    var w1 = 0.5 * t1 / (t1 + t2);\r\n    isect.coords[0] += w0*org.coords[0] + w1*dst.coords[0];\r\n    isect.coords[1] += w0*org.coords[1] + w1*dst.coords[1];\r\n    isect.coords[2] += w0*org.coords[2] + w1*dst.coords[2];\r\n}\r\n\r\n\r\n//static void GetIntersectData( TESStesselator *tess, TESSvertex *isect, TESSvertex *orgUp, TESSvertex *dstUp, TESSvertex *orgLo, TESSvertex *dstLo )\r\nSweep.getIntersectData = function( tess, isect, orgUp, dstUp, orgLo, dstLo ) {\r\n    /*\r\n    * We've computed a new intersection point, now we need a \"data\" pointer\r\n    * from the user so that we can refer to this new vertex in the\r\n    * rendering callbacks.\r\n    */\r\n    isect.coords[0] = isect.coords[1] = isect.coords[2] = 0;\r\n    isect.idx = -1;\r\n    Sweep.vertexWeights( isect, orgUp, dstUp );\r\n    Sweep.vertexWeights( isect, orgLo, dstLo );\r\n}\r\n\r\n//static int CheckForRightSplice( TESStesselator *tess, ActiveRegion *regUp )\r\nSweep.checkForRightSplice = function( tess, regUp ) {\r\n    /*\r\n    * Check the upper and lower edge of \"regUp\", to make sure that the\r\n    * eUp->Org is above eLo, or eLo->Org is below eUp (depending on which\r\n    * origin is leftmost).\r\n    *\r\n    * The main purpose is to splice right-going edges with the same\r\n    * dest vertex and nearly identical slopes (ie. we can't distinguish\r\n    * the slopes numerically).  However the splicing can also help us\r\n    * to recover from numerical errors.  For example, suppose at one\r\n    * point we checked eUp and eLo, and decided that eUp->Org is barely\r\n    * above eLo.  Then later, we split eLo into two edges (eg. from\r\n    * a splice operation like this one).  This can change the result of\r\n    * our test so that now eUp->Org is incident to eLo, or barely below it.\r\n    * We must correct this condition to maintain the dictionary invariants.\r\n    *\r\n    * One possibility is to check these edges for intersection again\r\n    * (ie. CheckForIntersect).  This is what we do if possible.  However\r\n    * CheckForIntersect requires that tess->event lies between eUp and eLo,\r\n    * so that it has something to fall back on when the intersection\r\n    * calculation gives us an unusable answer.  So, for those cases where\r\n    * we can't check for intersection, this routine fixes the problem\r\n    * by just splicing the offending vertex into the other edge.\r\n    * This is a guaranteed solution, no matter how degenerate things get.\r\n    * Basically this is a combinatorial solution to a numerical problem.\r\n    */\r\n    var regLo = Sweep.regionBelow(regUp);\r\n    var eUp = regUp.eUp;\r\n    var eLo = regLo.eUp;\r\n\r\n    if( Geom.vertLeq( eUp.Org, eLo.Org )) {\r\n        if( Geom.edgeSign( eLo.Dst, eUp.Org, eLo.Org ) > 0 ) return false;\r\n\r\n        /* eUp->Org appears to be below eLo */\r\n        if( ! Geom.vertEq( eUp.Org, eLo.Org )) {\r\n            /* Splice eUp->Org into eLo */\r\n            tess.mesh.splitEdge( eLo.Sym );\r\n            tess.mesh.splice( eUp, eLo.Oprev );\r\n            regUp.dirty = regLo.dirty = true;\r\n\r\n        } else if( eUp.Org !== eLo.Org ) {\r\n            /* merge the two vertices, discarding eUp->Org */\r\n            tess.pq.delete( eUp.Org.pqHandle );\r\n            Sweep.spliceMergeVertices( tess, eLo.Oprev, eUp );\r\n        }\r\n    } else {\r\n        if( Geom.edgeSign( eUp.Dst, eLo.Org, eUp.Org ) < 0 ) return false;\r\n\r\n        /* eLo->Org appears to be above eUp, so splice eLo->Org into eUp */\r\n        Sweep.regionAbove(regUp).dirty = regUp.dirty = true;\r\n        tess.mesh.splitEdge( eUp.Sym );\r\n        tess.mesh.splice( eLo.Oprev, eUp );\r\n    }\r\n    return true;\r\n}\r\n\r\n//static int CheckForLeftSplice( TESStesselator *tess, ActiveRegion *regUp )\r\nSweep.checkForLeftSplice = function( tess, regUp ) {\r\n    /*\r\n    * Check the upper and lower edge of \"regUp\", to make sure that the\r\n    * eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which\r\n    * destination is rightmost).\r\n    *\r\n    * Theoretically, this should always be true.  However, splitting an edge\r\n    * into two pieces can change the results of previous tests.  For example,\r\n    * suppose at one point we checked eUp and eLo, and decided that eUp->Dst\r\n    * is barely above eLo.  Then later, we split eLo into two edges (eg. from\r\n    * a splice operation like this one).  This can change the result of\r\n    * the test so that now eUp->Dst is incident to eLo, or barely below it.\r\n    * We must correct this condition to maintain the dictionary invariants\r\n    * (otherwise new edges might get inserted in the wrong place in the\r\n    * dictionary, and bad stuff will happen).\r\n    *\r\n    * We fix the problem by just splicing the offending vertex into the\r\n    * other edge.\r\n    */\r\n    var regLo = Sweep.regionBelow(regUp);\r\n    var eUp = regUp.eUp;\r\n    var eLo = regLo.eUp;\r\n    var e;\r\n\r\n    assert( ! Geom.vertEq( eUp.Dst, eLo.Dst ));\r\n\r\n    if( Geom.vertLeq( eUp.Dst, eLo.Dst )) {\r\n        if( Geom.edgeSign( eUp.Dst, eLo.Dst, eUp.Org ) < 0 ) return false;\r\n\r\n        /* eLo->Dst is above eUp, so splice eLo->Dst into eUp */\r\n        Sweep.regionAbove(regUp).dirty = regUp.dirty = true;\r\n        e = tess.mesh.splitEdge( eUp );\r\n        tess.mesh.splice( eLo.Sym, e );\r\n        e.Lface.inside = regUp.inside;\r\n    } else {\r\n        if( Geom.edgeSign( eLo.Dst, eUp.Dst, eLo.Org ) > 0 ) return false;\r\n\r\n        /* eUp->Dst is below eLo, so splice eUp->Dst into eLo */\r\n        regUp.dirty = regLo.dirty = true;\r\n        e = tess.mesh.splitEdge( eLo );\r\n        tess.mesh.splice( eUp.Lnext, eLo.Sym );\r\n        e.Rface.inside = regUp.inside;\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\n//static int CheckForIntersect( TESStesselator *tess, ActiveRegion *regUp )\r\nSweep.checkForIntersect = function( tess, regUp ) {\r\n    /*\r\n    * Check the upper and lower edges of the given region to see if\r\n    * they intersect.  If so, create the intersection and add it\r\n    * to the data structures.\r\n    *\r\n    * Returns TRUE if adding the new intersection resulted in a recursive\r\n    * call to AddRightEdges(); in this case all \"dirty\" regions have been\r\n    * checked for intersections, and possibly regUp has been deleted.\r\n    */\r\n    var regLo = Sweep.regionBelow(regUp);\r\n    var eUp = regUp.eUp;\r\n    var eLo = regLo.eUp;\r\n    var orgUp = eUp.Org;\r\n    var orgLo = eLo.Org;\r\n    var dstUp = eUp.Dst;\r\n    var dstLo = eLo.Dst;\r\n    var tMinUp, tMaxLo;\r\n    var isect = new TESSvertex, orgMin;\r\n    var e;\r\n\r\n    assert( ! Geom.vertEq( dstLo, dstUp ));\r\n    assert( Geom.edgeSign( dstUp, tess.event, orgUp ) <= 0 );\r\n    assert( Geom.edgeSign( dstLo, tess.event, orgLo ) >= 0 );\r\n    assert( orgUp !== tess.event && orgLo !== tess.event );\r\n    assert( ! regUp.fixUpperEdge && ! regLo.fixUpperEdge );\r\n\r\n    if( orgUp === orgLo ) return false;\t/* right endpoints are the same */\r\n\r\n    tMinUp = Math.min( orgUp.t, dstUp.t );\r\n    tMaxLo = Math.max( orgLo.t, dstLo.t );\r\n    if( tMinUp > tMaxLo ) return false;\t/* t ranges do not overlap */\r\n\r\n    if( Geom.vertLeq( orgUp, orgLo )) {\r\n        if( Geom.edgeSign( dstLo, orgUp, orgLo ) > 0 ) return false;\r\n    } else {\r\n        if( Geom.edgeSign( dstUp, orgLo, orgUp ) < 0 ) return false;\r\n    }\r\n\r\n    /* At this point the edges intersect, at least marginally */\r\n    Sweep.debugEvent( tess );\r\n\r\n    Geom.intersect( dstUp, orgUp, dstLo, orgLo, isect );\r\n    /* The following properties are guaranteed: */\r\n    assert( Math.min( orgUp.t, dstUp.t ) <= isect.t );\r\n    assert( isect.t <= Math.max( orgLo.t, dstLo.t ));\r\n    assert( Math.min( dstLo.s, dstUp.s ) <= isect.s );\r\n    assert( isect.s <= Math.max( orgLo.s, orgUp.s ));\r\n\r\n    if( Geom.vertLeq( isect, tess.event )) {\r\n        /* The intersection point lies slightly to the left of the sweep line,\r\n        * so move it until it''s slightly to the right of the sweep line.\r\n        * (If we had perfect numerical precision, this would never happen\r\n        * in the first place).  The easiest and safest thing to do is\r\n        * replace the intersection by tess->event.\r\n        */\r\n        isect.s = tess.event.s;\r\n        isect.t = tess.event.t;\r\n    }\r\n    /* Similarly, if the computed intersection lies to the right of the\r\n    * rightmost origin (which should rarely happen), it can cause\r\n    * unbelievable inefficiency on sufficiently degenerate inputs.\r\n    * (If you have the test program, try running test54.d with the\r\n    * \"X zoom\" option turned on).\r\n    */\r\n    orgMin = Geom.vertLeq( orgUp, orgLo ) ? orgUp : orgLo;\r\n    if( Geom.vertLeq( orgMin, isect )) {\r\n        isect.s = orgMin.s;\r\n        isect.t = orgMin.t;\r\n    }\r\n\r\n    if( Geom.vertEq( isect, orgUp ) || Geom.vertEq( isect, orgLo )) {\r\n        /* Easy case -- intersection at one of the right endpoints */\r\n        Sweep.checkForRightSplice( tess, regUp );\r\n        return false;\r\n    }\r\n\r\n    if(    (! Geom.vertEq( dstUp, tess.event )\r\n        && Geom.edgeSign( dstUp, tess.event, isect ) >= 0)\r\n        || (! Geom.vertEq( dstLo, tess.event )\r\n            && Geom.edgeSign( dstLo, tess.event, isect ) <= 0 ))\r\n    {\r\n        /* Very unusual -- the new upper or lower edge would pass on the\r\n        * wrong side of the sweep event, or through it.  This can happen\r\n        * due to very small numerical errors in the intersection calculation.\r\n        */\r\n        if( dstLo === tess.event ) {\r\n            /* Splice dstLo into eUp, and process the new region(s) */\r\n            tess.mesh.splitEdge( eUp.Sym );\r\n            tess.mesh.splice( eLo.Sym, eUp );\r\n            regUp = Sweep.topLeftRegion( tess, regUp );\r\n            //\t\t\tif (regUp == NULL) longjmp(tess->env,1);\r\n            eUp = Sweep.regionBelow(regUp).eUp;\r\n            Sweep.finishLeftRegions( tess, Sweep.regionBelow(regUp), regLo );\r\n            Sweep.addRightEdges( tess, regUp, eUp.Oprev, eUp, eUp, true );\r\n            return TRUE;\r\n        }\r\n        if( dstUp === tess.event ) {\r\n            /* Splice dstUp into eLo, and process the new region(s) */\r\n            tess.mesh.splitEdge( eLo.Sym );\r\n            tess.mesh.splice( eUp.Lnext, eLo.Oprev );\r\n            regLo = regUp;\r\n            regUp = Sweep.topRightRegion( regUp );\r\n            e = Sweep.regionBelow(regUp).eUp.Rprev;\r\n            regLo.eUp = eLo.Oprev;\r\n            eLo = Sweep.finishLeftRegions( tess, regLo, null );\r\n            Sweep.addRightEdges( tess, regUp, eLo.Onext, eUp.Rprev, e, true );\r\n            return true;\r\n        }\r\n        /* Special case: called from ConnectRightVertex.  If either\r\n        * edge passes on the wrong side of tess->event, split it\r\n        * (and wait for ConnectRightVertex to splice it appropriately).\r\n        */\r\n        if( Geom.edgeSign( dstUp, tess.event, isect ) >= 0 ) {\r\n            Sweep.regionAbove(regUp).dirty = regUp.dirty = true;\r\n            tess.mesh.splitEdge( eUp.Sym );\r\n            eUp.Org.s = tess.event.s;\r\n            eUp.Org.t = tess.event.t;\r\n        }\r\n        if( Geom.edgeSign( dstLo, tess.event, isect ) <= 0 ) {\r\n            regUp.dirty = regLo.dirty = true;\r\n            tess.mesh.splitEdge( eLo.Sym );\r\n            eLo.Org.s = tess.event.s;\r\n            eLo.Org.t = tess.event.t;\r\n        }\r\n        /* leave the rest for ConnectRightVertex */\r\n        return false;\r\n    }\r\n\r\n    /* General case -- split both edges, splice into new vertex.\r\n    * When we do the splice operation, the order of the arguments is\r\n    * arbitrary as far as correctness goes.  However, when the operation\r\n    * creates a new face, the work done is proportional to the size of\r\n    * the new face.  We expect the faces in the processed part of\r\n    * the mesh (ie. eUp->Lface) to be smaller than the faces in the\r\n    * unprocessed original contours (which will be eLo->Oprev->Lface).\r\n    */\r\n    tess.mesh.splitEdge( eUp.Sym );\r\n    tess.mesh.splitEdge( eLo.Sym );\r\n    tess.mesh.splice( eLo.Oprev, eUp );\r\n    eUp.Org.s = isect.s;\r\n    eUp.Org.t = isect.t;\r\n    eUp.Org.pqHandle = tess.pq.insert( eUp.Org );\r\n    Sweep.getIntersectData( tess, eUp.Org, orgUp, dstUp, orgLo, dstLo );\r\n    Sweep.regionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;\r\n    return false;\r\n}\r\n\r\n//static void WalkDirtyRegions( TESStesselator *tess, ActiveRegion *regUp )\r\nSweep.walkDirtyRegions = function( tess, regUp ) {\r\n    /*\r\n    * When the upper or lower edge of any region changes, the region is\r\n    * marked \"dirty\".  This routine walks through all the dirty regions\r\n    * and makes sure that the dictionary invariants are satisfied\r\n    * (see the comments at the beginning of this file).  Of course\r\n    * new dirty regions can be created as we make changes to restore\r\n    * the invariants.\r\n    */\r\n    var regLo = Sweep.regionBelow(regUp);\r\n    var eUp, eLo;\r\n\r\n    for( ;; ) {\r\n        /* Find the lowest dirty region (we walk from the bottom up). */\r\n        while( regLo.dirty ) {\r\n            regUp = regLo;\r\n            regLo = Sweep.regionBelow(regLo);\r\n        }\r\n        if( ! regUp.dirty ) {\r\n            regLo = regUp;\r\n            regUp = Sweep.regionAbove( regUp );\r\n            if( regUp == null || ! regUp.dirty ) {\r\n                /* We've walked all the dirty regions */\r\n                return;\r\n            }\r\n        }\r\n        regUp.dirty = false;\r\n        eUp = regUp.eUp;\r\n        eLo = regLo.eUp;\r\n\r\n        if( eUp.Dst !== eLo.Dst ) {\r\n            /* Check that the edge ordering is obeyed at the Dst vertices. */\r\n            if( Sweep.checkForLeftSplice( tess, regUp )) {\r\n\r\n                /* If the upper or lower edge was marked fixUpperEdge, then\r\n                * we no longer need it (since these edges are needed only for\r\n                * vertices which otherwise have no right-going edges).\r\n                */\r\n                if( regLo.fixUpperEdge ) {\r\n                    Sweep.deleteRegion( tess, regLo );\r\n                    tess.mesh.delete( eLo );\r\n                    regLo = Sweep.regionBelow( regUp );\r\n                    eLo = regLo.eUp;\r\n                } else if( regUp.fixUpperEdge ) {\r\n                    Sweep.deleteRegion( tess, regUp );\r\n                    tess.mesh.delete( eUp );\r\n                    regUp = Sweep.regionAbove( regLo );\r\n                    eUp = regUp.eUp;\r\n                }\r\n            }\r\n        }\r\n        if( eUp.Org !== eLo.Org ) {\r\n            if(    eUp.Dst !== eLo.Dst\r\n                && ! regUp.fixUpperEdge && ! regLo.fixUpperEdge\r\n                && (eUp.Dst === tess.event || eLo.Dst === tess.event) )\r\n            {\r\n                /* When all else fails in CheckForIntersect(), it uses tess->event\r\n                * as the intersection location.  To make this possible, it requires\r\n                * that tess->event lie between the upper and lower edges, and also\r\n                * that neither of these is marked fixUpperEdge (since in the worst\r\n                * case it might splice one of these edges into tess->event, and\r\n                * violate the invariant that fixable edges are the only right-going\r\n                * edge from their associated vertex).\r\n                */\r\n                if( Sweep.checkForIntersect( tess, regUp )) {\r\n                    /* WalkDirtyRegions() was called recursively; we're done */\r\n                    return;\r\n                }\r\n            } else {\r\n                /* Even though we can't use CheckForIntersect(), the Org vertices\r\n                * may violate the dictionary edge ordering.  Check and correct this.\r\n                */\r\n                Sweep.checkForRightSplice( tess, regUp );\r\n            }\r\n        }\r\n        if( eUp.Org === eLo.Org && eUp.Dst === eLo.Dst ) {\r\n            /* A degenerate loop consisting of only two edges -- delete it. */\r\n            Sweep.addWinding( eLo, eUp );\r\n            Sweep.deleteRegion( tess, regUp );\r\n            tess.mesh.delete( eUp );\r\n            regUp = Sweep.regionAbove( regLo );\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//static void ConnectRightVertex( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eBottomLeft )\r\nSweep.connectRightVertex = function( tess, regUp, eBottomLeft ) {\r\n    /*\r\n    * Purpose: connect a \"right\" vertex vEvent (one where all edges go left)\r\n    * to the unprocessed portion of the mesh.  Since there are no right-going\r\n    * edges, two regions (one above vEvent and one below) are being merged\r\n    * into one.  \"regUp\" is the upper of these two regions.\r\n    *\r\n    * There are two reasons for doing this (adding a right-going edge):\r\n    *  - if the two regions being merged are \"inside\", we must add an edge\r\n    *    to keep them separated (the combined region would not be monotone).\r\n    *  - in any case, we must leave some record of vEvent in the dictionary,\r\n    *    so that we can merge vEvent with features that we have not seen yet.\r\n    *    For example, maybe there is a vertical edge which passes just to\r\n    *    the right of vEvent; we would like to splice vEvent into this edge.\r\n    *\r\n    * However, we don't want to connect vEvent to just any vertex.  We don''t\r\n    * want the new edge to cross any other edges; otherwise we will create\r\n    * intersection vertices even when the input data had no self-intersections.\r\n    * (This is a bad thing; if the user's input data has no intersections,\r\n    * we don't want to generate any false intersections ourselves.)\r\n    *\r\n    * Our eventual goal is to connect vEvent to the leftmost unprocessed\r\n    * vertex of the combined region (the union of regUp and regLo).\r\n    * But because of unseen vertices with all right-going edges, and also\r\n    * new vertices which may be created by edge intersections, we don''t\r\n    * know where that leftmost unprocessed vertex is.  In the meantime, we\r\n    * connect vEvent to the closest vertex of either chain, and mark the region\r\n    * as \"fixUpperEdge\".  This flag says to delete and reconnect this edge\r\n    * to the next processed vertex on the boundary of the combined region.\r\n    * Quite possibly the vertex we connected to will turn out to be the\r\n    * closest one, in which case we won''t need to make any changes.\r\n    */\r\n    var eNew;\r\n    var eTopLeft = eBottomLeft.Onext;\r\n    var regLo = Sweep.regionBelow(regUp);\r\n    var eUp = regUp.eUp;\r\n    var eLo = regLo.eUp;\r\n    var degenerate = false;\r\n\r\n    if( eUp.Dst !== eLo.Dst ) {\r\n        Sweep.checkForIntersect( tess, regUp );\r\n    }\r\n\r\n    /* Possible new degeneracies: upper or lower edge of regUp may pass\r\n    * through vEvent, or may coincide with new intersection vertex\r\n    */\r\n    if( Geom.vertEq( eUp.Org, tess.event )) {\r\n        tess.mesh.splice( eTopLeft.Oprev, eUp );\r\n        regUp = Sweep.topLeftRegion( tess, regUp );\r\n        eTopLeft = Sweep.regionBelow( regUp ).eUp;\r\n        Sweep.finishLeftRegions( tess, Sweep.regionBelow(regUp), regLo );\r\n        degenerate = true;\r\n    }\r\n    if( Geom.vertEq( eLo.Org, tess.event )) {\r\n        tess.mesh.splice( eBottomLeft, eLo.Oprev );\r\n        eBottomLeft = Sweep.finishLeftRegions( tess, regLo, null );\r\n        degenerate = true;\r\n    }\r\n    if( degenerate ) {\r\n        Sweep.addRightEdges( tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true );\r\n        return;\r\n    }\r\n\r\n    /* Non-degenerate situation -- need to add a temporary, fixable edge.\r\n    * Connect to the closer of eLo->Org, eUp->Org.\r\n    */\r\n    if( Geom.vertLeq( eLo.Org, eUp.Org )) {\r\n        eNew = eLo.Oprev;\r\n    } else {\r\n        eNew = eUp;\r\n    }\r\n    eNew = tess.mesh.connect( eBottomLeft.Lprev, eNew );\r\n\r\n    /* Prevent cleanup, otherwise eNew might disappear before we've even\r\n    * had a chance to mark it as a temporary edge.\r\n    */\r\n    Sweep.addRightEdges( tess, regUp, eNew, eNew.Onext, eNew.Onext, false );\r\n    eNew.Sym.activeRegion.fixUpperEdge = true;\r\n    Sweep.walkDirtyRegions( tess, regUp );\r\n}\r\n\r\n/* Because vertices at exactly the same location are merged together\r\n* before we process the sweep event, some degenerate cases can't occur.\r\n* However if someone eventually makes the modifications required to\r\n* merge features which are close together, the cases below marked\r\n* TOLERANCE_NONZERO will be useful.  They were debugged before the\r\n* code to merge identical vertices in the main loop was added.\r\n*/\r\n//#define TOLERANCE_NONZERO\tFALSE\r\n\r\n//static void ConnectLeftDegenerate( TESStesselator *tess, ActiveRegion *regUp, TESSvertex *vEvent )\r\nSweep.connectLeftDegenerate = function( tess, regUp, vEvent ) {\r\n    /*\r\n    * The event vertex lies exacty on an already-processed edge or vertex.\r\n    * Adding the new vertex involves splicing it into the already-processed\r\n    * part of the mesh.\r\n    */\r\n    var e, eTopLeft, eTopRight, eLast;\r\n    var reg;\r\n\r\n    e = regUp.eUp;\r\n    if( Geom.vertEq( e.Org, vEvent )) {\r\n        /* e->Org is an unprocessed vertex - just combine them, and wait\r\n        * for e->Org to be pulled from the queue\r\n        */\r\n        assert( false /*TOLERANCE_NONZERO*/ );\r\n        Sweep.spliceMergeVertices( tess, e, vEvent.anEdge );\r\n        return;\r\n    }\r\n\r\n    if( ! Geom.vertEq( e.Dst, vEvent )) {\r\n        /* General case -- splice vEvent into edge e which passes through it */\r\n        tess.mesh.splitEdge( e.Sym );\r\n        if( regUp.fixUpperEdge ) {\r\n            /* This edge was fixable -- delete unused portion of original edge */\r\n            tess.mesh.delete( e.Onext );\r\n            regUp.fixUpperEdge = false;\r\n        }\r\n        tess.mesh.splice( vEvent.anEdge, e );\r\n        Sweep.sweepEvent( tess, vEvent );\t/* recurse */\r\n        return;\r\n    }\r\n\r\n    /* vEvent coincides with e->Dst, which has already been processed.\r\n    * Splice in the additional right-going edges.\r\n    */\r\n    assert( false /*TOLERANCE_NONZERO*/ );\r\n    regUp = Sweep.topRightRegion( regUp );\r\n    reg = Sweep.regionBelow( regUp );\r\n    eTopRight = reg.eUp.Sym;\r\n    eTopLeft = eLast = eTopRight.Onext;\r\n    if( reg.fixUpperEdge ) {\r\n        /* Here e->Dst has only a single fixable edge going right.\r\n        * We can delete it since now we have some real right-going edges.\r\n        */\r\n        assert( eTopLeft !== eTopRight );   /* there are some left edges too */\r\n        Sweep.deleteRegion( tess, reg );\r\n        tess.mesh.delete( eTopRight );\r\n        eTopRight = eTopLeft.Oprev;\r\n    }\r\n    tess.mesh.splice( vEvent.anEdge, eTopRight );\r\n    if( ! Geom.edgeGoesLeft( eTopLeft )) {\r\n        /* e->Dst had no left-going edges -- indicate this to AddRightEdges() */\r\n        eTopLeft = null;\r\n    }\r\n    Sweep.addRightEdges( tess, regUp, eTopRight.Onext, eLast, eTopLeft, true );\r\n}\r\n\r\n\r\n//static void ConnectLeftVertex( TESStesselator *tess, TESSvertex *vEvent )\r\nSweep.connectLeftVertex = function( tess, vEvent ) {\r\n    /*\r\n    * Purpose: connect a \"left\" vertex (one where both edges go right)\r\n    * to the processed portion of the mesh.  Let R be the active region\r\n    * containing vEvent, and let U and L be the upper and lower edge\r\n    * chains of R.  There are two possibilities:\r\n    *\r\n    * - the normal case: split R into two regions, by connecting vEvent to\r\n    *   the rightmost vertex of U or L lying to the left of the sweep line\r\n    *\r\n    * - the degenerate case: if vEvent is close enough to U or L, we\r\n    *   merge vEvent into that edge chain.  The subcases are:\r\n    *\t- merging with the rightmost vertex of U or L\r\n    *\t- merging with the active edge of U or L\r\n    *\t- merging with an already-processed portion of U or L\r\n    */\r\n    var regUp, regLo, reg;\r\n    var eUp, eLo, eNew;\r\n    var tmp = new ActiveRegion();\r\n\r\n    /* assert( vEvent->anEdge->Onext->Onext == vEvent->anEdge ); */\r\n\r\n    /* Get a pointer to the active region containing vEvent */\r\n    tmp.eUp = vEvent.anEdge.Sym;\r\n    /* __GL_DICTLISTKEY */ /* tessDictListSearch */\r\n    regUp = tess.dict.search( tmp ).key;\r\n    regLo = Sweep.regionBelow( regUp );\r\n    if( !regLo ) {\r\n        // This may happen if the input polygon is coplanar.\r\n        return;\r\n    }\r\n    eUp = regUp.eUp;\r\n    eLo = regLo.eUp;\r\n\r\n    /* Try merging with U or L first */\r\n    if( Geom.edgeSign( eUp.Dst, vEvent, eUp.Org ) === 0.0 ) {\r\n        Sweep.connectLeftDegenerate( tess, regUp, vEvent );\r\n        return;\r\n    }\r\n\r\n    /* Connect vEvent to rightmost processed vertex of either chain.\r\n    * e->Dst is the vertex that we will connect to vEvent.\r\n    */\r\n    reg = Geom.vertLeq( eLo.Dst, eUp.Dst ) ? regUp : regLo;\r\n\r\n    if( regUp.inside || reg.fixUpperEdge) {\r\n        if( reg === regUp ) {\r\n            eNew = tess.mesh.connect( vEvent.anEdge.Sym, eUp.Lnext );\r\n        } else {\r\n            var tempHalfEdge = tess.mesh.connect( eLo.Dnext, vEvent.anEdge);\r\n            eNew = tempHalfEdge.Sym;\r\n        }\r\n        if( reg.fixUpperEdge ) {\r\n            Sweep.fixUpperEdge( tess, reg, eNew );\r\n        } else {\r\n            Sweep.computeWinding( tess, Sweep.addRegionBelow( tess, regUp, eNew ));\r\n        }\r\n        Sweep.sweepEvent( tess, vEvent );\r\n    } else {\r\n        /* The new vertex is in a region which does not belong to the polygon.\r\n        * We don''t need to connect this vertex to the rest of the mesh.\r\n        */\r\n        Sweep.addRightEdges( tess, regUp, vEvent.anEdge, vEvent.anEdge, null, true );\r\n    }\r\n};\r\n\r\n\r\n//static void SweepEvent( TESStesselator *tess, TESSvertex *vEvent )\r\nSweep.sweepEvent = function( tess, vEvent ) {\r\n    /*\r\n    * Does everything necessary when the sweep line crosses a vertex.\r\n    * Updates the mesh and the edge dictionary.\r\n    */\r\n\r\n    tess.event = vEvent;\t\t/* for access in EdgeLeq() */\r\n    Sweep.debugEvent( tess );\r\n\r\n    /* Check if this vertex is the right endpoint of an edge that is\r\n    * already in the dictionary.  In this case we don't need to waste\r\n    * time searching for the location to insert new edges.\r\n    */\r\n    var e = vEvent.anEdge;\r\n    while( e.activeRegion === null ) {\r\n        e = e.Onext;\r\n        if( e == vEvent.anEdge ) {\r\n            /* All edges go right -- not incident to any processed edges */\r\n            Sweep.connectLeftVertex( tess, vEvent );\r\n            return;\r\n        }\r\n    }\r\n\r\n    /* Processing consists of two phases: first we \"finish\" all the\r\n    * active regions where both the upper and lower edges terminate\r\n    * at vEvent (ie. vEvent is closing off these regions).\r\n    * We mark these faces \"inside\" or \"outside\" the polygon according\r\n    * to their winding number, and delete the edges from the dictionary.\r\n    * This takes care of all the left-going edges from vEvent.\r\n    */\r\n    var regUp = Sweep.topLeftRegion( tess, e.activeRegion );\r\n    assert( regUp !== null );\r\n    //\tif (regUp == NULL) longjmp(tess->env,1);\r\n    var reg = Sweep.regionBelow( regUp );\r\n    var eTopLeft = reg.eUp;\r\n    var eBottomLeft = Sweep.finishLeftRegions( tess, reg, null );\r\n\r\n    /* Next we process all the right-going edges from vEvent.  This\r\n    * involves adding the edges to the dictionary, and creating the\r\n    * associated \"active regions\" which record information about the\r\n    * regions between adjacent dictionary edges.\r\n    */\r\n    if( eBottomLeft.Onext === eTopLeft ) {\r\n        /* No right-going edges -- add a temporary \"fixable\" edge */\r\n        Sweep.connectRightVertex( tess, regUp, eBottomLeft );\r\n    } else {\r\n        Sweep.addRightEdges( tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true );\r\n    }\r\n};\r\n\r\n\r\n/* Make the sentinel coordinates big enough that they will never be\r\n* merged with real input features.\r\n*/\r\n\r\n//static void AddSentinel( TESStesselator *tess, TESSreal smin, TESSreal smax, TESSreal t )\r\nSweep.addSentinel = function( tess, smin, smax, t ) {\r\n    /*\r\n    * We add two sentinel edges above and below all other edges,\r\n    * to avoid special cases at the top and bottom.\r\n    */\r\n    var reg = new ActiveRegion();\r\n    var e = tess.mesh.makeEdge();\r\n    //\tif (e == NULL) longjmp(tess->env,1);\r\n\r\n    e.Org.s = smax;\r\n    e.Org.t = t;\r\n    e.Dst.s = smin;\r\n    e.Dst.t = t;\r\n    tess.event = e.Dst;\t\t/* initialize it */\r\n\r\n    reg.eUp = e;\r\n    reg.windingNumber = 0;\r\n    reg.inside = false;\r\n    reg.fixUpperEdge = false;\r\n    reg.sentinel = true;\r\n    reg.dirty = false;\r\n    reg.nodeUp = tess.dict.insert( reg );\r\n    //\tif (reg->nodeUp == NULL) longjmp(tess->env,1);\r\n}\r\n\r\n\r\n//static void InitEdgeDict( TESStesselator *tess )\r\nSweep.initEdgeDict = function( tess ) {\r\n    /*\r\n    * We maintain an ordering of edge intersections with the sweep line.\r\n    * This order is maintained in a dynamic dictionary.\r\n    */\r\n    tess.dict = new Dict( tess, Sweep.edgeLeq );\r\n    //\tif (tess->dict == NULL) longjmp(tess->env,1);\r\n\r\n    var w = (tess.bmax[0] - tess.bmin[0]);\r\n    var h = (tess.bmax[1] - tess.bmin[1]);\r\n\r\n    var smin = tess.bmin[0] - w;\r\n    var smax = tess.bmax[0] + w;\r\n    var tmin = tess.bmin[1] - h;\r\n    var tmax = tess.bmax[1] + h;\r\n\r\n    Sweep.addSentinel( tess, smin, smax, tmin );\r\n    Sweep.addSentinel( tess, smin, smax, tmax );\r\n}\r\n\r\n\r\nSweep.doneEdgeDict = function( tess )\r\n{\r\n    var reg;\r\n    var fixedEdges = 0;\r\n\r\n    while( (reg = tess.dict.min().key) !== null ) {\r\n        /*\r\n        * At the end of all processing, the dictionary should contain\r\n        * only the two sentinel edges, plus at most one \"fixable\" edge\r\n        * created by ConnectRightVertex().\r\n        */\r\n        if( ! reg.sentinel ) {\r\n            assert( reg.fixUpperEdge );\r\n            assert( ++fixedEdges == 1 );\r\n        }\r\n        assert( reg.windingNumber == 0 );\r\n        Sweep.deleteRegion( tess, reg );\r\n        /*    tessMeshDelete( reg->eUp );*/\r\n    }\r\n    //\tdictDeleteDict( &tess->alloc, tess->dict );\r\n}\r\n\r\n\r\nSweep.removeDegenerateEdges = function( tess ) {\r\n    /*\r\n    * Remove zero-length edges, and contours with fewer than 3 vertices.\r\n    */\r\n    var e, eNext, eLnext;\r\n    var eHead = tess.mesh.eHead;\r\n\r\n    /*LINTED*/\r\n    for( e = eHead.next; e !== eHead; e = eNext ) {\r\n        eNext = e.next;\r\n        eLnext = e.Lnext;\r\n\r\n        if( Geom.vertEq( e.Org, e.Dst ) && e.Lnext.Lnext !== e ) {\r\n            /* Zero-length edge, contour has at least 3 edges */\r\n            Sweep.spliceMergeVertices( tess, eLnext, e );\t/* deletes e->Org */\r\n            tess.mesh.delete( e ); /* e is a self-loop */\r\n            e = eLnext;\r\n            eLnext = e.Lnext;\r\n        }\r\n        if( eLnext.Lnext === e ) {\r\n            /* Degenerate contour (one or two edges) */\r\n            if( eLnext !== e ) {\r\n                if( eLnext === eNext || eLnext === eNext.Sym ) { eNext = eNext.next; }\r\n                tess.mesh.delete( eLnext );\r\n            }\r\n            if( e === eNext || e === eNext.Sym ) { eNext = eNext.next; }\r\n            tess.mesh.delete( e );\r\n        }\r\n    }\r\n}\r\n\r\nSweep.initPriorityQ = function( tess ) {\r\n    /*\r\n    * Insert all vertices into the priority queue which determines the\r\n    * order in which vertices cross the sweep line.\r\n    */\r\n    var pq;\r\n    var v, vHead;\r\n    var vertexCount = 0;\r\n\r\n    vHead = tess.mesh.vHead;\r\n    for( v = vHead.next; v !== vHead; v = v.next ) {\r\n        vertexCount++;\r\n    }\r\n    /* Make sure there is enough space for sentinels. */\r\n    vertexCount += 8; //MAX( 8, tess->alloc.extraVertices );\r\n\r\n    pq = tess.pq = new PriorityQ( vertexCount, Geom.vertLeq );\r\n    //\tif (pq == NULL) return 0;\r\n\r\n    vHead = tess.mesh.vHead;\r\n    for( v = vHead.next; v !== vHead; v = v.next ) {\r\n        v.pqHandle = pq.insert( v );\r\n        //\t\tif (v.pqHandle == INV_HANDLE)\r\n        //\t\t\tbreak;\r\n    }\r\n\r\n    if (v !== vHead) {\r\n        return false;\r\n    }\r\n\r\n    pq.init();\r\n\r\n    return true;\r\n}\r\n\r\n\r\nSweep.donePriorityQ = function( tess ) {\r\n    tess.pq = null;\r\n}\r\n\r\n\r\nSweep.removeDegenerateFaces = function( tess, mesh ) {\r\n    /*\r\n    * Delete any degenerate faces with only two edges.  WalkDirtyRegions()\r\n    * will catch almost all of these, but it won't catch degenerate faces\r\n    * produced by splice operations on already-processed edges.\r\n    * The two places this can happen are in FinishLeftRegions(), when\r\n    * we splice in a \"temporary\" edge produced by ConnectRightVertex(),\r\n    * and in CheckForLeftSplice(), where we splice already-processed\r\n    * edges to ensure that our dictionary invariants are not violated\r\n    * by numerical errors.\r\n    *\r\n    * In both these cases it is *very* dangerous to delete the offending\r\n    * edge at the time, since one of the routines further up the stack\r\n    * will sometimes be keeping a pointer to that edge.\r\n    */\r\n    var f, fNext;\r\n    var e;\r\n\r\n    /*LINTED*/\r\n    for( f = mesh.fHead.next; f !== mesh.fHead; f = fNext ) {\r\n        fNext = f.next;\r\n        e = f.anEdge;\r\n        assert( e.Lnext !== e );\r\n\r\n        if( e.Lnext.Lnext === e ) {\r\n            /* A face with only two edges */\r\n            Sweep.addWinding( e.Onext, e );\r\n            tess.mesh.delete( e );\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nSweep.computeInterior = function( tess ) {\r\n    /*\r\n    * tessComputeInterior( tess ) computes the planar arrangement specified\r\n    * by the given contours, and further subdivides this arrangement\r\n    * into regions.  Each region is marked \"inside\" if it belongs\r\n    * to the polygon, according to the rule given by tess->windingRule.\r\n    * Each interior region is guaranteed be monotone.\r\n    */\r\n    var v, vNext;\r\n\r\n    /* Each vertex defines an event for our sweep line.  Start by inserting\r\n    * all the vertices in a priority queue.  Events are processed in\r\n    * lexicographic order, ie.\r\n    *\r\n    *\te1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)\r\n    */\r\n    Sweep.removeDegenerateEdges( tess );\r\n    if ( !Sweep.initPriorityQ( tess ) ) return false; /* if error */\r\n    Sweep.initEdgeDict( tess );\r\n\r\n    while( (v = tess.pq.extractMin()) !== null ) {\r\n        for( ;; ) {\r\n            vNext = tess.pq.min();\r\n            if( vNext === null || ! Geom.vertEq( vNext, v )) break;\r\n\r\n            /* Merge together all vertices at exactly the same location.\r\n            * This is more efficient than processing them one at a time,\r\n            * simplifies the code (see ConnectLeftDegenerate), and is also\r\n            * important for correct handling of certain degenerate cases.\r\n            * For example, suppose there are two identical edges A and B\r\n            * that belong to different contours (so without this code they would\r\n            * be processed by separate sweep events).  Suppose another edge C\r\n            * crosses A and B from above.  When A is processed, we split it\r\n            * at its intersection point with C.  However this also splits C,\r\n            * so when we insert B we may compute a slightly different\r\n            * intersection point.  This might leave two edges with a small\r\n            * gap between them.  This kind of error is especially obvious\r\n            * when using boundary extraction (TESS_BOUNDARY_ONLY).\r\n            */\r\n            vNext = tess.pq.extractMin();\r\n            Sweep.spliceMergeVertices( tess, v.anEdge, vNext.anEdge );\r\n        }\r\n        Sweep.sweepEvent( tess, v );\r\n    }\r\n\r\n    /* Set tess->event for debugging purposes */\r\n    tess.event = tess.dict.min().key.eUp.Org;\r\n    Sweep.debugEvent( tess );\r\n    Sweep.doneEdgeDict( tess );\r\n    Sweep.donePriorityQ( tess );\r\n\r\n    if ( !Sweep.removeDegenerateFaces( tess, tess.mesh ) ) return false;\r\n    tess.mesh.check();\r\n\r\n    return true;\r\n}\r\n\r\n\r\nfunction Tesselator() {\r\n\r\n    /*** state needed for collecting the input data ***/\r\n    this.mesh = null;\t\t/* stores the input contours, and eventually\r\n\t\t\t\t\t\t\tthe tessellation itself */\r\n\r\n    /*** state needed for projecting onto the sweep plane ***/\r\n\r\n    this.normal = [0.0, 0.0, 0.0];\t/* user-specified normal (if provided) */\r\n    this.sUnit = [0.0, 0.0, 0.0];\t/* unit vector in s-direction (debugging) */\r\n    this.tUnit = [0.0, 0.0, 0.0];\t/* unit vector in t-direction (debugging) */\r\n\r\n    this.bmin = [0.0, 0.0];\r\n    this.bmax = [0.0, 0.0];\r\n\r\n    /*** state needed for the line sweep ***/\r\n    this.windingRule = Tess2.WINDING_ODD;\t/* rule for determining polygon interior */\r\n\r\n    this.dict = null;\t\t/* edge dictionary for sweep line */\r\n    this.pq = null;\t\t/* priority queue of vertex events */\r\n    this.event = null;\t\t/* current sweep event being processed */\r\n\r\n    this.vertexIndexCounter = 0;\r\n\r\n    this.vertices = [];\r\n    this.vertexIndices = [];\r\n    this.vertexCount = 0;\r\n    this.elements = [];\r\n    this.elementCount = 0;\r\n};\r\n\r\nTesselator.prototype = {\r\n\r\n    dot_: function(u, v) {\r\n        return (u[0]*v[0] + u[1]*v[1] + u[2]*v[2]);\r\n    },\r\n\r\n    normalize_: function( v ) {\r\n        var len = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];\r\n        assert( len > 0.0 );\r\n        len = Math.sqrt( len );\r\n        v[0] /= len;\r\n        v[1] /= len;\r\n        v[2] /= len;\r\n    },\r\n\r\n    longAxis_: function( v ) {\r\n        var i = 0;\r\n        if( Math.abs(v[1]) > Math.abs(v[0]) ) { i = 1; }\r\n        if( Math.abs(v[2]) > Math.abs(v[i]) ) { i = 2; }\r\n        return i;\r\n    },\r\n\r\n    computeNormal_: function( norm )\r\n    {\r\n        var v, v1, v2;\r\n        var c, tLen2, maxLen2;\r\n        var maxVal = [0,0,0], minVal = [0,0,0], d1 = [0,0,0], d2 = [0,0,0], tNorm = [0,0,0];\r\n        var maxVert = [null,null,null], minVert = [null,null,null];\r\n        var vHead = this.mesh.vHead;\r\n        var i;\r\n\r\n        v = vHead.next;\r\n        for( i = 0; i < 3; ++i ) {\r\n            c = v.coords[i];\r\n            minVal[i] = c;\r\n            minVert[i] = v;\r\n            maxVal[i] = c;\r\n            maxVert[i] = v;\r\n        }\r\n\r\n        for( v = vHead.next; v !== vHead; v = v.next ) {\r\n            for( i = 0; i < 3; ++i ) {\r\n                c = v.coords[i];\r\n                if( c < minVal[i] ) { minVal[i] = c; minVert[i] = v; }\r\n                if( c > maxVal[i] ) { maxVal[i] = c; maxVert[i] = v; }\r\n            }\r\n        }\r\n\r\n        /* Find two vertices separated by at least 1/sqrt(3) of the maximum\r\n        * distance between any two vertices\r\n        */\r\n        i = 0;\r\n        if( maxVal[1] - minVal[1] > maxVal[0] - minVal[0] ) { i = 1; }\r\n        if( maxVal[2] - minVal[2] > maxVal[i] - minVal[i] ) { i = 2; }\r\n        if( minVal[i] >= maxVal[i] ) {\r\n            /* All vertices are the same -- normal doesn't matter */\r\n            norm[0] = 0; norm[1] = 0; norm[2] = 1;\r\n            return;\r\n        }\r\n\r\n        /* Look for a third vertex which forms the triangle with maximum area\r\n        * (Length of normal == twice the triangle area)\r\n        */\r\n        maxLen2 = 0;\r\n        v1 = minVert[i];\r\n        v2 = maxVert[i];\r\n        d1[0] = v1.coords[0] - v2.coords[0];\r\n        d1[1] = v1.coords[1] - v2.coords[1];\r\n        d1[2] = v1.coords[2] - v2.coords[2];\r\n        for( v = vHead.next; v !== vHead; v = v.next ) {\r\n            d2[0] = v.coords[0] - v2.coords[0];\r\n            d2[1] = v.coords[1] - v2.coords[1];\r\n            d2[2] = v.coords[2] - v2.coords[2];\r\n            tNorm[0] = d1[1]*d2[2] - d1[2]*d2[1];\r\n            tNorm[1] = d1[2]*d2[0] - d1[0]*d2[2];\r\n            tNorm[2] = d1[0]*d2[1] - d1[1]*d2[0];\r\n            tLen2 = tNorm[0]*tNorm[0] + tNorm[1]*tNorm[1] + tNorm[2]*tNorm[2];\r\n            if( tLen2 > maxLen2 ) {\r\n                maxLen2 = tLen2;\r\n                norm[0] = tNorm[0];\r\n                norm[1] = tNorm[1];\r\n                norm[2] = tNorm[2];\r\n            }\r\n        }\r\n\r\n        if( maxLen2 <= 0 ) {\r\n            /* All points lie on a single line -- any decent normal will do */\r\n            norm[0] = norm[1] = norm[2] = 0;\r\n            norm[this.longAxis_(d1)] = 1;\r\n        }\r\n    },\r\n\r\n    checkOrientation_: function() {\r\n        var area;\r\n        var f, fHead = this.mesh.fHead;\r\n        var v, vHead = this.mesh.vHead;\r\n        var e;\r\n\r\n        /* When we compute the normal automatically, we choose the orientation\r\n        * so that the the sum of the signed areas of all contours is non-negative.\r\n        */\r\n        area = 0;\r\n        for( f = fHead.next; f !== fHead; f = f.next ) {\r\n            e = f.anEdge;\r\n            if( e.winding <= 0 ) continue;\r\n            do {\r\n                area += (e.Org.s - e.Dst.s) * (e.Org.t + e.Dst.t);\r\n                e = e.Lnext;\r\n            } while( e !== f.anEdge );\r\n        }\r\n        if( area < 0 ) {\r\n            /* Reverse the orientation by flipping all the t-coordinates */\r\n            for( v = vHead.next; v !== vHead; v = v.next ) {\r\n                v.t = - v.t;\r\n            }\r\n            this.tUnit[0] = - this.tUnit[0];\r\n            this.tUnit[1] = - this.tUnit[1];\r\n            this.tUnit[2] = - this.tUnit[2];\r\n        }\r\n    },\r\n\r\n    /*\t#ifdef FOR_TRITE_TEST_PROGRAM\r\n        #include <stdlib.h>\r\n        extern int RandomSweep;\r\n        #define S_UNIT_X\t(RandomSweep ? (2*drand48()-1) : 1.0)\r\n        #define S_UNIT_Y\t(RandomSweep ? (2*drand48()-1) : 0.0)\r\n        #else\r\n        #if defined(SLANTED_SWEEP) */\r\n    /* The \"feature merging\" is not intended to be complete.  There are\r\n    * special cases where edges are nearly parallel to the sweep line\r\n    * which are not implemented.  The algorithm should still behave\r\n    * robustly (ie. produce a reasonable tesselation) in the presence\r\n    * of such edges, however it may miss features which could have been\r\n    * merged.  We could minimize this effect by choosing the sweep line\r\n    * direction to be something unusual (ie. not parallel to one of the\r\n    * coordinate axes).\r\n    */\r\n    /*\t#define S_UNIT_X\t(TESSreal)0.50941539564955385\t// Pre-normalized\r\n        #define S_UNIT_Y\t(TESSreal)0.86052074622010633\r\n        #else\r\n        #define S_UNIT_X\t(TESSreal)1.0\r\n        #define S_UNIT_Y\t(TESSreal)0.0\r\n        #endif\r\n        #endif*/\r\n\r\n    /* Determine the polygon normal and project vertices onto the plane\r\n    * of the polygon.\r\n    */\r\n    projectPolygon_: function() {\r\n        var v, vHead = this.mesh.vHead;\r\n        var norm = [0,0,0];\r\n        var sUnit, tUnit;\r\n        var i, first, computedNormal = false;\r\n\r\n        norm[0] = this.normal[0];\r\n        norm[1] = this.normal[1];\r\n        norm[2] = this.normal[2];\r\n        if( norm[0] === 0.0 && norm[1] === 0.0 && norm[2] === 0.0 ) {\r\n            this.computeNormal_( norm );\r\n            computedNormal = true;\r\n        }\r\n        sUnit = this.sUnit;\r\n        tUnit = this.tUnit;\r\n        i = this.longAxis_( norm );\r\n\r\n        /*\t#if defined(FOR_TRITE_TEST_PROGRAM) || defined(TRUE_PROJECT)\r\n                // Choose the initial sUnit vector to be approximately perpendicular\r\n                // to the normal.\r\n\r\n                Normalize( norm );\r\n\r\n                sUnit[i] = 0;\r\n                sUnit[(i+1)%3] = S_UNIT_X;\r\n                sUnit[(i+2)%3] = S_UNIT_Y;\r\n\r\n                // Now make it exactly perpendicular\r\n                w = Dot( sUnit, norm );\r\n                sUnit[0] -= w * norm[0];\r\n                sUnit[1] -= w * norm[1];\r\n                sUnit[2] -= w * norm[2];\r\n                Normalize( sUnit );\r\n\r\n                // Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame\r\n                tUnit[0] = norm[1]*sUnit[2] - norm[2]*sUnit[1];\r\n                tUnit[1] = norm[2]*sUnit[0] - norm[0]*sUnit[2];\r\n                tUnit[2] = norm[0]*sUnit[1] - norm[1]*sUnit[0];\r\n                Normalize( tUnit );\r\n            #else*/\r\n        /* Project perpendicular to a coordinate axis -- better numerically */\r\n        sUnit[i] = 0;\r\n        sUnit[(i+1)%3] = 1.0;\r\n        sUnit[(i+2)%3] = 0.0;\r\n\r\n        tUnit[i] = 0;\r\n        tUnit[(i+1)%3] = 0.0;\r\n        tUnit[(i+2)%3] = (norm[i] > 0) ? 1.0 : -1.0;\r\n        //\t#endif\r\n\r\n        /* Project the vertices onto the sweep plane */\r\n        for( v = vHead.next; v !== vHead; v = v.next ) {\r\n            v.s = this.dot_( v.coords, sUnit );\r\n            v.t = this.dot_( v.coords, tUnit );\r\n        }\r\n        if( computedNormal ) {\r\n            this.checkOrientation_();\r\n        }\r\n\r\n        /* Compute ST bounds. */\r\n        first = true;\r\n        for( v = vHead.next; v !== vHead; v = v.next ) {\r\n            if (first) {\r\n                this.bmin[0] = this.bmax[0] = v.s;\r\n                this.bmin[1] = this.bmax[1] = v.t;\r\n                first = false;\r\n            } else {\r\n                if (v.s < this.bmin[0]) this.bmin[0] = v.s;\r\n                if (v.s > this.bmax[0]) this.bmax[0] = v.s;\r\n                if (v.t < this.bmin[1]) this.bmin[1] = v.t;\r\n                if (v.t > this.bmax[1]) this.bmax[1] = v.t;\r\n            }\r\n        }\r\n    },\r\n\r\n    addWinding_: function(eDst,eSrc) {\r\n        eDst.winding += eSrc.winding;\r\n        eDst.Sym.winding += eSrc.Sym.winding;\r\n    },\r\n\r\n    /* tessMeshTessellateMonoRegion( face ) tessellates a monotone region\r\n    * (what else would it do??)  The region must consist of a single\r\n    * loop of half-edges (see mesh.h) oriented CCW.  \"Monotone\" in this\r\n    * case means that any vertical line intersects the interior of the\r\n    * region in a single interval.\r\n    *\r\n    * Tessellation consists of adding interior edges (actually pairs of\r\n    * half-edges), to split the region into non-overlapping triangles.\r\n    *\r\n    * The basic idea is explained in Preparata and Shamos (which I don''t\r\n    * have handy right now), although their implementation is more\r\n    * complicated than this one.  The are two edge chains, an upper chain\r\n    * and a lower chain.  We process all vertices from both chains in order,\r\n    * from right to left.\r\n    *\r\n    * The algorithm ensures that the following invariant holds after each\r\n    * vertex is processed: the untessellated region consists of two\r\n    * chains, where one chain (say the upper) is a single edge, and\r\n    * the other chain is concave.  The left vertex of the single edge\r\n    * is always to the left of all vertices in the concave chain.\r\n    *\r\n    * Each step consists of adding the rightmost unprocessed vertex to one\r\n    * of the two chains, and forming a fan of triangles from the rightmost\r\n    * of two chain endpoints.  Determining whether we can add each triangle\r\n    * to the fan is a simple orientation test.  By making the fan as large\r\n    * as possible, we restore the invariant (check it yourself).\r\n    */\r\n    //\tint tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )\r\n    tessellateMonoRegion_: function( mesh, face ) {\r\n        var up, lo;\r\n\r\n        /* All edges are oriented CCW around the boundary of the region.\r\n        * First, find the half-edge whose origin vertex is rightmost.\r\n        * Since the sweep goes from left to right, face->anEdge should\r\n        * be close to the edge we want.\r\n        */\r\n        up = face.anEdge;\r\n        assert( up.Lnext !== up && up.Lnext.Lnext !== up );\r\n\r\n        for( ; Geom.vertLeq( up.Dst, up.Org ); up = up.Lprev )\r\n            ;\r\n        for( ; Geom.vertLeq( up.Org, up.Dst ); up = up.Lnext )\r\n            ;\r\n        lo = up.Lprev;\r\n\r\n        while( up.Lnext !== lo ) {\r\n            if( Geom.vertLeq( up.Dst, lo.Org )) {\r\n                /* up->Dst is on the left.  It is safe to form triangles from lo->Org.\r\n                * The EdgeGoesLeft test guarantees progress even when some triangles\r\n                * are CW, given that the upper and lower chains are truly monotone.\r\n                */\r\n                while( lo.Lnext !== up && (Geom.edgeGoesLeft( lo.Lnext )\r\n                    || Geom.edgeSign( lo.Org, lo.Dst, lo.Lnext.Dst ) <= 0.0 )) {\r\n                    var tempHalfEdge = mesh.connect( lo.Lnext, lo );\r\n                    //if (tempHalfEdge == NULL) return 0;\r\n                    lo = tempHalfEdge.Sym;\r\n                }\r\n                lo = lo.Lprev;\r\n            } else {\r\n                /* lo->Org is on the left.  We can make CCW triangles from up->Dst. */\r\n                while( lo.Lnext != up && (Geom.edgeGoesRight( up.Lprev )\r\n                    || Geom.edgeSign( up.Dst, up.Org, up.Lprev.Org ) >= 0.0 )) {\r\n                    var tempHalfEdge = mesh.connect( up, up.Lprev );\r\n                    //if (tempHalfEdge == NULL) return 0;\r\n                    up = tempHalfEdge.Sym;\r\n                }\r\n                up = up.Lnext;\r\n            }\r\n        }\r\n\r\n        /* Now lo->Org == up->Dst == the leftmost vertex.  The remaining region\r\n        * can be tessellated in a fan from this leftmost vertex.\r\n        */\r\n        assert( lo.Lnext !== up );\r\n        while( lo.Lnext.Lnext !== up ) {\r\n            var tempHalfEdge = mesh.connect( lo.Lnext, lo );\r\n            //if (tempHalfEdge == NULL) return 0;\r\n            lo = tempHalfEdge.Sym;\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n\r\n    /* tessMeshTessellateInterior( mesh ) tessellates each region of\r\n    * the mesh which is marked \"inside\" the polygon.  Each such region\r\n    * must be monotone.\r\n    */\r\n    //int tessMeshTessellateInterior( TESSmesh *mesh )\r\n    tessellateInterior_: function( mesh ) {\r\n        var f, next;\r\n\r\n        /*LINTED*/\r\n        for( f = mesh.fHead.next; f !== mesh.fHead; f = next ) {\r\n            /* Make sure we don''t try to tessellate the new triangles. */\r\n            next = f.next;\r\n            if( f.inside ) {\r\n                if ( !this.tessellateMonoRegion_( mesh, f ) ) return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    },\r\n\r\n\r\n    /* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces\r\n    * which are not marked \"inside\" the polygon.  Since further mesh operations\r\n    * on NULL faces are not allowed, the main purpose is to clean up the\r\n    * mesh so that exterior loops are not represented in the data structure.\r\n    */\r\n    //void tessMeshDiscardExterior( TESSmesh *mesh )\r\n    discardExterior_: function( mesh ) {\r\n        var f, next;\r\n\r\n        /*LINTED*/\r\n        for( f = mesh.fHead.next; f !== mesh.fHead; f = next ) {\r\n            /* Since f will be destroyed, save its next pointer. */\r\n            next = f.next;\r\n            if( ! f.inside ) {\r\n                mesh.zapFace( f );\r\n            }\r\n        }\r\n    },\r\n\r\n    /* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the\r\n    * winding numbers on all edges so that regions marked \"inside\" the\r\n    * polygon have a winding number of \"value\", and regions outside\r\n    * have a winding number of 0.\r\n    *\r\n    * If keepOnlyBoundary is TRUE, it also deletes all edges which do not\r\n    * separate an interior region from an exterior one.\r\n    */\r\n    //\tint tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )\r\n    setWindingNumber_: function( mesh, value, keepOnlyBoundary ) {\r\n        var e, eNext;\r\n\r\n        for( e = mesh.eHead.next; e !== mesh.eHead; e = eNext ) {\r\n            eNext = e.next;\r\n            if( e.Rface.inside !== e.Lface.inside ) {\r\n\r\n                /* This is a boundary edge (one side is interior, one is exterior). */\r\n                e.winding = (e.Lface.inside) ? value : -value;\r\n            } else {\r\n\r\n                /* Both regions are interior, or both are exterior. */\r\n                if( ! keepOnlyBoundary ) {\r\n                    e.winding = 0;\r\n                } else {\r\n                    mesh.delete( e );\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    getNeighbourFace_: function(edge)\r\n    {\r\n        if (!edge.Rface)\r\n            return -1;\r\n        if (!edge.Rface.inside)\r\n            return -1;\r\n        return edge.Rface.n;\r\n    },\r\n\r\n    outputPolymesh_: function( mesh, elementType, polySize, vertexSize ) {\r\n        var v;\r\n        var f;\r\n        var edge;\r\n        var maxFaceCount = 0;\r\n        var maxVertexCount = 0;\r\n        var faceVerts, i;\r\n        var elements = 0;\r\n        var vert;\r\n\r\n        // Assume that the input data is triangles now.\r\n        // Try to merge as many polygons as possible\r\n        if (polySize > 3)\r\n        {\r\n            mesh.mergeConvexFaces( polySize );\r\n        }\r\n\r\n        // Mark unused\r\n        for ( v = mesh.vHead.next; v !== mesh.vHead; v = v.next )\r\n            v.n = -1;\r\n\r\n        // Create unique IDs for all vertices and faces.\r\n        for ( f = mesh.fHead.next; f != mesh.fHead; f = f.next )\r\n        {\r\n            f.n = -1;\r\n            if( !f.inside ) continue;\r\n\r\n            edge = f.anEdge;\r\n            faceVerts = 0;\r\n            do\r\n            {\r\n                v = edge.Org;\r\n                if ( v.n === -1 )\r\n                {\r\n                    v.n = maxVertexCount;\r\n                    maxVertexCount++;\r\n                }\r\n                faceVerts++;\r\n                edge = edge.Lnext;\r\n            }\r\n            while (edge !== f.anEdge);\r\n\r\n            assert( faceVerts <= polySize );\r\n\r\n            f.n = maxFaceCount;\r\n            ++maxFaceCount;\r\n        }\r\n\r\n        this.elementCount = maxFaceCount;\r\n        if (elementType == Tess2.CONNECTED_POLYGONS)\r\n            maxFaceCount *= 2;\r\n        /*\t\ttess.elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,\r\n                                                                  sizeof(TESSindex) * maxFaceCount * polySize );\r\n                if (!tess->elements)\r\n                {\r\n                    tess->outOfMemory = 1;\r\n                    return;\r\n                }*/\r\n        this.elements = [];\r\n        this.elements.length = maxFaceCount * polySize;\r\n\r\n        this.vertexCount = maxVertexCount;\r\n        /*\t\ttess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,\r\n                                                                 sizeof(TESSreal) * tess->vertexCount * vertexSize );\r\n                if (!tess->vertices)\r\n                {\r\n                    tess->outOfMemory = 1;\r\n                    return;\r\n                }*/\r\n        this.vertices = [];\r\n        this.vertices.length = maxVertexCount * vertexSize;\r\n\r\n        /*\t\ttess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,\r\n                                                                        sizeof(TESSindex) * tess->vertexCount );\r\n                if (!tess->vertexIndices)\r\n                {\r\n                    tess->outOfMemory = 1;\r\n                    return;\r\n                }*/\r\n        this.vertexIndices = [];\r\n        this.vertexIndices.length = maxVertexCount;\r\n\r\n\r\n        // Output vertices.\r\n        for ( v = mesh.vHead.next; v !== mesh.vHead; v = v.next )\r\n        {\r\n            if ( v.n != -1 )\r\n            {\r\n                // Store coordinate\r\n                var idx = v.n * vertexSize;\r\n                this.vertices[idx+0] = v.coords[0];\r\n                this.vertices[idx+1] = v.coords[1];\r\n                if ( vertexSize > 2 )\r\n                    this.vertices[idx+2] = v.coords[2];\r\n                // Store vertex index.\r\n                this.vertexIndices[v.n] = v.idx;\r\n            }\r\n        }\r\n\r\n        // Output indices.\r\n        var nel = 0;\r\n        for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )\r\n        {\r\n            if ( !f.inside ) continue;\r\n\r\n            // Store polygon\r\n            edge = f.anEdge;\r\n            faceVerts = 0;\r\n            do\r\n            {\r\n                v = edge.Org;\r\n                this.elements[nel++] = v.n;\r\n                faceVerts++;\r\n                edge = edge.Lnext;\r\n            }\r\n            while (edge !== f.anEdge);\r\n            // Fill unused.\r\n            for (i = faceVerts; i < polySize; ++i)\r\n                this.elements[nel++] = -1;\r\n\r\n            // Store polygon connectivity\r\n            if ( elementType == Tess2.CONNECTED_POLYGONS )\r\n            {\r\n                edge = f.anEdge;\r\n                do\r\n                {\r\n                    this.elements[nel++] = this.getNeighbourFace_( edge );\r\n                    edge = edge.Lnext;\r\n                }\r\n                while (edge !== f.anEdge);\r\n                // Fill unused.\r\n                for (i = faceVerts; i < polySize; ++i)\r\n                    this.elements[nel++] = -1;\r\n            }\r\n        }\r\n    },\r\n\r\n    //\tvoid OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )\r\n    outputContours_: function( mesh, vertexSize ) {\r\n        var f;\r\n        var edge;\r\n        var start;\r\n        var verts;\r\n        var elements;\r\n        var vertInds;\r\n        var startVert = 0;\r\n        var vertCount = 0;\r\n\r\n        this.vertexCount = 0;\r\n        this.elementCount = 0;\r\n\r\n        for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )\r\n        {\r\n            if ( !f.inside ) continue;\r\n\r\n            start = edge = f.anEdge;\r\n            do\r\n            {\r\n                this.vertexCount++;\r\n                edge = edge.Lnext;\r\n            }\r\n            while ( edge !== start );\r\n\r\n            this.elementCount++;\r\n        }\r\n\r\n        /*\t\ttess->elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,\r\n                                                                  sizeof(TESSindex) * tess->elementCount * 2 );\r\n                if (!tess->elements)\r\n                {\r\n                    tess->outOfMemory = 1;\r\n                    return;\r\n                }*/\r\n        this.elements = [];\r\n        this.elements.length = this.elementCount * 2;\r\n\r\n        /*\t\ttess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,\r\n                                                                  sizeof(TESSreal) * tess->vertexCount * vertexSize );\r\n                if (!tess->vertices)\r\n                {\r\n                    tess->outOfMemory = 1;\r\n                    return;\r\n                }*/\r\n        this.vertices = [];\r\n        this.vertices.length = this.vertexCount * vertexSize;\r\n\r\n        /*\t\ttess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,\r\n                                                                        sizeof(TESSindex) * tess->vertexCount );\r\n                if (!tess->vertexIndices)\r\n                {\r\n                    tess->outOfMemory = 1;\r\n                    return;\r\n                }*/\r\n        this.vertexIndices = [];\r\n        this.vertexIndices.length = this.vertexCount;\r\n\r\n        var nv = 0;\r\n        var nvi = 0;\r\n        var nel = 0;\r\n        startVert = 0;\r\n\r\n        for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )\r\n        {\r\n            if ( !f.inside ) continue;\r\n\r\n            vertCount = 0;\r\n            start = edge = f.anEdge;\r\n            do\r\n            {\r\n                this.vertices[nv++] = edge.Org.coords[0];\r\n                this.vertices[nv++] = edge.Org.coords[1];\r\n                if ( vertexSize > 2 )\r\n                    this.vertices[nv++] = edge.Org.coords[2];\r\n                this.vertexIndices[nvi++] = edge.Org.idx;\r\n                vertCount++;\r\n                edge = edge.Lnext;\r\n            }\r\n            while ( edge !== start );\r\n\r\n            this.elements[nel++] = startVert;\r\n            this.elements[nel++] = vertCount;\r\n\r\n            startVert += vertCount;\r\n        }\r\n    },\r\n\r\n    addContour: function( size, vertices )\r\n    {\r\n        var e;\r\n        var i;\r\n\r\n        if ( this.mesh === null )\r\n            this.mesh = new TESSmesh();\r\n        /*\t \tif ( tess->mesh == NULL ) {\r\n                    tess->outOfMemory = 1;\r\n                    return;\r\n                }*/\r\n\r\n        if ( size < 2 )\r\n            size = 2;\r\n        if ( size > 3 )\r\n            size = 3;\r\n\r\n        e = null;\r\n\r\n        for( i = 0; i < vertices.length; i += size )\r\n        {\r\n            if( e == null ) {\r\n                /* Make a self-loop (one vertex, one edge). */\r\n                e = this.mesh.makeEdge();\r\n                /*\t\t\t\tif ( e == NULL ) {\r\n                                    tess->outOfMemory = 1;\r\n                                    return;\r\n                                }*/\r\n                this.mesh.splice( e, e.Sym );\r\n            } else {\r\n                /* Create a new vertex and edge which immediately follow e\r\n                * in the ordering around the left face.\r\n                */\r\n                this.mesh.splitEdge( e );\r\n                e = e.Lnext;\r\n            }\r\n\r\n            /* The new vertex is now e->Org. */\r\n            e.Org.coords[0] = vertices[i+0];\r\n            e.Org.coords[1] = vertices[i+1];\r\n            if ( size > 2 )\r\n                e.Org.coords[2] = vertices[i+2];\r\n            else\r\n                e.Org.coords[2] = 0.0;\r\n            /* Store the insertion number so that the vertex can be later recognized. */\r\n            e.Org.idx = this.vertexIndexCounter++;\r\n\r\n            /* The winding of an edge says how the winding number changes as we\r\n            * cross from the edge''s right face to its left face.  We add the\r\n            * vertices in such an order that a CCW contour will add +1 to\r\n            * the winding number of the region inside the contour.\r\n            */\r\n            e.winding = 1;\r\n            e.Sym.winding = -1;\r\n        }\r\n    },\r\n\r\n    //\tint tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )\r\n    tesselate: function( windingRule, elementType, polySize, vertexSize, normal ) {\r\n        this.vertices = [];\r\n        this.elements = [];\r\n        this.vertexIndices = [];\r\n\r\n        this.vertexIndexCounter = 0;\r\n\r\n        if (normal)\r\n        {\r\n            this.normal[0] = normal[0];\r\n            this.normal[1] = normal[1];\r\n            this.normal[2] = normal[2];\r\n        }\r\n\r\n        this.windingRule = windingRule;\r\n\r\n        if (vertexSize < 2)\r\n            vertexSize = 2;\r\n        if (vertexSize > 3)\r\n            vertexSize = 3;\r\n\r\n        /*\t\tif (setjmp(tess->env) != 0) {\r\n                    // come back here if out of memory\r\n                    return 0;\r\n                }*/\r\n\r\n        if (!this.mesh)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        /* Determine the polygon normal and project vertices onto the plane\r\n        * of the polygon.\r\n        */\r\n        this.projectPolygon_();\r\n\r\n        /* tessComputeInterior( tess ) computes the planar arrangement specified\r\n        * by the given contours, and further subdivides this arrangement\r\n        * into regions.  Each region is marked \"inside\" if it belongs\r\n        * to the polygon, according to the rule given by tess->windingRule.\r\n        * Each interior region is guaranteed be monotone.\r\n        */\r\n        Sweep.computeInterior( this );\r\n\r\n        var mesh = this.mesh;\r\n\r\n        /* If the user wants only the boundary contours, we throw away all edges\r\n        * except those which separate the interior from the exterior.\r\n        * Otherwise we tessellate all the regions marked \"inside\".\r\n        */\r\n        if (elementType == Tess2.BOUNDARY_CONTOURS) {\r\n            this.setWindingNumber_( mesh, 1, true );\r\n        } else {\r\n            this.tessellateInterior_( mesh );\r\n        }\r\n        //\t\tif (rc == 0) longjmp(tess->env,1);  /* could've used a label */\r\n\r\n        mesh.check();\r\n\r\n        if (elementType == Tess2.BOUNDARY_CONTOURS) {\r\n            this.outputContours_( mesh, vertexSize );     /* output contours */\r\n        }\r\n        else\r\n        {\r\n            this.outputPolymesh_( mesh, elementType, polySize, vertexSize );     /* output polygons */\r\n        }\r\n\r\n//\t\t\ttess.mesh = null;\r\n\r\n        return true;\r\n    }\r\n};","'use strict';\r\n/**\r\n * @enum {string} AttributeType\r\n * @private\r\n * @readonly\r\n */\r\nconst AttributeType = {\r\n    Int8:   'BYTE',\r\n    Uint8:  'UNSIGNED_BYTE',\r\n    Int16:  'SHORT',\r\n    Uint16: 'UNSIGNED_SHORT',\r\n    Int32:  'INT',\r\n    Uint32: 'UNSIGNED_INT',\r\n    Float32: 'FLOAT'\r\n};\r\n\r\n/**\r\n * The `Buffer` class turns a `StructArray` into a WebGL buffer. Each member of the StructArray's\r\n * Struct type is converted to a WebGL atribute.\r\n * @private\r\n */\r\nclass BufferUtil {\r\n    /**\r\n     * @param {Object} array A serialized StructArray.\r\n     * @param {Object} arrayType A serialized StructArrayType.\r\n     * @param {BufferType} type\r\n     */\r\n    constructor(array, arrayType, type) {\r\n        this.arrayBuffer = array.arrayBuffer;\r\n        this.length = array.length;\r\n        this.attributes = arrayType.members;\r\n        this.itemSize = arrayType.bytesPerElement;\r\n        this.type = type;\r\n        this.arrayType = arrayType;\r\n    }\r\n\r\n    static fromStructArray(array, type) {\r\n        return new BufferUtil(array.serialize(), array.constructor.serialize(), type);\r\n    }\r\n\r\n    updateData(gl,array) {\r\n        this.bind(gl);\r\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, array.arrayBuffer);\r\n    }\r\n\r\n    /**\r\n     * Bind this buffer to a WebGL context.\r\n     * @param gl The WebGL context\r\n     */\r\n    bind(gl) {\r\n        const type = gl[this.type];\r\n\r\n        if (!this.buffer) {\r\n            this.gl = gl;\r\n            this.buffer = gl.createBuffer();\r\n            gl.bindBuffer(type, this.buffer);\r\n            gl.bufferData(type, this.arrayBuffer, gl.STATIC_DRAW);\r\n\r\n            // dump array buffer once it's bound to gl\r\n            this.arrayBuffer = null;\r\n        } else {\r\n            gl.bindBuffer(type, this.buffer);\r\n        }\r\n    }\r\n\r\n    enableAttributes (gl, program) {\r\n        for (let j = 0; j < this.attributes.length; j++) {\r\n            const member = this.attributes[j];\r\n            const attribIndex = program[member.name];\r\n            if (attribIndex !== undefined) {\r\n                gl.enableVertexAttribArray(attribIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the attribute pointers in a WebGL context\r\n     * @param gl The WebGL context\r\n     * @param program The active WebGL program\r\n     * @param vertexOffset Index of the starting vertex of the segment\r\n     */\r\n    setVertexAttribPointers(gl, program, vertexOffset) {\r\n        for (let j = 0; j < this.attributes.length; j++) {\r\n            const member = this.attributes[j];\r\n            const attribIndex = program[member.name];\r\n\r\n            if (attribIndex !== undefined) {\r\n                gl.vertexAttribPointer(\r\n                    attribIndex,\r\n                    member.components,\r\n                    gl[AttributeType[member.type]],\r\n                    false,\r\n                    this.arrayType.bytesPerElement,\r\n                    member.offset + (this.arrayType.bytesPerElement * vertexOffset || 0)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the GL buffer bound to the given WebGL context\r\n     * @param gl The WebGL context\r\n     */\r\n    destroy() {\r\n        if (this.buffer) {\r\n            this.gl.deleteBuffer(this.buffer);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @enum {string} BufferType\r\n * @private\r\n * @readonly\r\n */\r\nBufferUtil.BufferType = {\r\n    VERTEX: 'ARRAY_BUFFER',\r\n    ELEMENT: 'ELEMENT_ARRAY_BUFFER'\r\n};\r\n\r\nexport default BufferUtil;\r\n","'use strict';\r\n// @flow\r\n\r\n// Note: all \"sizes\" are measured in bytes\r\n\r\n// const assert = require('assert');\r\n\r\nexport default  createStructArrayType;\r\n\r\nconst viewTypes = {\r\n    'Int8': Int8Array,\r\n    'Uint8': Uint8Array,\r\n    'Uint8Clamped': Uint8ClampedArray,\r\n    'Int16': Int16Array,\r\n    'Uint16': Uint16Array,\r\n    'Int32': Int32Array,\r\n    'Uint32': Uint32Array,\r\n    'Float32': Float32Array,\r\n    'Float64': Float64Array\r\n};\r\n\r\n/* eslint-disable no-undef */\r\n// type ViewType = $Keys<typeof viewTypes>;\r\n/* eslint-enable no-undef */\r\n\r\n/**\r\n * @typedef {Object} StructMember\r\n * @private\r\n * @property {string} name\r\n * @property {string} type\r\n * @property {number} components\r\n */\r\n\r\n/**\r\n * @private\r\n */\r\nclass Struct {\r\n    // _pos1: number;\r\n    // _pos2: number;\r\n    // _pos4: number;\r\n    // _pos8: number;\r\n    // _structArray: StructArray;\r\n    // // The following properties are defined on the prototype of sub classes.\r\n    // size: number;\r\n    // alignment: number;\r\n    /**\r\n     * @param {StructArray} structArray The StructArray the struct is stored in\r\n     * @param {number} index The index of the struct in the StructArray.\r\n     * @private\r\n     */\r\n    constructor(structArray, index) {\r\n        this._structArray = structArray;\r\n        this._pos1 = index * this.size;\r\n        this._pos2 = this._pos1 / 2;\r\n        this._pos4 = this._pos1 / 4;\r\n        this._pos8 = this._pos1 / 8;\r\n    }\r\n}\r\n\r\nconst DEFAULT_CAPACITY = 128;\r\nconst RESIZE_MULTIPLIER = 5;\r\n\r\n// type StructArrayMember = {|\r\n//     name: string,\r\n//     type: ViewType,\r\n//     components: number,\r\n//     offset: number\r\n// |};\r\n\r\n/**\r\n * The StructArray class is inherited by the custom StructArrayType classes created with\r\n * `createStructArrayType(members, options)`.\r\n * @private\r\n */\r\nclass StructArray {\r\n    // capacity: number;\r\n    // length: number;\r\n    // isTransferred: boolean;\r\n    // arrayBuffer: ArrayBuffer;\r\n    // int8: ?Int8Array;\r\n    // uint8: Uint8Array;\r\n    // uint8clamped: ?Uint8ClampedArray;\r\n    // int16: ?Int16Array;\r\n    // uint16: ?Uint16Array;\r\n    // int32: ?Int32Array;\r\n    // uint32: ?Uint32Array;\r\n    // float32: ?Float32Array;\r\n    // float64: ?Float64Array;\r\n    // // The following properties aer defined on the prototype.\r\n    // members: Array<StructArrayMember>;\r\n    // StructType: typeof Struct;\r\n    // bytesPerElement: number;\r\n    // _usedTypes: Array<ViewType>;\r\n    // emplaceBack: Function;\r\n    constructor(serialized, length) {\r\n        this.isTransferred = false;\r\n\r\n        if (serialized !== undefined) {\r\n        // Create from an serialized StructArray\r\n            this.arrayBuffer = serialized.arrayBuffer;\r\n            this.length = serialized.length;\r\n            this.capacity = this.arrayBuffer.byteLength / this.bytesPerElement;\r\n            this._refreshViews();\r\n\r\n        // Create a new StructArray\r\n        } else {\r\n            this.capacity = -1;\r\n            this.resize(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize the StructArray type. This serializes the *type* not an instance of the type.\r\n     */\r\n    static serialize() {\r\n        return {\r\n            members: this.prototype.members,\r\n            alignment: this.prototype.StructType.prototype.alignment,\r\n            bytesPerElement: this.prototype.bytesPerElement\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Serialize this StructArray instance\r\n     */\r\n    serialize(transferables) {\r\n        // assert(!this.isTransferred);\r\n\r\n        this._trim();\r\n\r\n        if (transferables) {\r\n            this.isTransferred = true;\r\n            transferables.push(this.arrayBuffer);\r\n        }\r\n        return {\r\n            length: this.length,\r\n            arrayBuffer: this.arrayBuffer\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Return the Struct at the given location in the array.\r\n     * @param {number} index The index of the element.\r\n     */\r\n    get(index) {\r\n        // assert(!this.isTransferred);\r\n        return new this.StructType(this, index);\r\n    }\r\n\r\n    /**\r\n     * Resize the array to discard unused capacity.\r\n     */\r\n    _trim() {\r\n        if (this.length !== this.capacity) {\r\n            this.capacity = this.length;\r\n            this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement);\r\n            this._refreshViews();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resize the array.\r\n     * If `n` is greater than the current length then additional elements with undefined values are added.\r\n     * If `n` is less than the current length then the array will be reduced to the first `n` elements.\r\n     * @param {number} n The new size of the array.\r\n     */\r\n    resize(n) {\r\n        // assert(!this.isTransferred);\r\n\r\n        this.length = n;\r\n        if (n > this.capacity) {\r\n            this.capacity = Math.max(n, Math.floor(this.capacity * RESIZE_MULTIPLIER), DEFAULT_CAPACITY);\r\n            this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);\r\n\r\n            const oldUint8Array = this.uint8;\r\n            this._refreshViews();\r\n            if (oldUint8Array) this.uint8.set(oldUint8Array);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create TypedArray views for the current ArrayBuffer.\r\n     */\r\n    _refreshViews() {\r\n        for (const type of this._usedTypes) {\r\n            // $FlowFixMe\r\n            this[getArrayViewName(type)] = new viewTypes[type](this.arrayBuffer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Output the `StructArray` between indices `startIndex` and `endIndex` as an array of `StructTypes` to enable sorting\r\n     * @param {number} startIndex\r\n     * @param {number} endIndex\r\n     */\r\n    toArray(startIndex, endIndex) {\r\n        // assert(!this.isTransferred);\r\n\r\n        const array = [];\r\n\r\n        for (let i = startIndex; i < endIndex; i++) {\r\n            const struct = this.get(i);\r\n            array.push(struct);\r\n        }\r\n\r\n        return array;\r\n    }\r\n}\r\n\r\nconst structArrayTypeCache = {};\r\n\r\n/**\r\n * `createStructArrayType` is used to create new `StructArray` types.\r\n *\r\n * `StructArray` provides an abstraction over `ArrayBuffer` and `TypedArray` making it behave like\r\n * an array of typed structs. A StructArray is comprised of elements. Each element has a set of\r\n * members that are defined when the `StructArrayType` is created.\r\n *\r\n * StructArrays useful for creating large arrays that:\r\n * - can be transferred from workers as a Transferable object\r\n * - can be copied cheaply\r\n * - use less memory for lower-precision members\r\n * - can be used as buffers in WebGL.\r\n *\r\n * @class\r\n * @param {Object} options\r\n * @param {number} options.alignment Use `4` to align members to 4 byte boundaries. Default is 1.\r\n * @param {Array<StructMember>} options.members\r\n * @example\r\n *\r\n * var PointArrayType = createStructArrayType({\r\n *  members: [\r\n *      { type: 'Int16', name: 'x' },\r\n *      { type: 'Int16', name: 'y' }\r\n *  ]});\r\n *\r\n *  var pointArray = new PointArrayType();\r\n *  pointArray.emplaceBack(10, 15);\r\n *  pointArray.emplaceBack(20, 35);\r\n *\r\n *  point = pointArray.get(0);\r\n *  assert(point.x === 10);\r\n *  assert(point.y === 15);\r\n *\r\n * @private\r\n */\r\n\r\nfunction createStructArrayType(options, name, components,\r\n  alignment) {\r\n\r\n    const key = JSON.stringify(options);\r\n\r\n    if (structArrayTypeCache[key]) {\r\n        return structArrayTypeCache[key];\r\n    }\r\n\r\n    alignment = (options.alignment === undefined) ?\r\n      1 : options.alignment;\r\n\r\n    let offset = 0;\r\n    let maxSize = 0;\r\n    const usedTypes = ['Uint8'];\r\n\r\n    const members = options.members.map((member) => {\r\n        // assert(member.name.length);\r\n        // assert(member.type in viewTypes);\r\n\r\n        if (usedTypes.indexOf(member.type) < 0) usedTypes.push(member.type);\r\n\r\n        const typeSize = sizeOf(member.type);\r\n        const memberOffset = offset = align(offset, Math.max(alignment, typeSize));\r\n        const components = member.components || 1;\r\n\r\n        maxSize = Math.max(maxSize, typeSize);\r\n        offset += typeSize * components;\r\n\r\n        return {\r\n            name: member.name,\r\n            type: member.type,\r\n            components: components,\r\n            offset: memberOffset\r\n        };\r\n    });\r\n\r\n    const size = align(offset, Math.max(maxSize, alignment));\r\n\r\n    class StructType extends Struct {}\r\n\r\n    StructType.prototype.alignment = alignment;\r\n    StructType.prototype.size = size;\r\n\r\n    for (const member of members) {\r\n        for (let c = 0; c < member.components; c++) {\r\n            const name = member.name + (member.components === 1 ? '' : c);\r\n            Object.defineProperty(StructType.prototype, name, {\r\n                get: createGetter(member, c),\r\n                set: createSetter(member, c)\r\n            });\r\n        }\r\n    }\r\n\r\n    class StructArrayType extends StructArray {}\r\n\r\n    StructArrayType.prototype.members = members;\r\n    StructArrayType.prototype.StructType = StructType;\r\n    StructArrayType.prototype.bytesPerElement = size;\r\n    StructArrayType.prototype.emplaceBack = createEmplaceBack(members, size);\r\n    StructArrayType.prototype._usedTypes = usedTypes;\r\n\r\n    structArrayTypeCache[key] = StructArrayType;\r\n\r\n    return StructArrayType;\r\n}\r\n\r\nfunction align(offset, size) {\r\n    return Math.ceil(offset / size) * size;\r\n}\r\n\r\nfunction sizeOf(type) {\r\n    return viewTypes[type].BYTES_PER_ELEMENT;\r\n}\r\n\r\nfunction getArrayViewName(type) {\r\n    return type.toLowerCase();\r\n}\r\n\r\n/*\r\n * > I saw major perf gains by shortening the source of these generated methods (i.e. renaming\r\n * > elementIndex to i) (likely due to v8 inlining heuristics).\r\n * - lucaswoj\r\n */\r\nfunction createEmplaceBack(members, bytesPerElement) {\r\n    const usedTypeSizes = [];\r\n    const argNames = [];\r\n    let body =\r\n        'var i = this.length;\\n' +\r\n        'this.resize(this.length + 1);\\n';\r\n\r\n    for (const member of members) {\r\n        const size = sizeOf(member.type);\r\n\r\n        // array offsets to the end of current data for each type size\r\n        // var o{SIZE} = i * ROUNDED(bytesPerElement / size);\r\n        if (usedTypeSizes.indexOf(size) < 0) {\r\n            usedTypeSizes.push(size);\r\n            body += `var o${size.toFixed(0)} = i * ${(bytesPerElement / size).toFixed(0)};\\n`;\r\n        }\r\n\r\n        for (let c = 0; c < member.components; c++) {\r\n            // arguments v0, v1, v2, ... are, in order, the components of\r\n            // member 0, then the components of member 1, etc.\r\n            const argName = `v${argNames.length}`;\r\n            // The index for `member` component `c` into the appropriate type array is:\r\n            // this.{TYPE}[o{SIZE} + MEMBER_OFFSET + {c}] = v{X}\r\n            // where MEMBER_OFFSET = ROUND(member.offset / size) is the per-element\r\n            // offset of this member into the array\r\n            const index = `o${size.toFixed(0)} + ${(member.offset / size + c).toFixed(0)}`;\r\n            body += `this.${getArrayViewName(member.type)}[${index}] = ${argName};\\n`;\r\n            argNames.push(argName);\r\n        }\r\n    }\r\n\r\n    body += 'return i;';\r\n\r\n    return new Function(argNames.toString(), body);\r\n}\r\n\r\nfunction createMemberComponentString(member, component) {\r\n    const elementOffset = `this._pos${sizeOf(member.type).toFixed(0)}`;\r\n    const componentOffset = (member.offset / sizeOf(member.type) + component).toFixed(0);\r\n    const index = `${elementOffset} + ${componentOffset}`;\r\n    return `this._structArray.${getArrayViewName(member.type)}[${index}]`;\r\n}\r\n\r\nfunction createGetter(member, c) {\r\n    return new Function(`return ${createMemberComponentString(member, c)};`);\r\n}\r\n\r\nfunction createSetter(member, c) {\r\n    return new Function('x', `${createMemberComponentString(member, c)} = x;`);\r\n}\r\n","'use strict';\r\nimport createStructArrayType from './StructArray';\r\n\r\nexport default createElementArrayType;\r\n\r\n/**\r\n * An element array stores Uint16 indicies of vertexes in a corresponding vertex array. With no\r\n * arguments, it defaults to three components per element, forming triangles.\r\n * @private\r\n */\r\nfunction createElementArrayType(components) {\r\n    return createStructArrayType({\r\n        members: [{\r\n            type: 'Uint16',\r\n            name: 'vertices',\r\n            components: components || 3\r\n        }]\r\n    });\r\n}\r\n","'use strict';\r\nimport createStructArrayType from './StructArray';\r\nexport default createVertexArrayType;\r\n\r\n/**\r\n * A vertex array stores data for each vertex in a geometry. Elements are aligned to 4 byte\r\n * boundaries for best performance in WebGL.\r\n * @private\r\n */\r\nfunction createVertexArrayType(members) {\r\n    return createStructArrayType({\r\n        members: members,\r\n        alignment: 4\r\n    });\r\n}\r\n","// @flow\r\n\r\nimport SegmentVector from '../segment';\r\nimport Bucket from './Bucket';\r\nimport classifyRings from './ClassifyRings';\r\n// import earcut from './earcut';\r\nimport Tess2 from './tess2';\r\n// import turf from '@turf/turf';\r\n\r\nimport BufferUtil from '../../util/BufferUtil';\r\nimport createElementArrayType from '../../util/ElementArrayType';\r\nimport createVertexArrayType from '../../util/VertexArrayType';\r\n\r\nconst layoutAttributes = [{name: 'a_pos', components: 2, type: 'Float32'}];\r\nconst FillLayoutArrayType = createVertexArrayType(layoutAttributes);\r\nconst IndexArrayType = createElementArrayType(3);\r\nconst IndexArrayType2= createElementArrayType(2);\r\n\r\nconst EARCUT_MAX_RINGS = 1500;\r\nclass FillBucket extends Bucket{\r\n    constructor(options) {\r\n        super(options);\r\n        this.overscaling = options.overscaling;\r\n        this.layoutVertexArray = new FillLayoutArrayType();\r\n        this.layoutVertexArray2 = new FillLayoutArrayType();\r\n        this.indexArray = new IndexArrayType();\r\n        this.indexArray2 = new IndexArrayType2();\r\n        this.segments = new SegmentVector();\r\n        this.segments2 = new SegmentVector();\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.layoutVertexArray.length === 0;\r\n    }\r\n\r\n    destroy() {\r\n        this.segments.destroy();\r\n        this.segments2.destroy();\r\n    }\r\n\r\n    addFeature(feature) {\r\n        for (const polygon of classifyRings(feature, EARCUT_MAX_RINGS)) {\r\n            let numVertices = 0;\r\n            let flatteneds = [];\r\n            const holeIndices = [];\r\n\r\n\r\n            for (const ring of polygon) {\r\n                const flattened = [];\r\n                if (ring.length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (ring !== polygon[0]) {\r\n                    holeIndices.push(flattened.length / 2);\r\n                }\r\n\r\n                const lineSegment = this.segments2.prepareSegment(ring.length, this.layoutVertexArray2, this.indexArray2);\r\n                const lineIndex = lineSegment.vertexLength;\r\n\r\n                this.layoutVertexArray2.emplaceBack(ring[0].x, ring[0].y);\r\n                this.indexArray2.emplaceBack(lineIndex + ring.length - 1, lineIndex);\r\n                flattened.push(ring[0].x);\r\n                flattened.push(ring[0].y);\r\n\r\n\r\n                for (let i = 1; i < ring.length; i++) {\r\n                    this.layoutVertexArray2.emplaceBack(ring[i].x, ring[i].y);\r\n                    this.indexArray2.emplaceBack(lineIndex + i - 1, lineIndex + i);\r\n                    flattened.push(ring[i].x);\r\n                    flattened.push(ring[i].y);\r\n                }\r\n\r\n                lineSegment.vertexLength += ring.length;\r\n                lineSegment.primitiveLength += ring.length;\r\n\r\n                flatteneds.push(flattened);\r\n            }\r\n\r\n\r\n            var res = Tess2.tesselate({\r\n                contours:flatteneds,\r\n                windingRule: Tess2.WINDING_ODD,\r\n                elementType: Tess2.POLYGONS,\r\n                polySize: 3,\r\n                vertexSize: 2\r\n            });\r\n\r\n            numVertices = res.vertices.length/2;\r\n\r\n\r\n            const triangleSegment = this.segments.prepareSegment(numVertices, this.layoutVertexArray, this.indexArray);\r\n            const triangleIndex = triangleSegment.vertexLength;\r\n            for(let j = 0;j<res.vertices.length;j+=2){\r\n                this.layoutVertexArray.emplaceBack(res.vertices[j], res.vertices[j+1]);\r\n            }\r\n\r\n\r\n            const indices = res.elements;\r\n            for (let i = 0; i < indices.length; i += 3) {\r\n                this.indexArray.emplaceBack(\r\n                    triangleIndex + indices[i],\r\n                    triangleIndex + indices[i + 1],\r\n                    triangleIndex + indices[i + 2]);\r\n            }\r\n\r\n            triangleSegment.vertexLength += numVertices;\r\n            triangleSegment.primitiveLength += indices.length / 3;\r\n\r\n\r\n\r\n            // let numVertices = 0;\r\n            // for (const ring of polygon) {\r\n            //     numVertices += ring.length;\r\n            // }\r\n            //\r\n            // const triangleSegment = arrays.prepareSegment(numVertices);\r\n            // const triangleIndex = triangleSegment.vertexLength;\r\n            //\r\n            // const flattened = [];\r\n            // const holeIndices = [];\r\n            //\r\n            // for (const ring of polygon) {\r\n            //     if (ring.length === 0) {\r\n            //         continue;\r\n            //     }\r\n            //\r\n            //     if (ring !== polygon[0]) {\r\n            //         holeIndices.push(flattened.length / 2);\r\n            //     }\r\n            //\r\n            //     const lineSegment = arrays.prepareSegment2(ring.length);\r\n            //     const lineIndex = lineSegment.vertexLength;\r\n            //\r\n            //     arrays.layoutVertexArray.emplaceBack(ring[0].x, ring[0].y);\r\n            //     arrays.layoutVertexArray2.emplaceBack(ring[0].x, ring[0].y);\r\n            //     arrays.elementArray2.emplaceBack(lineIndex + ring.length - 1, lineIndex);\r\n            //     flattened.push(ring[0].x);\r\n            //     flattened.push(ring[0].y);\r\n            //\r\n            //     for (let i = 1; i < ring.length; i++) {\r\n            //         arrays.layoutVertexArray.emplaceBack(ring[i].x, ring[i].y);\r\n            //         arrays.layoutVertexArray2.emplaceBack(ring[i].x, ring[i].y);\r\n            //         arrays.elementArray2.emplaceBack(lineIndex + i - 1, lineIndex + i);\r\n            //         flattened.push(ring[i].x);\r\n            //         flattened.push(ring[i].y);\r\n            //     }\r\n            //\r\n            //     lineSegment.vertexLength += ring.length;\r\n            //     lineSegment.primitiveLength += ring.length;\r\n            // }\r\n            //\r\n            // const indices = earcut(flattened, holeIndices);\r\n            //\r\n            // for (let i = 0; i < indices.length; i += 3) {\r\n            //     arrays.elementArray.emplaceBack(\r\n            //         triangleIndex + indices[i],\r\n            //         triangleIndex + indices[i + 1],\r\n            //         triangleIndex + indices[i + 2]);\r\n            // }\r\n            //\r\n            // triangleSegment.vertexLength += numVertices;\r\n            // triangleSegment.primitiveLength += indices.length / 3;\r\n\r\n\r\n            // console.log('顶点个数：'+ triangleSegment.vertexLength + '   三角形个数: '+triangleSegment.primitiveLength );\r\n        }\r\n\r\n        // for (const polygon of classifyRings(geometry, EARCUT_MAX_RINGS)) {\r\n        //     let numVertices = 0;\r\n        //     for (const ring of polygon) {\r\n        //         numVertices += ring.length;\r\n        //     }\r\n        //\r\n        //     const triangleSegment = this.segments.prepareSegment(numVertices, this.layoutVertexArray, this.indexArray);\r\n        //     const triangleIndex = triangleSegment.vertexLength;\r\n        //\r\n        //     const flattened = [];\r\n        //     const holeIndices = [];\r\n        //\r\n        //     for (const ring of polygon) {\r\n        //         if (ring.length === 0) {\r\n        //             continue;\r\n        //         }\r\n        //\r\n        //         if (ring !== polygon[0]) {\r\n        //             holeIndices.push(flattened.length / 2);\r\n        //         }\r\n        //\r\n        //         const lineSegment = this.segments2.prepareSegment(ring.length, this.layoutVertexArray, this.indexArray2);\r\n        //         const lineIndex = lineSegment.vertexLength;\r\n        //\r\n        //         this.layoutVertexArray.emplaceBack(ring[0].x, ring[0].y);\r\n        //         this.indexArray2.emplaceBack(lineIndex + ring.length - 1, lineIndex);\r\n        //         flattened.push(ring[0].x);\r\n        //         flattened.push(ring[0].y);\r\n        //\r\n        //         for (let i = 1; i < ring.length; i++) {\r\n        //             this.layoutVertexArray.emplaceBack(ring[i].x, ring[i].y);\r\n        //             this.indexArray2.emplaceBack(lineIndex + i - 1, lineIndex + i);\r\n        //             flattened.push(ring[i].x);\r\n        //             flattened.push(ring[i].y);\r\n        //         }\r\n        //\r\n        //         lineSegment.vertexLength += ring.length;\r\n        //         lineSegment.primitiveLength += ring.length;\r\n        //     }\r\n        //\r\n        //     const indices = earcut(flattened, holeIndices);\r\n        //\r\n        //     for (let i = 0; i < indices.length; i += 3) {\r\n        //         this.indexArray.emplaceBack(\r\n        //             triangleIndex + indices[i],\r\n        //             triangleIndex + indices[i + 1],\r\n        //             triangleIndex + indices[i + 2]);\r\n        //     }\r\n        //\r\n        //     triangleSegment.vertexLength += numVertices;\r\n        //     triangleSegment.primitiveLength += indices.length / 3;\r\n        // }\r\n    }\r\n\r\n    serialize(transferables) {\r\n        return {\r\n            type:this.type,\r\n            style:this.style,\r\n            tileSize: this.tileSize,\r\n            layoutVertexArray: this.layoutVertexArray.serialize(transferables),\r\n            layoutVertexArray2: this.layoutVertexArray2.serialize(transferables),\r\n            indexArray:  this.indexArray.serialize(transferables),\r\n            indexArray2: this.indexArray2.serialize(transferables),\r\n            segments: this.segments,\r\n            segments2: this.segments2\r\n        };\r\n    }\r\n\r\n    static createBuffer(bucket){\r\n        bucket.layoutVertexBuffer = new BufferUtil(bucket.layoutVertexArray,\r\n            FillLayoutArrayType.serialize(), BufferUtil.BufferType.VERTEX);\r\n        bucket.layoutVertexBuffer2 = new BufferUtil(bucket.layoutVertexArray2,\r\n            FillLayoutArrayType.serialize(), BufferUtil.BufferType.VERTEX);\r\n        bucket.indexBuffer = new BufferUtil(bucket.indexArray,\r\n            IndexArrayType.serialize(), BufferUtil.BufferType.ELEMENT);\r\n        bucket.indexBuffer2 = new BufferUtil(bucket.indexArray2,\r\n            IndexArrayType2.serialize(), BufferUtil.BufferType.ELEMENT);\r\n    }\r\n}\r\n\r\nexport default FillBucket;\r\n","// @flow\r\nimport SegmentVector from '../segment';\r\nimport Bucket from './Bucket';\r\n\r\n\r\nimport BufferUtil from '../../util/BufferUtil';\r\nimport createElementArrayType from '../../util/ElementArrayType';\r\nimport createVertexArrayType from '../../util/VertexArrayType';\r\n\r\nconst layoutAttributes = [{name: 'a_pos',  components: 2, type: 'Float32'},\r\n    {name: 'a_data', components: 4, type: 'Uint8'},\r\n    {name: 'a_txy',  components: 2, type: 'Int16'}];\r\nconst FillLayoutArrayType = createVertexArrayType(layoutAttributes);\r\nconst IndexArrayType = createElementArrayType(3);\r\n\r\nconst EXTRUDE_SCALE = 63;\r\nconst EXTENT = 8192;\r\n\r\n/*\r\n * Sharp corners cause dashed lines to tilt because the distance along the line\r\n * is the same at both the inner and outer corners. To improve the appearance of\r\n * dashed lines we add extra points near sharp corners so that a smaller part\r\n * of the line is tilted.\r\n *\r\n * COS_HALF_SHARP_CORNER controls how sharp a corner has to be for us to add an\r\n * extra vertex. The default is 75 degrees.\r\n *\r\n * The newly created vertices are placed SHARP_CORNER_OFFSET pixels from the corner.\r\n */\r\nconst COS_HALF_SHARP_CORNER = Math.cos(75 / 2 * (Math.PI / 180));\r\nconst SHARP_CORNER_OFFSET = 15;\r\n\r\n// The number of bits that is used to store the line distance in the buffer.\r\nconst LINE_DISTANCE_BUFFER_BITS = 15;\r\n\r\n// We don't have enough bits for the line distance as we'd like to have, so\r\n// use this value to scale the line distance (in tile units) down to a smaller\r\n// value. This lets us store longer distances while sacrificing precision.\r\nconst LINE_DISTANCE_SCALE = 1 / 2;\r\n\r\n// The maximum line distance, in tile units, that fits in the buffer.\r\nconst MAX_LINE_DISTANCE = Math.pow(2, LINE_DISTANCE_BUFFER_BITS - 1)/ LINE_DISTANCE_SCALE;\r\n\r\nfunction addLineVertex(layoutVertexBuffer, point, extrude, tx, ty, dir, linesofar) {\r\n    layoutVertexBuffer.emplaceBack(\r\n        // a_pos\r\n        point.x,\r\n        point.y,\r\n        // a_data\r\n        // add 128 to store a byte in an unsigned byte\r\n        Math.round(EXTRUDE_SCALE * extrude.x) + 128,\r\n        Math.round(EXTRUDE_SCALE * extrude.y) + 128,\r\n        // Encode the -1/0/1 direction value into the first two bits of .z of a_data.\r\n        // Combine it with the lower 6 bits of `linesofar` (shifted by 2 bites to make\r\n        // room for the direction value). The upper 8 bits of `linesofar` are placed in\r\n        // the `w` component. `linesofar` is scaled down by `LINE_DISTANCE_SCALE` so that\r\n        // we can store longer distances while sacrificing precision.\r\n        ((dir === 0 ? 0 : (dir < 0 ? -1 : 1)) + 1) | (((linesofar * LINE_DISTANCE_SCALE) & 0x3F) << 2),\r\n        (linesofar * LINE_DISTANCE_SCALE) >> 6,\r\n        tx,\r\n        ty);\r\n}\r\n/**\r\n * @private\r\n */\r\nclass LineBucket extends Bucket{\r\n    constructor(options) {\r\n        super(options);\r\n        this.overscaling = this.tileSize/512;\r\n\r\n        this.layoutVertexArray = new FillLayoutArrayType();\r\n        this.indexArray = new IndexArrayType();\r\n        this.segments = new SegmentVector();\r\n    }\r\n\r\n    upload(context) {\r\n        this.uploaded = true;\r\n    }\r\n\r\n    destroy() {\r\n        this.segments.destroy();\r\n    }\r\n\r\n    addFeature(feature) {\r\n        const join = 'round';\r\n        const cap = this.style['lineCap']?this.style['lineCap']:'butt';\r\n        const miterLimit = 0;\r\n        const roundLimit = 0;\r\n\r\n        for (const line of feature) {\r\n            this.addLine(line, feature, join, cap, miterLimit, roundLimit);\r\n        }\r\n    }\r\n\r\n    addLine(vertices, feature, join, cap, miterLimit, roundLimit) {\r\n        // const featureProperties = feature.properties;\r\n        // const isPolygon = VectorTileFeature.types[feature.type] === 'Polygon';\r\n        const isPolygon = false;\r\n        // If the line has duplicate vertices at the ends, adjust start/length to remove them.\r\n        let len = vertices.length;\r\n        while (len >= 2 && vertices[len - 1].equals(vertices[len - 2])) {\r\n            len--;\r\n        }\r\n        let first = 0;\r\n        while (first < len - 1 && vertices[first].equals(vertices[first + 1])) {\r\n            first++;\r\n        }\r\n\r\n        // Ignore invalid geometry.\r\n        if (len < (isPolygon ? 3 : 2)) return;\r\n\r\n        if (join === 'bevel') miterLimit = 1.05;\r\n\r\n        const sharpCornerOffset = SHARP_CORNER_OFFSET * (EXTENT / (512 * this.overscaling));\r\n\r\n        const firstVertex = vertices[first];\r\n        // const arrays = this.arrays;\r\n\r\n        // we could be more precise, but it would only save a negligible amount of space\r\n        // const segment = arrays.prepareSegment(len * 10);\r\n\r\n        const segment = this.segments.prepareSegment(len * 10, this.layoutVertexArray, this.indexArray);\r\n        this.distance = 0;\r\n\r\n        const beginCap = cap,\r\n            endCap = isPolygon ? 'butt' : cap;\r\n        let startOfLine = true;\r\n        let currentVertex, prevVertex, nextVertex, prevNormal, nextNormal, offsetA, offsetB;\r\n\r\n        // the last three vertices added\r\n        this.e1 = this.e2 = this.e3 = -1;\r\n\r\n        if (isPolygon) {\r\n            currentVertex = vertices[len - 2];\r\n            nextNormal = firstVertex.sub(currentVertex)._unit()._perp();\r\n        }\r\n\r\n        for (let i = first; i < len; i++) {\r\n\r\n            nextVertex = isPolygon && i === len - 1 ?\r\n                vertices[first + 1] : // if the line is closed, we treat the last vertex like the first\r\n                vertices[i + 1]; // just the next vertex\r\n\r\n            // if two consecutive vertices exist, skip the current one\r\n            if (nextVertex && vertices[i].equals(nextVertex)) continue;\r\n\r\n            if (nextNormal) prevNormal = nextNormal;\r\n            if (currentVertex) prevVertex = currentVertex;\r\n\r\n            currentVertex = vertices[i];\r\n\r\n            // Calculate the normal towards the next vertex in this line. In case\r\n            // there is no next vertex, pretend that the line is continuing straight,\r\n            // meaning that we are just using the previous normal.\r\n            nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;\r\n\r\n            // If we still don't have a previous normal, this is the beginning of a\r\n            // non-closed line, so we're doing a straight \"join\".\r\n            prevNormal = prevNormal || nextNormal;\r\n\r\n            // Determine the normal of the join extrusion. It is the angle bisector\r\n            // of the segments between the previous line and the next line.\r\n            // In the case of 180° angles, the prev and next normals cancel each other out:\r\n            // prevNormal + nextNormal = (0, 0), its magnitude is 0, so the unit vector would be\r\n            // undefined. In that case, we're keeping the joinNormal at (0, 0), so that the cosHalfAngle\r\n            // below will also become 0 and miterLength will become Infinity.\r\n            let joinNormal = prevNormal.add(nextNormal);\r\n            if (joinNormal.x !== 0 || joinNormal.y !== 0) {\r\n                joinNormal._unit();\r\n            }\r\n            /*  joinNormal     prevNormal\r\n             *             ↖      ↑\r\n             *                .________. prevVertex\r\n             *                |\r\n             * nextNormal  ←  |  currentVertex\r\n             *                |\r\n             *     nextVertex !\r\n             *\r\n             */\r\n\r\n            // Calculate the length of the miter (the ratio of the miter to the width).\r\n            // Find the cosine of the angle between the next and join normals\r\n            // using dot product. The inverse of that is the miter length.\r\n            const cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;\r\n            const miterLength = cosHalfAngle !== 0 ? 1 / cosHalfAngle : Infinity;\r\n\r\n            const isSharpCorner = cosHalfAngle < COS_HALF_SHARP_CORNER && prevVertex && nextVertex;\r\n\r\n            if (isSharpCorner && i > first) {\r\n                const prevSegmentLength = currentVertex.dist(prevVertex);\r\n                if (prevSegmentLength > 2 * sharpCornerOffset) {\r\n                    const newPrevVertex = currentVertex.sub(currentVertex.sub(prevVertex)._mult(sharpCornerOffset / prevSegmentLength)._round());\r\n                    this.distance += newPrevVertex.dist(prevVertex);\r\n                    this.addCurrentVertex(newPrevVertex, this.distance, prevNormal.mult(1), 0, 0, false, segment);\r\n                    prevVertex = newPrevVertex;\r\n                }\r\n            }\r\n\r\n            // The join if a middle vertex, otherwise the cap.\r\n            const middleVertex = prevVertex && nextVertex;\r\n            let currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;\r\n\r\n            if (middleVertex && currentJoin === 'round') {\r\n                if (miterLength < roundLimit) {\r\n                    currentJoin = 'miter';\r\n                } else if (miterLength <= 2) {\r\n                    currentJoin = 'fakeround';\r\n                }\r\n            }\r\n\r\n            if (currentJoin === 'miter' && miterLength > miterLimit) {\r\n                currentJoin = 'bevel';\r\n            }\r\n\r\n            if (currentJoin === 'bevel') {\r\n                // The maximum extrude length is 128 / 63 = 2 times the width of the line\r\n                // so if miterLength >= 2 we need to draw a different type of bevel here.\r\n                if (miterLength > 2) currentJoin = 'flipbevel';\r\n\r\n                // If the miterLength is really small and the line bevel wouldn't be visible,\r\n                // just draw a miter join to save a triangle.\r\n                if (miterLength < miterLimit) currentJoin = 'miter';\r\n            }\r\n\r\n            // Calculate how far along the line the currentVertex is\r\n            if (prevVertex) this.distance += currentVertex.dist(prevVertex);\r\n\r\n            if (currentJoin === 'miter') {\r\n\r\n                joinNormal._mult(miterLength);\r\n                this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false, segment);\r\n\r\n            } else if (currentJoin === 'flipbevel') {\r\n                // miter is too big, flip the direction to make a beveled join\r\n\r\n                if (miterLength > 100) {\r\n                    // Almost parallel lines\r\n                    joinNormal = nextNormal.clone().mult(-1);\r\n\r\n                } else {\r\n                    const direction = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x > 0 ? -1 : 1;\r\n                    const bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();\r\n                    joinNormal._perp()._mult(bevelLength * direction);\r\n                }\r\n                this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false, segment);\r\n                this.addCurrentVertex(currentVertex, this.distance, joinNormal.mult(-1), 0, 0, false, segment);\r\n\r\n            } else if (currentJoin === 'bevel' || currentJoin === 'fakeround') {\r\n                const lineTurnsLeft = (prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x) > 0;\r\n                const offset = -Math.sqrt(miterLength * miterLength - 1);\r\n                if (lineTurnsLeft) {\r\n                    offsetB = 0;\r\n                    offsetA = offset;\r\n                } else {\r\n                    offsetA = 0;\r\n                    offsetB = offset;\r\n                }\r\n\r\n                // Close previous segment with a bevel\r\n                if (!startOfLine) {\r\n                    this.addCurrentVertex(currentVertex, this.distance, prevNormal, offsetA, offsetB, false, segment);\r\n                }\r\n\r\n                if (currentJoin === 'fakeround') {\r\n                    // The join angle is sharp enough that a round join would be visible.\r\n                    // Bevel joins fill the gap between segments with a single pie slice triangle.\r\n                    // Create a round join by adding multiple pie slices. The join isn't actually round, but\r\n                    // it looks like it is at the sizes we render lines at.\r\n\r\n                    // Add more triangles for sharper angles.\r\n                    // This math is just a good enough approximation. It isn't \"correct\".\r\n                    const n = Math.floor((0.5 - (cosHalfAngle - 0.5)) * 8);\r\n                    let approxFractionalJoinNormal;\r\n\r\n                    for (let m = 0; m < n; m++) {\r\n                        approxFractionalJoinNormal = nextNormal.mult((m + 1) / (n + 1))._add(prevNormal)._unit();\r\n                        this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft, segment);\r\n                    }\r\n\r\n                    this.addPieSliceVertex(currentVertex, this.distance, joinNormal, lineTurnsLeft, segment);\r\n\r\n                    for (let k = n - 1; k >= 0; k--) {\r\n                        approxFractionalJoinNormal = prevNormal.mult((k + 1) / (n + 1))._add(nextNormal)._unit();\r\n                        this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft, segment);\r\n                    }\r\n                }\r\n\r\n                // Start next segment\r\n                if (nextVertex) {\r\n                    this.addCurrentVertex(currentVertex, this.distance, nextNormal, -offsetA, -offsetB, false, segment);\r\n                }\r\n\r\n            } else if (currentJoin === 'butt') {\r\n                if (!startOfLine) {\r\n                    // Close previous segment with a butt\r\n                    this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false, segment);\r\n                }\r\n\r\n                // Start next segment with a butt\r\n                if (nextVertex) {\r\n                    this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false, segment);\r\n                }\r\n\r\n            } else if (currentJoin === 'square') {\r\n\r\n                if (!startOfLine) {\r\n                    // Close previous segment with a square cap\r\n                    this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, false, segment);\r\n\r\n                    // The segment is done. Unset vertices to disconnect segments.\r\n                    this.e1 = this.e2 = -1;\r\n                }\r\n\r\n                // Start next segment\r\n                if (nextVertex) {\r\n                    this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, false, segment);\r\n                }\r\n\r\n            } else if (currentJoin === 'round') {\r\n\r\n                if (!startOfLine) {\r\n                    // Close previous segment with butt\r\n                    this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false, segment);\r\n\r\n                    // Add round cap or linejoin at end of segment\r\n                    this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, true, segment);\r\n\r\n                    // The segment is done. Unset vertices to disconnect segments.\r\n                    this.e1 = this.e2 = -1;\r\n                }\r\n\r\n\r\n                // Start next segment with a butt\r\n                if (nextVertex) {\r\n                    // Add round cap before first segment\r\n                    this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, true, segment);\r\n\r\n                    this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false, segment);\r\n                }\r\n            }\r\n\r\n            if (isSharpCorner && i < len - 1) {\r\n                const nextSegmentLength = currentVertex.dist(nextVertex);\r\n                if (nextSegmentLength > 2 * sharpCornerOffset) {\r\n                    const newCurrentVertex = currentVertex.add(nextVertex.sub(currentVertex)._mult(sharpCornerOffset / nextSegmentLength)._round());\r\n                    this.distance += newCurrentVertex.dist(currentVertex);\r\n                    this.addCurrentVertex(newCurrentVertex, this.distance, nextNormal.mult(1), 0, 0, false, segment);\r\n                    currentVertex = newCurrentVertex;\r\n                }\r\n            }\r\n\r\n            startOfLine = false;\r\n        }\r\n\r\n        // arrays.populatePaintArrays(featureProperties);\r\n    }\r\n\r\n    /**\r\n     * Add two vertices to the buffers.\r\n     *\r\n     * @param {Object} currentVertex the line vertex to add buffer vertices for\r\n     * @param {number} distance the distance from the beginning of the line to the vertex\r\n     * @param {number} endLeft extrude to shift the left vertex along the line\r\n     * @param {number} endRight extrude to shift the left vertex along the line\r\n     * @param {boolean} round whether this is a round cap\r\n     * @private\r\n     */\r\n    addCurrentVertex(currentVertex, distance, normal, endLeft, endRight, round, segment) {\r\n        const tx = round ? 1 : 0;\r\n        let extrude;\r\n        // const arrays = this.arrays;\r\n        // const layoutVertexArray = arrays.layoutVertexArray;\r\n        // const elementArray = arrays.elementArray;\r\n\r\n        extrude = normal.clone();\r\n        if (endLeft) extrude._sub(normal.perp()._mult(endLeft));\r\n        addLineVertex(this.layoutVertexArray, currentVertex, extrude, tx, 0, endLeft, distance);\r\n        this.e3 = segment.vertexLength++;\r\n        if (this.e1 >= 0 && this.e2 >= 0) {\r\n            this.indexArray.emplaceBack(this.e1, this.e2, this.e3);\r\n            segment.primitiveLength++;\r\n        }\r\n        this.e1 = this.e2;\r\n        this.e2 = this.e3;\r\n\r\n        extrude = normal.mult(-1);\r\n        if (endRight) extrude._sub(normal.perp()._mult(endRight));\r\n        addLineVertex(this.layoutVertexArray, currentVertex, extrude, tx, 1, -endRight, distance);\r\n        this.e3 = segment.vertexLength++;\r\n        if (this.e1 >= 0 && this.e2 >= 0) {\r\n            this.indexArray.emplaceBack(this.e1, this.e2, this.e3);\r\n            segment.primitiveLength++;\r\n        }\r\n        this.e1 = this.e2;\r\n        this.e2 = this.e3;\r\n\r\n        // There is a maximum \"distance along the line\" that we can store in the buffers.\r\n        // When we get close to the distance, reset it to zero and add the vertex again with\r\n        // a distance of zero. The max distance is determined by the number of bits we allocate\r\n        // to `linesofar`.\r\n        if (distance > MAX_LINE_DISTANCE / 2) {\r\n            this.distance = 0;\r\n            this.addCurrentVertex(currentVertex, this.distance, normal, endLeft, endRight, round, segment);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a single new vertex and a triangle using two previous vertices.\r\n     * This adds a pie slice triangle near a join to simulate round joins\r\n     *\r\n     * @param {Object} currentVertex the line vertex to add buffer vertices for\r\n     * @param {number} distance the distance from the beggining of the line to the vertex\r\n     * @param {Object} extrude the offset of the new vertex from the currentVertex\r\n     * @param {boolean} whether the line is turning left or right at this angle\r\n     * @private\r\n     */\r\n    addPieSliceVertex(currentVertex, distance, extrude, lineTurnsLeft, segment) {\r\n        const ty = lineTurnsLeft ? 1 : 0;\r\n        extrude = extrude.mult(lineTurnsLeft ? -1 : 1);\r\n        // const arrays = this.arrays;\r\n        // const layoutVertexArray = arrays.layoutVertexArray;\r\n        // const elementArray = arrays.elementArray;\r\n\r\n        addLineVertex(this.layoutVertexArray, currentVertex, extrude, 0, ty, 0, distance);\r\n        this.e3 = segment.vertexLength++;\r\n        if (this.e1 >= 0 && this.e2 >= 0) {\r\n            this.indexArray.emplaceBack(this.e1, this.e2, this.e3);\r\n            segment.primitiveLength++;\r\n        }\r\n\r\n        if (lineTurnsLeft) {\r\n            this.e2 = this.e3;\r\n        } else {\r\n            this.e1 = this.e3;\r\n        }\r\n    }\r\n\r\n\r\n    serialize(transferables) {\r\n        return {\r\n            type:this.type,\r\n            style:this.style,\r\n            tileSize: this.tileSize,\r\n            layoutVertexArray: this.layoutVertexArray.serialize(transferables),\r\n            indexArray:  this.indexArray.serialize(transferables),\r\n            segments: this.segments\r\n        };\r\n    }\r\n\r\n\r\n    static createBuffer(bucket){\r\n        bucket.layoutVertexBuffer = new BufferUtil(bucket.layoutVertexArray,\r\n            FillLayoutArrayType.serialize(), BufferUtil.BufferType.VERTEX);\r\n        bucket.indexBuffer = new BufferUtil(bucket.indexArray,\r\n            IndexArrayType.serialize(), BufferUtil.BufferType.ELEMENT);\r\n    }\r\n}\r\n\r\nexport default LineBucket;\r\n","/*\r\n (c) 2017, Vladimir Agafonkin\r\n Simplify.js, a high-performance JS polyline simplification library\r\n mourner.github.io/simplify-js\r\n*/\r\n\r\n// to suit your point format, run search/replace for '.x' and '.y';\r\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\r\n\r\n// square distance between 2 points\r\n    function getSqDist(p1X,p1Y, p2X,p2Y) {\r\n\r\n        var dx = p1X - p2X,\r\n            dy = p1Y - p2Y;\r\n\r\n        return dx * dx + dy * dy;\r\n    }\r\n\r\n// square distance from a point to a segment\r\n    function getSqSegDist(pX,pY,p1X,p1Y,p2X,p2Y) {\r\n\r\n        var x = p1X,\r\n            y = p1Y,\r\n            dx = p2X - x,\r\n            dy = p2Y - y;\r\n\r\n        if (dx !== 0 || dy !== 0) {\r\n\r\n            var t = ((pX - x) * dx + (pY - y) * dy) / (dx * dx + dy * dy);\r\n\r\n            if (t > 1) {\r\n                x = p2X;\r\n                y = p2Y;\r\n\r\n            } else if (t > 0) {\r\n                x += dx * t;\r\n                y += dy * t;\r\n            }\r\n        }\r\n\r\n        dx = pX - x;\r\n        dy = pY - y;\r\n\r\n        return dx * dx + dy * dy;\r\n    }\r\n// rest of the code doesn't care about point format\r\n\r\n// basic distance-based simplification\r\n    function simplifyRadialDist(points, sqTolerance) {\r\n\r\n        var prevPointX = points[0];\r\n        var prevPointY = points[1];\r\n        var newPoints = [points[0],points[1]];\r\n        var pointX;\r\n        var pointY;\r\n        var len = points.length / 2;\r\n        for (var i = 1 ; i < len; i++) {\r\n            pointX = points[i * 2];\r\n            pointY = points[i * 2 + 1];\r\n\r\n            if (getSqDist(pointX,pointY, prevPointX,prevPointY) > sqTolerance) {\r\n                newPoints.push(pointX);\r\n                newPoints.push(pointY);\r\n                prevPointX = pointX;\r\n                prevPointY = pointY;\r\n            }\r\n        }\r\n\r\n        if (prevPointX !== pointX && prevPointY !== pointY) {\r\n            newPoints.push(pointX);\r\n            newPoints.push(pointY);\r\n\r\n        }\r\n\r\n        return newPoints;\r\n    }\r\n\r\n    function simplifyDPStep(points, first, last, sqTolerance, simplified) {\r\n        var maxSqDist = sqTolerance,\r\n            index;\r\n\r\n        for (var i = first + 1; i < last; i++) {\r\n            var sqDist = getSqSegDist(points[i * 2] , points[i * 2 + 1] , points[first * 2] , points[first * 2 + 1] , points[last * 2] , points[last * 2 + 1]);\r\n            if (sqDist > maxSqDist) {\r\n                index = i;\r\n                maxSqDist = sqDist;\r\n            }\r\n        }\r\n\r\n        if (maxSqDist > sqTolerance) {\r\n            if (index - first > 1) {\r\n                simplifyDPStep(points, first, index, sqTolerance, simplified);\r\n            }\r\n\r\n            simplified.push(points[index * 2]);\r\n            simplified.push(points[index * 2 + 1]);\r\n\r\n            if (last - index > 1) {\r\n                simplifyDPStep(points, index, last, sqTolerance, simplified);\r\n            }\r\n        }\r\n    }\r\n\r\n// simplification using Ramer-Douglas-Peucker algorithm\r\n    function simplifyDouglasPeucker(points, sqTolerance) {\r\n        var last = points.length / 2 - 1;\r\n\r\n        var simplified = [points[0],points[1]];\r\n\r\n        simplifyDPStep(points, 0, last, sqTolerance , simplified);\r\n        simplified.push(points[last * 2] , points[last * 2 + 1]);\r\n\r\n        return simplified;\r\n    }\r\n\r\n// both algorithms combined for awesome performance\r\n    function simplify(points, tolerance, highestQuality) {\r\n\r\n        if (points.length <= 4) return points;\r\n\r\n        var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\r\n\r\n        points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\r\n        points = simplifyDouglasPeucker(points, sqTolerance);\r\n\r\n        return points;\r\n    }\r\n\r\nexport default simplify;","\r\nfunction Point(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n}\r\n\r\nPoint.prototype = {\r\n    clone: function() { return new Point(this.x, this.y); },\r\n\r\n    add:     function(p) { return this.clone()._add(p);     },\r\n    sub:     function(p) { return this.clone()._sub(p);     },\r\n    mult:    function(k) { return this.clone()._mult(k);    },\r\n    div:     function(k) { return this.clone()._div(k);     },\r\n    rotate:  function(a) { return this.clone()._rotate(a);  },\r\n    matMult: function(m) { return this.clone()._matMult(m); },\r\n    unit:    function() { return this.clone()._unit(); },\r\n    perp:    function() { return this.clone()._perp(); },\r\n    round:   function() { return this.clone()._round(); },\r\n\r\n    mag: function() {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    },\r\n\r\n    equals: function(p) {\r\n        return this.x === p.x &&\r\n            this.y === p.y;\r\n    },\r\n\r\n    dist: function(p) {\r\n        return Math.sqrt(this.distSqr(p));\r\n    },\r\n\r\n    distSqr: function(p) {\r\n        var dx = p.x - this.x,\r\n            dy = p.y - this.y;\r\n        return dx * dx + dy * dy;\r\n    },\r\n\r\n    angle: function() {\r\n        return Math.atan2(this.y, this.x);\r\n    },\r\n\r\n    angleTo: function(b) {\r\n        return Math.atan2(this.y - b.y, this.x - b.x);\r\n    },\r\n\r\n    angleWith: function(b) {\r\n        return this.angleWithSep(b.x, b.y);\r\n    },\r\n\r\n    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.\r\n    angleWithSep: function(x, y) {\r\n        return Math.atan2(\r\n            this.x * y - this.y * x,\r\n            this.x * x + this.y * y);\r\n    },\r\n\r\n    _matMult: function(m) {\r\n        var x = m[0] * this.x + m[1] * this.y,\r\n            y = m[2] * this.x + m[3] * this.y;\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    },\r\n\r\n    _add: function(p) {\r\n        this.x += p.x;\r\n        this.y += p.y;\r\n        return this;\r\n    },\r\n\r\n    _sub: function(p) {\r\n        this.x -= p.x;\r\n        this.y -= p.y;\r\n        return this;\r\n    },\r\n\r\n    _mult: function(k) {\r\n        this.x *= k;\r\n        this.y *= k;\r\n        return this;\r\n    },\r\n\r\n    _div: function(k) {\r\n        this.x /= k;\r\n        this.y /= k;\r\n        return this;\r\n    },\r\n\r\n    _unit: function() {\r\n        this._div(this.mag());\r\n        return this;\r\n    },\r\n\r\n    _perp: function() {\r\n        var y = this.y;\r\n        this.y = this.x;\r\n        this.x = -y;\r\n        return this;\r\n    },\r\n\r\n    _rotate: function(angle) {\r\n        var cos = Math.cos(angle),\r\n            sin = Math.sin(angle),\r\n            x = cos * this.x - sin * this.y,\r\n            y = sin * this.x + cos * this.y;\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    },\r\n\r\n    _round: function() {\r\n        this.x = Math.round(this.x);\r\n        this.y = Math.round(this.y);\r\n        return this;\r\n    }\r\n};\r\n\r\n// constructs Point from an array if necessary\r\nPoint.convert = function (a) {\r\n    if (a instanceof Point) {\r\n        return a;\r\n    }\r\n    if (Array.isArray(a)) {\r\n        return new Point(a[0], a[1]);\r\n    }\r\n    return a;\r\n};\r\nexport default Point;"],"names":["layoutAttributes","FillLayoutArrayType","IndexArrayType","Bucket","SegmentVector","Tess2","BufferUtil"],"mappings":"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AAW;IAC3C,oBAAoB,aAAa,GAAG,OAAO,CAAC,CAAC,CAAC;IAC9C,oBAAoB,aAAa,GAAG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;IAClD,oBAAoB,aAAa,GAAG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACpD,aAAa;AACb;IACA,YAAY,eAAe,CAAC,YAAY,IAAI,WAAW,CAAC;IACxD,YAAY,eAAe,CAAC,eAAe,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;AAClE;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;AACA;IACA;IACA,SAAS;AACT;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,KAAK;AACL;IACA,IAAI,SAAS,CAAC,aAAa,EAAE;IAC7B,QAAQ,OAAO;IACf,YAAY,IAAI,CAAC,IAAI,CAAC,IAAI;IAC1B,YAAY,KAAK,CAAC,IAAI,CAAC,KAAK;IAC5B,YAAY,QAAQ,EAAE,IAAI,CAAC,QAAQ;IACnC,YAAY,iBAAiB,EAAE,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,aAAa,CAAC;IAC9E,YAAY,kBAAkB,EAAE,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC,aAAa,CAAC;IAChF,YAAY,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,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"}
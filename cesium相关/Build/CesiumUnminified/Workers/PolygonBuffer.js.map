{"version":3,"file":"PolygonBuffer.js","sources":["../../../Source/WorkersES6/PolygonBuffer.js"],"sourcesContent":["// @flow\r\n// DEMData is a data structure for decoding, backfilling, and storing elevation data for processing in the hillshade shaders\r\n// data can be populated either from a pngraw image tile or from serliazed data sent back from a worker. When data is initially\r\n// loaded from a image tile, we decode the pixel values using the appropriate decoding formula, but we store the\r\n// elevation data as an Int32 value. we add 65536 (2^16) to eliminate negative values and enable the use of\r\n// integer overflow when creating the texture used in the hillshadePrepare step.\r\nimport turf from './turf.min';\r\nimport Cartesian3 from '../Core/Cartesian3.js';\r\n// DEMData also handles the backfilling of data from a tile's neighboring tiles. This is necessary because we use a pixel's 8\r\n// surrounding pixel values to compute the slope at that pixel, and we cannot accurately calculate the slope at pixels on a\r\n// tile's edge without backfilling from neighboring tiles.\r\nclass PolygonBuffer {\r\n    static buffer(featuremap,distance){\r\n        for(let key in featuremap){\r\n            let features = featuremap[key];\r\n            features.map((item) => {\r\n                for(let i =0;i<item.geometrys.length;i++){\r\n                    if (item.geometrys[i].length < 8) {//少于8个坐标点直接返回直接返回\r\n                        continue;\r\n                    }\r\n                    let convertedPolygon = PolygonBuffer.convertGeometory(item.geometrys[i])\r\n                    let tmpGeo = turf.polygon(convertedPolygon)//暂不考虑多地块要素\r\n                    let bufferedGeo = turf.buffer(tmpGeo, distance, { units: 'kilometers' });\r\n                    item.geometrys[i] = bufferedGeo.geometry.coordinates[0].flat();\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    static convertGeometory(dots){\r\n        if (!(dots[0] == dots[dots.length - 2] && dots[1] == dots[dots.length - 1])) {\r\n            //如果收尾不相接则接起来\r\n            dots.push(dots[0], dots[1])\r\n        }\r\n        let newdots = []\r\n        for (let i = 0; i < dots.length; i = i + 2) {\r\n            const element = dots[i];\r\n            newdots.push([dots[i], dots[i + 1]])\r\n        }\r\n        return [newdots];\r\n    }\r\n\r\n}\r\nexport default PolygonBuffer;\r\n\r\n"],"names":["turf"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;IAAA;IAQA;IACA;IACA;IACA,MAAM,aAAa,CAAC;IACpB,IAAI,OAAO,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC;IACtC,QAAQ,IAAI,IAAI,GAAG,IAAI,UAAU,CAAC;IAClC,YAAY,IAAI,QAAQ,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;IAC3C,YAAY,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK;IACnC,gBAAgB,IAAI,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC;IACzD,oBAAoB,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;IACtD,wBAAwB,SAAS;IACjC,qBAAqB;IACrB,oBAAoB,IAAI,gBAAgB,GAAG,aAAa,CAAC,gBAAgB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAC;IAC5F,oBAAoB,IAAI,MAAM,GAAGA,QAAI,CAAC,OAAO,CAAC,gBAAgB,EAAC;IAC/D,oBAAoB,IAAI,WAAW,GAAGA,QAAI,CAAC,MAAM,CAAC,MAAM,EAAE,QAAQ,EAAE,EAAE,KAAK,EAAE,YAAY,EAAE,CAAC,CAAC;IAC7F,oBAAoB,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;IACnF,iBAAiB;IACjB,aAAa,EAAC;IACd,SAAS;IACT,KAAK;AACL;IACA,IAAI,OAAO,gBAAgB,CAAC,IAAI,CAAC;IACjC,QAAQ,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;IACrF;IACA,YAAY,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,EAAC;IACvC,SAAS;IACT,QAAQ,IAAI,OAAO,GAAG,GAAE;IACxB,QAAQ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;IACpD,YAA4B,IAAI,CAAC,CAAC,EAAE;IACpC,YAAY,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAC;IAChD,SAAS;IACT,QAAQ,OAAO,CAAC,OAAO,CAAC,CAAC;IACzB,KAAK;AACL;IACA;;;;;;;;"}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"> <!-- Use Chrome Frame in IE -->
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="A sample Vector dataset on terrain rendered with 3D Tiles.">
    <meta name="cesium-sandcastle-labels" content="Showcases, 3D Tiles">
    <title>水流测试(加入雨水)</title>
    <link rel="stylesheet" href="../Build/bootstrap.css">
    <script type="text/javascript" src="../Build/CesiumUnminified/Cesium.js"></script>
    <script type="text/javascript" src="../Build/CustomCesiumSDK.js"></script>
    <script type="text/javascript" src="./config.js"></script>
    <script type="text/javascript" src="../Build/jquery-3.1.1.min.js"></script>
</head>
<style>
    html,
    body,
    #cesiumContainer {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
    }

    .cesium-viewer,
    .cesium-viewer-cesiumWidgetContainer,
    .cesium-widget {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
    }

    canvas {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
    }
</style>
<span style="position: absolute;top:10px;left:10px;">
    <button class="btn btn-primary" onclick="flood()">淹没分析</button>
</span>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay">
    <h1>Loading...</h1>
</div>
<div id="toolbar"></div>
<script id="cesium_sandcastle_script">
    var viewer;
    var waterPrimitive;
    // var timeClock=0.1;
    
    function startup(Cesium) {
        createMap();
    }
    // function TimeClock() {
    //     console.log(Cesium.ClockStep.TICK_DEPENDENT);
    //     timeClock+=1;
    //     requestAnimationFrame(TimeClock) 
    // }
    function flood() {
        waterPrimitive.show = true;
        var startHeight = 151;
        var targetHeight = 500;
        var waterHeight = startHeight;
        var timer = setInterval(() => {
            if (waterHeight < targetHeight) {
                waterHeight += 5;
                if (waterHeight > targetHeight) {
                    waterHeight = targetHeight
                }
                updateHeight(waterPrimitive, waterHeight / startHeight, [119.66760572310903, 28.286631413472247]);
            }
        }, 100);
    }



    function updateHeight(waterPrimitive, scale, center) {
        var cc = Cesium.Cartesian3.fromDegrees(center[0], center[1], 0);
        let m = Cesium.Transforms.eastNorthUpToFixedFrame(cc);
        let inverse = Cesium.Matrix4.inverse(m, new Cesium.Matrix4);

        let mScale = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(1.0, 1.0, scale));
        let tt = Cesium.Matrix4.multiply(mScale, inverse, new Cesium.Matrix4);
        
        waterPrimitive.modelMatrix = Cesium.Matrix4.multiply(m, tt, new Cesium.Matrix4);
    }

    function createMap() {
        let cesiumTerrainProvider = new Cesium.CesiumTerrainProvider({
            url:'http://data.mars3d.cn/terrain'

        });
        viewer = new Cesium.Viewer('cesiumContainer', {
             selectionIndicator: false,
            terrainProvider: cesiumTerrainProvider,
            animation: false,  //是否显示动画控件
            baseLayerPicker: true, //是否显示图层选择控件
            geocoder: false, //是否显示地名查找控件
            timeline: true, //是否显示时间线控件
            sceneModePicker: true, //是否显示投影方式控件
            navigationHelpButton: false, //是否显示帮助信息控件
            infoBox: false,  //是否显示点击要素之后显示的信息
            imageryProvider: false,
            vrButton: true,
            useBrowserRecommendedResolution: false,
            fullscreenButton: true
        });
        
        viewer.scene.primitives.destroyPrimitives = false;
        viewer.scene.globe.preloadAncestors = true;
        viewer.scene.globe.depthTestAgainstTerrain = true;
        var imageryLayers = viewer.imageryLayers;
        var scene = viewer.scene;
        //天地图影像图层
        var tiandituImageLayer = new Cesium.ImageryLayer(new Cesium.WebMapTileServiceImageryProvider({
            url: baseMapUrl,
            layer: "",
            style: "",
            format: "",
            tileMatrixSetID: "",
            subdomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"],
            tilingScheme: new Cesium.GeographicTilingScheme(),
            tileMatrixLabels: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19"],
            maximumLevel: 18,
        }));
        viewer.imageryLayers.add(tiandituImageLayer);
        // var collection=viewer.scene.postProcessStages;
        // var rain=Cesium.PostProcessStageLibrary.createRainStage();
        // collection.add(rain);


   const Snow =`uniform sampler2D colorTexture; //输入的场景渲染照片
    varying vec2 v_textureCoordinates;
    uniform float snow_density;
    uniform float snow_size;
    uniform float snow_fall_speed;

    float snow(vec2 uv,float scale)
    {
       
        float fallsize =clamp(ceil(snow_size*4.0),1.,4.);
     //   float fallspeed =clamp(snow_fall_speed*100.,10.,100.);
        float time = czm_frameNumber / 400.0*clamp(snow_fall_speed*10.,2.0,10.0);
        float w=smoothstep(1.,0.,-uv.y*(scale/10.));if(w<.1)return 0.;
        //运动轨迹控制
        uv+=time/scale;
        uv.y+=time*2./scale;
        uv.x+=sin(uv.y+time*.5)/scale;
        uv*=scale;
        vec2 s=floor(uv),f=fract(uv),p;float k=9.,d;
        p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p*clamp((1.5-fallsize*0.5),0.3,1.4));k=min(d,k);
        k=smoothstep(0.,k,sin(f.x+f.y)*0.01);
        return k*w;
    }
    
    void main(void){
        float density =clamp(ceil(snow_density*4.0),1.,4.);
        vec2 resolution = czm_viewport.zw;
        vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y)*vec2(clamp(0.1*density,0.2,0.8));
        vec3 finalColor=vec3(0);
        //float c=smoothstep(1.,0.3,clamp(uv.y*.3+.8,0.,.75));
        float c = clamp(0.1*density,0.1,1.0);
        // c+=snow(uv,30.)*.0;
        // c+=snow(uv,20.)*.0;
        // c+=snow(uv,15.)*.0;
        c+=snow(uv,12.*clamp(2.*density,1.2,1.8));
        c+=snow(uv,10.*clamp(2.*density,1.2,1.8));
        c+=snow(uv,8.*clamp(2.*density,1.2,1.8));
        c+=snow(uv,6.*clamp(2.*density,1.2,1.8));
        finalColor=(vec3(c)); //屏幕上雪的颜色
        gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor,1), 0.5);  //将雪和三维场景融合
    
    }`;
      const Rain = `
            uniform sampler2D colorTexture;//输入的场景渲染照片
            varying vec2 v_textureCoordinates;
            uniform float rain_density;
            uniform float rain_size;
            uniform float rain_fall_speed;
            float hash(float x){
                return fract(sin(x*133.3)*13.13);
            }
            void main(void){
                
                float r_speed =clamp(rain_fall_speed*5.0,0.8,5.);
                float r_size=clamp(ceil(rain_size*3.0)+0.5,1.,4.);
                float r_density=clamp(ceil(rain_density*4.0),1.,4.);
                float time = czm_frameNumber / 340.0*(clamp(r_speed,0.8,5.));
                vec2 resolution = czm_viewport.zw;
                vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y)*vec2(clamp(0.2*r_density,0.8,1.0));
                vec3 c=vec3(0.2);
                float a=.1;
                float si=sin(a),co=cos(a);
                uv*=mat2(co,-si,si,co);
                uv*=length(uv+vec2(0,2.9)*vec2(clamp((3.6-r_size*0.6),0.6,3.0)))*.3+1.;
                
                float v=1.-sin(hash(floor(uv.x*50.))*0.2);  
                float b=clamp(abs(sin(20.*time*v+uv.y*(5./(2.+v))))-.95,0.,1.)*4.0;
                c=c*v*b*clamp(r_size,1.,3.); 
                


                
                // float cycle = mod(czm_frameNumber, 300.0)/300.0>0.85?0.8:0.;   
                // vec3  Thunderlight = vec3(1.0)*1.5;
                // vec4 mixColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(Thunderlight,1.0),cycle);

                gl_FragColor=mix(texture2D(colorTexture, v_textureCoordinates),vec4(c*vec3(5.5),1.0),0.2);
                

            }`;
        viewer.scene.postProcessStages.add(
            new Cesium.PostProcessStage({
                fragmentShader: Rain,
                uniforms:{
                    rain_density:0.1,
                    rain_size:0.1,
                    rain_fall_speed:0.2
                }
            })
        );
        
        // viewer.scene.postProcessStages.add(
        //     new Cesium.PostProcessStage({
        //         fragmentShader: Snow,
        //         uniforms:{
        //             snow_density:0.5,//密度，值越大越密
        //             snow_size:0.1, //size越大，雪花越大
        //             snow_fall_speed:0.9//speed越快，下雪速度越快
        //         }
        //     })
        // );

        var waterMaterial = new Cesium.Material({
            fabric: {
                type: 'Water',
                uniforms: {
                    normalMap: '../image/water.jpg',
                    frequency: 1000.0,
                    animationSpeed: 0.1,
                    amplitude: 4.0
                }
            }
        });
        $.getJSON("../data/河面测试数据.json",function(result){
           let arr = []
           result.features.forEach(item=>{
             if(item&&item.geometry.coordinates){
              item.geometry.coordinates.forEach(obj=>{
                obj.forEach(data=>{
                  if(Number(data[0])>0&&Number(data[1])>0){
                    arr.push(Number(data[0]),Number(data[1]))
                  }
                })
             })
             }
           })
        //    alert(arr);
        });
        var polygonInstance = new Cesium.GeometryInstance({
            geometry: Cesium.PolygonGeometry.fromPositions({
                positions: Cesium.Cartesian3.fromDegreesArray([119.467444, 28.562214,
                    119.741000, 28.379154,
                    119.639312, 28.372095,
                    119.547387, 28.319825,
                    119.374338, 28.43156,
                    119.308763, 28.543007,
                    119.324388, 28.596889,
                    119.448939, 28.584777]),
                height: 125,
                extrudedHeight: 125,
                vertexFormat: Cesium.VertexFormat.ALL
            }),
            attributes: {
                color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('#ff0000').withAlpha(0.5))
            }
        });




    const czmFresnel=
    `
    const int max_iterations = 100;
    const float stop_threshold = 0.001;
    const float grad_step = 0.01;
    const float clip_far = 100.0;

    const vec3 worldForward = vec3( 0, 0, 1 );

    const float PI = 3.14159265359;
    const float DEGS2RADS = PI / 180.0;

    struct HitInfo
    {
        float distance; 
        int id;
    };

    
    float hash( vec2 p )
    {
        float h = dot(p,vec2(127.1,311.7));
        
        return -1.0 + 2.0*fract(sin(h)*43758.5453123);
    }

    //梯度噪声(一般应用具有连续性的纹理)
    float noise( in vec2 p )
    {
        vec2 i = floor( p );//网格索引
        vec2 f = fract( p );//片元在网格中的位置
        
        vec2 u = f*f*(3.0-2.0*f);

        return mix( mix( hash( i + vec2(0.0,0.0) ), 
                        hash( i + vec2(1.0,0.0) ), u.x),
                    mix( hash( i + vec2(0.0,1.0) ), 
                        hash( i + vec2(1.0,1.0) ), u.x), u.y);
    }
    //噪声  分形布朗运动FBM
    float texNoise1( in vec3 x, float lod_bias )
    {   
        vec3 p = floor( x );
        vec3 f = fract( x );
        f = f * f * ( 3.0 - 2.0 * f );
        vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
        vec2 rg = texture2D(WaveImage, fract(uv*(1./256.0))).yx;
        return mix( rg.x, rg.y, f.z );

    }
    vec4 BlendUnder(vec4 accum,vec4 col)
    {
        col = clamp( col, vec4( 0 ), vec4( 1 ) );   
        accum += vec4( col.rgb * col.a, col.a ) * ( 1.0 - accum.a );   
        return accum;
    }
    float sdPlane( vec3 p, vec4 n )
    {
       return dot( p, n.xyz ) + n.w;
    }
    HitInfo dist_field( vec3 pos ) 
    {
        float dPlane = sdPlane( pos, vec4( 0, 1, 0, 1 ) );
        return HitInfo( dPlane, 0 );  
    }
    vec3 gradient( vec3 pos ) 
    {
        const vec3 dx = vec3( grad_step, 0.0, 0.0 );
        const vec3 dy = vec3( 0.0, grad_step, 0.0 );
        const vec3 dz = vec3( 0.0, 0.0, grad_step );
        return normalize(   vec3(   dist_field( pos + dx ).distance - dist_field( pos - dx ).distance,
                                    dist_field( pos + dy ).distance - dist_field( pos - dy ).distance,
                                    dist_field( pos + dz ).distance - dist_field( pos - dz ).distance ) );
    }
    HitInfo rayMarch( vec3 origin, vec3 dir, float farClip )
    {
        float rayDistance = 0.0;
        for( int i = 0; i < max_iterations; i++ ) 
        {
            HitInfo hit = dist_field( origin + dir * rayDistance );
            float d = hit.distance;
            if ( d <= stop_threshold )
                return HitInfo( rayDistance, hit.id );
    
            rayDistance += d;
        }
        
        return HitInfo( rayDistance, 0 ); // hack: default material is zero?
    }

    float softShadowRayMarch( vec3 origin, vec3 dir ) 
    {
        float rayDistance = 0.0;
        float penumbra = 1.0;
        for( int i = 0; i < max_iterations; i++ ) 
        {
            float d = dist_field( origin + dir * rayDistance ).distance;
            if ( d <= stop_threshold )
                return 0.0;
            penumbra = min( penumbra, 15.0 * d / rayDistance );
            rayDistance += d;
        }
        return penumbra;
    }

    vec4 rotYZ( vec4 v, float thetaDegs )
    {
        mat4 m = mat4( 1 );
        float thetaRads = DEGS2RADS * thetaDegs;
        m[ 1 ].yz = vec2( cos( thetaRads ), -sin( thetaRads ) );
        m[ 2 ].yz = vec2( sin( thetaRads ), cos( thetaRads ) );
        return m * v;
    }

    float groundTex( vec3 point, vec2 scale )
    {
        vec2 uv = point.xz * scale;
        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );
        float f  = 0.5000*noise( uv ); uv = m*uv;
        f += 0.2500*noise( uv ); uv = m*uv;
        f += 0.1250*noise( uv ); uv = m*uv;
        f += 0.0625*noise( uv ); uv = m*uv;
        f = 0.5 + 0.5*f;

        f *= smoothstep( 0.0, 0.005, abs(point.x-0.6) );
        return f;
    }
    






    czm_material czm_getMaterial(czm_materialInput materialInput)
    { 
        czm_material material = czm_getDefaultMaterial(materialInput); 
        vec4 accum = vec4(0., 69., 129., 0.) / 255.;
        
        vec3 uvw =  materialInput.positionToEyeEC;
        uvw *= 0.05;//控制雨滴的大小
        uvw.y += czm_frameNumber * 0.6;//雨滴的速度
        
        float dens = texNoise1(uvw, 0.0 );

        dens = pow( dens, 5. );
        dens=sin(dens);
        dens *= 0.4;
        accum = BlendUnder( accum, vec4( 1, 1, 1, dens ));



        // vec3 col = vec3( 0 );
        // vec3 light = vec3( 1.0);
        // float f = groundTex(materialInput.positionToEyeEC, vec2( 0.725, 0.125 ) );
        // light *= f;
        // // //加上闪电
        // // float ThundArg=mod( czm_frameNumber, 5.0 ) > 4.0 ? 0.2 : 0.;
        // // col = light + vec3(0.9451, 0.9255, 0.9255)*ThundArg;
        // col=light;
        // col = BlendUnder( accum, vec4( col, 1. ) ).rgb;



           
        material.diffuse=vec3(dens);    
        material.alpha=0.5;
        return material;
    }
    `;




        const mWater = new Cesium.Material({
        fabric: {
            uniforms: {
                WaveImage: "../image/iChannel5.png",
                bottomImage: "../image/shazi.jpeg",
            },
            source: czmFresnel
        }
        });

        waterPrimitive = new Cesium.Primitive({
            show: false,
            geometryInstances: [polygonInstance],
            undisplayable: true,
            appearance: new Cesium.EllipsoidSurfaceAppearance({
                material:mWater
            })
        });



        viewer.scene.primitives.add(waterPrimitive);

       viewer.clock.currentTime = Cesium.JulianDate.addHours(Cesium.JulianDate.now(new Date()),10, new Cesium.JulianDate());
        viewer.scene.postProcessStages._fxaa.enabled = true;    
        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(119.1620733283383, 28.65841206230267, 9042.75883),//设置位置
            orientation: {  
                heading: Cesium.Math.toRadians(123.69117),
                pitch: Cesium.Math.toRadians(-16.37963),
            }
        });

    }

    if (typeof Cesium !== 'undefined') {
        // TimeClock()
        startup(Cesium);
    }
</script>
</body>

</html>
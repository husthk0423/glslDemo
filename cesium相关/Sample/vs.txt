#version 300 es
#define WEBGL_2
#define HAS_TEXCOORD_0
#define USE_DEQUANTIZATION
#define unifromZ  13.168162035794712
#define OUTPUT_DECLARATION

#define OES_texture_float_linear

#define OES_texture_float

uniform mat3 czm_normal;
uniform mat4 czm_modelView;
uniform mat3 czm_normal3D;
uniform mat4 czm_modelView3D;












struct czm_modelVertexOutput {
  vec3 positionMC;
  float pointSize;
};

uniform mat4 czm_model;
uniform mat4 czm_projection;


#line 0

#line 0
in vec3 a_quantized_positionMC;
in vec2 a_quantized_texCoord_0;
uniform vec3 model_quantizedVolumeOffset_positionMC;
uniform vec3 model_quantizedVolumeStepSize_positionMC;
uniform vec2 model_quantizedVolumeOffset_texCoord_0;
uniform vec2 model_quantizedVolumeStepSize_texCoord_0;
out vec3 v_positionWC;
out vec3 v_positionEC;
out vec3 v_positionMC;
out vec2 v_texCoord_0;
struct ProcessedAttributes
{
    vec3 positionMC;
    vec2 texCoord_0;
};
struct SelectedFeature
{
    float _empty;
};
struct FeatureIds
{
    float _empty;
};
struct Metadata
{
    float _empty;
};
struct MetadataClass
{
    float _empty;
};
struct MetadataStatistics
{
    float _empty;
};
void initializeAttributes(out ProcessedAttributes attributes)
{
}
void setDynamicVaryings(inout ProcessedAttributes attributes)
{
    v_texCoord_0 = attributes.texCoord_0;
}
void dequantizationStage(inout ProcessedAttributes attributes)
{
    attributes.positionMC = model_quantizedVolumeOffset_positionMC + a_quantized_positionMC * model_quantizedVolumeStepSize_positionMC;
    attributes.texCoord_0 = model_quantizedVolumeOffset_texCoord_0 + a_quantized_texCoord_0 * model_quantizedVolumeStepSize_texCoord_0;
}
void initializeFeatureIds(out FeatureIds featureIds, ProcessedAttributes attributes)
{
}
void initializeFeatureIdAliases(inout FeatureIds featureIds)
{
}
void setFeatureIdVaryings()
{
}
void initializeMetadata(out Metadata metadata, out MetadataClass metadataClass, out MetadataStatistics metadataStatistics, ProcessedAttributes attributes)
{
}
void setMetadataVaryings()
{
}
vec4 geometryStage(inout ProcessedAttributes attributes, mat4 modelView, mat3 normal) 
{
    vec4 computedPosition;

    
    vec3 positionMC = attributes.positionMC;
    v_positionMC = positionMC;
    v_positionEC = (modelView * vec4(positionMC, 1.0)).xyz;

    #if defined(USE_2D_POSITIONS) || defined(USE_2D_INSTANCING)
    vec3 position2D = attributes.position2D;
    vec3 positionEC = (u_modelView2D * vec4(position2D, 1.0)).xyz;
    computedPosition = czm_projection * vec4(positionEC, 1.0);
    #else
    computedPosition = czm_projection * vec4(v_positionEC, 1.0);
    #endif

    
    #if defined(COMPUTE_POSITION_WC_CUSTOM_SHADER) || defined(COMPUTE_POSITION_WC_STYLE)
    
    
    v_positionWC = (czm_model * vec4(positionMC, 1.0)).xyz;
    #endif

    #ifdef HAS_NORMALS
    v_normalEC = normalize(normal * attributes.normalMC);
    #endif

    #ifdef HAS_TANGENTS
    v_tangentEC = normalize(normal * attributes.tangentMC);    
    #endif

    #ifdef HAS_BITANGENTS
    v_bitangentEC = normalize(normal * attributes.bitangentMC);
    #endif

    
    
    setDynamicVaryings(attributes);
    
    return computedPosition;
}

void featureIdStage(out FeatureIds featureIds, ProcessedAttributes attributes) 
{
  initializeFeatureIds(featureIds, attributes);
  initializeFeatureIdAliases(featureIds);
  setFeatureIdVaryings();
}

void metadataStage(
  out Metadata metadata,
  out MetadataClass metadataClass,
  out MetadataStatistics metadataStatistics,
  ProcessedAttributes attributes
  )
{
  initializeMetadata(metadata, metadataClass, metadataStatistics, attributes);
  setMetadataVaryings();
}



czm_modelVertexOutput defaultVertexOutput(vec3 positionMC) {
    czm_modelVertexOutput vsOutput;
    vsOutput.positionMC = positionMC;
    vsOutput.pointSize = 1.0;
    return vsOutput;
}

void main() 
{
    
    
    ProcessedAttributes attributes;
    initializeAttributes(attributes);

    
    
    #ifdef USE_DEQUANTIZATION
    dequantizationStage(attributes);
    #endif

    #ifdef HAS_MORPH_TARGETS
    morphTargetsStage(attributes);
    #endif

    #ifdef HAS_SKINNING
    skinningStage(attributes);
    #endif

    #ifdef HAS_PRIMITIVE_OUTLINE
    primitiveOutlineStage();
    #endif

    
    
    
    #ifdef HAS_BITANGENTS
    attributes.bitangentMC = normalize(cross(attributes.normalMC, attributes.tangentMC) * attributes.tangentSignMC);
    #endif

    FeatureIds featureIds;
    featureIdStage(featureIds, attributes);

    #ifdef HAS_SELECTED_FEATURE_ID
    SelectedFeature feature;
    selectedFeatureIdStage(feature, featureIds);
    
    cpuStylingStage(attributes.positionMC, feature);
    #endif

    #if defined(USE_2D_POSITIONS) || defined(USE_2D_INSTANCING)
    
    
    
    
    mat4 modelView = czm_modelView3D;
    mat3 normal = czm_normal3D;
    #else
    
    
    mat4 modelView = czm_modelView;
    mat3 normal = czm_normal;
    #endif

    
    #ifdef HAS_INSTANCING

        
        
        
        
        #ifdef USE_LEGACY_INSTANCING
        mat4 instanceModelView;
        mat3 instanceModelViewInverseTranspose;
        
        legacyInstancingStage(attributes, instanceModelView, instanceModelViewInverseTranspose);

        modelView = instanceModelView;
        normal = instanceModelViewInverseTranspose;
        #else
        instancingStage(attributes);
        #endif

        #ifdef USE_PICKING
        v_pickColor = a_pickColor;
        #endif

    #endif

    Metadata metadata;
    MetadataClass metadataClass;
    MetadataStatistics metadataStatistics;
    metadataStage(metadata, metadataClass, metadataStatistics, attributes);

    #ifdef HAS_CUSTOM_VERTEX_SHADER
    czm_modelVertexOutput vsOutput = defaultVertexOutput(attributes.positionMC);
    customShaderStage(vsOutput, attributes, featureIds, metadata, metadataClass, metadataStatistics);
    #endif

    
    
    vec4 positionClip = geometryStage(attributes, modelView, normal);    

    #ifdef HAS_SILHOUETTE
    silhouetteStage(attributes, positionClip);
    #endif

    #ifdef HAS_POINT_CLOUD_SHOW_STYLE
    float show = pointCloudShowStylingStage(attributes, metadata);
    #else
    float show = 1.0;
    #endif

    #ifdef HAS_POINT_CLOUD_BACK_FACE_CULLING
    show *= pointCloudBackFaceCullingStage();
    #endif

    #ifdef HAS_POINT_CLOUD_COLOR_STYLE
    v_pointCloudColor = pointCloudColorStylingStage(attributes, metadata);
    #endif

    #ifdef PRIMITIVE_TYPE_POINTS
        #ifdef HAS_CUSTOM_VERTEX_SHADER
        gl_PointSize = vsOutput.pointSize;
        #elif defined(HAS_POINT_CLOUD_POINT_SIZE_STYLE) || defined(HAS_POINT_CLOUD_ATTENUATION)
        gl_PointSize = pointCloudPointSizeStylingStage(attributes, metadata);
        #else
        gl_PointSize = 1.0;
        #endif

        gl_PointSize *= show;
    #endif
    gl_Position = show * positionClip;



    
    
    
    
    
}


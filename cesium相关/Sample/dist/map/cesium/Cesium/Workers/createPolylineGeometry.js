define(["./when-c2e8ef35","./Check-c4f3a3fc","./Math-d30358ed","./Cartesian2-f9492f23","./BoundingSphere-dcb1d5fc","./Transforms-8b7e0d39","./RuntimeError-6122571f","./Rectangle-3285eeb3","./WebGLConstants-4ae0db90","./ComponentDatatype-5d3f6452","./GeometryAttribute-a5c051b9","./GeometryAttributes-57608efc","./IndexDatatype-e3260434","./IntersectionTests-525ff5aa","./Plane-dbdf17bf","./VertexFormat-ad523db1","./arrayRemoveDuplicates-a580a060","./ArcType-29cf2197","./EllipsoidRhumbLine-01c8204c","./EllipsoidGeodesic-c0017f17","./PolylinePipeline-b34abe5b","./Color-73b261ab"],(function(e,t,r,a,o,n,i,l,s,p,c,d,u,y,m,f,h,v,C,g,_,b){"use strict";var A=[];function E(e,t,r,a,o){var n,i=A;i.length=o;var l=r.red,s=r.green,p=r.blue,c=r.alpha,d=a.red,u=a.green,y=a.blue,m=a.alpha;if(b.Color.equals(r,a)){for(n=0;n<o;n++)i[n]=b.Color.clone(r);return i}var f=(d-l)/o,h=(u-s)/o,v=(y-p)/o,C=(m-c)/o;for(n=0;n<o;n++)i[n]=new b.Color(l+n*f,s+n*h,p+n*v,c+n*C);return i}function P(t){var o=(t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT)).positions,n=t.colors,i=e.defaultValue(t.width,1),l=e.defaultValue(t.colorsPerVertex,!1);this._positions=o,this._colors=n,this._width=i,this._colorsPerVertex=l,this._vertexFormat=f.VertexFormat.clone(e.defaultValue(t.vertexFormat,f.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(t.arcType,v.ArcType.GEODESIC),this._granularity=e.defaultValue(t.granularity,r.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=a.Ellipsoid.clone(e.defaultValue(t.ellipsoid,a.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";var s=1+o.length*a.Cartesian3.packedLength;s+=e.defined(n)?1+n.length*b.Color.packedLength:1,this.packedLength=s+a.Ellipsoid.packedLength+f.VertexFormat.packedLength+4}P.pack=function(t,r,o){var n;o=e.defaultValue(o,0);var i=t._positions,l=i.length;for(r[o++]=l,n=0;n<l;++n,o+=a.Cartesian3.packedLength)a.Cartesian3.pack(i[n],r,o);var s=t._colors;for(l=e.defined(s)?s.length:0,r[o++]=l,n=0;n<l;++n,o+=b.Color.packedLength)b.Color.pack(s[n],r,o);return a.Ellipsoid.pack(t._ellipsoid,r,o),o+=a.Ellipsoid.packedLength,f.VertexFormat.pack(t._vertexFormat,r,o),o+=f.VertexFormat.packedLength,r[o++]=t._width,r[o++]=t._colorsPerVertex?1:0,r[o++]=t._arcType,r[o]=t._granularity,r};var w=a.Ellipsoid.clone(a.Ellipsoid.UNIT_SPHERE),T=new f.VertexFormat,x={positions:void 0,colors:void 0,ellipsoid:w,vertexFormat:T,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};P.unpack=function(t,r,o){var n;r=e.defaultValue(r,0);var i=t[r++],l=new Array(i);for(n=0;n<i;++n,r+=a.Cartesian3.packedLength)l[n]=a.Cartesian3.unpack(t,r);var s=(i=t[r++])>0?new Array(i):void 0;for(n=0;n<i;++n,r+=b.Color.packedLength)s[n]=b.Color.unpack(t,r);var p=a.Ellipsoid.unpack(t,r,w);r+=a.Ellipsoid.packedLength;var c=f.VertexFormat.unpack(t,r,T);r+=f.VertexFormat.packedLength;var d=t[r++],u=1===t[r++],y=t[r++],m=t[r];return e.defined(o)?(o._positions=l,o._colors=s,o._ellipsoid=a.Ellipsoid.clone(p,o._ellipsoid),o._vertexFormat=f.VertexFormat.clone(c,o._vertexFormat),o._width=d,o._colorsPerVertex=u,o._arcType=y,o._granularity=m,o):(x.positions=l,x.colors=s,x.width=d,x.colorsPerVertex=u,x.arcType=y,x.granularity=m,new P(x))};var k=new a.Cartesian3,D=new a.Cartesian3,V=new a.Cartesian3,L=new a.Cartesian3;return P.createGeometry=function(t){var n,i,l,s=t._width,y=t._vertexFormat,m=t._colors,f=t._colorsPerVertex,C=t._arcType,g=t._granularity,P=t._ellipsoid,w=h.arrayRemoveDuplicates(t._positions,a.Cartesian3.equalsEpsilon),T=w.length;if(!(T<2||s<=0)){if(C===v.ArcType.GEODESIC||C===v.ArcType.RHUMB){var x,F;C===v.ArcType.GEODESIC?(x=r.CesiumMath.chordLength(g,P.maximumRadius),F=_.PolylinePipeline.numberOfPoints):(x=g,F=_.PolylinePipeline.numberOfPointsRhumbLine);var G=_.PolylinePipeline.extractHeights(w,P);if(e.defined(m)){var R=1;for(n=0;n<T-1;++n)R+=F(w[n],w[n+1],x);var O=new Array(R),S=0;for(n=0;n<T-1;++n){var B=w[n],I=w[n+1],U=m[n],N=F(B,I,x);if(f&&n<R){var M=E(0,0,U,m[n+1],N),H=M.length;for(i=0;i<H;++i)O[S++]=M[i]}else for(i=0;i<N;++i)O[S++]=b.Color.clone(U)}O[S]=b.Color.clone(m[m.length-1]),m=O,A.length=0}w=C===v.ArcType.GEODESIC?_.PolylinePipeline.generateCartesianArc({positions:w,minDistance:x,ellipsoid:P,height:G}):_.PolylinePipeline.generateCartesianRhumbArc({positions:w,granularity:x,ellipsoid:P,height:G})}var W,Y=4*(T=w.length)-4,q=new Float64Array(3*Y),z=new Float64Array(3*Y),J=new Float64Array(3*Y),j=new Float32Array(2*Y),K=y.st?new Float32Array(2*Y):void 0,Q=e.defined(m)?new Uint8Array(4*Y):void 0,X=0,Z=0,$=0,ee=0;for(i=0;i<T;++i){var te,re;0===i?(W=k,a.Cartesian3.subtract(w[0],w[1],W),a.Cartesian3.add(w[0],W,W)):W=w[i-1],a.Cartesian3.clone(W,V),a.Cartesian3.clone(w[i],D),i===T-1?(W=k,a.Cartesian3.subtract(w[T-1],w[T-2],W),a.Cartesian3.add(w[T-1],W,W)):W=w[i+1],a.Cartesian3.clone(W,L),e.defined(Q)&&(te=0===i||f?m[i]:m[i-1],i!==T-1&&(re=m[i]));var ae=i===T-1?2:4;for(l=0===i?2:0;l<ae;++l){a.Cartesian3.pack(D,q,X),a.Cartesian3.pack(V,z,X),a.Cartesian3.pack(L,J,X),X+=3;var oe=l-2<0?-1:1;if(j[Z++]=l%2*2-1,j[Z++]=oe*s,y.st&&(K[$++]=i/(T-1),K[$++]=Math.max(j[Z-2],0)),e.defined(Q)){var ne=l<2?te:re;Q[ee++]=b.Color.floatToByte(ne.red),Q[ee++]=b.Color.floatToByte(ne.green),Q[ee++]=b.Color.floatToByte(ne.blue),Q[ee++]=b.Color.floatToByte(ne.alpha)}}}var ie=new d.GeometryAttributes;ie.position=new c.GeometryAttribute({componentDatatype:p.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:q}),ie.prevPosition=new c.GeometryAttribute({componentDatatype:p.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:z}),ie.nextPosition=new c.GeometryAttribute({componentDatatype:p.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:J}),ie.expandAndWidth=new c.GeometryAttribute({componentDatatype:p.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:j}),y.st&&(ie.st=new c.GeometryAttribute({componentDatatype:p.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:K})),e.defined(Q)&&(ie.color=new c.GeometryAttribute({componentDatatype:p.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:Q,normalize:!0}));var le=u.IndexDatatype.createTypedArray(Y,6*T-6),se=0,pe=0,ce=T-1;for(i=0;i<ce;++i)le[pe++]=se,le[pe++]=se+2,le[pe++]=se+1,le[pe++]=se+1,le[pe++]=se+2,le[pe++]=se+3,se+=4;return new c.Geometry({attributes:ie,indices:le,primitiveType:c.PrimitiveType.TRIANGLES,boundingSphere:o.BoundingSphere.fromPoints(w),geometryType:c.GeometryType.POLYLINES})}},function(t,r){return e.defined(r)&&(t=P.unpack(t,r)),t._ellipsoid=a.Ellipsoid.clone(t._ellipsoid),P.createGeometry(t)}}));

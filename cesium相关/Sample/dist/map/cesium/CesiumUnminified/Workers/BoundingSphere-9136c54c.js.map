{"version":3,"file":"BoundingSphere-9136c54c.js","sources":["../../../../Source/Core/Intersect.js","../../../../Source/Core/Interval.js","../../../../Source/Core/BoundingSphere.js"],"sourcesContent":["/**\n * This enumerated type is used in determining where, relative to the frustum, an\n * object is located. The object can either be fully contained within the frustum (INSIDE),\n * partially inside the frustum and partially outside (INTERSECTING), or somewhere entirely\n * outside of the frustum's 6 planes (OUTSIDE).\n *\n * @enum {Number}\n */\nvar Intersect = {\n  /**\n   * Represents that an object is not contained within the frustum.\n   *\n   * @type {Number}\n   * @constant\n   */\n  OUTSIDE: -1,\n\n  /**\n   * Represents that an object intersects one of the frustum's planes.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INTERSECTING: 0,\n\n  /**\n   * Represents that an object is fully within the frustum.\n   *\n   * @type {Number}\n   * @constant\n   */\n  INSIDE: 1,\n};\nexport default Object.freeze(Intersect);\n","import defaultValue from \"./defaultValue.js\";\n\n/**\n * Represents the closed interval [start, stop].\n * @alias Interval\n * @constructor\n *\n * @param {Number} [start=0.0] The beginning of the interval.\n * @param {Number} [stop=0.0] The end of the interval.\n */\nfunction Interval(start, stop) {\n  /**\n   * The beginning of the interval.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.start = defaultValue(start, 0.0);\n  /**\n   * The end of the interval.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.stop = defaultValue(stop, 0.0);\n}\nexport default Interval;\n","import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport Intersect from \"./Intersect.js\";\nimport Interval from \"./Interval.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Rectangle from \"./Rectangle.js\";\n\n/**\n * A bounding sphere with a center and a radius.\n * @alias BoundingSphere\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n * @param {Number} [radius=0.0] The radius of the bounding sphere.\n *\n * @see AxisAlignedBoundingBox\n * @see BoundingRectangle\n * @see Packable\n */\nfunction BoundingSphere(center, radius) {\n  /**\n   * The center point of the sphere.\n   * @type {Cartesian3}\n   * @default {@link Cartesian3.ZERO}\n   */\n  this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\n\n  /**\n   * The radius of the sphere.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.radius = defaultValue(radius, 0.0);\n}\n\nvar fromPointsXMin = new Cartesian3();\nvar fromPointsYMin = new Cartesian3();\nvar fromPointsZMin = new Cartesian3();\nvar fromPointsXMax = new Cartesian3();\nvar fromPointsYMax = new Cartesian3();\nvar fromPointsZMax = new Cartesian3();\nvar fromPointsCurrentPos = new Cartesian3();\nvar fromPointsScratch = new Cartesian3();\nvar fromPointsRitterCenter = new Cartesian3();\nvar fromPointsMinBoxPt = new Cartesian3();\nvar fromPointsMaxBoxPt = new Cartesian3();\nvar fromPointsNaiveCenterScratch = new Cartesian3();\nvar volumeConstant = (4.0 / 3.0) * CesiumMath.PI;\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n *\n * @param {Cartesian3[]} [positions] An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://help.agi.com/AGIComponents/html/BlogBoundingSphere.htm|Bounding Sphere computation article}\n */\nBoundingSphere.fromPoints = function (positions, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  var currentPos = Cartesian3.clone(positions[0], fromPointsCurrentPos);\n\n  var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n  var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n  var numPositions = positions.length;\n  var i;\n  for (i = 1; i < numPositions; i++) {\n    Cartesian3.clone(positions[i], currentPos);\n\n    var x = currentPos.x;\n    var y = currentPos.y;\n    var z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  var xSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(xMax, xMin, fromPointsScratch)\n  );\n  var ySpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(yMax, yMin, fromPointsScratch)\n  );\n  var zSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(zMax, zMin, fromPointsScratch)\n  );\n\n  // Set the diameter endpoints to the largest span.\n  var diameter1 = xMin;\n  var diameter2 = xMax;\n  var maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  var ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  var radiusSquared = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch)\n  );\n  var ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  var minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  var maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  var naiveCenter = Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  var naiveRadius = 0;\n  for (i = 0; i < numPositions; i++) {\n    Cartesian3.clone(positions[i], currentPos);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    var r = Cartesian3.magnitude(\n      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch)\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    var oldCenterToPointSquared = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch)\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      var oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\nvar defaultProjection = new GeographicProjection();\nvar fromRectangle2DLowerLeft = new Cartesian3();\nvar fromRectangle2DUpperRight = new Cartesian3();\nvar fromRectangle2DSouthwest = new Cartographic();\nvar fromRectangle2DNortheast = new Cartographic();\n\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangle2D = function (rectangle, projection, result) {\n  return BoundingSphere.fromRectangleWithHeights2D(\n    rectangle,\n    projection,\n    0.0,\n    0.0,\n    result\n  );\n};\n\n/**\n * Computes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the\n * object's minimum and maximum heights over the rectangle.\n *\n * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n * @param {Number} [minimumHeight=0.0] The minimum height over the rectangle.\n * @param {Number} [maximumHeight=0.0] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangleWithHeights2D = function (\n  rectangle,\n  projection,\n  minimumHeight,\n  maximumHeight,\n  result\n) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(rectangle)) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  projection = defaultValue(projection, defaultProjection);\n\n  Rectangle.southwest(rectangle, fromRectangle2DSouthwest);\n  fromRectangle2DSouthwest.height = minimumHeight;\n  Rectangle.northeast(rectangle, fromRectangle2DNortheast);\n  fromRectangle2DNortheast.height = maximumHeight;\n\n  var lowerLeft = projection.project(\n    fromRectangle2DSouthwest,\n    fromRectangle2DLowerLeft\n  );\n  var upperRight = projection.project(\n    fromRectangle2DNortheast,\n    fromRectangle2DUpperRight\n  );\n\n  var width = upperRight.x - lowerLeft.x;\n  var height = upperRight.y - lowerLeft.y;\n  var elevation = upperRight.z - lowerLeft.z;\n\n  result.radius =\n    Math.sqrt(width * width + height * height + elevation * elevation) * 0.5;\n  var center = result.center;\n  center.x = lowerLeft.x + width * 0.5;\n  center.y = lowerLeft.y + height * 0.5;\n  center.z = lowerLeft.z + elevation * 0.5;\n  return result;\n};\n\nvar fromRectangle3DScratch = [];\n\n/**\n * Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points\n * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.\n *\n * @param {Rectangle} [rectangle] The valid rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.\n * @param {Number} [surfaceHeight=0.0] The height above the surface of the ellipsoid.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromRectangle3D = function (\n  rectangle,\n  ellipsoid,\n  surfaceHeight,\n  result\n) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  surfaceHeight = defaultValue(surfaceHeight, 0.0);\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(rectangle)) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  var positions = Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    surfaceHeight,\n    fromRectangle3DScratch\n  );\n  return BoundingSphere.fromPoints(positions, result);\n};\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are\n * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {Number[]} [positions] An array of points that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the\n *        origin of the coordinate system.  This is useful when the positions are to be used for\n *        relative-to-center (RTC) rendering.\n * @param {Number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may\n *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position\n *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index\n *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If\n *        the stride is 5, however, two array elements are skipped and the next position begins at array\n *        index 5.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @example\n * // Compute the bounding sphere from 3 positions, each specified relative to a center.\n * // In addition to the X, Y, and Z coordinates, the points array contains two additional\n * // elements per point which are ignored for the purpose of computing the bounding sphere.\n * var center = new Cesium.Cartesian3(1.0, 2.0, 3.0);\n * var points = [1.0, 2.0, 3.0, 0.1, 0.2,\n *               4.0, 5.0, 6.0, 0.1, 0.2,\n *               7.0, 8.0, 9.0, 0.1, 0.2];\n * var sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\nBoundingSphere.fromVertices = function (positions, center, stride, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(positions) || positions.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  center = defaultValue(center, Cartesian3.ZERO);\n\n  stride = defaultValue(stride, 3);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"stride\", stride, 3);\n  //>>includeEnd('debug');\n\n  var currentPos = fromPointsCurrentPos;\n  currentPos.x = positions[0] + center.x;\n  currentPos.y = positions[1] + center.y;\n  currentPos.z = positions[2] + center.z;\n\n  var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n  var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n  var numElements = positions.length;\n  var i;\n  for (i = 0; i < numElements; i += stride) {\n    var x = positions[i] + center.x;\n    var y = positions[i + 1] + center.y;\n    var z = positions[i + 2] + center.z;\n\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  var xSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(xMax, xMin, fromPointsScratch)\n  );\n  var ySpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(yMax, yMin, fromPointsScratch)\n  );\n  var zSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(zMax, zMin, fromPointsScratch)\n  );\n\n  // Set the diameter endpoints to the largest span.\n  var diameter1 = xMin;\n  var diameter2 = xMax;\n  var maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  var ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  var radiusSquared = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch)\n  );\n  var ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  var minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  var maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  var naiveCenter = Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  var naiveRadius = 0;\n  for (i = 0; i < numElements; i += stride) {\n    currentPos.x = positions[i] + center.x;\n    currentPos.y = positions[i + 1] + center.y;\n    currentPos.z = positions[i + 2] + center.z;\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    var r = Cartesian3.magnitude(\n      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch)\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    var oldCenterToPointSquared = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch)\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      var oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of EncodedCartesian3s, where the points are\n * stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two\n * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to\n * ensure a tight fit.\n *\n * @param {Number[]} [positionsHigh] An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {Number[]} [positionsLow] An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point\n *        is formed from three elements in the array in the order X, Y, Z.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n *\n * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n */\nBoundingSphere.fromEncodedCartesianVertices = function (\n  positionsHigh,\n  positionsLow,\n  result\n) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (\n    !defined(positionsHigh) ||\n    !defined(positionsLow) ||\n    positionsHigh.length !== positionsLow.length ||\n    positionsHigh.length === 0\n  ) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  var currentPos = fromPointsCurrentPos;\n  currentPos.x = positionsHigh[0] + positionsLow[0];\n  currentPos.y = positionsHigh[1] + positionsLow[1];\n  currentPos.z = positionsHigh[2] + positionsLow[2];\n\n  var xMin = Cartesian3.clone(currentPos, fromPointsXMin);\n  var yMin = Cartesian3.clone(currentPos, fromPointsYMin);\n  var zMin = Cartesian3.clone(currentPos, fromPointsZMin);\n\n  var xMax = Cartesian3.clone(currentPos, fromPointsXMax);\n  var yMax = Cartesian3.clone(currentPos, fromPointsYMax);\n  var zMax = Cartesian3.clone(currentPos, fromPointsZMax);\n\n  var numElements = positionsHigh.length;\n  var i;\n  for (i = 0; i < numElements; i += 3) {\n    var x = positionsHigh[i] + positionsLow[i];\n    var y = positionsHigh[i + 1] + positionsLow[i + 1];\n    var z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n    currentPos.x = x;\n    currentPos.y = y;\n    currentPos.z = z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      Cartesian3.clone(currentPos, xMin);\n    }\n\n    if (x > xMax.x) {\n      Cartesian3.clone(currentPos, xMax);\n    }\n\n    if (y < yMin.y) {\n      Cartesian3.clone(currentPos, yMin);\n    }\n\n    if (y > yMax.y) {\n      Cartesian3.clone(currentPos, yMax);\n    }\n\n    if (z < zMin.z) {\n      Cartesian3.clone(currentPos, zMin);\n    }\n\n    if (z > zMax.z) {\n      Cartesian3.clone(currentPos, zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  var xSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(xMax, xMin, fromPointsScratch)\n  );\n  var ySpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(yMax, yMin, fromPointsScratch)\n  );\n  var zSpan = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(zMax, zMin, fromPointsScratch)\n  );\n\n  // Set the diameter endpoints to the largest span.\n  var diameter1 = xMin;\n  var diameter2 = xMax;\n  var maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  var ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  var radiusSquared = Cartesian3.magnitudeSquared(\n    Cartesian3.subtract(diameter2, ritterCenter, fromPointsScratch)\n  );\n  var ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  var minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  var maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  var naiveCenter = Cartesian3.midpoint(\n    minBoxPt,\n    maxBoxPt,\n    fromPointsNaiveCenterScratch\n  );\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  var naiveRadius = 0;\n  for (i = 0; i < numElements; i += 3) {\n    currentPos.x = positionsHigh[i] + positionsLow[i];\n    currentPos.y = positionsHigh[i + 1] + positionsLow[i + 1];\n    currentPos.z = positionsHigh[i + 2] + positionsLow[i + 2];\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    var r = Cartesian3.magnitude(\n      Cartesian3.subtract(currentPos, naiveCenter, fromPointsScratch)\n    );\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    var oldCenterToPointSquared = Cartesian3.magnitudeSquared(\n      Cartesian3.subtract(currentPos, ritterCenter, fromPointsScratch)\n    );\n    if (oldCenterToPointSquared > radiusSquared) {\n      var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      var oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x =\n        (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) /\n        oldCenterToPoint;\n      ritterCenter.y =\n        (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) /\n        oldCenterToPoint;\n      ritterCenter.z =\n        (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) /\n        oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    Cartesian3.clone(ritterCenter, result.center);\n    result.radius = ritterRadius;\n  } else {\n    Cartesian3.clone(naiveCenter, result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n};\n\n/**\n * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n * tighly and fully encompases the box.\n *\n * @param {Cartesian3} [corner] The minimum height over the rectangle.\n * @param {Cartesian3} [oppositeCorner] The maximum height over the rectangle.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * // Create a bounding sphere around the unit cube\n * var sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));\n */\nBoundingSphere.fromCornerPoints = function (corner, oppositeCorner, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"corner\", corner);\n  Check.typeOf.object(\"oppositeCorner\", oppositeCorner);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  var center = Cartesian3.midpoint(corner, oppositeCorner, result.center);\n  result.radius = Cartesian3.distance(center, oppositeCorner);\n  return result;\n};\n\n/**\n * Creates a bounding sphere encompassing an ellipsoid.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid around which to create a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * var boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);\n */\nBoundingSphere.fromEllipsoid = function (ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"ellipsoid\", ellipsoid);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  Cartesian3.clone(Cartesian3.ZERO, result.center);\n  result.radius = ellipsoid.maximumRadius;\n  return result;\n};\n\nvar fromBoundingSpheresScratch = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.\n *\n * @param {BoundingSphere[]} [boundingSpheres] The array of bounding spheres.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromBoundingSpheres = function (boundingSpheres, result) {\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  if (!defined(boundingSpheres) || boundingSpheres.length === 0) {\n    result.center = Cartesian3.clone(Cartesian3.ZERO, result.center);\n    result.radius = 0.0;\n    return result;\n  }\n\n  var length = boundingSpheres.length;\n  if (length === 1) {\n    return BoundingSphere.clone(boundingSpheres[0], result);\n  }\n\n  if (length === 2) {\n    return BoundingSphere.union(boundingSpheres[0], boundingSpheres[1], result);\n  }\n\n  var positions = [];\n  var i;\n  for (i = 0; i < length; i++) {\n    positions.push(boundingSpheres[i].center);\n  }\n\n  result = BoundingSphere.fromPoints(positions, result);\n\n  var center = result.center;\n  var radius = result.radius;\n  for (i = 0; i < length; i++) {\n    var tmp = boundingSpheres[i];\n    radius = Math.max(\n      radius,\n      Cartesian3.distance(center, tmp.center, fromBoundingSpheresScratch) +\n        tmp.radius\n    );\n  }\n  result.radius = radius;\n\n  return result;\n};\n\nvar fromOrientedBoundingBoxScratchU = new Cartesian3();\nvar fromOrientedBoundingBoxScratchV = new Cartesian3();\nvar fromOrientedBoundingBoxScratchW = new Cartesian3();\n\n/**\n * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n *\n * @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.fromOrientedBoundingBox = function (\n  orientedBoundingBox,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"orientedBoundingBox\", orientedBoundingBox);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  var halfAxes = orientedBoundingBox.halfAxes;\n  var u = Matrix3.getColumn(halfAxes, 0, fromOrientedBoundingBoxScratchU);\n  var v = Matrix3.getColumn(halfAxes, 1, fromOrientedBoundingBoxScratchV);\n  var w = Matrix3.getColumn(halfAxes, 2, fromOrientedBoundingBoxScratchW);\n\n  Cartesian3.add(u, v, u);\n  Cartesian3.add(u, w, u);\n\n  result.center = Cartesian3.clone(orientedBoundingBox.center, result.center);\n  result.radius = Cartesian3.magnitude(u);\n\n  return result;\n};\n\n/**\n * Duplicates a BoundingSphere instance.\n *\n * @param {BoundingSphere} sphere The bounding sphere to duplicate.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)\n */\nBoundingSphere.clone = function (sphere, result) {\n  if (!defined(sphere)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new BoundingSphere(sphere.center, sphere.radius);\n  }\n\n  result.center = Cartesian3.clone(sphere.center, result.center);\n  result.radius = sphere.radius;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nBoundingSphere.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {BoundingSphere} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nBoundingSphere.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var center = value.center;\n  array[startingIndex++] = center.x;\n  array[startingIndex++] = center.y;\n  array[startingIndex++] = center.z;\n  array[startingIndex] = value.radius;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {BoundingSphere} [result] The object into which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n */\nBoundingSphere.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  var center = result.center;\n  center.x = array[startingIndex++];\n  center.y = array[startingIndex++];\n  center.z = array[startingIndex++];\n  result.radius = array[startingIndex];\n  return result;\n};\n\nvar unionScratch = new Cartesian3();\nvar unionScratchCenter = new Cartesian3();\n/**\n * Computes a bounding sphere that contains both the left and right bounding spheres.\n *\n * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.union = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  var leftCenter = left.center;\n  var leftRadius = left.radius;\n  var rightCenter = right.center;\n  var rightRadius = right.radius;\n\n  var toRightCenter = Cartesian3.subtract(\n    rightCenter,\n    leftCenter,\n    unionScratch\n  );\n  var centerSeparation = Cartesian3.magnitude(toRightCenter);\n\n  if (leftRadius >= centerSeparation + rightRadius) {\n    // Left sphere wins.\n    left.clone(result);\n    return result;\n  }\n\n  if (rightRadius >= centerSeparation + leftRadius) {\n    // Right sphere wins.\n    right.clone(result);\n    return result;\n  }\n\n  // There are two tangent points, one on far side of each sphere.\n  var halfDistanceBetweenTangentPoints =\n    (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n  // Compute the center point halfway between the two tangent points.\n  var center = Cartesian3.multiplyByScalar(\n    toRightCenter,\n    (-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation,\n    unionScratchCenter\n  );\n  Cartesian3.add(center, leftCenter, center);\n  Cartesian3.clone(center, result.center);\n  result.radius = halfDistanceBetweenTangentPoints;\n\n  return result;\n};\n\nvar expandScratch = new Cartesian3();\n/**\n * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.\n *\n * @param {BoundingSphere} sphere A sphere to expand.\n * @param {Cartesian3} point A point to enclose in a bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.expand = function (sphere, point, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"point\", point);\n  //>>includeEnd('debug');\n\n  result = BoundingSphere.clone(sphere, result);\n\n  var radius = Cartesian3.magnitude(\n    Cartesian3.subtract(point, result.center, expandScratch)\n  );\n  if (radius > result.radius) {\n    result.radius = radius;\n  }\n\n  return result;\n};\n\n/**\n * Determines which side of a plane a sphere is located.\n *\n * @param {BoundingSphere} sphere The bounding sphere to test.\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nBoundingSphere.intersectPlane = function (sphere, plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"plane\", plane);\n  //>>includeEnd('debug');\n\n  var center = sphere.center;\n  var radius = sphere.radius;\n  var normal = plane.normal;\n  var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\n\n  if (distanceToPlane < -radius) {\n    // The center point is negative side of the plane normal\n    return Intersect.OUTSIDE;\n  } else if (distanceToPlane < radius) {\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    return Intersect.INTERSECTING;\n  }\n  return Intersect.INSIDE;\n};\n\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.transform = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  result.center = Matrix4.multiplyByPoint(\n    transform,\n    sphere.center,\n    result.center\n  );\n  result.radius = Matrix4.getMaximumScale(transform) * sphere.radius;\n\n  return result;\n};\n\nvar distanceSquaredToScratch = new Cartesian3();\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {BoundingSphere} sphere The sphere.\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The distance squared from the bounding sphere to the point. Returns 0 if the point is inside the sphere.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);\n * });\n */\nBoundingSphere.distanceSquaredTo = function (sphere, cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  var diff = Cartesian3.subtract(\n    sphere.center,\n    cartesian,\n    distanceSquaredToScratch\n  );\n\n  var distance = Cartesian3.magnitude(diff) - sphere.radius;\n  if (distance <= 0.0) {\n    return 0.0;\n  }\n\n  return distance * distance;\n};\n\n/**\n * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale\n * The transformation matrix is not verified to have a uniform scale of 1.\n * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.\n *\n * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n *\n * @example\n * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\n * var boundingSphere = new Cesium.BoundingSphere();\n * var newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);\n */\nBoundingSphere.transformWithoutScale = function (sphere, transform, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"transform\", transform);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new BoundingSphere();\n  }\n\n  result.center = Matrix4.multiplyByPoint(\n    transform,\n    sphere.center,\n    result.center\n  );\n  result.radius = sphere.radius;\n\n  return result;\n};\n\nvar scratchCartesian3 = new Cartesian3();\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\nBoundingSphere.computePlaneDistances = function (\n  sphere,\n  position,\n  direction,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"position\", position);\n  Check.typeOf.object(\"direction\", direction);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Interval();\n  }\n\n  var toCenter = Cartesian3.subtract(\n    sphere.center,\n    position,\n    scratchCartesian3\n  );\n  var mag = Cartesian3.dot(direction, toCenter);\n\n  result.start = mag - sphere.radius;\n  result.stop = mag + sphere.radius;\n  return result;\n};\n\nvar projectTo2DNormalScratch = new Cartesian3();\nvar projectTo2DEastScratch = new Cartesian3();\nvar projectTo2DNorthScratch = new Cartesian3();\nvar projectTo2DWestScratch = new Cartesian3();\nvar projectTo2DSouthScratch = new Cartesian3();\nvar projectTo2DCartographicScratch = new Cartographic();\nvar projectTo2DPositionsScratch = new Array(8);\nfor (var n = 0; n < 8; ++n) {\n  projectTo2DPositionsScratch[n] = new Cartesian3();\n}\n\nvar projectTo2DProjection = new GeographicProjection();\n/**\n * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.\n *\n * @param {BoundingSphere} sphere The bounding sphere to transform to 2D.\n * @param {Object} [projection=GeographicProjection] The projection to 2D.\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.projectTo2D = function (sphere, projection, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  //>>includeEnd('debug');\n\n  projection = defaultValue(projection, projectTo2DProjection);\n\n  var ellipsoid = projection.ellipsoid;\n  var center = sphere.center;\n  var radius = sphere.radius;\n\n  var normal;\n  if (Cartesian3.equals(center, Cartesian3.ZERO)) {\n    // Bounding sphere is at the center. The geodetic surface normal is not\n    // defined here so pick the x-axis as a fallback.\n    normal = Cartesian3.clone(Cartesian3.UNIT_X, projectTo2DNormalScratch);\n  } else {\n    normal = ellipsoid.geodeticSurfaceNormal(center, projectTo2DNormalScratch);\n  }\n  var east = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    normal,\n    projectTo2DEastScratch\n  );\n  Cartesian3.normalize(east, east);\n  var north = Cartesian3.cross(normal, east, projectTo2DNorthScratch);\n  Cartesian3.normalize(north, north);\n\n  Cartesian3.multiplyByScalar(normal, radius, normal);\n  Cartesian3.multiplyByScalar(north, radius, north);\n  Cartesian3.multiplyByScalar(east, radius, east);\n\n  var south = Cartesian3.negate(north, projectTo2DSouthScratch);\n  var west = Cartesian3.negate(east, projectTo2DWestScratch);\n\n  var positions = projectTo2DPositionsScratch;\n\n  // top NE corner\n  var corner = positions[0];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, east, corner);\n\n  // top NW corner\n  corner = positions[1];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // top SW corner\n  corner = positions[2];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // top SE corner\n  corner = positions[3];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, east, corner);\n\n  Cartesian3.negate(normal, normal);\n\n  // bottom NE corner\n  corner = positions[4];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, east, corner);\n\n  // bottom NW corner\n  corner = positions[5];\n  Cartesian3.add(normal, north, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // bottom SW corner\n  corner = positions[6];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, west, corner);\n\n  // bottom SE corner\n  corner = positions[7];\n  Cartesian3.add(normal, south, corner);\n  Cartesian3.add(corner, east, corner);\n\n  var length = positions.length;\n  for (var i = 0; i < length; ++i) {\n    var position = positions[i];\n    Cartesian3.add(center, position, position);\n    var cartographic = ellipsoid.cartesianToCartographic(\n      position,\n      projectTo2DCartographicScratch\n    );\n    projection.project(cartographic, position);\n  }\n\n  result = BoundingSphere.fromPoints(positions, result);\n\n  // swizzle center components\n  center = result.center;\n  var x = center.x;\n  var y = center.y;\n  var z = center.z;\n  center.x = z;\n  center.y = x;\n  center.z = y;\n\n  return result;\n};\n\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {BoundingSphere} sphere The bounding sphere surrounding the occludee object.\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nBoundingSphere.isOccluded = function (sphere, occluder) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"sphere\", sphere);\n  Check.typeOf.object(\"occluder\", occluder);\n  //>>includeEnd('debug');\n  return !occluder.isBoundingSphereVisible(sphere);\n};\n\n/**\n * Compares the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [left] The first BoundingSphere.\n * @param {BoundingSphere} [right] The second BoundingSphere.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nBoundingSphere.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      Cartesian3.equals(left.center, right.center) &&\n      left.radius === right.radius)\n  );\n};\n\n/**\n * Determines which side of a plane the sphere is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nBoundingSphere.prototype.intersectPlane = function (plane) {\n  return BoundingSphere.intersectPlane(this, plane);\n};\n\n/**\n * Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n *\n * @param {Cartesian3} cartesian The point\n * @returns {Number} The estimated distance squared from the bounding sphere to the point.\n *\n * @example\n * // Sort bounding spheres from back to front\n * spheres.sort(function(a, b) {\n *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\n * });\n */\nBoundingSphere.prototype.distanceSquaredTo = function (cartesian) {\n  return BoundingSphere.distanceSquaredTo(this, cartesian);\n};\n\n/**\n * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction\n * plus/minus the radius of the bounding sphere.\n * <br>\n * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\n * closest and farthest planes from position that intersect the bounding sphere.\n *\n * @param {Cartesian3} position The position to calculate the distance from.\n * @param {Cartesian3} direction The direction from position.\n * @param {Interval} [result] A Interval to store the nearest and farthest distances.\n * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n */\nBoundingSphere.prototype.computePlaneDistances = function (\n  position,\n  direction,\n  result\n) {\n  return BoundingSphere.computePlaneDistances(\n    this,\n    position,\n    direction,\n    result\n  );\n};\n\n/**\n * Determines whether or not a sphere is hidden from view by the occluder.\n *\n * @param {Occluder} occluder The occluder.\n * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\n */\nBoundingSphere.prototype.isOccluded = function (occluder) {\n  return BoundingSphere.isOccluded(this, occluder);\n};\n\n/**\n * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {BoundingSphere} [right] The right hand side BoundingSphere.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nBoundingSphere.prototype.equals = function (right) {\n  return BoundingSphere.equals(this, right);\n};\n\n/**\n * Duplicates this BoundingSphere instance.\n *\n * @param {BoundingSphere} [result] The object onto which to store the result.\n * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.\n */\nBoundingSphere.prototype.clone = function (result) {\n  return BoundingSphere.clone(this, result);\n};\n\n/**\n * Computes the radius of the BoundingSphere.\n * @returns {Number} The radius of the BoundingSphere.\n */\nBoundingSphere.prototype.volume = function () {\n  var radius = this.radius;\n  return volumeConstant * radius * radius * radius;\n};\nexport default BoundingSphere;\n"],"names":["defaultValue","Cartesian3","CesiumMath","defined","GeographicProjection","Cartographic","Rectangle","Ellipsoid","Check","Matrix3","Intersect","Matrix4"],"mappings":"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"}
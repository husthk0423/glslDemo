


        vec3 vSunColour = vec3(1.0, 0.9, 0.8) * 5.0;
        const vec3 vSkyBase = vec3(0.05, 0.2, 1.0);
        vec3 vSkyColourA = vSkyBase * 1.5;
        vec3 vSkyColourB = vSkyBase * 0.5;
        const vec3 vAmbientLight = (vSkyBase + vec3(0.5));
        const vec3 vWaterExtinction = (vec3(1.0) - vec3(0.7, 0.6, 0.2)) * 1.5; // murky water
        vec3 vSunDir = normalize(vec3(-0.5, -1.5, 1.0));
        const mat3 m = mat3( 0.00,  0.80,  0.60,
                    -0.80,  0.36, -0.48,
                    -0.60, -0.48,  0.64 );

        float hash( const in float n ) {
            return fract(sin(n)*4378.5453);
        }
        float noise11(in vec3 o) 
        {
            vec3 p = floor(o);
            vec3 fr = fract(o);
                
            float n = p.x + p.y*57.0 + p.z * 1009.0;

            float a = hash(n+  0.0);
            float b = hash(n+  1.0);
            float c = hash(n+ 57.0);
            float d = hash(n+ 58.0);
            
            float e = hash(n+  0.0 + 1009.0);
            float f = hash(n+  1.0 + 1009.0);
            float g = hash(n+ 57.0 + 1009.0);
            float h = hash(n+ 58.0 + 1009.0);
            
            
            vec3 fr2 = fr * fr;
            vec3 fr3 = fr2 * fr;
            
            vec3 t = 3.0 * fr2 - 2.0 * fr3;
            
            float u = t.x;
            float v = t.y;
            float w = t.z;

            // this last bit should be refactored to the same form as the rest :)
            float res1 = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;
            float res2 = e + (f-e)*u +(g-e)*v + (e-f+h-g)*u*v;
            
            float res = res1 * (1.0- w) + res2 * (w);
            
            return res;
        }
        float noise12(in float o) 
        {
            float p = floor(o);
            float fr = fract(o);
                
            float n = p;

            float a = hash(n);
            float b = hash(n+  1.0);

            float fr2 = fr * fr;
            float fr3 = fr2 * fr;
            
            float t = 3.0 * fr2 - 2.0 * fr3;	

            return a * (1.0 - t) + b * t;
        }

        float SmoothNoise( vec3 p )
        {
            float f;
            f  = 0.5000*noise11( p ); 
            p = m*p*2.02;
            f += 0.2500*noise11( p ); 
            return f * (1.0 / (0.5000 + 0.2500));
        }
        float SmoothNoise( float p )
        {
            float f;
            f  = 0.5000*noise12( p ); p = p*2.02;
            f += 0.2500*noise12( p ); p = p*2.03;
            f += 0.1250*noise12( p ); 
            
            return f * (1.0 / (0.5000 + 0.2500 + 0.1250));
        }
        float smin( float a, float b, float k )
        {
            float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
            return mix( b, a, h ) - k*h*(1.0-h);
        }

        float smax( float a, float b, float k)
        {
            return -smin(-a, -b, k);
        }


        vec3 noise_dxy(in vec2 o) 
        {
            vec2 p = floor(o);
            vec2 f = fract(o);
                
            float n = p.x + p.y*57.0;

            float a = hash(n+  0.0);
            float b = hash(n+  1.0);
            float c = hash(n+ 57.0);
            float d = hash(n+ 58.0);
            
            vec2 f2 = f * f;
            vec2 f3 = f2 * f;
            
            vec2 t = 3.0 * f2 - 2.0 * f3;
            vec2 dt = 6.0 * f - 6.0 * f2;
            
            float u = t.x;
            float du = dt.x;	
            float v = t.y;
            float dv = dt.y;	

            float res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;
            
            float dx = (b-a)*du + (a-b+d-c)*du*v;
            float dy = (c-a)*dv + (a-b+d-c)*u*dv;
            
            return vec3(dx, dy, res);
        }

        vec3 fbm_dxy( vec2 p, vec2 d ) {
            vec3 f;
            p += d * 1.0;
            f  =      0.5000*noise_dxy( p );
            p = p * 2.0;
            p += d * 1.0;
            p += f.xy * 0.75;
            f +=      0.2500*noise_dxy( p);
            p = p * 2.0;
            p += d * 1.0;
            p += f.xy * 0.75;
            f +=      0.1250*noise_dxy( p );	
            return f * (1.0/(0.5000 + 0.2500 + 0.1250));
        }

        float GetRoundedBoxDistance( const in vec3 vPos, const in vec3 vMin, const in vec3 vMax, const in float fRadius )
        {
            vec3 vCentre = (vMin + vMax) * 0.5;
            vec3 vSize = abs(vMax - vMin) * 0.5;
            return length(max(abs(vPos-vCentre)-vSize,0.0))-fRadius;

        }
        const float kFarClip = 100.0;
        float GetSceneDistance( const in vec3 vPos,float deltaDepth )
        {
            float fFloorHeight = 2.0;
	
            float fFloorDist = deltaDepth-15.;
            

            float fRiverDist=length(vPos);

            float fResult = smax(fFloorDist, -fRiverDist, 0.75);

            fResult-= SmoothNoise(vPos * vec3(0.5, 1.25, 0.5) + vec3(2.0, -vPos.z * 0.25, 0.0));
            
            return fResult;
        }
        float getWaterFBM(vec2 st,vec3 pEC,float deltaDepth)
        {
            vec2 speed= vec2(0.0, czm_frameNumber/100.) * 2.0;
            vec3 vWaterFBM = fbm_dxy(st, speed);


            float fFoam = sqrt(1.-vWaterFBM.z);
            float fWaterToSceneryDist = GetSceneDistance(-pEC*0.001,deltaDepth);
            fFoam -= clamp(fWaterToSceneryDist* 0.5, 0., 10.);
            fFoam = clamp(fFoam, 0.0, 1.0);
            return fFoam;

        }
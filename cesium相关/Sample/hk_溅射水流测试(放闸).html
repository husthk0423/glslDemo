<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"> <!-- Use Chrome Frame in IE -->
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="A sample Vector dataset on terrain rendered with 3D Tiles.">
    <meta name="cesium-sandcastle-labels" content="Showcases, 3D Tiles">
    <title>水流测试(放闸)</title>
    <link rel="stylesheet" href="../Build/bootstrap.css">
    <script type="text/javascript" src="../Build/CesiumUnminified/Cesium.js"></script>
    <script type="text/javascript" src="../Build/CustomCesiumSDK.js"></script>
    <script type="text/javascript" src="./config.js"></script>
    <script type="text/javascript" src="../Build/jquery-3.1.1.min.js"></script>
</head>
<style>
    html,
    body,
    #cesiumContainer {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
    }

    .cesium-viewer,
    .cesium-viewer-cesiumWidgetContainer,
    .cesium-widget {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
    }

    canvas {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
    }
</style>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay">
    <h1>Loading...</h1>
</div>
<div id="toolbar"></div>
<script id="cesium_sandcastle_script">
    var viewer;
    var waterPrimitive;
    // var timeClock=0.1;
    
    function startup(Cesium) {
        createMap();
    }

    
    function UpdatePrimitiveMatrx(Primitive, XDegree, center) {
        
        var cc = Cesium.Cartesian3.fromDegrees(center[0], center[1], 0);
        let m = Cesium.Transforms.eastNorthUpToFixedFrame(cc);
        let inverse = Cesium.Matrix4.inverse(m, new Cesium.Matrix4);
        const my = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(XDegree));
        const rotate= Cesium.Matrix4.fromRotationTranslation(my);
        let tt = Cesium.Matrix4.multiply(rotate, inverse, new Cesium.Matrix4);
        Primitive.modelMatrix=Cesium.Matrix4.multiply(m, tt, new Cesium.Matrix4);
        
    }

     function createMap() {
        let cesiumTerrainProvider = new Cesium.CesiumTerrainProvider({
            url:'http://data.mars3d.cn/terrain'

        });
        viewer = new Cesium.Viewer('cesiumContainer', {
             selectionIndicator: false,
            terrainProvider: cesiumTerrainProvider,
            animation: false,  //是否显示动画控件
            baseLayerPicker: true, //是否显示图层选择控件
            geocoder: false, //是否显示地名查找控件
            timeline: true, //是否显示时间线控件
            sceneModePicker: true, //是否显示投影方式控件
            navigationHelpButton: false, //是否显示帮助信息控件
            infoBox: false,  //是否显示点击要素之后显示的信息
            imageryProvider: false,
            vrButton: true,
            useBrowserRecommendedResolution: false,
            fullscreenButton: true
        });
        
        viewer.scene.primitives.destroyPrimitives = false;
        viewer.scene.globe.preloadAncestors = true;
        viewer.scene.globe.depthTestAgainstTerrain = true;
        var imageryLayers = viewer.imageryLayers;
        var scene = viewer.scene;
        //天地图影像图层
        var tiandituImageLayer = new Cesium.ImageryLayer(new Cesium.WebMapTileServiceImageryProvider({
            url: baseMapUrl,
            layer: "",
            style: "",
            format: "",
            tileMatrixSetID: "",
            subdomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"],
            tilingScheme: new Cesium.GeographicTilingScheme(),
            tileMatrixLabels: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19"],
            maximumLevel: 18,
        }));    
        viewer.imageryLayers.add(tiandituImageLayer);
        var waterMaterial = new Cesium.Material({
            fabric: {
                type: 'Water',
                uniforms: {
                    normalMap: '../image/water.jpg',
                    frequency: 1000.0,
                    animationSpeed: 0.1,
                    amplitude: 4.0
                }
            }
        });
        $.getJSON("../data/河面测试数据.json",function(result){
           let arr = []
           result.features.forEach(item=>{
             if(item&&item.geometry.coordinates){
              item.geometry.coordinates.forEach(obj=>{
                obj.forEach(data=>{
                  if(Number(data[0])>0&&Number(data[1])>0){
                    arr.push(Number(data[0]),Number(data[1]))
                  }
                })
             })
             }
           })
          //alert(arr);
        });
        var polygonInstance = new Cesium.GeometryInstance({
            geometry: Cesium.PolygonGeometry.fromPositions({
                positions: Cesium.Cartesian3.fromDegreesArray(
                    [119.502312,28.510330,
                    119.489740,28.493765,
                    119.494784,28.490883,
                    119.509139,28.506910]
                ),
                height:395,
                extrudedHeight: 355,
                vertexFormat: Cesium.VertexFormat.ALL
            }),
            attributes: {
                color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('#ff0000').withAlpha(0.5))
            }
        });

        const czmFresnel=
        `
        czm_material czm_getMaterial(czm_materialInput materialInput)
        { 
            czm_material material = czm_getDefaultMaterial(materialInput); 

            
            material.diffuse=vec3(1.0);    
            material.alpha=0.7;
            return material;
        }
        `;  
        const mWater = new Cesium.Material({
        fabric: {
            uniforms: {
                WaveImage: "../image/iChannel5.png",
                bottomImage: "../image/shazi.jpeg",
            },
            source: czmFresnel
        }
        });

        waterPrimitive = new Cesium.GroundPrimitive({
            show: true,
            geometryInstances: [polygonInstance],
            appearance: new Cesium.EllipsoidSurfaceAppearance({
                material:mWater
            })
        });



        const czm_inclinePlane=
        ` 

        const mat3 m = mat3( 0.00,  0.80,  0.60,
                            -0.80,  0.36, -0.48,
                            -0.60, -0.48,  0.64 );

        float hash( const in float n ) {
            return fract(sin(n)*4378.5453);
        }

        float noise(in float o) 
        {
            float p = floor(o);
            float fr = fract(o);
                
            float n = p;

            float a = hash(n);
            float b = hash(n+  1.0);

            float fr2 = fr * fr;
            float fr3 = fr2 * fr;

            float t = 3.0 * fr2 - 2.0 * fr3;	
            return a * (1.0 - t) + b * t;
        }

        float noise(in vec3 o) 
        {
            vec3 p = floor(o);
            vec3 fr = fract(o);
                
            float n = p.x + p.y*57.0 + p.z * 1009.0;

            float a = hash(n+  0.0);
            float b = hash(n+  1.0);
            float c = hash(n+ 57.0);
            float d = hash(n+ 58.0);
            
            float e = hash(n+  0.0 + 1009.0);
            float f = hash(n+  1.0 + 1009.0);
            float g = hash(n+ 57.0 + 1009.0);
            float h = hash(n+ 58.0 + 1009.0);
            vec3 fr2 = fr * fr;
            vec3 fr3 = fr2 * fr;
            
            vec3 t = 3.0 * fr2 - 2.0 * fr3;
            
            float u = t.x;
            float v = t.y;
            float w = t.z;

            float res1 = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;
            float res2 = e + (f-e)*u +(g-e)*v + (e-f+h-g)*u*v;
            
            float res = res1 * (1.0- w) + res2 * (w);
            
            return res;
        }
        // Vector3
        float SmoothNoise( vec3 p )
        {
            float f;
            f  = 0.5000*noise( p ); 
            p = m*p*2.02;
            f += 0.2500*noise( p ); 
            
            return f * (1.0 / (0.5000 + 0.2500));
        }
        // Float
        float SmoothNoise( float p )
        {
            float f;
            f  = 0.5000*noise( p ); 
            p = p*2.02;
            f += 0.2500*noise( p ); 
            p = p*2.03;
            f += 0.1250*noise( p ); 
            return f * (1.0 / (0.5000 + 0.2500 + 0.1250));
        }
        float GetWaterfallNoise( const vec3 vPos,float iTime)
        {
            float f = SmoothNoise( vPos * vec3(16.0, 2.0, 16.0) + vec3(0.0, mod(iTime * 10.0, 1000.0), 0.0) );
            return f * f;
        }
        czm_material czm_getMaterial(czm_materialInput materialInput)
        { 
            czm_material material = czm_getDefaultMaterial(materialInput); 
            float iTime=czm_frameNumber;
            vec3 uwc=czm_lightDirectionWC;
            float fFraction = 0.0;  
            const int kTraceIter =19;	
	        float fFractionDelta = 1.0 / float(kTraceIter);
            float TestNoise=0.0;
            for(int i=0;i<kTraceIter;i++)
            {
                
                // vec3 vUVWCurr = mix(
                //     vec3(materialInput.positionToEyeEC.x, length(materialInput.positionToEyeEC.yz), materialInput.positionToEyeEC.y),
                //     vec3(materialInput.positionToEyeEC.x, length(materialInput.positionToEyeEC.yz), materialInput.positionToEyeEC.y),
                //     fFraction);


                
                vec3 vUVWCurr = mix(vec3(0.2,-5,-1), vec3(-0.2,-5,-2), fFraction);
                float fNoise=GetWaterfallNoise(vUVWCurr,iTime);
                fFraction+=fFractionDelta;
                TestNoise=fNoise;
            }
            material.diffuse=vec3(TestNoise);
            material.alpha=0.3;
            return material;
        }
        `;
        const mat_inclinePlane = new Cesium.Material({
        fabric: {
            uniforms: {
            },
            source: czm_inclinePlane
        }
        });
        
       var inclinePlane_Primitive = new Cesium.Primitive({
            show: true,
            geometryInstances: [polygonInstance],
            appearance: new Cesium.EllipsoidSurfaceAppearance({
                material:mat_inclinePlane
            })
        });


       viewer.scene.primitives.add(waterPrimitive);
       viewer.scene.primitives.add(inclinePlane_Primitive);
       UpdatePrimitiveMatrx(inclinePlane_Primitive,6,[119.499274564273,28.502124429566]);
       viewer.clock.currentTime = Cesium.JulianDate.addHours(Cesium.JulianDate.now(new Date()),10, new Cesium.JulianDate());
       viewer.scene.postProcessStages._fxaa.enabled = true;    
       viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(119.488001750321, 28.481068187288, 856),//设置位置
            orientation: {  
                heading: 0.6111067786324735,
                pitch: -0.3576898670382149,
            }
        });



         var handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
         handler.setInputAction(function (event) {
            var ray = viewer.camera.getPickRay(event.position);
            var c3 = scene.globe.pick(ray,scene);
            var cartographic= Cesium.Cartographic.fromCartesian(c3);
            var lat=Cesium.Math.toDegrees(cartographic.latitude);
            var lng=Cesium.Math.toDegrees(cartographic.longitude);
            var height=cartographic.height;
            console.log(lng.toFixed(12)+','+ lat.toFixed(12)+','+height);
            console.log('heading'+viewer.camera.heading +','+'pitch'+ viewer.camera.pitch);

        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
       

    }

    if (typeof Cesium !== 'undefined') {
        // TimeClock()
        startup(Cesium);
    }
</script>
</body>

</html>
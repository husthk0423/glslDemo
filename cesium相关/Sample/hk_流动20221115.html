<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"> <!-- Use Chrome Frame in IE -->
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="A sample Vector dataset on terrain rendered with 3D Tiles.">
    <meta name="cesium-sandcastle-labels" content="Showcases, 3D Tiles">
    <title>hk_流动20221115</title>
    <link rel="stylesheet" href="../Build/bootstrap.css">
    <script type="text/javascript" src="../Build/CesiumUnminified/Cesium.js"></script>
    <script type="text/javascript" src="../Build/CustomCesiumSDK.js"></script>
    <script type="text/javascript" src="./config.js"></script>
    <script type="text/javascript" src="../Build/jquery-3.1.1.min.js"></script>
</head>
<style>
    html,
    body,
    #cesiumContainer {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
    }

    .cesium-viewer,
    .cesium-viewer-cesiumWidgetContainer,
    .cesium-widget {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
    }

    canvas {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
    }
</style>
<span style="position: absolute;top:10px;left:10px;">
    <button class="btn btn-primary" onclick="waterActive()">显示primitive</button>
    <button class="btn btn-primary" onclick="NoActive()">隐藏primitive</button>
</span>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay">
    <h1>Loading...</h1>
</div>
<div id="toolbar"></div>
<script id="cesium_sandcastle_script">
    var viewer;
    var waterPrimitive;

    var highPrimitive;
    var highpolygonInstance;
    var shazi_Primitive;
    var polygonInstance;
    var mWater;
    var czmFresnel
    // var timeClock=0.1;
    function NoActive()
    {
        waterPrimitive.show = false;
    }
    function waterActive() {
        flood(viewer,polygonInstance,mWater)
    }
    function startup(Cesium) {
        createMap();
    }
    // function TimeClock() {
    //     console.log(Cesium.ClockStep.TICK_DEPENDENT);
    //     timeClock+=1;
    //     requestAnimationFrame(TimeClock) 
    // }
    function flood(viewer,polygonInstance,mWater) {


        mWater = new Cesium.Material({
        fabric: {
            uniforms: {
                WaveImage: "../image/Waves_N.png",
                bottomImage: "../image/Sand_D.jpg",
                RepeatX:new Cesium.Cartesian2(8, 8),
                WaterColor:new Cesium.Color(0.5411765,0.5647059,0.5294118,1.0),
                FlowImage:"../image/flowmapAA.png",
                FoamImage:"../image/FoamA.png",
            //    depthTexture:viewer.globeDepth.colorFramebufferManager.getDepthStencilTexture(),
                // depthTexture:"../image/flowmapAA.png",
            },
            source: czmFresnel
        }
        });

        waterPrimitive = new Cesium.Primitive({
            // show: false,
            geometryInstances: [polygonInstance],
            undisplayable: true,
            appearance: new Cesium.EllipsoidSurfaceAppearance({
                translucent: false,
                material:mWater
                
            })
        });     

  
        viewer.scene.primitives.add(waterPrimitive);
        
        
    }



    function updateHeight(waterPrimitive, scale, center) {
        var cc = Cesium.Cartesian3.fromDegrees(center[0], center[1], 0);
        let m = Cesium.Transforms.eastNorthUpToFixedFrame(cc);
        let inverse = Cesium.Matrix4.inverse(m, new Cesium.Matrix4);

        let mScale = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(1.0, 1.0, scale));
        let tt = Cesium.Matrix4.multiply(mScale, inverse, new Cesium.Matrix4);
        waterPrimitive.modelMatrix = Cesium.Matrix4.multiply(m, tt, new Cesium.Matrix4);
    }

    function createMap() {
        let cesiumTerrainProvider = new Cesium.CesiumTerrainProvider({
            url:'http://data.mars3d.cn/terrain'

        });
        viewer = new Cesium.Viewer('cesiumContainer', {
             selectionIndicator: false,
            terrainProvider: cesiumTerrainProvider,
            animation: false,  //是否显示动画控件
            baseLayerPicker: true, //是否显示图层选择控件
            geocoder: false, //是否显示地名查找控件
            timeline: true, //是否显示时间线控件
            sceneModePicker: true, //是否显示投影方式控件
            navigationHelpButton: false, //是否显示帮助信息控件
            infoBox: false,  //是否显示点击要素之后显示的信息
            imageryProvider: false,
            vrButton: true,
            useBrowserRecommendedResolution: false,
            fullscreenButton: true
        });
        
        viewer.scene.primitives.destroyPrimitives = false;
        viewer.scene.globe.preloadAncestors = true;
        viewer.scene.globe.depthTestAgainstTerrain = true;
        var imageryLayers = viewer.imageryLayers;
        var scene = viewer.scene;
        imageryLayers.removeAll();

        //天地图影像图层
        var tiandituImageLayer = new Cesium.ImageryLayer(new Cesium.WebMapTileServiceImageryProvider({
            url: baseMapUrl,
            layer: "",
            style: "",
            format: "",
            tileMatrixSetID: "",
            subdomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"],
            tilingScheme: new Cesium.GeographicTilingScheme(),
            tileMatrixLabels: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19"],
            maximumLevel: 18,
        }));
        viewer.imageryLayers.add(tiandituImageLayer);



        var waterMaterial = new Cesium.Material({
            fabric: {
                type: 'Water',
                uniforms: {
                    normalMap: '../image/water.jpg',
                    frequency: 1000.0,
                    animationSpeed: 0.1,
                    amplitude: 4.0
                }
            }
        });
        $.getJSON("../data/河面测试数据.json",function(result){
           let arr = []
           result.features.forEach(item=>{
             if(item&&item.geometry.coordinates){
              item.geometry.coordinates.forEach(obj=>{
                obj.forEach(data=>{
                  if(Number(data[0])>0&&Number(data[1])>0){
                    arr.push(Number(data[0]),Number(data[1]))
                  }
                })
             })
             }
           })
        //    alert(arr);
        });
       polygonInstance = new Cesium.GeometryInstance({
            geometry: Cesium.PolygonGeometry.fromPositions({
                positions: Cesium.Cartesian3.fromDegreesArray([
                119.467444, 28.562214,
                119.741000, 28.379154,
                119.639312, 28.372095,
                119.547387, 28.319825,
                119.374338, 28.43156,
                119.308763, 28.543007,
                119.324388, 28.596889,
                119.448939, 28.584777


                   

                ]),
                height:485,
                extrudedHeight: 485,
                vertexFormat: Cesium.VertexFormat.ALL
            }),

            attributes: {
                color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('#ff0000'))
            }
        });
       

        highpolygonInstance= new Cesium.GeometryInstance({
            geometry: Cesium.PolygonGeometry.fromPositions({
                positions: Cesium.Cartesian3.fromDegreesArray([
                119.932028,28.188356,
                119.275988,27.894984,
                119.119987,28.403159,
                119.546695,28.543999,
              
                    

                   

                ]),
                height: 1055,
                extrudedHeight: 1055,
                vertexFormat: Cesium.VertexFormat.ALL
            }),

            attributes: {
                color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('#ff0000'))
            }
        });

        var shazi_polygonInstance = new Cesium.GeometryInstance({
            geometry: Cesium.PolygonGeometry.fromPositions({
                positions: Cesium.Cartesian3.fromDegreesArray([
                119.491133,28.285150,
                119.452775,28.246126,
                119.340569,28.332514,
                119.293163,28.278900,
                119.261811,28.308954,
                119.340968,28.370506,
                ]),
                height: 140,
                extrudedHeight: 125,
                vertexFormat: Cesium.VertexFormat.ALL
            }),
        });



 czmFresnel=
    `
    float getMixValue(float cycle, inout float offset1, inout float offset2)
    {

        float mixval = cycle * 2.0;
        if(mixval > 1.0) mixval = 2.0 - mixval;
        offset1 = cycle;
        offset2 = mod(offset1 + .5, 1.0);
        return mixval;
    }

    float  getInterval(float _interval)
    {
        float time = czm_frameNumber;
        //间隔速度，值越大，间隔时间越长；值越小，间隔时间越大；
        float cycle = mod(time, _interval)/_interval;   
        return cycle;
    }

    vec4  PIE_czm_windowToEyeCoordinates(vec2 fragmentCoordinateXY, float depthOrLogDepth)
    {
    
        float near = czm_currentFrustum.x;
        float far = czm_currentFrustum.y;
        float log2Depth = depthOrLogDepth * czm_log2FarDepthFromNearPlusOne;
        float depthFromNear = pow(2.0, log2Depth) - 1.0;
        float depthFromCamera = depthFromNear + near;
        vec4 windowCoord = vec4(fragmentCoordinateXY, far * (1.0 - near / depthFromCamera) / (far - near), 1.0);
        vec4 eyeCoordinate = czm_windowToEyeCoordinates(windowCoord);
        eyeCoordinate.w = 1.0 / depthFromCamera; 
        return eyeCoordinate;
    }
   
    czm_material czm_getMaterial(czm_materialInput materialInput)
    { 
        //水波时间
        float timeInterval=200.;
        float _WaveXSpeed=-0.005;
        float _WaveYSpeed=-0.111;  
     
      
        float o1, o2 = 0.;
        float cycle = mod(czm_frameNumber, timeInterval)/timeInterval;
        float mv = getMixValue(cycle, o1, o2);
        float _time=getInterval(timeInterval);
        
        //流向控制
        
        //往上流
        vec2 shang_speed = _time* vec2(_WaveXSpeed, -_WaveYSpeed);
        //往下流
         vec2 xia_speed =vec2(_WaveXSpeed, _WaveYSpeed);
         vec2 xia_speed1 =vec2(-_WaveXSpeed, _WaveYSpeed);

         
        //往左流
         vec2 zuo_speed = _time* vec2(_WaveXSpeed, _WaveYSpeed);    
        //往右流
         vec2 you_speed = _time* vec2(-_WaveXSpeed, -_WaveYSpeed);


        czm_material material = czm_getDefaultMaterial(materialInput); 
        
        

    //    vec3 flowDir=(texture2D(FlowImage,fract(materialInput.st))).xyz;
      
        vec3 bump1 = normalize(texture2D(WaveImage, fract(RepeatX*materialInput.st))).rgb; 
        vec3 bump2 = normalize(texture2D(WaveImage, fract(RepeatX*materialInput.st)+o1*xia_speed)).rgb; 
        //叉乘得到法线分量
        vec3 bumpnormaCross1 = normalize(cross(bump1, bump2));
        vec3 bump3 = normalize(texture2D(WaveImage, fract(RepeatX*materialInput.st))).rgb; 
        vec3 bump4 = normalize(texture2D(WaveImage, fract(RepeatX*materialInput.st)+o2*xia_speed1)).rgb; 
        //叉乘得到法线分量分量
        vec3 bumpnormaCross2 = normalize(cross(bump3, bump4));
        // //得到新的分量,保证水流连续
        vec3 bumpnormaCross=normalize(mix(bumpnormaCross2, bumpnormaCross1, mv));
       
        //opengl光照原理,传入法向量
        float diffuseFactor=czm_getLambertDiffuse(czm_lightDirectionEC,bumpnormaCross);
        float specularFactor = czm_getSpecular(czm_lightDirectionEC, bumpnormaCross,normalize(materialInput.positionToEyeEC),0.1);
        
        
        diffuseFactor= pow(diffuseFactor, 2.)* 1.;
         
        
        float wd = dot(bumpnormaCross, czm_lightDirectionEC);
        wd = max(0.0, wd);
        float wrp = 0.5;
        wd = (wd+wrp)/(1.+wrp);
        
        vec4 blue = vec4(0., 69., 129., 0.) / 255.;
        vec4 orange = vec4(.7, .3, 0.1, 0.0);
        vec3 bottomColor=vec3(0.7451, 0.7686, 0.6471);

        vec3 frescol = diffuseFactor*orange.rgb*0.4+blue.rgb*wd;
        // material.diffuse=mix(bottomColor,frescol,0.3);
        // material.normal=normalize(materialInput.tangentToEyeMatrix * bumpnormaCross); 
        // material.specular=specularFactor;
        // material.shininess=30.;
        // material.alpha=0.7;
   
  

        // vec4 posWC = czm_eyeToWindowCoordinates(vec4(materialInput.positionToEyeEC,1.0));
        // float terrianZ=texture2D(czm_globeDepthTexture, posWC.xy / czm_viewport.zw).z;
        // vec3 finalDelta=vec3(0.);
        // if(terrianZ>0.6) 
        //   finalDelta=vec3(terrianZ);
        // else  
        //   finalDelta=frescol;
        // material.diffuse=finalDelta;

      
        //地形深度
        vec4 posWC = czm_eyeToWindowCoordinates(vec4(materialInput.positionToEyeEC,1.0));
        float depth = czm_unpackDepth(texture2D(czm_globeDepthTexture, posWC.xy / czm_viewport.zw)); 
        vec4 eyeCoordinate = PIE_czm_windowToEyeCoordinates(posWC.xy, depth);
        float GlobeDepth=-eyeCoordinate.z / eyeCoordinate.w;

        // float  GlobeDepth=length(eyeCoordinate.xyz);
        // float GlobeDepth = czm_readDepth(czm_globeDepthTexture,);
        float terrianZ=texture2D(czm_globeDepthTexture, posWC.xy / czm_viewport.zw).z;
        float  GlobeDepth12=length(terrianZ);
        //地形深度 模型空间
        vec3 pointMCTerrian = (czm_inverseModelView * eyeCoordinate).xyz;
        //primitive和相机的距离
        float PrimitiveLength=length(materialInput.positionToEyeEC);

        float PrimitiveLength11=-materialInput.positionToEyeEC.z;
        vec4 eyeCoordinate11 = czm_windowToEyeCoordinates(posWC.xy, PrimitiveLength);
        float GlobeDepth11=-eyeCoordinate11.z / eyeCoordinate11.w;
        //primitive模型空间
        vec3 pointMCPrimitive = (czm_inverseModelView * vec4(materialInput.positionToEyeEC, 1.0)).xyz;
        //距离差值
        float deltaDepth=(GlobeDepth-length(materialInput.positionToEyeEC.z))*0.005;
        float deltaDepthZ=length(pointMCPrimitive)-length(pointMCTerrian);
        float testArg=materialInput.height;
        // material.diffuse=vec3(0.,1.0,1.)*vec3(testArg);
        float _dynamicDepth=getInterval(500.)*0.3;
        vec2 Foram_speed =vec2(-0.005, -0.111);
        vec3 foramColor = texture2D(FoamImage, fract(materialInput.st*vec2(500.0))).xyz; 
        if(deltaDepth>0.4)
         {
             material.diffuse=frescol;
             material.normal=normalize(materialInput.tangentToEyeMatrix * bumpnormaCross); 
            material.specular=specularFactor;
            material.shininess=10.;
             material.alpha=0.5;
         }
        else
        {
        
            material.diffuse=mix(foramColor,frescol,0.3);
            material.normal=normalize(materialInput.tangentToEyeMatrix * bumpnormaCross);
            material.alpha=0.5;
        }
        // material.diffuse=vec3(GlobeDepth/100000.);
        // material.diffuse=vec3(length(materialInput.positionToEyeEC.z)/100000.);
        // material.diffuse=vec3(deltaDepth);
        // material.alpha=0.5;

        // material.alpha=0.7;
        return material;    
    }
    `;




   


    highPrimitive= new Cesium.Primitive({
            // show: false,
            geometryInstances: [highpolygonInstance],
            undisplayable: true,
            appearance: new Cesium.PerInstanceColorAppearance({
            translucent: false,
            closed: true,
        })
        });   
        // viewer.scene.primitives.add(highPrimitive);


    //     const czm_WaterVS=  `
    //         attribute vec3 position3DHigh;
    //         attribute vec3 position3DLow;
    //         attribute vec2 st;
    //         attribute float batchId;
    //         attribute vec3 normal;

    //         varying vec3 v_positionMC;
    //         varying vec3 v_positionEC;
    //         varying vec3 v_positionWC;
    //         varying vec3 v_normalEC;
    //         varying vec2 v_st;
    //         uniform mat4 ClipMatrix;
    //         varying vec2 v_textureCoordinates;
    //         void main()
    //         {
    //             vec4 p = ClipMatrix*czm_computePosition();
    //             v_positionMC = position3DHigh + position3DLow;           // position in model coordinates
    //             v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates
    //             v_st = st;
    //             v_positionWC=(czm_model*vec4(v_positionMC,1.0)).xyz;
    //             v_normalEC= czm_normal * normal;
    //             gl_Position = czm_modelViewProjectionRelativeToEye * p;
    //         }
    //         `;
    //     const czm_WateFS=  `
    //         varying vec3 v_positionWC;
    //         varying vec3 v_normalEC;        
    //         varying vec2 v_st;
    //         varying vec2 v_textureCoordinates;
    //         varying vec3 v_positionEC;
    //         uniform sampler2D WaveImage;


    //     float getMixValue(float cycle, inout float offset1, inout float offset2)
    //     {

    //         float mixval = cycle * 2.0;
    //         if(mixval > 1.0) mixval = 2.0 - mixval;
    //         offset1 = cycle;
    //         offset2 = mod(offset1 + .5, 1.0);
    //         return mixval;
    //     }

    //     float  getInterval(float _interval)
    //     {
    //         float time = czm_frameNumber;
    //         //间隔速度，值越大，间隔时间越长；值越小，间隔时间越大；
    //         float cycle = mod(time, _interval)/_interval;   
    //         return cycle;
    //     }

    //     void main()
    //     {
    //         vec3 cameraToPositionWC = v_positionWC - czm_viewerPositionWC;//世界空间下视角方向
    //         vec3 cameraToPositionEC=(czm_modelView*vec4(cameraToPositionWC,1.0)).xyz;//裁剪空间下视角方向
    //         vec3 cameraToPositionECDirection = normalize(cameraToPositionEC);
    //         float nDotL = 1.-clamp(dot(v_normalEC, -cameraToPositionECDirection), 0.0, 1.0);
    //         vec4 bump1 = texture2D(WaveImage,v_st); 

    //         vec3 positionToEyeEC = -v_positionEC;
        
    //         czm_materialInput materialInput;
    //         materialInput.normalEC = v_normalEC;
    //         materialInput.positionToEyeEC = positionToEyeEC;
    //         materialInput.st = v_st;
    //         czm_material material = czm_getMaterial(materialInput);

    //         // vec4 diffuseColor = texture2D(WaveImage,fract(materialInput.st)); 
    //         // material.diffuse = bump1.xyz;
    //         // material.alpha=0.8;
    //         // material.shininess=30.;
            
    //         gl_FragColor =bump1;

    //         // gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);

    //         // gl_FragColor = vec4(vec3(1.0)*pow(nDotL,1./0.5),1.0);
    //     }
    // `;

   
    //     waterPrimitive = new Cesium.Primitive({
    //         show: true,
    //         geometryInstances: [polygonInstance],
    //         undisplayable: true,
    //         appearance: new Cesium.EllipsoidSurfaceAppearance({
    //             fragmentShaderSource:czm_WateFS,
    //             vertexShaderSource:czm_WaterVS,
      
    //             // translucent: true,
    //         })
    //     });
    //     const appearance = this.waterPrimitive.appearance;
    //     //赋顶点着色器uniform
    //     appearance.uniforms={};
    //     var v = [1, 0, 0, 0, 
    //              0, 1,0, 0, 
    //              0, 0, 1, 0,
    //              0, 0, 0, 1];
    //     var m = Cesium.Matrix4.fromArray(v);
    //     appearance.uniforms.ClipMatrix = m;
    //     appearance.uniforms.WaveImage="../image/758px-Canestra_di_frutta_(Caravaggio).jpg"




        //  viewer.scene.primitives.add(waterPrimitive);



        
        const shaziShader=
        `
        float  getInterval(float _interval)
        {
            float time = czm_frameNumber;
            //间隔速度，值越大，间隔时间越长；值越小，间隔时间越大；
            float cycle = mod(time, _interval)/_interval;   
            return cycle;
        }

        czm_material czm_getMaterial(czm_materialInput materialInput)
        {
            float timeInterval=400.;

            float cycle = mod(czm_frameNumber, timeInterval)/timeInterval;

            czm_material material = czm_getDefaultMaterial(materialInput); 
            
            // vec2 st=normalize(materialInput.st);
            // vec4 shaziColor_01 = normalize(texture2D(bottomImage,(materialInput.st+vec2(0.24*cycle,cycle))*vec2(1.0,0.5))); 
            vec4 shaziColor_01 = texture2D(bottomImage,materialInput.st); 
 
           
            // vec4 shaziColor_01 = texture2D(bottomImage,fract(materialInput.st*vec2(4.0)+0.2)); 
            material.diffuse=shaziColor_01.xyz;

            material.alpha=0.9;
            return material;
        }

        `;
        const mshazi = new Cesium.Material({
        fabric: {
            uniforms: {
                bottomImage: "../image/Cesium_Logo_Color.jpg",
            },
            source: shaziShader
        }
        });
        shazi_Primitive=new Cesium.Primitive({
            // show: false,
            geometryInstances: [shazi_polygonInstance],
            // undisplayable: true,
            appearance: new Cesium.EllipsoidSurfaceAppearance({
                material:mshazi
            })
        });
        // viewer.scene.primitives.add(shazi_Primitive);




    //   viewer.clock.currentTime = Cesium.JulianDate.addHours(Cesium.JulianDate.now(new Date()),5, new Cesium.JulianDate());

        viewer.scene.postProcessStages._fxaa.enabled = true;    
        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(119.1620733283383, 28.65841206230267, 9042.75883),//设置位置
            orientation: {  
                heading: Cesium.Math.toRadians(123.69117),
                pitch: Cesium.Math.toRadians(-16.37963),
            }
        });



        var handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
        handler.setInputAction(function (event) {
            var position = event.position;
            var cartesian =  viewer.scene.pickPosition(position);
            if (!Cesium.defined(cartesian)) {
                return;
            }
            var ellipsoid=viewer.scene.globe.ellipsoid;
            var cartographic=ellipsoid.cartesianToCartographic(cartesian);
            var lat=Cesium.Math.toDegrees(cartographic.latitude);
            var lng=Cesium.Math.toDegrees(cartographic.longitude);
            var height=cartographic.height;
            console.log(lng.toFixed(6)+','+ lat.toFixed(6)+','+height);

        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    }

    if (typeof Cesium !== 'undefined') {
        // TimeClock()
        startup(Cesium);
    }
</script>
</body>

</html>
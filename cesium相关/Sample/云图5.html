
<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Use correct character set. -->
    <meta charset="utf-8"/>
    <!-- Tell IE to use the latest, best version. -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
    <meta
            name="viewport"
            content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <title>Cesium model popup</title>
<!--    <link rel="stylesheet" href="./popup.css" type="text/css">-->
    <link rel="stylesheet" href="../Build/style.css" />
<!--    <script src="http://openlayers.vip/examples/csdn/Cesium.js"></script>-->
<!--    <script src="./cesium_init.js"></script>-->
    <script src="../Build/CesiumUnminified/Cesium.js"></script>
    <script src="../Build/CustomCesiumSDK.js"></script>
    <script src="http://www.openlayers.vip/examples/resources/jquery-3.5.1.min.js"></script>
<!--    <script src="./CesiumPopup.js"></script>-->
    <style>
        @import url(../Build/CesiumUnminified/Widgets/widgets.css);

        html,
        body,
        #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>

    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?f80a36f14f8a73bb0f82e0fdbcee3058";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
</head>
<body>
<div id="cesiumContainer"></div>
<script>

    var cesiumTerrainProvider = new Cesium.CesiumTerrainProvider({
        url: 'http://data.mars3d.cn/terrain'
    });

    // 创建三维球
    const viewer = new Cesium.Viewer("cesiumContainer",{
        terrainProvider: cesiumTerrainProvider,
        baseLayerPicker: false, //是否显示图层选择控件
        geocoder: false, //是否显示地名查找控件
        sceneModePicker: true, //是否显示投影方式控件
        navigationHelpButton: false, //是否显示帮助信息控件
        infoBox: false,  //是否显示点击要素之后显示的信息
        imageryProvider: false,
        shadows: true,
        shouldAnimate: true,
    });
    const sunLight = new Cesium.SunLight({
        intensity:10,
        color:Cesium.Color.fromCssColorString('#ffffff')
    });
    viewer.scene.light = sunLight;

    requestAnimationFrame(changeColor);

    viewer.scene.globe.depthTestAgainstTerrain = true;
    var tiandituImageLayer = new Cesium.ImageryLayer(new Cesium.WebMapTileServiceImageryProvider({
        url: "http://{s}.tianditu.gov.cn/img_c/wmts?service=wmts&request=GetTile&version=1.0.0" +
            "&LAYER=img&tileMatrixSet=c&TileMatrix={TileMatrix}&TileRow={TileRow}&TileCol={TileCol}" +
            "&style=default&format=tiles&tk=440b96d736fad95da7934bc130a2258a",
        layer: "tdtImg_c",
        style: "default",
        format: "tiles",
        tileMatrixSetID: "c",
        subdomains: ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7"],
        tilingScheme: new Cesium.GeographicTilingScheme(),
        tileMatrixLabels: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19"],
        maximumLevel: 17,
    }));
    viewer.imageryLayers.add(tiandituImageLayer);

    const entities = viewer.entities;

    // const image = 'https://openlayers.vip/examples/resources/earth_cloud.png';


    // const image = '../image/noise11.png';
    const image = './云.png';
    const color = new Cesium.Color(1.0, 1.0, 1.0, 1);

    const time = 20;

    const imageMaterial = new Cesium.ImageMaterialProperty({
        image: image,
    });


    function CloudEffectMaterialProperty() {

        this._definitionChanged = new Cesium.Event();

        this.speed = 20;
        this.color = color;
        this._image = image;
        this.time = time;


        const durationDefault = 100000;
        this.duration = 100 / this.speed * durationDefault;

        this._time = new Date().getTime();

    }

    Object.defineProperties(CloudEffectMaterialProperty.prototype, {
        isConstant: {
            get: function() {
                return false;
            }
        },
        definitionChanged: {
            get: function() {
                return this._definitionChanged;
            }
        },
        color: Cesium.createPropertyDescriptor('color')
    });
    CloudEffectMaterialProperty.prototype.getType = function(time) {
        return 'CloudEffect';
    };
    CloudEffectMaterialProperty.prototype.getValue = function(time, result) {
        if (!Cesium.defined(result)) {
            result = {};
        }
        result.color = Cesium.Property.getValueOrClonedDefault(
            this._color, time, Cesium.Color.WHITE, result.color);
        result.time = ((new Date().getTime() - this._time) % this.duration) / this.duration;
        return result;
    };
    CloudEffectMaterialProperty.prototype.equals = function(other) {
        return (this === other ||
            (other instanceof CloudEffectMaterialProperty &&
                Cesium.Property.equals(this._color, other._color) &&
                Cesium.Property.equals(this.speed, other.speed)));
    }
    ;
    Cesium.Material.CloudEffectType = 'CloudEffect';
    Cesium.Material.CloudEffectImage = image;
    Cesium.Material.CloudEffectColor = color;
    Cesium.Material.CloudEffectSource = `

 //SETTINGS//
const float timeScale = 10.0;
const float cloudScale = 1.0;
const float skyCover = 0.6; //overwritten by mouse x drag
const float softness = 0.2;
const float brightness = 1.0;
const int noiseOctaves = 8;
const float curlStrain = 3.0;
//SETTINGS//

float saturate(float num)
{
    return clamp(num,0.0,1.0);
}

float noise(vec2 uv)
{
    return texture2D(image,fract(uv)).a;
}

vec2 rotate(vec2 uv)
{
    uv = uv + noise(uv*0.2)*0.005;
    float rot = curlStrain;
    float sinRot=sin(rot);
    float cosRot=cos(rot);
    mat2 rotMat = mat2(cosRot,-sinRot,sinRot,cosRot);
    return uv * rotMat;
}

float fbm (vec2 uv)
{
    float rot = 1.57;
    float sinRot=sin(rot);
    float cosRot=cos(rot);
    float f = 0.0;
    float total = 0.0;
    float mul = 0.5;
    mat2 rotMat = mat2(cosRot,-sinRot,sinRot,cosRot);

    for(int i = 0;i < noiseOctaves;i++)
    {
        f += noise(uv+0.00015*timeScale*(1.0-mul))*mul;
        total += mul;
        uv *= 3.0;
        uv=rotate(uv);
        mul *= 0.5;
    }
    return f/total;
}



 #define rgb(r,g,b) (vec3(r,g,b)/255.)
        vec4 sunColor(vec2 uv){
            vec4 sunPos = czm_morphTime == 1.0 ? vec4(czm_sunPositionWC, 1.0) : vec4(czm_sunPositionColumbusView.zxy, 1.0);
            vec4 sunPosition = czm_projection * czm_view * sunPos;
            vec2 sunUV = vec2(sunPosition.x/sunPosition.w,sunPosition.y/sunPosition.w);

            // sky
            vec3 color = mix(rgb(255,212,166), rgb(204,235,255), uv.y);
            // sun
             vec2 spos = uv - sunUV;
            //vec2 spos = -vec2(0.0, 0.0);
            float sun = exp(-20.*dot(spos,spos));
            vec3 scol = rgb(255,155,102) * sun * 0.3;
            color += scol;
            return vec4(color,1.);
        }


vec4 mainImage(  vec2 st ,vec2 uv1)
{

    vec2 uv = st - 0.5 / cloudScale;

    float cover = 0.5;

    float bright = brightness*(1.8-cover);

    float color1 = fbm(uv-0.5+0.00004*timeScale);
    float color2 = fbm(uv-10.5+0.00002*timeScale);

    float clouds1 = smoothstep(1.0-cover,min((1.0-cover)+softness*2.0,1.0),color1);
    float clouds2 = smoothstep(1.0-cover,min((1.0-cover)+softness,1.0),color2);

    float cloudsFormComb = saturate(clouds1+clouds2);

    vec4 skyCol = vec4(0.6,0.8,1.0,1.0);
    float cloudCol = saturate(saturate(1.0-pow(color1,1.0)*0.2)*bright);
    vec4 clouds1Color = vec4(cloudCol,cloudCol,cloudCol,1.0);

    // vec4 sunColor = sunColor(uv1);

    vec4 clouds2Color = mix(clouds1Color,skyCol,0.25);
    vec4 cloudColComb = mix(clouds1Color,clouds2Color,saturate(clouds2-clouds1));

    return mix(skyCol,cloudColComb,cloudsFormComb);
}




czm_material czm_getMaterial(czm_materialInput materialInput,vec2 uv)
                {
                     czm_material material = czm_getDefaultMaterial(materialInput);
                     vec2 st = materialInput.st;
                     vec4 colorImage = mainImage(st,uv);
                     //vec4 colorImage = texture2D(image, vec2(fract(st.s + time),st.t));
                     //vec4 colorImage = texture2D(image,fract(st / 1.8));
                     material.alpha = colorImage.a  ;
                     material.diffuse = colorImage.rgb ;
                     return material;
}
`;


    var cloudVS =`
        attribute vec3 position3DHigh;
          attribute vec3 position3DLow;
          attribute vec3 normal;
          attribute vec2 st;
          attribute float batchId;
          varying vec2 v_st;
          varying vec3 v_normalEC;
          varying vec3 v_positionEC;
          void main()
          {
              vec4 p = czm_translateRelativeToEye(position3DHigh,position3DLow);
              v_positionEC = (czm_modelViewRelativeToEye * p).xyz;
              v_normalEC = czm_normal * normal;
              v_st=st;
              gl_Position = czm_modelViewProjectionRelativeToEye * p;
          }
    `;

    var cloudFS =`


        varying vec3 v_positionEC;
            varying vec3 v_normalEC;
            varying vec2 v_st;
            void main()
            {
                vec4 gt = czm_projection * vec4(v_positionEC,1.);
                vec2 glpt = gt.xy/gt.w;

                vec2 uv = vec2(glpt.x ,glpt.y * (czm_viewport.w/czm_viewport.z));

                 vec3 positionToEyeEC = -v_positionEC;
                 vec3 normalEC = normalize(v_normalEC);
                  czm_materialInput materialInput;
                  materialInput.normalEC = normalEC;
                   materialInput.positionToEyeEC = positionToEyeEC;
                   materialInput.st = v_st;
                   czm_material material = czm_getMaterial(materialInput,uv);
                   vec4 cloudColor = vec4(material.diffuse , material.alpha);



                   // vec4 sunColor = sunColor(uv);
                   // gl_FragColor = mix(sunColor,cloudColor, 0.1);
                   gl_FragColor = cloudColor;
               }
    `;

    Cesium.Material._materialCache.addMaterial(Cesium.Material.CloudEffectType, {
        fabric: {
            type: Cesium.Material.CloudEffectType,
            uniforms: {
                color: Cesium.Material.CloudEffectColor,
                image: Cesium.Material.CloudEffectImage,
                time: time
            },
            source: Cesium.Material.CloudEffectSource
        },
        translucent: function(material) {
            return true;
        }
    });


    // const entity = entities.add({
    //     rectangle: {
    //         coordinates: Cesium.Rectangle.fromDegrees(114.290000, 35.720000, 114.300000, 35.725000 ),
    //         height : 1000,
    //         extrudedHeight : 1000,
    //         // coordinates: Cesium.Rectangle.fromDegrees(-180.0, -90.0, 180.0, 90.0),
    //         // height : 100001,
    //         // extrudedHeight : 100000,
    //         material: new CloudEffectMaterialProperty()
    //         // material: imageMaterial,
    //     },
    // });


    // var polygonInstance = new Cesium.GeometryInstance({
    //     geometry : new Cesium.RectangleGeometry({
    //         rectangle : Cesium.Rectangle.fromDegrees(114.290000, 35.720000, 114.300000, 35.725000),
    //         height : 1000,
    //         // extrudedHeight : 1000,
    //         // vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
    //     })
    // });


    var polygonInstance = new Cesium.GeometryInstance({
        geometry : new Cesium.RectangleGeometry({
            // rectangle : Cesium.Rectangle.fromDegrees(-180, -90, 180, 90),
            // height : 100001,
            // extrudedHeight : 100000,

            rectangle : Cesium.Rectangle.fromDegrees(114.290000, 35.720000, 114.300000, 35.725000),
            height : 1000,
            extrudedHeight : 1000,

            // extrudedHeight : 1000,
            // vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
        })
    });

    var cloudPrimitive= new Cesium.Primitive({
        geometryInstances: [polygonInstance],
        appearance: new Cesium.MaterialAppearance({
            material:Cesium.Material.fromType(Cesium.Material.CloudEffectType),
            vertexShaderSource: cloudVS,
            fragmentShaderSource:cloudFS,
        }),
        asynchronous:false,
    });


    viewer.scene.primitives.add(cloudPrimitive);



    var tile3d = new Cesium.Cesium3DTileset({
        // skipLevelOfDetail: true,
        // debugShowBoundingVolume:true,
        // modelUpAxis:Cesium.Axis.Y,
        url: 'http://124.70.104.88:9069/tile/hb3dtiles/tileset.json',
    });
    viewer.scene.primitives.add(tile3d);

    // viewer.camera.setView({
    //     destination: Cesium.Cartesian3.fromDegrees(113.90923365120773,35.67741913009481, 11364.888527884033), //设置位置
    //     orientation: {
    //         heading: Cesium.Math.toRadians(71.02500633598642),
    //         pitch: Cesium.Math.toRadians(-5.101474200471572),
    //         roll: 0
    //     }
    // });


    viewer.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(114.293789487477, 35.71498152596116, 627.724367140964), //设置位置
        orientation: {
            heading: Cesium.Math.toRadians(3.8112736838317627),
            pitch: Cesium.Math.toRadians(-38.247132353179815),
            roll: 0
        }
    });



    function changeColor(){
        var color1 = [10,0,0,125];
        var color2 = [255,255,255,255];
        var color3 = [10,0,0,125];
        // 获取当前时间
        var currentTime = new Date(viewer.clock.currentTime);
        var hours = currentTime.getHours();
        var minutes = currentTime.getMinutes();
        var seconds = currentTime.getSeconds();

        // 计算过渡时间总秒数
        var totalSeconds = (hours * 3600) + (minutes * 60) + seconds;

        // // 计算过渡时间百分比
        var percentage = totalSeconds / 86400; // 86400秒是一天的总秒数
        var transitionColor;
        if(percentage <= 0.5){
            // 计算过渡颜色
            transitionColor = interpolateColors(color1, color2, percentage);
        }else{
            transitionColor = interpolateColors(color2, color3, percentage);
        }

        // var transitionColor;
        // var percentage;
        // //早上4点到9点
        // if(totalSeconds > 4 * 3600 && totalSeconds < 9 * 3600){
        //     percentage = (totalSeconds - 4 * 3600) / (5* 3600);
        //     // 计算过渡颜色
        //     transitionColor = interpolateColors(color1, color2, percentage);
        // }else if(totalSeconds > 17 * 3600 && totalSeconds < 21 * 3600){//下午5点到9点
        //     percentage = (totalSeconds - 17 * 3600) / (4* 3600);
        //     transitionColor = interpolateColors(color2, color3, percentage);
        // }else{//白色
        //     transitionColor = [255,255,255,255];
        // }

        sunLight.color = Cesium.Color.fromBytes(transitionColor[0],transitionColor[1],transitionColor[2],255);
        requestAnimationFrame(changeColor);
    }


    // 插值函数，用于计算两种颜色之间的过渡颜色
    function interpolateColors(color1, color2, percentage) {
        var r = Math.round(color1[0] + (color2[0] - color1[0]) * percentage);
        var g = Math.round(color1[1] + (color2[1] - color1[1]) * percentage);
        var b = Math.round(color1[2] + (color2[2] - color1[2]) * percentage);
        return [r, g, b];
    }



    var handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
    handler.setInputAction(function (event) {
        var position = event.position;
        var cartesian =  viewer.scene.pickPosition(position);
        if (!Cesium.defined(cartesian)) {
            return;
        }

        var ellipsoid=viewer.scene.globe.ellipsoid;
        var cartographic=ellipsoid.cartesianToCartographic(cartesian);
        var lat=Cesium.Math.toDegrees(cartographic.latitude);
        var lng=Cesium.Math.toDegrees(cartographic.longitude);
        var height=cartographic.height;
        alert(lng.toFixed(6)+','+ lat.toFixed(6)+','+height);

    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    // viewer.camera.setView({
    //     destination: Cesium.Cartesian3.fromDegrees(104.99877222554414,30.385728344468113, 6661.368718511896), //设置位置
    //     orientation: {
    //         heading: Cesium.Math.toRadians(350.06084392370116),
    //         pitch: Cesium.Math.toRadians(-8.900854873588093),
    //         roll: 0
    //     }
    // });


    // viewer.zoomTo(viewer.entities);

</script>
</body>
</html>

